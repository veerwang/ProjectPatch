From d6c1b61e25e901f138a15ce040e34615ee5c803b Mon Sep 17 00:00:00 2001
From: kevin <kevin.wang2004@hotmail.com>
Date: Tue, 7 Jan 2014 15:06:26 +0800
Subject: [PATCH 2/2] =?UTF-8?q?=E6=94=B9=E5=8F=98=E5=B7=A5=E7=A8=8B?=
 =?UTF-8?q?=E7=9B=AE=E5=BD=95=E7=BB=93=E6=9E=84?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 Makefile                                  |    4 +-
 src/EVA11/ASMS/Asm_Fun_Sets.s             |  123 -
 src/EVA11/AlarmManage.cpp                 |  238 --
 src/EVA11/AlarmManage.h                   |   68 -
 src/EVA11/AlarmRegion.cpp                 | 1102 ---------
 src/EVA11/AlarmRegion.h                   |  137 --
 src/EVA11/AlarmView.cpp                   |  213 --
 src/EVA11/AlarmView.h                     |   60 -
 src/EVA11/AlgMixing.cpp                   |  560 -----
 src/EVA11/AlgMixing.h                     |   80 -
 src/EVA11/Algorithm.cpp                   |  717 ------
 src/EVA11/Algorithm.h                     |  115 -
 src/EVA11/AnalyzeView.cpp                 |  151 --
 src/EVA11/AnalyzeView.h                   |   48 -
 src/EVA11/BasePanel.cpp                   |   38 -
 src/EVA11/BasePanel.h                     |   47 -
 src/EVA11/Basescreen.cpp                  |  286 ---
 src/EVA11/Basescreen.h                    |   77 -
 src/EVA11/Basewin.cpp                     |  414 ----
 src/EVA11/Basewin.h                       |  117 -
 src/EVA11/Battery.cpp                     |  315 ---
 src/EVA11/Battery.h                       |   71 -
 src/EVA11/Bufferbar.cpp                   |  145 --
 src/EVA11/Bufferbar.h                     |   58 -
 src/EVA11/CZKPanel.cpp                    |  815 -------
 src/EVA11/CZKPanel.h                      |   82 -
 src/EVA11/CalculateCenter.cpp             |  310 ---
 src/EVA11/CalculateCenter.h               |   64 -
 src/EVA11/Chart.cpp                       |  228 --
 src/EVA11/Chart.h                         |   68 -
 src/EVA11/Color3DScan.cpp                 |  182 --
 src/EVA11/Color3DScan.h                   |   61 -
 src/EVA11/ColorObj.cpp                    |  144 --
 src/EVA11/ColorObj.h                      |   62 -
 src/EVA11/ColorPanel.cpp                  |  342 ---
 src/EVA11/ColorPanel.h                    |   61 -
 src/EVA11/ColorScan.cpp                   |  130 --
 src/EVA11/ColorScan.h                     |   53 -
 src/EVA11/Colorbar.cpp                    |  186 --
 src/EVA11/Colorbar.h                      |   50 -
 src/EVA11/ConcreteDataProcess.cpp         |  379 ----
 src/EVA11/ConcreteDataProcess.h           |  110 -
 src/EVA11/ConvertCode.cpp                 |   99 -
 src/EVA11/ConvertCode.h                   |   49 -
 src/EVA11/DEPS/README                     |    0
 src/EVA11/DFilter.cpp                     |  149 --
 src/EVA11/DFilter.h                       |   42 -
 src/EVA11/DZKPanel.cpp                    | 1155 ----------
 src/EVA11/DZKPanel.h                      |  112 -
 src/EVA11/DataRepo.cpp                    |  305 ---
 src/EVA11/DataRepo.h                      |   72 -
 src/EVA11/Datawin.cpp                     |  638 ------
 src/EVA11/Datawin.h                       |   93 -
 src/EVA11/DebugView.cpp                   |  178 --
 src/EVA11/DebugView.h                     |   50 -
 src/EVA11/DetectView.cpp                  |  307 ---
 src/EVA11/DetectView.h                    |   80 -
 src/EVA11/Device.cpp                      |  688 ------
 src/EVA11/Device.h                        |  148 --
 src/EVA11/Filte.cpp                       |   60 -
 src/EVA11/Filte.h                         |   37 -
 src/EVA11/Fit.c                           |   88 -
 src/EVA11/FitHead.h                       |   37 -
 src/EVA11/FreeType.cpp                    |  468 ----
 src/EVA11/FreeType.h                      |   73 -
 src/EVA11/GUILowCode.hpp                  |  850 -------
 src/EVA11/Gif.cpp                         |  251 --
 src/EVA11/Gif.h                           |   40 -
 src/EVA11/Global.cpp                      |  752 ------
 src/EVA11/Global.h                        |  222 --
 src/EVA11/Gradual.cpp                     |  113 -
 src/EVA11/Gradual.h                       |   48 -
 src/EVA11/Graphic.cpp                     |  985 --------
 src/EVA11/Graphic.h                       |  155 --
 src/EVA11/Helpwin.cpp                     |  239 --
 src/EVA11/Helpwin.h                       |   50 -
 src/EVA11/IDataProcess.cpp                |  118 -
 src/EVA11/IDataProcess.h                  |   57 -
 src/EVA11/IView.cpp                       |  229 --
 src/EVA11/IView.h                         |   83 -
 src/EVA11/Iconbutton.cpp                  |  168 --
 src/EVA11/Iconbutton.h                    |   65 -
 src/EVA11/Initfacade.cpp                  |  201 --
 src/EVA11/Initfacade.h                    |   56 -
 src/EVA11/JPGS/backscreen.png             |  Bin 4742 -> 0 bytes
 src/EVA11/JPGS/colorspot.jpg              |  Bin 9817 -> 0 bytes
 src/EVA11/JPGS/czkscreen.jpg              |  Bin 10830 -> 0 bytes
 src/EVA11/JPGS/dzkscreen.jpg              |  Bin 12032 -> 0 bytes
 src/EVA11/JPGS/eddysunlogo.png            |  Bin 2930 -> 0 bytes
 src/EVA11/JPGS/ozkscreen.jpg              |  Bin 11629 -> 0 bytes
 src/EVA11/JPGS/run.png                    |  Bin 1821 -> 0 bytes
 src/EVA11/JPGS/splash.gif                 |  Bin 159882 -> 0 bytes
 src/EVA11/JPGS/startup.jpg                |  Bin 20820 -> 0 bytes
 src/EVA11/JPGS/stop.png                   |  Bin 1484 -> 0 bytes
 src/EVA11/JPGS/video.jpg                  |  Bin 8184 -> 0 bytes
 src/EVA11/JPGS/zkscreen.jpg               |  Bin 10580 -> 0 bytes
 src/EVA11/JpegOper.cpp                    |  393 ----
 src/EVA11/JpegOper.h                      |   90 -
 src/EVA11/KFInterface.cpp                 |   96 -
 src/EVA11/KFInterface.h                   |  100 -
 src/EVA11/Label.cpp                       |  464 ----
 src/EVA11/Label.h                         |   80 -
 src/EVA11/Language.cpp                    |  846 -------
 src/EVA11/Language.h                      |   48 -
 src/EVA11/LimitManage.cpp                 |  137 --
 src/EVA11/LimitManage.h                   |   47 -
 src/EVA11/Loadwin.cpp                     |  605 -----
 src/EVA11/Loadwin.h                       |   79 -
 src/EVA11/Log.cpp                         |  146 --
 src/EVA11/Log.h                           |   46 -
 src/EVA11/Logic.cpp                       |  997 --------
 src/EVA11/Logic.h                         |  121 -
 src/EVA11/MKlib.mk                        |  186 --
 src/EVA11/Mainwin.cpp                     | 3532 -----------------------------
 src/EVA11/Mainwin.h                       |  175 --
 src/EVA11/Makefile                        |  127 +-
 src/EVA11/ManageMD5.cpp                   |  132 --
 src/EVA11/ManageMD5.h                     |   41 -
 src/EVA11/MixingManage.cpp                |  200 --
 src/EVA11/MixingManage.h                  |   54 -
 src/EVA11/Modifywin.cpp                   |  277 ---
 src/EVA11/Modifywin.h                     |   41 -
 src/EVA11/Msgbox.cpp                      |  480 ----
 src/EVA11/Msgbox.h                        |   92 -
 src/EVA11/Netclient.cpp                   |  317 ---
 src/EVA11/Netclient.h                     |   84 -
 src/EVA11/OBJS/ASMS/Asm_Fun_Sets.s.o      |  Bin 1108 -> 0 bytes
 src/EVA11/OBJS/ASMS/README                |    0
 src/EVA11/OBJS/JPGS/README                |    0
 src/EVA11/OBJS/README                     |    0
 src/EVA11/OZKPanel.cpp                    |  603 -----
 src/EVA11/OZKPanel.h                      |   85 -
 src/EVA11/Object.cpp                      |   39 -
 src/EVA11/Object.h                        |   44 -
 src/EVA11/Operationwin.cpp                |  248 --
 src/EVA11/Operationwin.h                  |   58 -
 src/EVA11/OtherView.cpp                   |  166 --
 src/EVA11/OtherView.h                     |   49 -
 src/EVA11/PICwin.cpp                      |  337 ---
 src/EVA11/PICwin.h                        |   55 -
 src/EVA11/PanelView.cpp                   |  255 ---
 src/EVA11/PanelView.h                     |   59 -
 src/EVA11/ParaView.cpp                    |  210 --
 src/EVA11/ParaView.h                      |   60 -
 src/EVA11/Parawin.cpp                     |  707 ------
 src/EVA11/Parawin.h                       |   91 -
 src/EVA11/Png.cpp                         |  179 --
 src/EVA11/Png.h                           |   40 -
 src/EVA11/Process.cpp                     | 3445 ----------------------------
 src/EVA11/Process.h                       |  115 -
 src/EVA11/ProjectFixHead.h                |  243 --
 src/EVA11/ProjectGBText.h                 |  770 -------
 src/EVA11/Resource.cpp                    |  264 ---
 src/EVA11/Resource.h                      |   58 -
 src/EVA11/Rule.cpp                        |  181 --
 src/EVA11/Rule.h                          |   43 -
 src/EVA11/SQLLiteWrapper.cpp              |  253 ---
 src/EVA11/SQLLiteWrapper.h                |  115 -
 src/EVA11/ShellCommand.cpp                |  130 --
 src/EVA11/ShellCommand.h                  |   45 -
 src/EVA11/Sinscreen.cpp                   |  108 -
 src/EVA11/Sinscreen.h                     |   48 -
 src/EVA11/Splashscreen.cpp                |   67 -
 src/EVA11/Splashscreen.h                  |   37 -
 src/EVA11/TCPMainwin.cpp                  |  212 --
 src/EVA11/TCPMainwin.h                    |   54 -
 src/EVA11/USB.cpp                         |  117 -
 src/EVA11/USB.h                           |   41 -
 src/EVA11/Uart.cpp                        |  102 -
 src/EVA11/Uart.h                          |   39 -
 src/EVA11/Video.cpp                       | 1038 ---------
 src/EVA11/Video.h                         |   98 -
 src/EVA11/VideoHead.h                     |  205 --
 src/EVA11/VideoPanel.cpp                  |  283 ---
 src/EVA11/VideoPanel.h                    |   71 -
 src/EVA11/ZKPanel.cpp                     |  941 --------
 src/EVA11/ZKPanel.h                       |  103 -
 src/EVA11/ZScreen.cpp                     |  999 --------
 src/EVA11/ZScreen.h                       |  161 --
 src/EVA11/base/ASMS/Asm_Fun_Sets.s        |  123 +
 src/EVA11/base/AlarmManage.cpp            |  238 ++
 src/EVA11/base/AlarmManage.h              |   68 +
 src/EVA11/base/AlarmRegion.cpp            | 1102 +++++++++
 src/EVA11/base/AlarmRegion.h              |  137 ++
 src/EVA11/base/AlarmView.cpp              |  213 ++
 src/EVA11/base/AlarmView.h                |   60 +
 src/EVA11/base/AlgMixing.cpp              |  560 +++++
 src/EVA11/base/AlgMixing.h                |   80 +
 src/EVA11/base/Algorithm.cpp              |  717 ++++++
 src/EVA11/base/Algorithm.h                |  115 +
 src/EVA11/base/AnalyzeView.cpp            |  151 ++
 src/EVA11/base/AnalyzeView.h              |   48 +
 src/EVA11/base/BasePanel.cpp              |   38 +
 src/EVA11/base/BasePanel.h                |   47 +
 src/EVA11/base/Basescreen.cpp             |  286 +++
 src/EVA11/base/Basescreen.h               |   77 +
 src/EVA11/base/Basewin.cpp                |  414 ++++
 src/EVA11/base/Basewin.h                  |  117 +
 src/EVA11/base/Battery.cpp                |  315 +++
 src/EVA11/base/Battery.h                  |   71 +
 src/EVA11/base/Bufferbar.cpp              |  145 ++
 src/EVA11/base/Bufferbar.h                |   58 +
 src/EVA11/base/CZKPanel.cpp               |  815 +++++++
 src/EVA11/base/CZKPanel.h                 |   82 +
 src/EVA11/base/CalculateCenter.cpp        |  310 +++
 src/EVA11/base/CalculateCenter.h          |   64 +
 src/EVA11/base/Chart.cpp                  |  228 ++
 src/EVA11/base/Chart.h                    |   68 +
 src/EVA11/base/Color3DScan.cpp            |  182 ++
 src/EVA11/base/Color3DScan.h              |   61 +
 src/EVA11/base/ColorObj.cpp               |  144 ++
 src/EVA11/base/ColorObj.h                 |   62 +
 src/EVA11/base/ColorPanel.cpp             |  342 +++
 src/EVA11/base/ColorPanel.h               |   61 +
 src/EVA11/base/ColorScan.cpp              |  130 ++
 src/EVA11/base/ColorScan.h                |   53 +
 src/EVA11/base/Colorbar.cpp               |  186 ++
 src/EVA11/base/Colorbar.h                 |   50 +
 src/EVA11/base/ConcreteDataProcess.cpp    |  379 ++++
 src/EVA11/base/ConcreteDataProcess.h      |  110 +
 src/EVA11/base/ConvertCode.cpp            |   99 +
 src/EVA11/base/ConvertCode.h              |   49 +
 src/EVA11/base/DEPS/README                |    0
 src/EVA11/base/DFilter.cpp                |  149 ++
 src/EVA11/base/DFilter.h                  |   42 +
 src/EVA11/base/DZKPanel.cpp               | 1155 ++++++++++
 src/EVA11/base/DZKPanel.h                 |  112 +
 src/EVA11/base/DataRepo.cpp               |  305 +++
 src/EVA11/base/DataRepo.h                 |   72 +
 src/EVA11/base/Datawin.cpp                |  638 ++++++
 src/EVA11/base/Datawin.h                  |   93 +
 src/EVA11/base/DebugView.cpp              |  178 ++
 src/EVA11/base/DebugView.h                |   50 +
 src/EVA11/base/DetectView.cpp             |  307 +++
 src/EVA11/base/DetectView.h               |   80 +
 src/EVA11/base/Device.cpp                 |  688 ++++++
 src/EVA11/base/Device.h                   |  148 ++
 src/EVA11/base/Filte.cpp                  |   60 +
 src/EVA11/base/Filte.h                    |   37 +
 src/EVA11/base/Fit.c                      |   88 +
 src/EVA11/base/FitHead.h                  |   37 +
 src/EVA11/base/FreeType.cpp               |  468 ++++
 src/EVA11/base/FreeType.h                 |   73 +
 src/EVA11/base/GUILowCode.hpp             |  850 +++++++
 src/EVA11/base/Gif.cpp                    |  251 ++
 src/EVA11/base/Gif.h                      |   40 +
 src/EVA11/base/Global.cpp                 |  752 ++++++
 src/EVA11/base/Global.h                   |  222 ++
 src/EVA11/base/Gradual.cpp                |  113 +
 src/EVA11/base/Gradual.h                  |   48 +
 src/EVA11/base/Graphic.cpp                |  985 ++++++++
 src/EVA11/base/Graphic.h                  |  155 ++
 src/EVA11/base/Helpwin.cpp                |  239 ++
 src/EVA11/base/Helpwin.h                  |   50 +
 src/EVA11/base/IDataProcess.cpp           |  118 +
 src/EVA11/base/IDataProcess.h             |   57 +
 src/EVA11/base/IView.cpp                  |  229 ++
 src/EVA11/base/IView.h                    |   83 +
 src/EVA11/base/Iconbutton.cpp             |  168 ++
 src/EVA11/base/Iconbutton.h               |   65 +
 src/EVA11/base/Initfacade.cpp             |  201 ++
 src/EVA11/base/Initfacade.h               |   56 +
 src/EVA11/base/JPGS/backscreen.png        |  Bin 0 -> 4742 bytes
 src/EVA11/base/JPGS/colorspot.jpg         |  Bin 0 -> 9817 bytes
 src/EVA11/base/JPGS/czkscreen.jpg         |  Bin 0 -> 10830 bytes
 src/EVA11/base/JPGS/dzkscreen.jpg         |  Bin 0 -> 12032 bytes
 src/EVA11/base/JPGS/eddysunlogo.png       |  Bin 0 -> 2930 bytes
 src/EVA11/base/JPGS/ozkscreen.jpg         |  Bin 0 -> 11629 bytes
 src/EVA11/base/JPGS/run.png               |  Bin 0 -> 1821 bytes
 src/EVA11/base/JPGS/splash.gif            |  Bin 0 -> 159882 bytes
 src/EVA11/base/JPGS/startup.jpg           |  Bin 0 -> 20820 bytes
 src/EVA11/base/JPGS/stop.png              |  Bin 0 -> 1484 bytes
 src/EVA11/base/JPGS/video.jpg             |  Bin 0 -> 8184 bytes
 src/EVA11/base/JPGS/zkscreen.jpg          |  Bin 0 -> 10580 bytes
 src/EVA11/base/JpegOper.cpp               |  393 ++++
 src/EVA11/base/JpegOper.h                 |   90 +
 src/EVA11/base/KFInterface.cpp            |   96 +
 src/EVA11/base/KFInterface.h              |  100 +
 src/EVA11/base/Label.cpp                  |  464 ++++
 src/EVA11/base/Label.h                    |   80 +
 src/EVA11/base/Language.cpp               |  846 +++++++
 src/EVA11/base/Language.h                 |   48 +
 src/EVA11/base/LimitManage.cpp            |  137 ++
 src/EVA11/base/LimitManage.h              |   47 +
 src/EVA11/base/Loadwin.cpp                |  605 +++++
 src/EVA11/base/Loadwin.h                  |   79 +
 src/EVA11/base/Log.cpp                    |  146 ++
 src/EVA11/base/Log.h                      |   46 +
 src/EVA11/base/Logic.cpp                  |  997 ++++++++
 src/EVA11/base/Logic.h                    |  121 +
 src/EVA11/base/MKlib.mk                   |  186 ++
 src/EVA11/base/Mainwin.cpp                | 3532 +++++++++++++++++++++++++++++
 src/EVA11/base/Mainwin.h                  |  175 ++
 src/EVA11/base/Makefile                   |  118 +
 src/EVA11/base/ManageMD5.cpp              |  132 ++
 src/EVA11/base/ManageMD5.h                |   41 +
 src/EVA11/base/MixingManage.cpp           |  200 ++
 src/EVA11/base/MixingManage.h             |   54 +
 src/EVA11/base/Modifywin.cpp              |  277 +++
 src/EVA11/base/Modifywin.h                |   41 +
 src/EVA11/base/Msgbox.cpp                 |  480 ++++
 src/EVA11/base/Msgbox.h                   |   92 +
 src/EVA11/base/Netclient.cpp              |  317 +++
 src/EVA11/base/Netclient.h                |   84 +
 src/EVA11/base/OBJS/ASMS/Asm_Fun_Sets.s.o |  Bin 0 -> 1108 bytes
 src/EVA11/base/OBJS/ASMS/README           |    0
 src/EVA11/base/OBJS/JPGS/README           |    0
 src/EVA11/base/OBJS/README                |    0
 src/EVA11/base/OZKPanel.cpp               |  603 +++++
 src/EVA11/base/OZKPanel.h                 |   85 +
 src/EVA11/base/Object.cpp                 |   39 +
 src/EVA11/base/Object.h                   |   44 +
 src/EVA11/base/Operationwin.cpp           |  248 ++
 src/EVA11/base/Operationwin.h             |   58 +
 src/EVA11/base/OtherView.cpp              |  166 ++
 src/EVA11/base/OtherView.h                |   49 +
 src/EVA11/base/PICwin.cpp                 |  337 +++
 src/EVA11/base/PICwin.h                   |   55 +
 src/EVA11/base/PanelView.cpp              |  255 +++
 src/EVA11/base/PanelView.h                |   59 +
 src/EVA11/base/ParaView.cpp               |  210 ++
 src/EVA11/base/ParaView.h                 |   60 +
 src/EVA11/base/Parawin.cpp                |  707 ++++++
 src/EVA11/base/Parawin.h                  |   91 +
 src/EVA11/base/Png.cpp                    |  179 ++
 src/EVA11/base/Png.h                      |   40 +
 src/EVA11/base/Process.cpp                | 3445 ++++++++++++++++++++++++++++
 src/EVA11/base/Process.h                  |  115 +
 src/EVA11/base/ProjectFixHead.h           |  243 ++
 src/EVA11/base/ProjectGBText.h            |  770 +++++++
 src/EVA11/base/Resource.cpp               |  264 +++
 src/EVA11/base/Resource.h                 |   58 +
 src/EVA11/base/Rule.cpp                   |  181 ++
 src/EVA11/base/Rule.h                     |   43 +
 src/EVA11/base/SQLLiteWrapper.cpp         |  253 +++
 src/EVA11/base/SQLLiteWrapper.h           |  115 +
 src/EVA11/base/ShellCommand.cpp           |  130 ++
 src/EVA11/base/ShellCommand.h             |   45 +
 src/EVA11/base/Sinscreen.cpp              |  108 +
 src/EVA11/base/Sinscreen.h                |   48 +
 src/EVA11/base/Splashscreen.cpp           |   67 +
 src/EVA11/base/Splashscreen.h             |   37 +
 src/EVA11/base/TCPMainwin.cpp             |  212 ++
 src/EVA11/base/TCPMainwin.h               |   54 +
 src/EVA11/base/USB.cpp                    |  117 +
 src/EVA11/base/USB.h                      |   41 +
 src/EVA11/base/Uart.cpp                   |  102 +
 src/EVA11/base/Uart.h                     |   39 +
 src/EVA11/base/Video.cpp                  | 1038 +++++++++
 src/EVA11/base/Video.h                    |   98 +
 src/EVA11/base/VideoHead.h                |  205 ++
 src/EVA11/base/VideoPanel.cpp             |  283 +++
 src/EVA11/base/VideoPanel.h               |   71 +
 src/EVA11/base/ZKPanel.cpp                |  941 ++++++++
 src/EVA11/base/ZKPanel.h                  |  103 +
 src/EVA11/base/ZScreen.cpp                |  999 ++++++++
 src/EVA11/base/ZScreen.h                  |  161 ++
 src/EVA11/base/cssl.c                     |  564 +++++
 src/EVA11/base/cssl.h                     |  128 ++
 src/EVA11/base/etio.cpp                   | 1762 ++++++++++++++
 src/EVA11/base/etio.h                     |  169 ++
 src/EVA11/base/main.cpp                   |  394 ++++
 src/EVA11/base/main.h                     |  123 +
 src/EVA11/cssl.c                          |  564 -----
 src/EVA11/cssl.h                          |  128 --
 src/EVA11/etio.cpp                        | 1762 --------------
 src/EVA11/etio.h                          |  169 --
 src/EVA11/main.cpp                        |  394 ----
 src/EVA11/main.h                          |  123 -
 369 files changed, 44973 insertions(+), 44944 deletions(-)
 delete mode 100644 src/EVA11/ASMS/Asm_Fun_Sets.s
 delete mode 100644 src/EVA11/AlarmManage.cpp
 delete mode 100644 src/EVA11/AlarmManage.h
 delete mode 100644 src/EVA11/AlarmRegion.cpp
 delete mode 100644 src/EVA11/AlarmRegion.h
 delete mode 100644 src/EVA11/AlarmView.cpp
 delete mode 100644 src/EVA11/AlarmView.h
 delete mode 100644 src/EVA11/AlgMixing.cpp
 delete mode 100644 src/EVA11/AlgMixing.h
 delete mode 100644 src/EVA11/Algorithm.cpp
 delete mode 100644 src/EVA11/Algorithm.h
 delete mode 100644 src/EVA11/AnalyzeView.cpp
 delete mode 100644 src/EVA11/AnalyzeView.h
 delete mode 100644 src/EVA11/BasePanel.cpp
 delete mode 100644 src/EVA11/BasePanel.h
 delete mode 100644 src/EVA11/Basescreen.cpp
 delete mode 100644 src/EVA11/Basescreen.h
 delete mode 100644 src/EVA11/Basewin.cpp
 delete mode 100644 src/EVA11/Basewin.h
 delete mode 100644 src/EVA11/Battery.cpp
 delete mode 100644 src/EVA11/Battery.h
 delete mode 100644 src/EVA11/Bufferbar.cpp
 delete mode 100644 src/EVA11/Bufferbar.h
 delete mode 100644 src/EVA11/CZKPanel.cpp
 delete mode 100644 src/EVA11/CZKPanel.h
 delete mode 100644 src/EVA11/CalculateCenter.cpp
 delete mode 100644 src/EVA11/CalculateCenter.h
 delete mode 100644 src/EVA11/Chart.cpp
 delete mode 100644 src/EVA11/Chart.h
 delete mode 100644 src/EVA11/Color3DScan.cpp
 delete mode 100644 src/EVA11/Color3DScan.h
 delete mode 100644 src/EVA11/ColorObj.cpp
 delete mode 100644 src/EVA11/ColorObj.h
 delete mode 100644 src/EVA11/ColorPanel.cpp
 delete mode 100644 src/EVA11/ColorPanel.h
 delete mode 100644 src/EVA11/ColorScan.cpp
 delete mode 100644 src/EVA11/ColorScan.h
 delete mode 100644 src/EVA11/Colorbar.cpp
 delete mode 100644 src/EVA11/Colorbar.h
 delete mode 100644 src/EVA11/ConcreteDataProcess.cpp
 delete mode 100644 src/EVA11/ConcreteDataProcess.h
 delete mode 100644 src/EVA11/ConvertCode.cpp
 delete mode 100644 src/EVA11/ConvertCode.h
 delete mode 100644 src/EVA11/DEPS/README
 delete mode 100644 src/EVA11/DFilter.cpp
 delete mode 100644 src/EVA11/DFilter.h
 delete mode 100644 src/EVA11/DZKPanel.cpp
 delete mode 100644 src/EVA11/DZKPanel.h
 delete mode 100644 src/EVA11/DataRepo.cpp
 delete mode 100644 src/EVA11/DataRepo.h
 delete mode 100644 src/EVA11/Datawin.cpp
 delete mode 100644 src/EVA11/Datawin.h
 delete mode 100644 src/EVA11/DebugView.cpp
 delete mode 100644 src/EVA11/DebugView.h
 delete mode 100644 src/EVA11/DetectView.cpp
 delete mode 100644 src/EVA11/DetectView.h
 delete mode 100644 src/EVA11/Device.cpp
 delete mode 100644 src/EVA11/Device.h
 delete mode 100644 src/EVA11/Filte.cpp
 delete mode 100644 src/EVA11/Filte.h
 delete mode 100644 src/EVA11/Fit.c
 delete mode 100644 src/EVA11/FitHead.h
 delete mode 100644 src/EVA11/FreeType.cpp
 delete mode 100644 src/EVA11/FreeType.h
 delete mode 100644 src/EVA11/GUILowCode.hpp
 delete mode 100644 src/EVA11/Gif.cpp
 delete mode 100644 src/EVA11/Gif.h
 delete mode 100644 src/EVA11/Global.cpp
 delete mode 100644 src/EVA11/Global.h
 delete mode 100644 src/EVA11/Gradual.cpp
 delete mode 100644 src/EVA11/Gradual.h
 delete mode 100644 src/EVA11/Graphic.cpp
 delete mode 100644 src/EVA11/Graphic.h
 delete mode 100644 src/EVA11/Helpwin.cpp
 delete mode 100644 src/EVA11/Helpwin.h
 delete mode 100644 src/EVA11/IDataProcess.cpp
 delete mode 100644 src/EVA11/IDataProcess.h
 delete mode 100644 src/EVA11/IView.cpp
 delete mode 100644 src/EVA11/IView.h
 delete mode 100644 src/EVA11/Iconbutton.cpp
 delete mode 100644 src/EVA11/Iconbutton.h
 delete mode 100644 src/EVA11/Initfacade.cpp
 delete mode 100644 src/EVA11/Initfacade.h
 delete mode 100644 src/EVA11/JPGS/backscreen.png
 delete mode 100644 src/EVA11/JPGS/colorspot.jpg
 delete mode 100644 src/EVA11/JPGS/czkscreen.jpg
 delete mode 100644 src/EVA11/JPGS/dzkscreen.jpg
 delete mode 100644 src/EVA11/JPGS/eddysunlogo.png
 delete mode 100644 src/EVA11/JPGS/ozkscreen.jpg
 delete mode 100644 src/EVA11/JPGS/run.png
 delete mode 100644 src/EVA11/JPGS/splash.gif
 delete mode 100644 src/EVA11/JPGS/startup.jpg
 delete mode 100644 src/EVA11/JPGS/stop.png
 delete mode 100644 src/EVA11/JPGS/video.jpg
 delete mode 100644 src/EVA11/JPGS/zkscreen.jpg
 delete mode 100644 src/EVA11/JpegOper.cpp
 delete mode 100644 src/EVA11/JpegOper.h
 delete mode 100644 src/EVA11/KFInterface.cpp
 delete mode 100644 src/EVA11/KFInterface.h
 delete mode 100644 src/EVA11/Label.cpp
 delete mode 100644 src/EVA11/Label.h
 delete mode 100644 src/EVA11/Language.cpp
 delete mode 100644 src/EVA11/Language.h
 delete mode 100644 src/EVA11/LimitManage.cpp
 delete mode 100644 src/EVA11/LimitManage.h
 delete mode 100644 src/EVA11/Loadwin.cpp
 delete mode 100644 src/EVA11/Loadwin.h
 delete mode 100644 src/EVA11/Log.cpp
 delete mode 100644 src/EVA11/Log.h
 delete mode 100644 src/EVA11/Logic.cpp
 delete mode 100644 src/EVA11/Logic.h
 delete mode 100644 src/EVA11/MKlib.mk
 delete mode 100644 src/EVA11/Mainwin.cpp
 delete mode 100644 src/EVA11/Mainwin.h
 delete mode 100644 src/EVA11/ManageMD5.cpp
 delete mode 100644 src/EVA11/ManageMD5.h
 delete mode 100644 src/EVA11/MixingManage.cpp
 delete mode 100644 src/EVA11/MixingManage.h
 delete mode 100644 src/EVA11/Modifywin.cpp
 delete mode 100644 src/EVA11/Modifywin.h
 delete mode 100644 src/EVA11/Msgbox.cpp
 delete mode 100644 src/EVA11/Msgbox.h
 delete mode 100644 src/EVA11/Netclient.cpp
 delete mode 100644 src/EVA11/Netclient.h
 delete mode 100644 src/EVA11/OBJS/ASMS/Asm_Fun_Sets.s.o
 delete mode 100644 src/EVA11/OBJS/ASMS/README
 delete mode 100644 src/EVA11/OBJS/JPGS/README
 delete mode 100644 src/EVA11/OBJS/README
 delete mode 100644 src/EVA11/OZKPanel.cpp
 delete mode 100644 src/EVA11/OZKPanel.h
 delete mode 100644 src/EVA11/Object.cpp
 delete mode 100644 src/EVA11/Object.h
 delete mode 100644 src/EVA11/Operationwin.cpp
 delete mode 100644 src/EVA11/Operationwin.h
 delete mode 100644 src/EVA11/OtherView.cpp
 delete mode 100644 src/EVA11/OtherView.h
 delete mode 100644 src/EVA11/PICwin.cpp
 delete mode 100644 src/EVA11/PICwin.h
 delete mode 100644 src/EVA11/PanelView.cpp
 delete mode 100644 src/EVA11/PanelView.h
 delete mode 100644 src/EVA11/ParaView.cpp
 delete mode 100644 src/EVA11/ParaView.h
 delete mode 100644 src/EVA11/Parawin.cpp
 delete mode 100644 src/EVA11/Parawin.h
 delete mode 100644 src/EVA11/Png.cpp
 delete mode 100644 src/EVA11/Png.h
 delete mode 100644 src/EVA11/Process.cpp
 delete mode 100644 src/EVA11/Process.h
 delete mode 100644 src/EVA11/ProjectFixHead.h
 delete mode 100644 src/EVA11/ProjectGBText.h
 delete mode 100644 src/EVA11/Resource.cpp
 delete mode 100644 src/EVA11/Resource.h
 delete mode 100644 src/EVA11/Rule.cpp
 delete mode 100644 src/EVA11/Rule.h
 delete mode 100644 src/EVA11/SQLLiteWrapper.cpp
 delete mode 100644 src/EVA11/SQLLiteWrapper.h
 delete mode 100644 src/EVA11/ShellCommand.cpp
 delete mode 100644 src/EVA11/ShellCommand.h
 delete mode 100644 src/EVA11/Sinscreen.cpp
 delete mode 100644 src/EVA11/Sinscreen.h
 delete mode 100644 src/EVA11/Splashscreen.cpp
 delete mode 100644 src/EVA11/Splashscreen.h
 delete mode 100644 src/EVA11/TCPMainwin.cpp
 delete mode 100644 src/EVA11/TCPMainwin.h
 delete mode 100644 src/EVA11/USB.cpp
 delete mode 100644 src/EVA11/USB.h
 delete mode 100644 src/EVA11/Uart.cpp
 delete mode 100644 src/EVA11/Uart.h
 delete mode 100644 src/EVA11/Video.cpp
 delete mode 100644 src/EVA11/Video.h
 delete mode 100644 src/EVA11/VideoHead.h
 delete mode 100644 src/EVA11/VideoPanel.cpp
 delete mode 100644 src/EVA11/VideoPanel.h
 delete mode 100644 src/EVA11/ZKPanel.cpp
 delete mode 100644 src/EVA11/ZKPanel.h
 delete mode 100644 src/EVA11/ZScreen.cpp
 delete mode 100644 src/EVA11/ZScreen.h
 create mode 100644 src/EVA11/base/ASMS/Asm_Fun_Sets.s
 create mode 100644 src/EVA11/base/AlarmManage.cpp
 create mode 100644 src/EVA11/base/AlarmManage.h
 create mode 100644 src/EVA11/base/AlarmRegion.cpp
 create mode 100644 src/EVA11/base/AlarmRegion.h
 create mode 100644 src/EVA11/base/AlarmView.cpp
 create mode 100644 src/EVA11/base/AlarmView.h
 create mode 100644 src/EVA11/base/AlgMixing.cpp
 create mode 100644 src/EVA11/base/AlgMixing.h
 create mode 100644 src/EVA11/base/Algorithm.cpp
 create mode 100644 src/EVA11/base/Algorithm.h
 create mode 100644 src/EVA11/base/AnalyzeView.cpp
 create mode 100644 src/EVA11/base/AnalyzeView.h
 create mode 100644 src/EVA11/base/BasePanel.cpp
 create mode 100644 src/EVA11/base/BasePanel.h
 create mode 100644 src/EVA11/base/Basescreen.cpp
 create mode 100644 src/EVA11/base/Basescreen.h
 create mode 100644 src/EVA11/base/Basewin.cpp
 create mode 100644 src/EVA11/base/Basewin.h
 create mode 100644 src/EVA11/base/Battery.cpp
 create mode 100644 src/EVA11/base/Battery.h
 create mode 100644 src/EVA11/base/Bufferbar.cpp
 create mode 100644 src/EVA11/base/Bufferbar.h
 create mode 100644 src/EVA11/base/CZKPanel.cpp
 create mode 100644 src/EVA11/base/CZKPanel.h
 create mode 100644 src/EVA11/base/CalculateCenter.cpp
 create mode 100644 src/EVA11/base/CalculateCenter.h
 create mode 100644 src/EVA11/base/Chart.cpp
 create mode 100644 src/EVA11/base/Chart.h
 create mode 100644 src/EVA11/base/Color3DScan.cpp
 create mode 100644 src/EVA11/base/Color3DScan.h
 create mode 100644 src/EVA11/base/ColorObj.cpp
 create mode 100644 src/EVA11/base/ColorObj.h
 create mode 100644 src/EVA11/base/ColorPanel.cpp
 create mode 100644 src/EVA11/base/ColorPanel.h
 create mode 100644 src/EVA11/base/ColorScan.cpp
 create mode 100644 src/EVA11/base/ColorScan.h
 create mode 100644 src/EVA11/base/Colorbar.cpp
 create mode 100644 src/EVA11/base/Colorbar.h
 create mode 100644 src/EVA11/base/ConcreteDataProcess.cpp
 create mode 100644 src/EVA11/base/ConcreteDataProcess.h
 create mode 100644 src/EVA11/base/ConvertCode.cpp
 create mode 100644 src/EVA11/base/ConvertCode.h
 create mode 100644 src/EVA11/base/DEPS/README
 create mode 100644 src/EVA11/base/DFilter.cpp
 create mode 100644 src/EVA11/base/DFilter.h
 create mode 100644 src/EVA11/base/DZKPanel.cpp
 create mode 100644 src/EVA11/base/DZKPanel.h
 create mode 100644 src/EVA11/base/DataRepo.cpp
 create mode 100644 src/EVA11/base/DataRepo.h
 create mode 100644 src/EVA11/base/Datawin.cpp
 create mode 100644 src/EVA11/base/Datawin.h
 create mode 100644 src/EVA11/base/DebugView.cpp
 create mode 100644 src/EVA11/base/DebugView.h
 create mode 100644 src/EVA11/base/DetectView.cpp
 create mode 100644 src/EVA11/base/DetectView.h
 create mode 100644 src/EVA11/base/Device.cpp
 create mode 100644 src/EVA11/base/Device.h
 create mode 100644 src/EVA11/base/Filte.cpp
 create mode 100644 src/EVA11/base/Filte.h
 create mode 100644 src/EVA11/base/Fit.c
 create mode 100644 src/EVA11/base/FitHead.h
 create mode 100644 src/EVA11/base/FreeType.cpp
 create mode 100644 src/EVA11/base/FreeType.h
 create mode 100644 src/EVA11/base/GUILowCode.hpp
 create mode 100644 src/EVA11/base/Gif.cpp
 create mode 100644 src/EVA11/base/Gif.h
 create mode 100644 src/EVA11/base/Global.cpp
 create mode 100644 src/EVA11/base/Global.h
 create mode 100644 src/EVA11/base/Gradual.cpp
 create mode 100644 src/EVA11/base/Gradual.h
 create mode 100644 src/EVA11/base/Graphic.cpp
 create mode 100644 src/EVA11/base/Graphic.h
 create mode 100644 src/EVA11/base/Helpwin.cpp
 create mode 100644 src/EVA11/base/Helpwin.h
 create mode 100644 src/EVA11/base/IDataProcess.cpp
 create mode 100644 src/EVA11/base/IDataProcess.h
 create mode 100644 src/EVA11/base/IView.cpp
 create mode 100644 src/EVA11/base/IView.h
 create mode 100644 src/EVA11/base/Iconbutton.cpp
 create mode 100644 src/EVA11/base/Iconbutton.h
 create mode 100644 src/EVA11/base/Initfacade.cpp
 create mode 100644 src/EVA11/base/Initfacade.h
 create mode 100644 src/EVA11/base/JPGS/backscreen.png
 create mode 100644 src/EVA11/base/JPGS/colorspot.jpg
 create mode 100644 src/EVA11/base/JPGS/czkscreen.jpg
 create mode 100644 src/EVA11/base/JPGS/dzkscreen.jpg
 create mode 100644 src/EVA11/base/JPGS/eddysunlogo.png
 create mode 100644 src/EVA11/base/JPGS/ozkscreen.jpg
 create mode 100644 src/EVA11/base/JPGS/run.png
 create mode 100644 src/EVA11/base/JPGS/splash.gif
 create mode 100644 src/EVA11/base/JPGS/startup.jpg
 create mode 100644 src/EVA11/base/JPGS/stop.png
 create mode 100644 src/EVA11/base/JPGS/video.jpg
 create mode 100644 src/EVA11/base/JPGS/zkscreen.jpg
 create mode 100644 src/EVA11/base/JpegOper.cpp
 create mode 100644 src/EVA11/base/JpegOper.h
 create mode 100644 src/EVA11/base/KFInterface.cpp
 create mode 100644 src/EVA11/base/KFInterface.h
 create mode 100644 src/EVA11/base/Label.cpp
 create mode 100644 src/EVA11/base/Label.h
 create mode 100644 src/EVA11/base/Language.cpp
 create mode 100644 src/EVA11/base/Language.h
 create mode 100644 src/EVA11/base/LimitManage.cpp
 create mode 100644 src/EVA11/base/LimitManage.h
 create mode 100644 src/EVA11/base/Loadwin.cpp
 create mode 100644 src/EVA11/base/Loadwin.h
 create mode 100644 src/EVA11/base/Log.cpp
 create mode 100644 src/EVA11/base/Log.h
 create mode 100644 src/EVA11/base/Logic.cpp
 create mode 100644 src/EVA11/base/Logic.h
 create mode 100644 src/EVA11/base/MKlib.mk
 create mode 100644 src/EVA11/base/Mainwin.cpp
 create mode 100644 src/EVA11/base/Mainwin.h
 create mode 100644 src/EVA11/base/Makefile
 create mode 100644 src/EVA11/base/ManageMD5.cpp
 create mode 100644 src/EVA11/base/ManageMD5.h
 create mode 100644 src/EVA11/base/MixingManage.cpp
 create mode 100644 src/EVA11/base/MixingManage.h
 create mode 100644 src/EVA11/base/Modifywin.cpp
 create mode 100644 src/EVA11/base/Modifywin.h
 create mode 100644 src/EVA11/base/Msgbox.cpp
 create mode 100644 src/EVA11/base/Msgbox.h
 create mode 100644 src/EVA11/base/Netclient.cpp
 create mode 100644 src/EVA11/base/Netclient.h
 create mode 100644 src/EVA11/base/OBJS/ASMS/Asm_Fun_Sets.s.o
 create mode 100644 src/EVA11/base/OBJS/ASMS/README
 create mode 100644 src/EVA11/base/OBJS/JPGS/README
 create mode 100644 src/EVA11/base/OBJS/README
 create mode 100644 src/EVA11/base/OZKPanel.cpp
 create mode 100644 src/EVA11/base/OZKPanel.h
 create mode 100644 src/EVA11/base/Object.cpp
 create mode 100644 src/EVA11/base/Object.h
 create mode 100644 src/EVA11/base/Operationwin.cpp
 create mode 100644 src/EVA11/base/Operationwin.h
 create mode 100644 src/EVA11/base/OtherView.cpp
 create mode 100644 src/EVA11/base/OtherView.h
 create mode 100644 src/EVA11/base/PICwin.cpp
 create mode 100644 src/EVA11/base/PICwin.h
 create mode 100644 src/EVA11/base/PanelView.cpp
 create mode 100644 src/EVA11/base/PanelView.h
 create mode 100644 src/EVA11/base/ParaView.cpp
 create mode 100644 src/EVA11/base/ParaView.h
 create mode 100644 src/EVA11/base/Parawin.cpp
 create mode 100644 src/EVA11/base/Parawin.h
 create mode 100644 src/EVA11/base/Png.cpp
 create mode 100644 src/EVA11/base/Png.h
 create mode 100644 src/EVA11/base/Process.cpp
 create mode 100644 src/EVA11/base/Process.h
 create mode 100644 src/EVA11/base/ProjectFixHead.h
 create mode 100644 src/EVA11/base/ProjectGBText.h
 create mode 100644 src/EVA11/base/Resource.cpp
 create mode 100644 src/EVA11/base/Resource.h
 create mode 100644 src/EVA11/base/Rule.cpp
 create mode 100644 src/EVA11/base/Rule.h
 create mode 100644 src/EVA11/base/SQLLiteWrapper.cpp
 create mode 100644 src/EVA11/base/SQLLiteWrapper.h
 create mode 100644 src/EVA11/base/ShellCommand.cpp
 create mode 100644 src/EVA11/base/ShellCommand.h
 create mode 100644 src/EVA11/base/Sinscreen.cpp
 create mode 100644 src/EVA11/base/Sinscreen.h
 create mode 100644 src/EVA11/base/Splashscreen.cpp
 create mode 100644 src/EVA11/base/Splashscreen.h
 create mode 100644 src/EVA11/base/TCPMainwin.cpp
 create mode 100644 src/EVA11/base/TCPMainwin.h
 create mode 100644 src/EVA11/base/USB.cpp
 create mode 100644 src/EVA11/base/USB.h
 create mode 100644 src/EVA11/base/Uart.cpp
 create mode 100644 src/EVA11/base/Uart.h
 create mode 100644 src/EVA11/base/Video.cpp
 create mode 100644 src/EVA11/base/Video.h
 create mode 100644 src/EVA11/base/VideoHead.h
 create mode 100644 src/EVA11/base/VideoPanel.cpp
 create mode 100644 src/EVA11/base/VideoPanel.h
 create mode 100644 src/EVA11/base/ZKPanel.cpp
 create mode 100644 src/EVA11/base/ZKPanel.h
 create mode 100644 src/EVA11/base/ZScreen.cpp
 create mode 100644 src/EVA11/base/ZScreen.h
 create mode 100644 src/EVA11/base/cssl.c
 create mode 100644 src/EVA11/base/cssl.h
 create mode 100644 src/EVA11/base/etio.cpp
 create mode 100644 src/EVA11/base/etio.h
 create mode 100644 src/EVA11/base/main.cpp
 create mode 100644 src/EVA11/base/main.h
 delete mode 100644 src/EVA11/cssl.c
 delete mode 100644 src/EVA11/cssl.h
 delete mode 100644 src/EVA11/etio.cpp
 delete mode 100644 src/EVA11/etio.h
 delete mode 100644 src/EVA11/main.cpp
 delete mode 100644 src/EVA11/main.h

diff --git a/Makefile b/Makefile
index 3db2642..67c2be4 100644
--- a/Makefile
+++ b/Makefile
@@ -93,7 +93,7 @@ export C_COMPILE_FLAG \
 export FLAG 	    := -Wall
 
 ###########################################################
-MAKEFLAG 	    := -s -j2
+MAKEFLAG 	    := -j2
 
 .PHONY : all
 all:
@@ -101,7 +101,7 @@ ifeq ($(PROJ),)
 	$(make_msg)
 else
 	@cd $(MAKE_DIR)/src;$(MAKE) $(MAKEFLAG) $(MAKECMDGOALS)
-	@cp $(MAKE_DIR)/src/$(PROJ)/$(EXEC) $(MAKE_DIR)/bin/$(EXEC)
+	@cp $(MAKE_DIR)/src/$(PROJ)/base/$(EXEC) $(MAKE_DIR)/bin/$(EXEC)
 
 ifeq ($(DEBUG),yes)
 else
diff --git a/src/EVA11/ASMS/Asm_Fun_Sets.s b/src/EVA11/ASMS/Asm_Fun_Sets.s
deleted file mode 100644
index e1b847e..0000000
--- a/src/EVA11/ASMS/Asm_Fun_Sets.s
+++ /dev/null
@@ -1,123 +0,0 @@
-@
-@	the file only for test ARM assemble language
-@
-@      ARM Register:
-@      R0~R3  : a1~a4
-@      R4~R11 : v1~v8    R11:fp
-@      R12    : ip
-@      R13    : sp
-@      R14    : lr 
-@      R15    : pc
-@
-@
-@
-@
-	.arch armv4t
-	.fpu softvfp
-	.text
-
-
-	.align	2
-	.global	Asm_Add
-	.type	Asm_Add, %function
-	@
-	@ int Asm_Add(int,int)
-	@
-Asm_Add:
-	mov	ip, sp
-	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
-	stmfd	sp!, {fp, ip, lr, pc}
-	@ stmfd: forward down 
-	@ sp = sp - 4 * 4
-	@ 
-	@ pc			   high meory
-	@ lr 
-	@ ip 
-	@ fp  <-----  sp           low memory
-	@
-	@sub	fp, ip, #4
-	@sub	sp, sp, #8
-
-	add	r0, r0, r1
-	@ 载入一个大数的伪代码
-	ldr	r1, =0xFFFFFFFF
-	add	r0, r0, r1
-
-	@sub	sp, ip, #16
-	ldmfd	sp, {fp, sp, lr}
-	bx	lr
-	.size	Asm_Add, .-Asm_Add
-
-
-	.align	2
-	.global	Asm_Mul
-	.type	Asm_Mul, %function
-	@
-	@ int Asm_Mul(int,int)
-	@
-Asm_Mul:
-	mov	ip, sp
-	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
-	stmfd	sp!, {fp, ip, lr, pc}
-
-	mul	r2, r0, r1
-	mov     r0, r2
-
-	ldmfd	sp, {fp, sp, lr}
-	bx	lr
-	.size	Asm_Mul, .-Asm_Mul
-
-
-	.align	2
-	.global	Asm_Point
-	.type	Asm_Point, %function
-	@
-	@ int Asm_Point(int*)
-	@
-Asm_Point:
-	mov	ip, sp
-	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
-	stmfd	sp!, {fp, ip, lr, pc}
-	sub	fp, ip, #4
-	sub	sp, sp, #8
-
-	ldr	r2, .L1_PTR
-	ldr	r1, [r2,#0]
-	str     r1, [r0,#0]
-
-	sub	sp, fp, #12
-	ldmfd	sp, {fp, sp, lr}
-	bx	lr
-	.size	Asm_Point, .-Asm_Point
-
-	.align	2
-.L1_PTR:
-	.word	ScrPtr
-
-
-	.align	2
-	.global	Asm_Init
-	.type	Asm_Init, %function
-	@
-	@ void Asm_Init(void)
-	@
-Asm_Init:
-	mov	ip, sp
-	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
-	stmfd	sp!, {fp, ip, lr, pc}
-	sub	fp, ip, #4
-	sub	sp, sp, #8
-
-	ldr	r0, .L1_PTR
-	mov     r1, #101
-	str	r1, [r0,#0]
-
-	sub	sp, fp, #12
-	ldmfd	sp, {fp, sp, lr}
-	bx	lr
-	.size	Asm_Init, .-Asm_Init
-
-
-	.ident	"GCC: (crosstool-NG-1.7.2) 4.3.2"
-	.comm	ScrPtr,4,4
-	.section	.note.GNU-stack,"",%progbits
diff --git a/src/EVA11/AlarmManage.cpp b/src/EVA11/AlarmManage.cpp
deleted file mode 100644
index 8a1be1b..0000000
--- a/src/EVA11/AlarmManage.cpp
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmManage.cpp
- *
- *    Description:  implementation of ManageAlarm class
- *
- *        Version:  1.0
- *        Created:  2012年09月21日 15时01分53秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<new>
-#include 	<string.h>
-
-#include 	"Graphic.h"
-#include 	"Global.h"
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"AlarmRegion.h"
-#include 	"AlarmManage.h"
-
-AlarmManage::AlarmManage (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_AlarmMask = NULL;
-	m_AlarmMask = new char[(width-2)*(heigh-2)];
-	memset(m_AlarmMask,0xff,(width-2)*(heigh-2));
-}
-
-AlarmManage::~AlarmManage()
-{
-	if ( m_AlarmMask != NULL )
-	{
-		delete[] m_AlarmMask;
-		m_AlarmMask = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Alarm_Sets
- *  Description:  Init the Alarm parameters 
- * =====================================================================================
- */
-void AlarmManage::Init_Alarm_Sets(Graphic&)
-{
-	for ( int i=0;i<m_cMAXAlarmCount;i++ )
-	{
-		m_Alarm[0][i] = new(std::nothrow) AmpAlarm(m_X,m_Y,m_Width,m_Heigh);
-		m_Alarm[0][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-
-		m_Alarm[1][i] = new(std::nothrow) HAmpAlarm(m_X,m_Y,m_Width,m_Heigh);
-		m_Alarm[1][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-
-		m_Alarm[2][i] = new(std::nothrow) RectAlarm(m_X,m_Y,m_Width,m_Heigh);
-		m_Alarm[2][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_Alarm_Sets
- *  Description:  Destroy the Alarm Sets 
- * =====================================================================================
- */
-void AlarmManage::Destroy_Alarm_Sets()
-{
-	for ( int i=0;i<m_cMAXAlarmCount;i++ )
-	{
-		delete m_Alarm[0][i];
-		m_Alarm[0][i] = NULL;
-		delete m_Alarm[1][i];
-		m_Alarm[1][i] = NULL;
-		delete m_Alarm[2][i];
-		m_Alarm[2][i] = NULL;
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm window parameters into Object 
- * =====================================================================================
- */
-void AlarmManage::Load_Alarm_Para(int gpalarm[3][8][4])
-{
-	for ( int type = 0;type < 3; type ++ )
-	{
-		for ( int i=0;i<m_cMAXAlarmCount;i++ )
-		{
-			m_Alarm[type][i]->Set_4Para(gpalarm[type][i][0],
-						    gpalarm[type][i][1],
-						    gpalarm[type][i][2],
-						    gpalarm[type][i][3]);
-		}
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Alarm_Para
- *  Description:  Save Alarm window parameters into Object 
- * =====================================================================================
- */
-void AlarmManage::Save_Alarm_Para(int gpalarm[3][8][4])
-{
-	for ( int type = 0;type < 3;type ++ )
-	{
-		for ( int i=0;i<m_cMAXAlarmCount;i++ )
-		{
-			gpalarm[type][i][0] = m_Alarm[type][i]->Get_P1();
-		        gpalarm[type][i][1] = m_Alarm[type][i]->Get_P2();
-		        gpalarm[type][i][2] = m_Alarm[type][i]->Get_P3();
-		        gpalarm[type][i][3] = m_Alarm[type][i]->Get_P4();
-		}
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Alarm_Sets
- *  Description:  Draw all class manage alarm on screen 
- * =====================================================================================
- */
-void AlarmManage::Draw_Alarm_Sets(Graphic& g,bool bufflag)
-{
-	if 	( m_AlarmType == 3 ) return;
-
-	if ( bufflag == true )
-		g.Switch_Screen();
-
-	for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
-	{
-		m_Alarm[m_AlarmType][i]->Drawme(g,false);
-	}
-
-	if ( bufflag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Adj_P1
- *  Description:  Adjust the 4 parameters of device 
- * =====================================================================================
- */
-void AlarmManage::Adj_P1(int v,int gpalarm[3][8][4])
-{
-	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P1(v);
-	Save_Alarm_Para(gpalarm);
-}
-void AlarmManage::Adj_P2(int v,int gpalarm[3][8][4])
-{
-	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P2(v);
-	Save_Alarm_Para(gpalarm);
-}
-void AlarmManage::Adj_P3(int v,int gpalarm[3][8][4])
-{
-	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P3(v);
-	Save_Alarm_Para(gpalarm);
-}
-void AlarmManage::Adj_P4(int v,int gpalarm[3][8][4])
-{
-	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P4(v);
-	Save_Alarm_Para(gpalarm);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Create_Alarm_Area_Mask
- *  Description:  When Reset Alarm Window Area Call it to create the alram window mask 
- * =====================================================================================
- */
-void AlarmManage::Create_Alarm_Area_Mask()
-{
-	memset(m_AlarmMask,0xff,(m_Width-2)*(m_Heigh-2));
-	if ( m_AlarmType == 3 ) return;
-
-	for ( int y = m_Up + 1; y < m_Down; y++ )
-	{
-		for ( int x = m_Left + 1; x < m_Right; x++ )
-		{
-			for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
-			{
-				if ( m_Alarm[m_AlarmType][i]->Is_In_Region(x,y) )
-					m_AlarmMask[(y-(m_Up+1))*(m_Width-2)+(x-(m_Left+1))] = i;
-			}
-		}
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Alarm
- *  Description:  Judge the signal whether in Alarm 
- * =====================================================================================
- */
-int AlarmManage::Is_In_Alarm(const int& x,const int& y)
-{
-	if ( m_AlarmType == 3 ) return 0xff;
-
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
-		return m_AlarmMask[(y-(m_Up+1))*(m_Width-2)+(x-(m_Left+1))];
-	else
-		return 0xff;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Test
- *  Description:  Just for Test Alarm region is OK 
- * =====================================================================================
- */
-void AlarmManage::Test(Graphic& g)
-{
-	if ( m_AlarmType == 3 ) return;
-	for ( int x=m_Left+1;x<m_Right;x++ )
-	{
-		for ( int y=m_Up+1;y<m_Down;y++ )
-		{
-			for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
-			{
-				if ( m_Alarm[m_AlarmType][i]->Is_In_Region(x,y) )
-					g.Setpixel(x,y,g.RGB24_16(0xff0000));
-			}
-		}
-	}
-}
diff --git a/src/EVA11/AlarmManage.h b/src/EVA11/AlarmManage.h
deleted file mode 100644
index 9c105c1..0000000
--- a/src/EVA11/AlarmManage.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmManage.h
- *
- *    Description:  Manage the all alarm widown in system
- *
- *        Version:  1.0
- *        Created:  2012年09月21日 14时56分39秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef  _ALARMMANAGE_INC
-#define  _ALARMMANAGE_INC
-
-class Object;
-class Graphic;
-class IAlarm;
-class AlarmManage : public Object
-{
-	public:
-		AlarmManage (int x,int y,int width,int heigh);
-		virtual ~AlarmManage ();
-
-		void Init_Alarm_Sets(Graphic&);
-		void Destroy_Alarm_Sets();
-
-		void Load_Alarm_Para(int gpalarm[3][8][4]);
-		void Save_Alarm_Para(int gpalarm[3][8][4]);
-
-		void Draw_Alarm_Sets(Graphic& g,bool bufflag=false);
-
-		void Adj_P1(int,int gpalarm[3][8][4]); 
-		void Adj_P2(int,int gpalarm[3][8][4]); 
-		void Adj_P3(int,int gpalarm[3][8][4]); 
-		void Adj_P4(int,int gpalarm[3][8][4]); 
-
-		void Create_Alarm_Area_Mask();
-		int Is_In_Alarm(const int& x,const int& y); 
-
-		void Test(Graphic& g);
-		/*-----------------------------------------------------------------------------
-		 * Attrib Operation of Alarm  
-		 *-----------------------------------------------------------------------------*/
-		inline void Set_Alarm_Type(int type) { m_AlarmType = type; }
-		inline int Get_Alarm_Type() { return m_AlarmType; }
-		inline void Set_Alarm_Count(int index,int value) { m_AlarmCount[index] = value; }
-		inline int Get_Alarm_Count(int index) { return m_AlarmCount[index]; }
-		inline void Set_Alarm_Index(int index,int value) { m_AlarmIndex[index] = value; }
-		inline int Get_Alarm_Index(int index) { return m_AlarmIndex[index]; }
-
-	protected:
-
-	private:
-		static const int	m_cMAXAlarmCount = 8;
-		IAlarm*			m_Alarm[3][m_cMAXAlarmCount];
-		char*			m_AlarmMask;
-
-		int			m_AlarmType;
-		int			m_AlarmCount[3];
-		int			m_AlarmIndex[3];
-};
-#endif
diff --git a/src/EVA11/AlarmRegion.cpp b/src/EVA11/AlarmRegion.cpp
deleted file mode 100644
index dd0c673..0000000
--- a/src/EVA11/AlarmRegion.cpp
+++ /dev/null
@@ -1,1102 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmRegion.cpp
- *
- *    Description:  Declaration of AlarmRegion class
- *
- *        Version:  1.0
- *        Created:  2012年09月18日 10时07分56秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<cmath>
-#include 	<vector>
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"AlarmRegion.h"
-#include 	"Graphic.h"
-#include 	"Algorithm.h"
-
-IAlarm::IAlarm (int x,int y,int width,int height)
-	: Basescreen(x,y,width,height)
-{
-	alg = Algorithm::Instance();
-}
-
-IAlarm::~IAlarm ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Border
- *  Description:  Set the border of View 
- * =====================================================================================
- */
-void IAlarm::Set_4Para(int p1,int p2,int p3,int p4)
-{
-	m_P1	  = 	p1;
-	m_P2 	  =	p2;
-	m_P3	  =  	p3;
-	m_P4	  = 	p4;
-}
-
-int IAlarm::Get_P1() { return m_P1; }
-int IAlarm::Get_P2() { return m_P2; }
-int IAlarm::Get_P3() { return m_P3; }
-int IAlarm::Get_P4() { return m_P4; }
-
-void IAlarm::Set_P1(int v) { m_P1 = v; }
-void IAlarm::Set_P2(int v) { m_P2 = v; }
-void IAlarm::Set_P3(int v) { m_P3 = v; }
-void IAlarm::Set_P4(int v) { m_P4 = v; }
-
-/* ----------------------------------------------------------------------------------- */
-
-RectAlarm::RectAlarm(int x,int y,int width,int height)
-	: IAlarm(x,y,width,height)
-{
-}
-RectAlarm::~RectAlarm()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw self on screen 
- * =====================================================================================
- */
-void RectAlarm::Refreshme(Graphic& g)
-{
-	ColorObj *colorobj = ColorObj::Instance();
-
-	short *datax = new short[4];
-	short *datay = new short[4];
-
-	datax[0] = m_P1;
-	datax[1] = m_P3;
-	datax[2] = m_P3;
-	datax[3] = m_P1;
-
-	datay[0] = m_P2;
-	datay[1] = m_P2;
-	datay[2] = m_P4;
-	datay[3] = m_P4+1;
-
-	g.FillPolygonColor(datax,datay,4,colorobj->Get_ColorVP(1)->color32);
-	g.PolygonColor(datax,datay,4,colorobj->Get_ColorVP(13)->color32);
-
-	delete[] datax;
-	datax = NULL;
-	delete[] datay;
-	datay = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Region
- *  Description:  Judge the point is it in alram region 
- * =====================================================================================
- */
-bool RectAlarm::Is_In_Region(int x,int y)
-{
-	if ( x>m_P1 && x <m_P3 && y > m_P2 && y < m_P4 )
-		return true;
-	else 
-		return false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Px
- *  Description:  Set the 4 parameters of Rect region
- *      caution:  P1:left P2:Up P3:Right P4:Down
- * =====================================================================================
- */
-void RectAlarm::Adj_P1(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			m_P1 ++;
-			if 	( m_P1 >= m_P3 )
-				m_P1 = m_P3 - 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			m_P1 --;
-			if 	( m_P1 <= m_X )
-				m_P1 = m_X + 1; 
-		}
-	}
-}
-void RectAlarm::Adj_P2(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			m_P2 ++;
-			if 	( m_P2 >= m_P4 )
-				m_P2 = m_P4 - 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			m_P2 --;
-			if 	( m_P2 <= m_Up )
-				m_P2 = m_Up + 1; 
-		}
-	}
-}
-void RectAlarm::Adj_P3(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			m_P3 ++;
-			if 	( m_P3 >= m_Right )
-				m_P3 = m_Right - 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			m_P3 --;
-			if 	( m_P3 <= m_P1 )
-				m_P3 = m_P1 + 1;
-		}
-	}
-}
-void RectAlarm::Adj_P4(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			m_P4 ++;
-			if 	( m_P4 >= m_Down )
-				m_P4 = m_Down - 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			m_P4 --;
-			if 	( m_P4 <= m_P2 )
-				m_P4 = m_P2 + 1; 
-		}
-	}
-}
-
-/* ----------------------------------------------------------------------------------- */
-/* ----------------------------------------------------------------------------------- */
-/* ----------------------------------------------------------------------------------- */
-
-AmpAlarm::AmpAlarm (int x,int y,int width,int height)
-	: IAlarm(x,y,width,height)
-{
-}
-
-AmpAlarm::~AmpAlarm()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw me on screen 
- * =====================================================================================
- */
-void AmpAlarm::Refreshme(Graphic& g)
-{
-	ColorObj *colorobj = ColorObj::Instance();
-	std::vector<int> vx1,vy1,vx2,vy2;
-
-	int starpointx;
-	int starpointy;
-	int endpointx;
-	int endpointy;
-
-	int _starpointx;
-	int _starpointy;
-	int _endpointx;
-	int _endpointy;
-
-	short dg1=0,dg2=0;                       /* the really degree */
-
-	int x,y;
-
-	if (m_P1 != 90)
-	{
-		double k;
-		k=alg->Get_Tan_Value(m_P1) * m_P3 / m_P4;
-		dg1 = static_cast<int>(180*atan(k)/3.1415926); 
-		if (dg1 < 0) dg1 += 180;
-	}
-	else { dg1 = 90; }
-	if (m_P2 != 90)
-	{
-		double k;
-		k=alg->Get_Tan_Value(m_P2) * m_P3 / m_P4;
-		dg2 = static_cast<int>(180*atan(k)/3.1415926); 
-		if (dg2 < 0) dg2 += 180;
-	}
-	else { dg2 = 90; }
-
-	starpointx = static_cast<int>(m_Center_X+m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
-	starpointy = static_cast<int>(m_Center_Y-m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
-	endpointx  = static_cast<int>(m_Center_X+m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
-	endpointy  = static_cast<int>(m_Center_Y-m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
-	_starpointx = static_cast<int>(m_Center_X-m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
-	_starpointy = static_cast<int>(m_Center_Y+m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
-	_endpointx  = static_cast<int>(m_Center_X-m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
-	_endpointy  = static_cast<int>(m_Center_Y+m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
-
-	for (int i=(180-static_cast<int>(dg2));i<(180-static_cast<int>(dg1));i++)
-	{
-		vx1.push_back(static_cast<int>(m_Center_X+m_P3*alg->Get_Cos_Value(i)));
-		vy1.push_back(static_cast<int>(m_Center_Y-m_P4*alg->Get_Sin_Value(i)));
-
-		vx2.push_back(static_cast<int>(m_Center_X-m_P3*alg->Get_Cos_Value(i)));
-		vy2.push_back(static_cast<int>(m_Center_Y+m_P4*alg->Get_Sin_Value(i)));
-	}
-
-	vx1.push_back(starpointx);
-	vy1.push_back(starpointy);
-
-	vx2.push_back(_starpointx);
-	vy2.push_back(_starpointy);
-
-
-	int flag = 0;
-	if 	( (dg1 > 0) && (dg1 < 90) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
-		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx1.push_back(m_Left+1);
-			vy1.push_back(m_Center_Y-y);
-			vx2.push_back(m_Right-1);
-			vy2.push_back(m_Center_Y+y);
-			flag = 0;
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			vx1.push_back(m_Center_X+x);
-			vy1.push_back(m_Up+1);
-			vx2.push_back(m_Center_X-x);
-			vy2.push_back(m_Down-1);
-			flag = 1;
-		}
-	}
-	else if (dg1 == 90 || dg1 == 91)
-	{
-		vx1.push_back(starpointx);
-		vy1.push_back(m_Up+1);
-		
-		vx2.push_back(starpointx);
-		vy2.push_back(m_Down-1);
-		flag = 2;
-	}
-	else if ( (dg1 > 91) && (dg1 < 180) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
-		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx1.push_back(m_Right-1);
-			vy1.push_back(m_Center_Y-y);
-
-			vx2.push_back(m_Left+1);
-			vy2.push_back(m_Center_Y+y);
-			flag = 4;
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			vx1.push_back(m_Center_X+x);
-			vy1.push_back(m_Up+1);
-
-			vx2.push_back(m_Center_X-x);
-			vy2.push_back(m_Down-1);
-			flag = 3;
-		}
-	}
-
-//--------------------------
-	if ( (dg2 > 0) && (dg2 < 90) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
-		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx1.push_back(m_Left+1);
-			vy1.push_back(m_Center_Y-y);
-
-			vx2.push_back(m_Right-1);
-			vy2.push_back(m_Center_Y+y);
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-
-			if ( flag == 0 )
-			{
-				vx1.push_back(m_Left+1);
-				vy1.push_back(m_Up+1);
-
-				vx2.push_back(m_Right-1);
-				vy2.push_back(m_Down-1);
-			}
-
-			vx1.push_back(m_Center_X+x);
-			vy1.push_back(m_Up+1);
-
-			vx2.push_back(m_Center_X-x);
-			vy2.push_back(m_Down-1);
-		}
-	}
-	else if ( dg2 == 90 || dg2 == 91 )
-	{
-		if ( flag == 0 )
-		{
-			vx1.push_back(m_Left+1);
-			vy1.push_back(m_Up+1);
-
-			vx2.push_back(m_Right-1);
-			vy2.push_back(m_Down-1);
-		}
-
-		vx1.push_back(endpointx);
-		vy1.push_back(m_Up+1);
-
-		vx2.push_back(endpointx);
-		vy2.push_back(m_Down-1);
-	}
-	else if ( (dg2 > 91) && (dg2 < 180) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
-		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			if ( flag == 0 )
-			{
-				vx1.push_back(m_Left+1);
-				vy1.push_back(m_Up+1);
-
-				vx1.push_back(m_Right-1);
-				vy1.push_back(m_Up+1);
-
-				vx2.push_back(m_Right-1);
-				vy2.push_back(m_Down-1);
-
-				vx2.push_back(m_Left+1);
-				vy2.push_back(m_Down-1);
-			}
-			else if ( flag != 0 && flag != 4 )
-			{
-				vx1.push_back(m_Right-1);
-				vy1.push_back(m_Up+1);
-
-				vx2.push_back(m_Left+1);
-				vy2.push_back(m_Down-1);
-			}
-
-			vx1.push_back(m_Right-1);
-			vy1.push_back(m_Center_Y-y);
-
-			vx2.push_back(m_Left+1);
-			vy2.push_back(m_Center_Y+y);
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-
-			if ( flag == 0 )
-			{
-				vx1.push_back(m_Left+1);
-				vy1.push_back(m_Up+1);
-
-				vx2.push_back(m_Right-1);
-				vy2.push_back(m_Down-1);
-			}
-
-			vx1.push_back(m_Center_X+x);
-			vy1.push_back(m_Up+1);
-
-			vx2.push_back(m_Center_X-x);
-			vy2.push_back(m_Down-1);
-		}
-	}
-
-	int len = vx1.size();
-	short *datax1 = new short[len];
-	short *datay1 = new short[len];
-	short *datax2 = new short[len];
-	short *datay2 = new short[len];
-
-	for ( int i=0;i<len;i++ )
-	{
-		datax1[i] = vx1[i];
-		datay1[i] = vy1[i];
-		datax2[i] = vx2[i];
-		datay2[i] = vy2[i];
-	}
-
-	g.FillPolygonColor(datax1,datay1,len,colorobj->Get_ColorVP(1)->color32);
-	g.PolygonColor(datax1,datay1,len,colorobj->Get_ColorVP(13)->color32);
-
-	g.FillPolygonColor(datax2,datay2,len,colorobj->Get_ColorVP(1)->color32);
-	g.PolygonColor(datax2,datay2,len,colorobj->Get_ColorVP(13)->color32);
-
-//	g.Ascii(starpointx,starpointy,'A',colorobj->Get_ColorVP(16)->color32);
-
-	delete[] datax1;
-	datax1 = NULL;
-	delete[] datay1;
-	datay1 = NULL;
-	delete[] datax2;
-	datax2 = NULL;
-	delete[] datay2;
-	datay2 = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Region
- *  Description:  Judge the point is it in alram region 
- * =====================================================================================
- */
-bool AmpAlarm::Is_In_Region(int x,int y)
-{
-	int x_tmp = 0;
-	int y_tmp = 0;
-
-	if ( y > m_Center_Y )
-	{
-		y_tmp = m_Center_Y - abs( y - m_Center_Y );
-		if ( x > m_Center_X ) 
-			x_tmp = m_Center_X - ( x - m_Center_X );
-		else
-			x_tmp = m_Center_X + ( m_Center_X - x );
-	}
-	else
-	{
-		x_tmp = x;
-		y_tmp = y;
-	}
-
-	int t1,t2,t3,t4;
-	if ( (m_P1 != 90) && (m_P2 != 90)  )
-	{
-		y_tmp = m_Center_Y - y_tmp;
-		t1 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));	
-		t2 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
-		if ( ((x_tmp > (t1 - 1) ) && (x_tmp > (t2 - 1))) || ( ( x_tmp <  t1 ) && ( x_tmp <  t2 )))
-		{
-			return false;
-		}	
-		else
-		{
-			x_tmp = abs(m_Center_X - x_tmp); 
-			t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-			t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-			if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1)
-				return true;
-			else
-				return false;
-		}
-	}
-	else
-	{
-		if (m_P1 == 90)
-		{
-			y_tmp = m_Center_Y - y_tmp;
-			t1 = m_Center_X;
-			t2 = m_Center_X - static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
-			if ( ((x_tmp > ( t1 - 1) ) && (x_tmp > ( t2 - 1))) || ( x_tmp < ( t1 ) && x_tmp < ( t2 )))
-			{
-				return false;
-			}	
-			else            /* the point is in the fan area */
-			{
-				x_tmp = abs(m_Center_X - x_tmp);
-				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) 
-					return true;
-				else
-					return false;
-			}
-		}
-		else            /* p2 == 90 degree */
-		{
-			y_tmp = m_Center_Y - y_tmp;
-			t1 = m_Center_X-static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));	;
-			t2 = m_Center_X;
-			if ( ((x_tmp > ( t1 - 1) ) && (x_tmp > ( t2 - 1))) || ( x_tmp < ( t1 ) && x_tmp < ( t2 )))
-				return false;
-			else
-			{
-				x_tmp = abs(m_Center_X - x_tmp);
-				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1)
-					return true;
-				else
-					return false;
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Px
- *  Description:  Set the 4 parameters of Rect region
- *      caution:  P1:left P2:Up P3:Right P4:Down
- * =====================================================================================
- */
-void AmpAlarm::Adj_P1(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			if ( m_P1 == ( m_P2 - 5 ) ) m_P1 = m_P1;
-			else m_P1 += 1; 
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			if ( m_P1 == 3 ) m_P1 = m_P1;
-			else m_P1 -= 1; 
-		}
-	}
-}
-void AmpAlarm::Adj_P2(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			if 	( m_P2 == 177 ) m_P2 = m_P2;
-			else m_P2 += 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			if 	( m_P2 == ( m_P1 + 5 ) ) m_P2 = m_P2;
-			else m_P2 -= 1;
-		}
-	}
-}
-void AmpAlarm::Adj_P3(int v)
-{
-	m_P3 += v;
-	if 	( m_P3 < (m_Width>>3) ) m_P3 = (m_Width>>3);
-	else if ( m_P3 > ((m_Width>>2)+(m_Width>>3)) ) m_P3 = (m_Width>>2)+(m_Width>>3);
-
-	if 	( m_P3 < m_P4 )
-	{
-		m_P3 = m_P4;
-	}
-}
-void AmpAlarm::Adj_P4(int v)
-{
-	m_P4 += v;
-	if 	( m_P4 < (m_Width>>3) ) m_P4 = (m_Width>>3);
-	else if ( m_P4 > ((m_Width>>2)+(m_Width>>3)) ) m_P4 = (m_Width>>2)+(m_Width>>3);
-
-	if 	( m_P4 > m_P3 )
-	{
-		m_P4 = m_P3;
-	}
-}
-
-/* ----------------------------------------------------------------------------------- */
-/* ----------------------------------------------------------------------------------- */
-/* ----------------------------------------------------------------------------------- */
-
-HAmpAlarm::HAmpAlarm (int x,int y,int width,int height)
-	: IAlarm(x,y,width,height)
-{
-}
-
-HAmpAlarm::~HAmpAlarm()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw me on screen 
- * =====================================================================================
- */
-void HAmpAlarm::Refreshme(Graphic& g)
-{
-	ColorObj *colorobj = ColorObj::Instance();
-	std::vector<int> vx,vy;
-
-	int x,y;
-	int starpointx;
-	int starpointy;
-	int endpointx;
-	int endpointy;
-
-	int dg1=0,dg2=0;                       /* the really degree */
-	if 	(m_P1 != 90)
-	{
-		double k;
-		k=alg->Get_Tan_Value(m_P1) * m_P3 / m_P4;
-		dg1 = static_cast<int>(180*atan(k)/3.1415926); 
-		if (dg1 < 0) dg1 += 180;
-	}
-	else { dg1 = 90; }
-	if 	( m_P2 != 90 )
-	{
-		double k;
-		k=alg->Get_Tan_Value(m_P2) * m_P3 / m_P4;
-		dg2 = static_cast<int>(180*atan(k)/3.1415926); 
-		if (dg2 < 0) dg2 += 180;
-	}
-	else { dg2 = 90; }
-
-	starpointx     = static_cast<int>(m_Center_X+m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
-
-	starpointy     = static_cast<int>(m_Center_Y-m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
-
-	endpointx      = static_cast<int>(m_Center_X+m_P3 *
-			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
-
-	endpointy      = static_cast<int>(m_Center_Y-m_P4 *
-			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
-
-	for (int i=(180-static_cast<int>(dg2));i<(180-static_cast<int>(dg1));i++)
-	{
-		vx.push_back(static_cast<int>(m_Center_X+m_P3*alg->Get_Cos_Value(i)));
-		vy.push_back(static_cast<int>(m_Center_Y-m_P4*alg->Get_Sin_Value(i)));
-	}
-
-	vx.push_back(starpointx);
-	vy.push_back(starpointy);
-
-	int flag = 0;
-	if 	( (dg1 > 0) && (dg1 < 90) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
-		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx.push_back(m_Left+1);
-			vy.push_back(m_Center_Y-y);
-			flag = 0;
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			vx.push_back(m_Center_X+x);
-			vy.push_back(m_Up+1);
-			flag = 1;
-		}
-	}
-	else if ( dg1 == 90 || dg1 == 91 )
-	{
-		vx.push_back(starpointx);
-		vy.push_back(m_Up+1);
-		flag = 2;
-	}
-	else if	( (dg1 > 91) && (dg1 < 180) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
-		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx.push_back(m_Right-1);
-			vy.push_back(m_Center_Y-y);
-			flag = 4;
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			vx.push_back(m_Center_X+x);
-			vy.push_back(m_Up+1);
-			flag = 3;
-		}
-	}
-//--------------------------
-	if 	( (dg2 > 0) && (dg2 < 90) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
-		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			vx.push_back(m_Left+1);
-			vy.push_back(m_Center_Y-y);
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			if ( flag == 0 )
-			{
-				vx.push_back(m_Left+1);
-				vy.push_back(m_Up+1);
-			}
-
-			vx.push_back(m_Center_X+x);
-			vy.push_back(m_Up+1);
-		}
-	}
-	else if (dg2 == 90 || dg2 == 91 )
-	{
-		if ( flag == 0 )
-		{
-			vx.push_back(m_Left+1);
-			vy.push_back(m_Up+1);
-		}
-
-		vx.push_back(endpointx);
-		vy.push_back(m_Up+1);
-	}
-	else if ( (dg2 > 91) && (dg2 < 180) )
-	{
-		double k=0,b=0;
-		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
-		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
-
-		if ( m_Center_Y - y >  m_Up + 1 )
-		{
-			if ( flag == 0 )
-			{
-				vx.push_back(m_Left+1);
-				vy.push_back(m_Up+1);
-
-				vx.push_back(m_Right-1);
-				vy.push_back(m_Up+1);
-
-			}
-			else if ( flag != 0 && flag != 4 )
-			{
-				vx.push_back(m_Right-1);
-				vy.push_back(m_Up+1);
-			}
-
-			vx.push_back(m_Right-1);
-			vy.push_back(m_Center_Y-y);
-		}
-		else
-		{
-			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
-			if ( flag == 0 )
-			{
-				vx.push_back(m_Left+1);
-				vy.push_back(m_Up+1);
-			}
-
-			vx.push_back(m_Center_X+x);
-			vy.push_back(m_Up+1);
-		}
-	}
-
-	int len = vx.size();
-	short *datax = new short[len];
-	short *datay = new short[len];
-
-	for ( int i=0;i<len;i++ )
-	{
-		datax[i] = vx[i];
-		datay[i] = vy[i];
-	}
-
-	g.FillPolygonColor(datax,datay,len,colorobj->Get_ColorVP(1)->color32);
-	g.PolygonColor(datax,datay,len,colorobj->Get_ColorVP(13)->color32);
-
-//	g.Ascii(starpointx,starpointy,'A',colorobj->Get_ColorVP(16)->color32);
-
-	delete[] datax;
-	datax = NULL;
-	delete[] datay;
-	datay = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Region
- *  Description:  Judge the point is it in alram region 
- * =====================================================================================
- */
-bool HAmpAlarm::Is_In_Region(int x,int y)
-{
-	int x_tmp = 0;
-	int y_tmp = 0;
-
-	if ( y > m_Center_Y )
-		return false;
-		
-	int t1,t2,t3,t4;
-	if ( (m_P1 != 90) && (m_P2 != 90)  )
-	{
-		y_tmp = m_Center_Y - y;
-		t1 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));
-		t2 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));
-		if ( ((x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( ( x <  t1 ) && ( x <  t2 )))
-			return false;
-		else
-		{
-			x_tmp = abs(m_Center_X - x); 
-			t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-			t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-			if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1 )                        /* outsize of the ellipse area */
-				return true; 
-			else
-				return false;
-		}
-	}
-	else
-	{
-		if (m_P1 == 90)
-		{
-			y_tmp = m_Center_Y - y;
-			t1 = m_Center_X;
-			t2 = m_Center_X - static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
-			if (( (x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( x < ( t1 ) && x < ( t2 )))
-				return false;
-			else
-			{
-				x_tmp = abs(m_Center_X - x);
-				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) /* outsize of the ellipse area */
-					return true;
-				else
-					return false;
-			}
-		}
-		else            /* p2 == 90 degree */
-		{
-			y_tmp = m_Center_Y - y;
-			t1 = m_Center_X-static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));
-			t2 = m_Center_X;
-			if ( ((x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( x < ( t1 ) && x < ( t2 )))
-				return false;
-			else
-			{
-				x_tmp = abs(m_Center_X - x);
-				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
-				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
-				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) /* outsize of the ellipse area */
-					return true;
-				else
-					return false;
-			}
-		}
-	}
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Px
- *  Description:  Set the 4 parameters of Rect region
- *      caution:  P1:left P2:Up P3:Right P4:Down
- * =====================================================================================
- */
-void HAmpAlarm::Adj_P1(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			if ( m_P1 == ( m_P2 - 5 ) ) m_P1 = m_P1;
-			else m_P1 += 1; 
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			if ( m_P1 == 3 ) m_P1 = m_P1;
-			else m_P1 -= 1; 
-		}
-	}
-}
-void HAmpAlarm::Adj_P2(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			if 	( m_P2 == 177 ) m_P2 = m_P2;
-			else m_P2 += 1;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			if 	( m_P2 == ( m_P1 + 5 ) ) m_P2 = m_P2;
-			else m_P2 -= 1;
-		}
-	}
-}
-void HAmpAlarm::Adj_P3(int v)
-{
-	m_P3 += v;
-	if 	( m_P3 < (m_Width>>3) ) m_P3 = (m_Width>>3);
-	else if ( m_P3 > ((m_Width>>3)+(m_Width>>2)) ) m_P3 = (m_Width>>2)+(m_Width>>3);
-
-	if 	( m_P3 < m_P4 )
-	{
-		m_P3 = m_P4;
-	}
-}
-void HAmpAlarm::Adj_P4(int v)
-{
-	m_P4 += v;
-	if 	( m_P4 < (m_Width>>3) ) m_P4 = (m_Width>>3);
-	else if ( m_P4 > ((m_Width>>3)+(m_Width>>2)) ) m_P4 = (m_Width>>2)+(m_Width>>3);
-
-	if 	( m_P4 > m_P3 )
-	{
-		m_P4 = m_P3;
-	}
-}
-
-SLimitAlarm::SLimitAlarm (int x,int y,int width,int height)
-	: IAlarm(x,y,width,height)
-{
-}
-
-SLimitAlarm::~SLimitAlarm()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw me on screen 
- * =====================================================================================
- */
-void SLimitAlarm::Refreshme(Graphic& g)
-{
-	ColorObj *colorobj = ColorObj::Instance();
-
-	short *datax = new short[4];
-	short *datay = new short[4];
-
-	datax[0] = m_Left + 1;
-	datax[1] = m_Right - 1;
-	datax[2] = m_Right - 1;
-	datax[3] = m_Left + 1;
-
-	datay[0] = m_Center_Y + m_P1;
-	datay[1] = m_Center_Y + m_P1;
-	datay[2] = m_Up + 1;
-	datay[3] = m_Up + 1 + 1;
-
-	g.FillPolygonColor(datax,datay,4,colorobj->Get_ColorVP(1)->color32);
-	g.PolygonColor(datax,datay,4,colorobj->Get_ColorVP(13)->color32);
-
-	delete[] datax;
-	datax = NULL;
-	delete[] datay;
-	datay = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Region
- *  Description:  Judge the point is it in alram region 
- * =====================================================================================
- */
-bool SLimitAlarm::Is_In_Region(int x,int y)
-{
-	if ( y <= ( m_Center_Y + m_P1 ) )
-		return true;
-	return false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Px
- *  Description:  Set the 4 parameters of Rect region
- *      caution:  P1:left P2:Up P3:Right P4:Down
- * =====================================================================================
- */
-void SLimitAlarm::Adj_P1(int v)
-{
-	if 	( v > 0 )
-	{
-		for ( int i=0;i<v;i++ )
-		{
-			m_P1 ++;
-			if 	( m_Center_Y + m_P1 >= m_Down - 10 )
-				m_P1 = m_Down - 10 - m_Center_Y;
-		}
-	}
-	else
-	{
-		for ( int i=0;i<-v;i++ )
-		{
-			m_P1 --;
-			if 	( m_Center_Y + m_P1 <= m_Up + 10 )
-				m_P1 = m_Up + 10 - m_Center_Y; 
-		}
-	}
-}
-void SLimitAlarm::Adj_P2(int v)
-{
-}
-void SLimitAlarm::Adj_P3(int v)
-{
-}
-void SLimitAlarm::Adj_P4(int v)
-{
-}
diff --git a/src/EVA11/AlarmRegion.h b/src/EVA11/AlarmRegion.h
deleted file mode 100644
index 1106906..0000000
--- a/src/EVA11/AlarmRegion.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmRegion.h
- *
- *    Description:  AlarmRegion class declaration
- *
- *        Version:  1.0
- *        Created:  2012年09月18日 10时04分12秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ALARMREGION_INC
-#define  _ALARMREGION_INC
-
-/*-----------------------------------------------------------------------------
- *  Base class of All Alarm Region class
- *-----------------------------------------------------------------------------*/
-class Graphic;
-class Basescreen;
-class Algorithm;
-class IAlarm : public Basescreen
-{
-	public:
-		IAlarm (int x,int y,int width,int height);   		/* Becare this function  set the bordor of alarm */
-		virtual ~IAlarm ();
-
-		virtual void Refreshme(Graphic &g)     = 0;
-		virtual bool Is_In_Region(int x,int y) = 0;
-
-		void Set_4Para(int p1,int p2,int p3,int p4);
-
-		/*-----------------------------------------------------------------------------
-		 *  Operation of set parameters
-		 *-----------------------------------------------------------------------------*/
-		void virtual Adj_P1(int) = 0;
-		void virtual Adj_P2(int) = 0;
-		void virtual Adj_P3(int) = 0;
-		void virtual Adj_P4(int) = 0;
-
-		virtual int Get_P1() 	    ;
-		virtual int Get_P2() 	    ;
-		virtual int Get_P3() 	    ;
-		virtual int Get_P4() 	    ;
-
-		virtual void Set_P1(int)    ;
-		virtual void Set_P2(int)    ;
-		virtual void Set_P3(int)    ;
-		virtual void Set_P4(int)    ;
-
-	protected:
-		int			m_P1;
-		int			m_P2;
-		int			m_P3;
-		int			m_P4;
-
-		Algorithm*		alg;
-
-	private:
-};
-
-class RectAlarm : public IAlarm
-{
-	public:
-		RectAlarm (int x,int y,int width,int height);
-		~RectAlarm ();
-
-		virtual void Refreshme(Graphic &g);
-		virtual bool Is_In_Region(int x,int y);
-
-		void virtual Adj_P1(int);
-		void virtual Adj_P2(int);
-		void virtual Adj_P3(int);
-		void virtual Adj_P4(int);
-
-	protected:
-
-	private:
-
-};
-
-class AmpAlarm : public IAlarm
-{
-	public:
-		AmpAlarm(int x,int y,int width,int height);
-		~AmpAlarm();
-
-		virtual void Refreshme(Graphic &g);
-		virtual bool Is_In_Region(int x,int y);
-
-		void virtual Adj_P1(int);
-		void virtual Adj_P2(int);
-		void virtual Adj_P3(int);
-		void virtual Adj_P4(int);
-	protected:
-
-	private:
-
-};
-
-class HAmpAlarm : public IAlarm
-{
-	public:
-		HAmpAlarm(int x,int y,int width,int height);
-		~HAmpAlarm();
-
-		virtual void Refreshme(Graphic &g);
-		virtual bool Is_In_Region(int x,int y);
-
-		void virtual Adj_P1(int);
-		void virtual Adj_P2(int);
-		void virtual Adj_P3(int);
-		void virtual Adj_P4(int);
-};
-
-class SLimitAlarm : public IAlarm
-{
-	public:
-		SLimitAlarm(int x,int y,int width,int height);
-		~SLimitAlarm();
-
-		virtual void Refreshme(Graphic &g);
-		virtual bool Is_In_Region(int x,int y);
-
-		void virtual Adj_P1(int);
-		void virtual Adj_P2(int);
-		void virtual Adj_P3(int);
-		void virtual Adj_P4(int);
-};
-
-#endif
diff --git a/src/EVA11/AlarmView.cpp b/src/EVA11/AlarmView.cpp
deleted file mode 100644
index 97b6f04..0000000
--- a/src/EVA11/AlarmView.cpp
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmView.cpp
- *
- *    Description:  Implementation of AlarmView class 
- *
- *        Version:  1.0
- *        Created:  2012年09月17日 13时34分43秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdlib>
-#include 	<cstdio>
-
-#include 	"Graphic.h"
-#include	"Global.h"
-#include 	"Device.h"
-#include 	"Language.h"
-
-#include 	"Object.h"
-
-#include 	"BasePanel.h"
-#include 	"IView.h"
-#include	"DetectView.h"
-#include 	"AlarmView.h"
-
-#include 	"FreeType.h"
-
-AlarmView::AlarmView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-	m_DetectView = NULL;
-}
-
-AlarmView::~AlarmView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view sets 
- * =====================================================================================
- */
-void AlarmView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  
- * =====================================================================================
- */
-void AlarmView::Release_View()
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  Loop View
- * =====================================================================================
- */
-int AlarmView::Loop_View(Graphic& g)
-{
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_DetectView_Object
- *  Description:  For Alarm view draw GUI on screen 
- * =====================================================================================
- */
-void AlarmView::Load_View_Object(IView* obj)
-{
-	m_DetectView = dynamic_cast<DetectView *>(obj);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message system
- * =====================================================================================
- */
-void AlarmView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI Object 
- * =====================================================================================
- */
-void AlarmView::Init_GUI(Graphic& g)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void AlarmView::Destroy_GUI()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- * =====================================================================================
- */
-void AlarmView::Drawme(Graphic& g)
-{
-	if ( m_DetectView != NULL )
-	{
-		m_DetectView->Drawme(g);
-//		Global *global = Global::Instance();
-//		global->bNeedResetAlarmArea = true;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Swtich_View
- *  Description:  when chang the view called it
- * =====================================================================================
- */
-void AlarmView::Switch_View()
-{
-	if ( m_DetectView != NULL )
-		m_DetectView->Switch_View();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fn_Fun
- *  Description:  Key Function 
- * =====================================================================================
- */
-int AlarmView::Key_NL1_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL1_Fun(g,sub);
-}
-int AlarmView::Key_NR1_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR1_Fun(g,sub);
-}
-int AlarmView::Key_NL2_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL2_Fun(g,sub);
-}
-int AlarmView::Key_NR2_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR2_Fun(g,sub);
-}
-int AlarmView::Key_NL3_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL3_Fun(g,sub);
-}
-int AlarmView::Key_NR3_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR3_Fun(g,sub);
-}
-int AlarmView::Key_NL4_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL4_Fun(g,sub);
-}
-int AlarmView::Key_NR4_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR4_Fun(g,sub);
-}
-int AlarmView::Key_NL5_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL5_Fun(g,sub);
-}
-int AlarmView::Key_NR5_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR5_Fun(g,sub);
-}
-int AlarmView::Key_NL6_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL6_Fun(g,sub);
-}
-int AlarmView::Key_NR6_Fun(Graphic& g,int sub)
-{
-	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR6_Fun(g,sub);
-}
diff --git a/src/EVA11/AlarmView.h b/src/EVA11/AlarmView.h
deleted file mode 100644
index 1a88e06..0000000
--- a/src/EVA11/AlarmView.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlarmView.h
- *
- *    Description:  Process Alarm view function
- *
- *        Version:  1.0
- *        Created:  2012年09月17日 13时31分45秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ALARMVIEW_INC
-#define  _ALARMVIEW_INC
-
-class IView;
-class DetectView;
-class AlarmView : public IView
-{
-	public:
-		AlarmView (int x,int y,int width,int heigh);
-		~AlarmView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		virtual void Drawme(Graphic&);
-
-		void Load_View_Object(IView* obj);
-		void Switch_View();
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		DetectView*		m_DetectView;
-	private:
-};
-#endif
diff --git a/src/EVA11/AlgMixing.cpp b/src/EVA11/AlgMixing.cpp
deleted file mode 100644
index e6e44b5..0000000
--- a/src/EVA11/AlgMixing.cpp
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlgMixing.cpp
- *
- *    Description:  Implementation of AlgMixing
- *
- *        Version:  1.0
- *        Created:  2012年11月16日 09时07分27秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cmath>
-#include 	<cstdio>
-
-#include 	<algorithm>
-#include 	"AlgMixing.h"
-#include 	"CalculateCenter.h"
-
-#include 	"Algorithm.h"
-#include 	"Global.h"
-
-#include 	"Logic.h"
-
-#include	<gsl/gsl_rng.h> 
-#include	<gsl/gsl_randist.h> 
-#include	<gsl/gsl_vector.h> 
-#include	<gsl/gsl_matrix.h> 
-#include	<gsl/gsl_multifit.h> 
-#include	<gsl/gsl_multifit_nlin.h> 
-#include 	<gsl/gsl_blas.h>
-
-#include 	"FitHead.h"
-
-extern "C"
-{
-	int expb_f(const gsl_vector* x,void* data,gsl_vector* f);
-	int expb_df(const gsl_vector* x,void* data,gsl_matrix* J);
-	int expb_fdf(const gsl_vector* x,void* data,gsl_vector* f,gsl_matrix* J);
-};
-
-struct AlgMixing::Mixp
-{
-	double 				Sx;
-	double 				Sy;
-	double 				Cos;
-	double 				Sin;
-
-	int				Sita;
-};
-
-struct AlgMixing::MixV2
-{
-	double 				a;	
-	double 				b;
-	double 				c;
-	double 				d;
-};
-
-struct AlgMixing::PImpl
-{
-	std::vector<ETDATA>		m_vX1;
-	std::vector<ETDATA>		m_vY1;
-
-	std::vector<ETDATA>		m_vX2;
-	std::vector<ETDATA>		m_vY2;
-
-	struct Mixp			m_Mp;
-	struct MixV2			m_MV2;
-
-	int				m_AlgMix_Version;
-};
-
-AlgMixing::AlgMixing ()
-	: m_Imple(new struct PImpl)
-{
-}
-
-AlgMixing::~AlgMixing ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Object
- *  Description:  Init the Object 
- * =====================================================================================
- */
-bool AlgMixing::Init_Object()
-{
-	m_Imple->m_vX1.clear();
-	m_Imple->m_vY1.clear();
-	     
-	m_Imple->m_vX2.clear();
-	m_Imple->m_vY2.clear();
-
-	m_Imple->m_Mp.Sx    = 1;
-	m_Imple->m_Mp.Sy    = 1;
-	m_Imple->m_Mp.Cos   = 1;
-	m_Imple->m_Mp.Sin   = 0;
-	m_Imple->m_Mp.Sita  = 0;
-
-	m_Imple->m_MV2.a    = 1;
-	m_Imple->m_MV2.b    = 0;
-	m_Imple->m_MV2.c    = 1;
-	m_Imple->m_MV2.d    = 0;
-
-	m_Imple->m_AlgMix_Version
-			    = 0;
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy
- *  Description:  Destroy the object of class 
- * =====================================================================================
- */
-void AlgMixing::Destroy_Object()
-{
-	m_Imple->m_vX1.clear();
-	m_Imple->m_vY1.clear();
-	     
-	m_Imple->m_vX2.clear();
-	m_Imple->m_vY2.clear();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Mix_Para
- *  Description:  Calculate the mixing parameters
- * =====================================================================================
- */
-void AlgMixing::Calculate_Mix_Para_V2()
-{
-	int len = m_Imple->m_vX1.size();
-
-	long long y2x1 = 0;
-	long long x1x2 = 0;
-	long long y1x2 = 0;
-	long long y1y2 = 0;
-	long long x2x2 = 0;
-	long long y2y2 = 0;
-	double a;
-	double a1,b1,c1;
-
-	for ( int i=0;i<len;i++ )
-	{
-		y2x1 += static_cast<long long >(m_Imple->m_vY2[i]) * static_cast<long long >(m_Imple->m_vX1[i]);
-		x1x2 += static_cast<long long >(m_Imple->m_vX1[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
-		y1x2 += static_cast<long long >(m_Imple->m_vY1[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
-		y1y2 += static_cast<long long >(m_Imple->m_vY1[i]) * static_cast<long long >(m_Imple->m_vY2[i]);
-		x2x2 += static_cast<long long >(m_Imple->m_vX2[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
-		y2y2 += static_cast<long long >(m_Imple->m_vY2[i]) * static_cast<long long >(m_Imple->m_vY2[i]);
-	}
-
-	a1 = (static_cast<double>(y1y2)*static_cast<double>(y2x1))/static_cast<double>(y2y2)-(static_cast<double>(y1x2)*static_cast<double>(x1x2))/static_cast<double>(x2x2);
-	b1 = (static_cast<double>(x1x2)*static_cast<double>(x1x2))/static_cast<double>(x2x2)-(static_cast<double>(y1x2)*static_cast<double>(y1x2))/static_cast<double>(x2x2)-
-	     (static_cast<double>(y2x1)*static_cast<double>(y2x1))/static_cast<double>(y2y2)+(static_cast<double>(y1y2)*static_cast<double>(y1y2))/static_cast<double>(y2y2); 
-	c1 = (static_cast<double>(x1x2)*static_cast<double>(y1x2))/static_cast<double>(x2x2)-(static_cast<double>(y1y2)*static_cast<double>(y2x1))/static_cast<double>(y2y2);
-
-	a = ( -b1 + sqrt(b1*b1-4*a1*c1) ) / ( 2 * a1 ); 
-
-	m_Imple->m_Mp.Cos = + sqrt( 1 / ( a * a + 1 ) );
-	m_Imple->m_Mp.Sin = a * m_Imple->m_Mp.Cos;
-
-	m_Imple->m_Mp.Sx  = ( m_Imple->m_Mp.Cos * static_cast<double>(x1x2) - m_Imple->m_Mp.Sin * static_cast<double>(y1x2) ) / static_cast<double>(x2x2);
-	m_Imple->m_Mp.Sy  = ( m_Imple->m_Mp.Sin * static_cast<double>(y2x1) + m_Imple->m_Mp.Cos * static_cast<double>(y1y2) ) / static_cast<double>(y2y2);
-
-	Calculate_Deviation();
-}
-void AlgMixing::Calculate_Mix_Para()
-{
-	int len = m_Imple->m_vX1.size();
-	double *x1 = new double[len];
-	double *y1 = new double[len];
-	double *x2 = new double[len];
-	double *y2 = new double[len];
-
-	for ( int i=0;i<len;i++ )
-	{
-		x1[i] = m_Imple->m_vX1[i];
-		y1[i] = m_Imple->m_vY1[i];
-		x2[i] = m_Imple->m_vX2[i];
-		y2[i] = m_Imple->m_vY2[i];
-	}
-
-	NoLine_Fitting(x1,y1,x2,y2,len);
-
-	delete[] x1;
-	delete[] y1;
-	delete[] x2;
-	delete[] y2;
-	x1 = NULL;
-	y1 = NULL;
-	x2 = NULL;
-	y2 = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mixing
- *  Description:  Mixing the Signal value 
- * =====================================================================================
- */
-void AlgMixing::Mixing_V2(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y)
-{
-	double tx;
-	double ty;
-
-	tx = m_Imple->m_Mp.Sy * y * m_Imple->m_Mp.Sin + m_Imple->m_Mp.Sx * x * m_Imple->m_Mp.Cos;
-	ty = m_Imple->m_Mp.Sy * y * m_Imple->m_Mp.Cos - m_Imple->m_Mp.Sx * x * m_Imple->m_Mp.Sin;
-
-	x = static_cast<ETDATA>(tx);
-	y = static_cast<ETDATA>(ty);
-
-	x = xb - x;
-	y = yb - y;
-}
-void AlgMixing::Mixing(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y)
-{
-	double tx = m_Imple->m_MV2.a * x + m_Imple->m_MV2.b * y;
-	double ty = m_Imple->m_MV2.c * y + m_Imple->m_MV2.d * x;
-
-	x = xb - static_cast<ETDATA>(tx);
-	y = yb - static_cast<ETDATA>(ty);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Data_Into_Buffer
- *  Description:  Load Data into Buffer of object 
- * =====================================================================================
- */
-void AlgMixing::Load_Data_Into_Buffer(ETDATA *data)
-{
-	if 	( gsl_hypot(data[0],data[1]) <= 10 )
-		return;
-
-	m_Imple->m_vX1.push_back(data[0]);
-	m_Imple->m_vY1.push_back(data[1]);
-
-	m_Imple->m_vX2.push_back(data[2]);
-	m_Imple->m_vY2.push_back(data[3]);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Process_Data_Center
- *  Description:  Process Data, Let the Data focus to center 
- * =====================================================================================
- */
-void AlgMixing::Process_Data_Center()
-{
-	int len = m_Imple->m_vX1.size();
-	CalculateCenter cc1;
-	cc1.Init_Object();
-	CalculateCenter cc2;
-	cc2.Init_Object();
-
-	for ( int i=0;i<len;i++ )
-	{
-		cc1.Calculate_Graphic_MAX_MIN_Value(m_Imple->m_vX1[i],
-						    m_Imple->m_vY1[i]);
-		cc2.Calculate_Graphic_MAX_MIN_Value(m_Imple->m_vX2[i],
-						    m_Imple->m_vY2[i]);
-	}
-
-	cc1.Calculate_Graphic_Center();
-	cc2.Calculate_Graphic_Center();
-
-	int cx,cy;
-	cc1.Get_Center_Point(cx,cy);
-	for ( int i=0;i<len;i++ )
-	{
-		m_Imple->m_vX1[i] -= cx;
-		m_Imple->m_vY1[i] -= cy;
-	}
-
-	cc2.Get_Center_Point(cx,cy);
-	for ( int i=0;i<len;i++ )
-	{
-		m_Imple->m_vX2[i] -= cx;
-		m_Imple->m_vY2[i] -= cy;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_Data_From_Buffer
- *  Description:  Clean Data from Buffer 
- * =====================================================================================
- */
-void AlgMixing::Clean_Data_From_Buffer()
-{
-	m_Imple->m_vX1.clear();
-	m_Imple->m_vY1.clear();
-	     
-	m_Imple->m_vX2.clear();
-	m_Imple->m_vY2.clear();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  NoLine_Fitting
- *  Description:  NoLine Fitting 
- * =====================================================================================
- */
-void AlgMixing::NoLine_Fitting(double *x1,double *y1,double *x2,double *y2,int len)
-{
-	const int32_t n = len;
-	const int32_t p = 4;      // need
-	double sigma[n];
-
-	double *yr = new double[n];
-	for ( int i=0;i<n;i++ )
-		yr[i] = 0;
-
-	DATA d = {n,x1,y1,x2,y2,yr,sigma};
-	const gsl_multifit_fdfsolver_type *T;
-	gsl_multifit_fdfsolver *s;
-	gsl_multifit_function_fdf f;
-	f.f = &expb_f;
-	f.df = &expb_df;
-	f.fdf = &expb_fdf;
-	f.n = n;
-	f.p = p;
-	f.params = &d;
-
-//	double x_init[p] = {0.2623,0.1603,0.2916,0.085};    // need
-
-	double x_init[p] = {m_Imple->m_MV2.a,m_Imple->m_MV2.b,m_Imple->m_MV2.c,m_Imple->m_MV2.d};    // need
-	gsl_vector_view x = gsl_vector_view_array(x_init,p);
-
-	double max,min,temp;
-	for ( int i=0;i<len;i++ )
-	{
-		temp = gsl_hypot(x2[i],y2[i]);
-		if ( i==0 )
-		{
-			max = temp;
-			min = max;
-			continue;
-		}
-		if ( max < temp )
-		{
-			max = temp;
-		}
-		if ( min > temp )
-		{
-			min = temp;
-		}
-	}
-
-	/*  ---------    filled the data   --------  */
-	for ( int i=0;i<n;i++ )
-	{
-		sigma[i] = 1;
-	}
-
-	T = gsl_multifit_fdfsolver_lmsder;
-	s = gsl_multifit_fdfsolver_alloc(T,n,p);
-	gsl_multifit_fdfsolver_set(s,&f,&x.vector);
-
-	gsl_vector *g = gsl_vector_alloc(4);;
-
-	gsl_multifit_gradient(s->J,s->f,g);
-	/*  ---------    find the fit variablelue   --------  */
-	int iter = 0;
-	int status = 0;
-	do
-	{
-		iter++;
-		status = gsl_multifit_fdfsolver_iterate (s);
-		if (status)
-			break;
-
-//		status = gsl_multifit_test_delta (s->dx, s->x,
-//				0.0001, 0.0001);
-
-		status = gsl_multifit_test_gradient (g,0.00001);
-
-		printf ( "(%d) a=%f b=%f c=%f d=%f |fit(x)|=%f,\n",iter,
-						   gsl_vector_get(s->x,0),
-		                                   gsl_vector_get(s->x,1),
-						   gsl_vector_get(s->x,2),
-		                                   gsl_vector_get(s->x,3),
-		      				   gsl_blas_dnrm2(s->f));
-	}
-	while (status == GSL_CONTINUE && iter < 500);
-
-	m_Imple->m_MV2.a = gsl_vector_get(s->x,0);
-	m_Imple->m_MV2.b = gsl_vector_get(s->x,1);
-	m_Imple->m_MV2.c = gsl_vector_get(s->x,2);
-	m_Imple->m_MV2.d = gsl_vector_get(s->x,3);
-
-	gsl_vector_free(g);
-
-	delete[] yr;
-	yr = NULL;
-	gsl_multifit_fdfsolver_free(s);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Deviation
- *  Description:  Give the calculate the deviation to user 
- * =====================================================================================
- */
-void AlgMixing::Calculate_Deviation()
-{
-	long long sum = 0;
-	int len = m_Imple->m_vX1.size();
-	ETDATA x1,y1,x2,y2,xm,ym;
-	long long distance = 0;
-	int indexdistance=0;
-	int dx,dy;
-	for ( int i=0;i<len;i++ )
-	{
-		x1 = m_Imple->m_vX1[i];
-		y1 = m_Imple->m_vY1[i];
-		x2 = m_Imple->m_vX2[i];
-		y2 = m_Imple->m_vY2[i];
-		xm = x2;
-		ym = y2;
-		Mixing(x1,y1,xm,ym);
-
-		sum += (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
-
-		if ( distance == 0 )
-		{
-			distance = (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
-			indexdistance = 0;
-			dx = x1-xm;
-			dy = y1-ym;
-		}
-		else
-		{
-			if ( distance < (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym) )
-			{
-				distance = (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
-				indexdistance = i;
-				dx = x1-xm;
-				dy = y1-ym;
-			}
-		}
-	}
-
-	printf ( "deviation sum %lld\n",sum );
-	printf ( "deviation max %lld index %d\n",distance,indexdistance );
-	printf ( "dx %d dy %d\n",dx,dy );
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_AlgMix_Version
- *  Description:  Set the Mixing Algorithm Version 
- * =====================================================================================
- */
-void AlgMixing::Set_AlgMix_Version(int value)
-{
-	m_Imple->m_AlgMix_Version = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_AlgMix_Version
- *  Description:  
- * =====================================================================================
- */
-int  AlgMixing::Get_AlgMix_Version()
-{
-	return m_Imple->m_AlgMix_Version;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_Sets
- *  Description:  Set the parameters function sets 
- * =====================================================================================
- */
-void AlgMixing::Set_Sx(double v)
-{
-	m_Imple->m_Mp.Sx = v;
-}
-void AlgMixing::Set_Sy(double v)
-{
-	m_Imple->m_Mp.Sy = v;
-}
-void AlgMixing::Set_Cos(double v)
-{
-	m_Imple->m_Mp.Cos = v;
-}
-void AlgMixing::Set_Sin(double v)
-{
-	m_Imple->m_Mp.Sin = v;
-}
-
-void AlgMixing::Set_a(double v)
-{
-	m_Imple->m_MV2.a = v;
-}
-void AlgMixing::Set_b(double v)
-{
-	m_Imple->m_MV2.b = v;
-}
-void AlgMixing::Set_c(double v)
-{
-	m_Imple->m_MV2.c = v;
-}
-void AlgMixing::Set_d(double v)
-{
-	m_Imple->m_MV2.d = v;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Para_Fun_Sets
- *  Description:  Get the parameters
- * =====================================================================================
- */
-double AlgMixing::Get_Sx()
-{
-	return m_Imple->m_Mp.Sx;
-}
-double AlgMixing::Get_Sy()
-{
-	return m_Imple->m_Mp.Sy;
-}
-double AlgMixing::Get_Sin()
-{
-	return m_Imple->m_Mp.Sin;
-}
-double AlgMixing::Get_Cos()
-{
-	return m_Imple->m_Mp.Cos;
-}
-
-double AlgMixing::Get_a()
-{
-	return m_Imple->m_MV2.a;
-}
-double AlgMixing::Get_b()
-{
-	return m_Imple->m_MV2.b;
-}
-double AlgMixing::Get_c()
-{
-	return m_Imple->m_MV2.c;
-}
-double AlgMixing::Get_d()
-{
-	return m_Imple->m_MV2.d;
-}
diff --git a/src/EVA11/AlgMixing.h b/src/EVA11/AlgMixing.h
deleted file mode 100644
index 5bacd1d..0000000
--- a/src/EVA11/AlgMixing.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AlgMixing.h
- *
- *    Description:  Declearation of catchlculate Mixing algorithm
- *
- *        Version:  1.0
- *        Created:  2012年11月16日 09时05分32秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ALGMIXING_INC
-#define  _ALGMIXING_INC
-
-#include 	<memory>	
-#include 	<vector>
-#include 	"main.h"
-
-class AlgMixing
-{
-	public:
-		AlgMixing ();
-		~AlgMixing ();
-		bool Init_Object();
-		void Destroy_Object();
-		void Clean_Data_From_Buffer();
-
-		void Load_Data_Into_Buffer(ETDATA *data);
-
-		void Calculate_Mix_Para();
-		void Mixing(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y);
-
-		void Calculate_Mix_Para_V2();
-		void Mixing_V2(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y);
-
-		void Set_Sx(double);
-		void Set_Sy(double);
-		void Set_Cos(double);
-		void Set_Sin(double);
-
-		double Get_Sx();
-		double Get_Sy();
-		double Get_Sin();
-		double Get_Cos();
-
-		void Set_a(double);
-		void Set_b(double);
-		void Set_c(double);
-		void Set_d(double);
-
-		double Get_a();
-		double Get_b();
-		double Get_c();
-		double Get_d();
-
-		void Set_AlgMix_Version(int);
-		int  Get_AlgMix_Version();
-
-	protected:
-
-	private:
-		void Calculate_Deviation();
-		void Process_Data_Center();
-		void NoLine_Fitting(double *x1,double *y1,double *x2,double *y2,int len);
-
-	private:
-		struct Mixp;
-		struct MixV2;
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif   /* ----- #ifndef _ALGMIXING_INC  ----- */
diff --git a/src/EVA11/Algorithm.cpp b/src/EVA11/Algorithm.cpp
deleted file mode 100644
index b3697ae..0000000
--- a/src/EVA11/Algorithm.cpp
+++ /dev/null
@@ -1,717 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Algorithm.cpp
- *
- *    Description:  Declare of Algorithm class 
- *
- *        Version:  1.0
- *        Created:  2010年03月26日 19时12分10秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-#include        <math.h>
-#include        <cstdio>
-#include        <cstdlib>
-#include 	<unistd.h>
-#include 	<sys/time.h>
-
-#include	<gsl/gsl_vector.h> 
-#include	<gsl/gsl_matrix.h> 
-#include	<gsl/gsl_multifit.h> 
-#include	<gsl/gsl_math.h> 
-
-#include        "Algorithm.h"
-#include 	"Global.h"
-#include 	"DFilter.h"
-
-std::auto_ptr<Algorithm> Algorithm::m_Instance;
-
-Algorithm::Algorithm ()                             
-{
-}
-
-Algorithm::~Algorithm ()
-{
-	m_Instance.get()->Release_Digital_Fileter_Value();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Make sure there is only one object in memory 
- * =====================================================================================
- */
-Algorithm* Algorithm::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Algorithm() );
-		/*-----------------------------------------------------------------------------
-		 *  Pre-calculate the Sin Cos Tan Tables
-		 *-----------------------------------------------------------------------------*/
-		m_Instance.get()->Init_SinCosTan_Table_Value();
-		m_Instance.get()->Init_SQRT_Table_Value();
-		/*-----------------------------------------------------------------------------
-		 *  Init table value for Digital filter
-		 *-----------------------------------------------------------------------------*/
-		m_Instance.get()->Init_Digital_Filter_Value(Global::CHANCOUNT);
-		m_Instance.get()->m_fGainPercent = 1.0;
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_SinCosTan_Table_Value
- *  Description:  Init Sin Cos Tan table value
- * =====================================================================================
- */
-void Algorithm::Init_SinCosTan_Table_Value()
-{
-	double coefficient = M_PI / 180;
-
-	for (int index=0;index<360;index++)
-	{
-		m_Sin[index] = sin(static_cast<double>(index * coefficient));
-		m_Cos[index] = cos(static_cast<double>(index * coefficient));
-	}
-	for (int i=0;i<180;i++)
-	{
-		m_Tan[i] = tan(static_cast<double>(i * coefficient));
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_SQRT_Table_Value
- *  Description:  Init the sqrt Table value 
- * =====================================================================================
- */
-void Algorithm::Init_SQRT_Table_Value()
-{
-	for ( int i = 0; i < MAXTABLELONG; i ++ )
-	{
-		for ( int j = 0; j < MAXTABLELONG; j ++ )
-		{
-			m_Tab_XX[i][j] = (i) * (i) + (j) * (j);
-			m_Tab_Sqrt[i][j] = sqrt(m_Tab_XX[i][j]);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Rotation
- *  Description:  Rotation the Degree 
- *
- *		old
- *                x' = x*cos0 - y*sin0
- *                y' = x*sin0 + y*cos0
- *
- *              new
- *                x' = x*cos0 + y*sin0
- *                y' = y*cos0 - x*sin0 
- *
- * =====================================================================================
- */
-void Algorithm::Rotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo)
-{
-	xo = static_cast<ETDATA>( y * m_Sin[deg] + x * m_Cos[deg] );
-	yo = static_cast<ETDATA>( y * m_Cos[deg] - x * m_Sin[deg] );
-}
-void Algorithm::MyRotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo)
-{
-	xo = static_cast<ETDATA>( -y * m_Sin[deg] + x * m_Cos[deg]);
-	yo = static_cast<ETDATA>(  y * m_Cos[deg] + x * m_Sin[deg]);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Digital_Filter_Value
- *  Description:  Init the data struct used for digital filter 
- * =====================================================================================
- */
-void Algorithm::Init_Digital_Filter_Value( int count )
-{
-	for 	( int i=0;i<count;i++ )
-	{
-		DFilter *dfbuf = new DFilter;
-		m_DFBuffer.push_back(dfbuf);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_Digital_Filter_Value
- *  Description:  Release the Digital filter value 
- * =====================================================================================
- */
-void Algorithm::Release_Digital_Fileter_Value()
-{
-	int length = m_DFBuffer.size();
-
-	for ( int i=0;i<length;i++ )
-	{
-		delete m_DFBuffer[i];
-	}
-
-	m_DFBuffer.clear();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_MAX_Value
- *  Description:  When chang the signal channel call this function init the parameters 
- *  Note:
- *                sigchan: Which signal need to be digital filter
- *                value:   from 0 to 7 
- * =====================================================================================
- */
-void Algorithm::Reset_MAX_Value(unsigned char sigchan,int value)
-{
-	m_DFBuffer[sigchan]->Reset_MAX_Value(value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Digital_Filter_Value
- *  Description:  Calculate the Digital Filter Value of device
- * =====================================================================================
- */
-void Algorithm::Calculate_Digital_Filter_Value(unsigned char sigchan,ETDATA& x,ETDATA& y)
-{
-	m_DFBuffer[sigchan]->Calculate_Digital_Filter_Value(x,y);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_K_b_Value
- *  Description:  For getting K and b value for one function 
- * =====================================================================================
- */
-void Algorithm::Get_K_b_Value(int x1,int y1,int x2,int y2,double &k,double &b)
-{
-	k = static_cast<double>(( y1 - y2 )) / static_cast<double>(( x1 - x2 ));
-	b = y2 - k * x2;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  IRCP
- *  Description:  Calculate the quadratic function coefficient 
- *  Input X[]  Y[] at least 2 points
- *  Output 
- *  y = A[0] + A[1] * x + A[2] * x * x
- * =====================================================================================
- */
-void Algorithm::PCIR(double * x, double * y, int n,double * a, int m )
-{
-    int i,j,k;
-    double z,p,c,g,q=0,d1,d2,s[20],t[20],b[20];
-    double ta[20],XX;
-    double dt[3]; dt[0]=0.0; dt[1]=0.0; dt[2]=0.0;
-
-    for (i=0; i<=m-1; i++)
-    {
-	a[i]=0.0;
-	ta[i]=0.0;
-    }
-    XX=0.0;
-    for (i=0; i<=n-1; i++)
-    {
-	XX +=x[i];
-    }
-    XX=XX/n;
-
-    if (m>n) m=n;
-    if (m>20) m=20;
-    z=0.0;
-    for (i=0; i<=n-1; i++) z=z+x[i]/(1.0*n);
-    b[0]=1.0; d1=1.0*n; p=0.0; c=0.0;
-    for (i=0; i<=n-1; i++)
-      { p=p+(x[i]-z); c=c+y[i];}
-    c=c/d1; p=p/d1;
-    a[0]=c*b[0];
-    if (m>1)
-      { t[1]=1.0; t[0]=-p;
-	d2=0.0; c=0.0; g=0.0;
-	for (i=0; i<=n-1; i++)
-	  { q=x[i]-z-p; d2=d2+q*q;
-	    c=c+y[i]*q;
-	    g=g+(x[i]-z)*q*q;
-	  }
-	c=c/d2; p=g/d2; q=d2/d1;
-	d1=d2;
-	a[1]=c*t[1]; a[0]=c*t[0]+a[0];
-      }
-    for (j=2; j<=m-1; j++)
-      { s[j]=t[j-1];
-	s[j-1]=-p*t[j-1]+t[j-2];
-	if (j>=3)
-	  for (k=j-2; k>=1; k--)
-	    s[k]=-p*t[k]+t[k-1]-q*b[k];
-	s[0]=-p*t[0]-q*b[0];
-	d2=0.0; c=0.0; g=0.0;
-	for (i=0; i<=n-1; i++)
-	  { q=s[j];
-	    for (k=j-1; k>=0; k--)
-	      q=q*(x[i]-z)+s[k];
-	    d2=d2+q*q; c=c+y[i]*q;
-	    g=g+(x[i]-z)*q*q;
-	  }
-	c=c/d2; p=g/d2; q=d2/d1;
-	d1=d2;
-	a[j]=c*s[j]; t[j]=s[j];
-	for (k=j-1; k>=0; k--)
-	  { a[k]=c*s[k]+a[k];
-	    b[k]=t[k]; t[k]=s[k];
-	  }
-      }
-
-
-    for (i=0; i<=n-1; i++)
-      { q=a[m-1];
-	for (k=m-2; k>=0; k--)
-	  q=a[k]+q*(x[i]-z);
-	p=q-y[i];
-	if (fabs(p)>dt[2]) dt[2]=fabs(p);
-	dt[0]=dt[0]+p*p;
-	dt[1]=dt[1]+fabs(p);
-      }
-
-    /* to convert the (X-XX) to X */
-    ta[0] = a[0]-a[1]*XX + a[2]*XX*XX;
-    ta[1] = a[1] - 2*a[2]*XX;
-    ta[2] = a[2];
-
-    /*return the recount value*/
-    a[0] = ta[0];
-    a[1] = ta[1];
-    a[2] = ta[2];
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Approx
- *  Description:  New Algorithm 
- *            m:  Points Count 
- *            n:  Times such   2 3 4
- *          n=2:  a0+a1*x+a2*x*x 
- *          n=3:  a0+a1*x+a2*x*x+a3*x*x*x 
- * =====================================================================================
- */
-void Algorithm::Approx(double *x,double *y,int m,int n,double* coe)
-{
-	double *c,*a;   
-	c = new double[((n+1)*(n+2)*sizeof(double))];   
-	for(int i=0;i<=n;i++)   
-	{
-		for ( int j=0;j<=n;j++)
-		{
-		    *(c+i*(n+2)+j)=0.0;
-		    for(int t=0;t<=m-1;t++)
-			*(c+i*(n+2)+j)+=power(i+j,x[t]);
-		}
-		*(c+i*(n+2)+n+1)=0.0;
-
-		for(int j=0;j<=m-1;j++)
-		    *(c+i*(n+2)+n+1)+=y[j]*power(i,x[j]);
-	}
-	a=ColPivot((double *)c,n+1);   
-	delete[] c;
-	c = NULL;
-
-	for ( int i=0;i<=n;i++ )
-	{
-		coe[i] = a[i];
-	}
-	delete[] a;
-	a = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  power
- *  Description:  
- * =====================================================================================
- */
-double Algorithm::power(int i,double v)   
-{   
-       	double a=1.0;
-	while(i--)
-	a*=v;
-	return a;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ColPivot
- *  Description:  
- * =====================================================================================
- */
-double *Algorithm::ColPivot(double *a,int n)   
-{   
-	int i,j,t,k;   
-	double *x,*c,p;   
-	x=new double[(n*sizeof(double))];   
-	c=new double[(n*(n+1)*sizeof(double))];   
-	for(i=0;i<=n-1;i++)   
-		for (j=0;j<=n;j++)   
-		    *(c+i*(n+1)+j)=(*(a+i*(n+1)+j));   
-	for(i=0;i<=n-2;i++)   
-	{   
-	k=i;   
-	for(j=i+1;j<=n-1;j++)   
-	    if(fabs(*(c+j*(n+1)+i))>(fabs(*(c+k*(n+1)+i))))   
-		k=j;   
-	    if(k!=j)   
-		for(j=i;j<=n;j++)   
-		{   
-		    p=*(c+i*(n+1)+j);   
-		    *(c+i*(n+1)+j)=*(c+k*(n+1)+j);   
-		    *(c+k*(n+1)+j)=p;   
-		}   
-	    for(j=i+1;j<=n-1;j++)   
-	    {   
-		p=(*(c+j*(n+1)+i))/(*(c+i*(n+1)+i));   
-		for(t=i;t<=n-1;t++)   
-		    *(c+j*(n+1)+t)=*(c+j*(n+1)+t)-p*(*(c+i*(n+1)+t));   
-		*(c+j*(n+1)+n)-=*(c+i*(n+1)+n)*p;   
-	    }   
-	}   
-	for( i=n-1;i>=0;i-- )   
-	{   
-		for( j=n-1;j>=i+1;j--)   
-		    (*(c+i*(n+1)+n))-=x[j]*(*(c+i*(n+1)+j));   
-		x[i]=*(c+i*(n+1)+n)/(*(c+i*(n+1)+i));   
-	}   
-	delete[] c;   
-	c = NULL;
-	return x;   
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  PolyFit
- *函数功能：最小二乘法曲线拟合   
- *使用方法：double *x ---- 存放n个数据点的X坐标   
- *          double *y ---- 存放n个数据点的Y坐标   
- *          int n -------- 给定数据点个数   
- *          double *a ---- 返回m-1次拟合多项式的m个系数   
- *          int m -------- 拟合多项式的项数，即拟合多项式的最高次为m-1。要求m=n,且   
- *                         m=20。若m>n或m>20，则本函数自动按m=min{n,20}处理   
- *          double *dt --- dt[0]返回拟合多项式与各数据点误差的平方和；dt[1]返回拟合多   
- *                         项式与各数据点的误差绝对值之和；dt[2]返回拟合多项式与各数据   
- *                         点误差绝对值的最大值   
- *注意事项：拟合多项式的形式为 y = b0 + b1*(x-Xavr)...   
- * =====================================================================================
- */
-void Algorithm::PolyFit(double *x, double *y, int n, double *a, int m, double *dt)
-{
-	int i, j, k;   
-	double z, p, c, g, q, d1, d2, s[20], t[20], b[20];   
-	for (i = 0; i <= m-1; i++)   
-	{   
-		a[i] = 0.0;   
-	}   
-	if (m > n)   
-	{   
-		m = n;   
-	}   
-	if (m > 20)   
-	{   
-		m = 20;   
-	}   
-	z = 0.0;   
-	for (i = 0; i <= n-1; i++)   
-	{   
-		z = z+x[i]/(1.0 *n);   
-	}   
-	b[0] = 1.0;   
-	d1 = 1.0 * n;   
-	p = 0.0;   
-	c = 0.0;   
-	for (i = 0; i <= n-1; i++)   
-	{   
-		p = p+(x[i]-z);   
-		c = c+y[i];   
-	}   
-	c = c/d1;   
-	p = p/d1;   
-	a[0] = c * b[0];   
-	if (m > 1)   
-	{   
-		t[1] = 1.0;   
-		t[0] = -p;   
-		d2 = 0.0;   
-		c = 0.0;   
-		g = 0.0;   
-		for (i = 0; i <= n-1; i++)   
-		{   
-			q = x[i]-z-p;   
-			d2 = d2+q * q;   
-			c = c+y[i] *q;   
-			g = g+(x[i]-z) *q * q;   
-		}   
-		c = c/d2;   
-		p = g/d2;   
-		q = d2/d1;   
-		d1 = d2;   
-		a[1] = c * t[1];   
-		a[0] = c * t[0]+a[0];   
-	}   
-	for (j = 2; j <= m-1; j++)   
-	{   
-		s[j] = t[j-1];   
-		s[j-1] = -p * t[j-1]+t[j-2];   
-		if (j >= 3)   
-			for (k = j-2; k >= 1; k--)   
-			{   
-				s[k] = -p * t[k]+t[k-1]-q * b[k];   
-			}   
-		s[0] = -p * t[0]-q * b[0];   
-		d2 = 0.0;   
-		c = 0.0;   
-		g = 0.0;   
-		for (i = 0; i <= n-1; i++)   
-		{   
-			q = s[j];   
-			for (k = j-1; k >= 0; k--)   
-			{   
-				q = q *(x[i]-z)+s[k];   
-			}   
-			d2 = d2+q * q;   
-			c = c+y[i] *q;   
-			g = g+(x[i]-z) *q * q;   
-		}   
-		c = c/d2;   
-		p = g/d2;   
-		q = d2/d1;   
-		d1 = d2;   
-		a[j] = c * s[j];   
-		t[j] = s[j];   
-		for (k = j-1; k >= 0; k--)   
-		{   
-			a[k] = c * s[k]+a[k];   
-			b[k] = t[k];   
-			t[k] = s[k];   
-		}   
-	}   
-	dt[0] = 0.0;   
-	dt[1] = 0.0;   
-	dt[2] = 0.0;   
-	for (i = 0; i <= n-1; i++)   
-	{   
-		q = a[m-1];   
-		for (k = m-2; k >= 0; k--)   
-		{   
-			q = a[k]+q *(x[i]-z);   
-		}   
-		p = q-y[i];   
-		if (fabs(p) > dt[2])   
-		{   
-			dt[2] = fabs(p);   
-		}   
-		dt[0] = dt[0]+p * p;   
-		dt[1] = dt[1]+fabs(p);   
-	}   
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  MDelay
- *  Description:  Delay ms milliseconds 
- * =====================================================================================
- */
-void Algorithm::MDelay(int ms)
-{
-	struct timeval tpStart, tpEnd;
-	float timeUse;
-	gettimeofday(&tpStart, NULL);
-	do 
-	{
-		gettimeofday(&tpEnd, NULL);
-		timeUse = 1000 * (tpEnd.tv_sec - tpStart.tv_sec) + (tpEnd.tv_usec - tpStart.tv_usec)/1000;
-	} while(timeUse < ms);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Alpha_Color
- *  Description:  Alpha Color calculate,only called in Alpha parameters exist
- * =====================================================================================
- */
-int Algorithm::Alpha_Color(int r,int g,int b,int alph,short bkcolor)
-{
-	int nr    = r;
-	int ng    = g;
-	int nb    = b;
-	int alpha = alph;
-
-	int oldr  = (( bkcolor >> 11 ) & 0x1f)<<3;
-	int oldg  = (( bkcolor >> 5 ) & 0x3f)<<2;
-	int oldb  = (( bkcolor ) & 0x1f)<<3;
-
-	nr        = (((nr - oldr)*alpha)>>8) + oldr;
-	ng        = (((ng - oldg)*alpha)>>8) + oldg;
-	nb        = (((nb - oldb)*alpha)>>8) + oldb;
-
-	return ( nr << 16 ) + ( ng << 8 ) + nb;
-}
-int Algorithm::Alpha_Color(short fgcolor,int alph,short bkcolor)
-{
-	int nr    = (( fgcolor >> 11 ) & 0x1f)<<3;
-	int ng    = (( fgcolor >> 5) & 0x3f)<<2;
-	int nb    = (( fgcolor ) & 0x1f)<<3;
-	int alpha = alph;
-
-	int oldr  = (( bkcolor >> 11 ) & 0x1f)<<3;
-	int oldg  = (( bkcolor >> 5 ) & 0x3f)<<2;
-	int oldb  = (( bkcolor ) & 0x1f)<<3;
-
-	nr        = (((nr - oldr)*alpha)>>8) + oldr;
-	ng        = (((ng - oldg)*alpha)>>8) + oldg;
-	nb        = (((nb - oldb)*alpha)>>8) + oldb;
-
-	return ( nr << 16 ) + ( ng << 8 ) + nb;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_SX_SY
- *  Description:  Calculate the X Gain and Y Gain 
- * =====================================================================================
- */
-void Algorithm::Calculate_SX_SY(const int& x1,const int& y1,
-				const int& x2,const int& y2,
-				double& sx,double& sy)
-{
-//	double k1 = y1 / x1;
-//	double k2 = y2 / x2;
-//
-//	sx = sqrt( ( 1 + k2 * k2 ) / ( 1 + k1 * k1 ) );
-//	sy = sx * ( ( static_cast<double>(y1) * static_cast<double>(x2) ) / ( static_cast<double>(x1) * static_cast<double>(y2) ) );
-
-//	sx = static_cast<double>(abs(x1)) / static_cast<double>(abs(x2));
-//	sy = static_cast<double>(abs(y1)) / static_cast<double>(abs(y2));
-
-	sx = sqrt((static_cast<double>(x1)*x1+static_cast<double>(y1)*y1)/(static_cast<double>(x2)*x2+static_cast<double>(y2)*y2));
-	sy = sx;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Angle
- *  Description:  
- * =====================================================================================
- */
-int Algorithm::Calculate_Angle(const int& x,const int& y)
-{
-	if 	( x == 0 )
-	{
-		if ( y > 0 )
-			return 90;
-		else 
-			return 270;
-	}
-	else if ( y == 0 )
-	{
-		if ( x > 0 )
-			return 180;
-		else 
-			return 0;
-	}
-	else 
-	{
-		if 	( x < 0 && y > 0 )
-			return 180 * atan(static_cast<double>(abs(y))/abs(x)) / M_PI;
-		else if ( x < 0 && y < 0 )
-			return 180 * atan(static_cast<double>(abs(x))/abs(y)) / M_PI + 270;
-		else if ( x > 0 && y > 0 )
-			return 180 * atan(static_cast<double>(abs(x))/abs(y)) / M_PI + 90;
-		else if ( x > 0 && y < 0 )
-			return 180 * atan(static_cast<double>(abs(y))/abs(x)) / M_PI + 180;
-	}
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Gain_Ratio
- *  Description:  Calculate the Gain Ratio 
- * =====================================================================================
- */
-void Algorithm::Calculate_Gain_Ratio(int value)
-{
-	m_fGainPercent = static_cast<double>(value) / 10;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Polynomial_Fitting
- *  Description:  Calculate the Polynomial factor 
- *        terms:  ex.: x^4 + x^3 + x^2   
- *                terms: 4
- *          coe:  coe[0]x^4 + coe[1]x^3 + coe[2]x^2 + coe[3]x^1 + coe[4]x^0
- * =====================================================================================
- */
-bool Algorithm::Polynomial_Fitting(double* x0,double* y0,int datalen,int terms,double* coe)
-{
-	if 	( datalen <= terms )
-	{
-		printf("at least datalen more than %d \n",terms);
-		return false;
-	}
-
-	double chisq;
-	gsl_matrix *X,*cov;
-	gsl_vector *y,*w,*c;
-	int n = datalen;
-
-	X = gsl_matrix_alloc(n,terms+1);
-	y = gsl_vector_alloc(n);
-	w = gsl_vector_alloc(n);
-	c = gsl_vector_alloc(terms+1);
-	cov = gsl_matrix_alloc(terms+1,terms+1);
-
-	for ( int i=0;i<n;i++ )
-	{
-		for ( int j=0;j<=terms;j++ )
-		{
-			gsl_matrix_set(X,i,j,gsl_pow_int(x0[i],j));
-		}
-
-		gsl_vector_set(y,i,y0[i]);
-		gsl_vector_set(w,i,1);
-	}
-
-	gsl_multifit_linear_workspace *work = gsl_multifit_linear_alloc(n,terms+1);
-	gsl_multifit_wlinear(X,w,y,c,cov,&chisq,work);
-
-	for ( int i=0;i<=terms;i++ )
-	{
-		coe[terms-i] = gsl_vector_get(c,i);
-	}
-
-	for ( int i=0;i<terms;i++ )
-	{
-		std::cout<<coe[i]<<"*"<<"X^"<<terms-i<<"+";
-	}
-	std::cout<<coe[terms]<<std::endl;
-
-	gsl_multifit_linear_free(work);
-
-	gsl_matrix_free(cov);
-	gsl_vector_free(c);
-	gsl_vector_free(w);
-	gsl_vector_free(y);
-	gsl_matrix_free(X);
-
-	return true;
-}
diff --git a/src/EVA11/Algorithm.h b/src/EVA11/Algorithm.h
deleted file mode 100644
index 2ce6074..0000000
--- a/src/EVA11/Algorithm.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Algorithm.h
- *
- *    Description:  The class create for special mathmatic algorithm
- *
- *        Version:  1.0
- *        Created:  2010年03月26日 19时07分26秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef _ALGORITHM_H
-#define _ALGORITHM_H
-
-#include 	<memory>
-#include 	<vector>
-
-#include 	"main.h" 
-
-class DFilter;
-class Algorithm
-{
-	public:
-		/* ====================  LIFECYCLE     ======================================= */
-		static Algorithm* Instance();
-
-		void MDelay(int ms);
-		/*-----------------------------------------------------------------------------
-		 *  About Get degree Sin Cos Tan value
-		 *-----------------------------------------------------------------------------*/
-		inline double Get_Sin_Value(int degree) { return m_Sin[degree]; }
-		inline double Get_Cos_Value(int degree) { return m_Cos[degree]; }
-		inline double Get_Tan_Value(int degree) { return m_Tan[degree]; }
-		inline double Get_XX_Value(int v1,int v2) { return m_Tab_XX[v1][v2]; }
-		inline double Get_Sqrt_Value(int v1,int v2) { return m_Tab_Sqrt[v1][v2]; }
-		/*-----------------------------------------------------------------------------
-		 *  ET Data Process function 
-		 *-----------------------------------------------------------------------------*/
-		void Rotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo);
-		void MyRotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo);
-		/*-----------------------------------------------------------------------------
-		 *  Digital filter used  
-		 *-----------------------------------------------------------------------------*/
-		void Reset_MAX_Value(unsigned char sigchan,int value);
-		void Calculate_Digital_Filter_Value(unsigned char sigchan,ETDATA& x,ETDATA& y);
-		/*-----------------------------------------------------------------------------
-		 *  For getting K and b value for one function 
-		 *-----------------------------------------------------------------------------*/
-		void Get_K_b_Value(int x1,int y1,int x2,int y2,double &k,double &b);
-		inline double Get_Rate(int x,int y,int centx,int centy) { 
-			return static_cast<double>(centy-y) / static_cast<double>(centx-x);
-		}
-		/*-----------------------------------------------------------------------------
-		 *  New Special Mix Frequence Algorithm 
-		 *-----------------------------------------------------------------------------*/
-		void PCIR(double * x, double * y, int n,double * a, int m );
-		/*-----------------------------------------------------------------------------
-		 *  New Calculate Algorithm 
-		 *-----------------------------------------------------------------------------*/
-		void Approx(double *x,double *y,int m,int n,double* coe);
-		double power(int i,double v);
- 		double *ColPivot(double *a,int n);
-
-		void PolyFit(double *x, double *y, int n, double *a, int m, double *dt);
-
-		int Alpha_Color(int r,int g,int b,int alph,short bkcolor);
-		int Alpha_Color(short fgcolor,int alpha,short bkcolor);
-
-		void Calculate_SX_SY(const int& x1,const int& y1,
-				     const int& x2,const int& y2,
-				     double& sx,double& sy);
-		int Calculate_Angle(const int& x,const int& y);
-		void Calculate_Gain_Ratio(int);
-
-		inline double Gain_Ratio(double yvalue){ return yvalue * m_fGainPercent; }
-
-		bool Polynomial_Fitting(double* x,double* y,int datalen,int terms,double* c);
-	protected:
-	private:
-		Algorithm ();
-		~Algorithm ();
-		Algorithm (const Algorithm&);
-		Algorithm& operator = (const Algorithm&);
-
-		void Init_SinCosTan_Table_Value();
-		void Init_SQRT_Table_Value();
-
-		void Init_Digital_Filter_Value(int count);
-		void Release_Digital_Fileter_Value();
-	private:
-		friend class std::auto_ptr<Algorithm>;
-		static std::auto_ptr<Algorithm>		m_Instance;
-
-		static const int MAXTABLELONG = 210;
-		static const int MAXDFCHANG   = 32; 
-		/*-----------------------------------------------------------------------------
-		*  Sin Cos function values array
-		*-----------------------------------------------------------------------------  */
-		double m_Cos[360];                                                              /* previously calculate                             */
-		double m_Sin[360];
-		double m_Tan[180];
-		double m_Tab_Sqrt[MAXTABLELONG][MAXTABLELONG];                                  /* The Tables of sqr(A*2 + B*2) for scale calculate */
-		double m_Tab_XX[MAXTABLELONG][MAXTABLELONG];                                    /* The Tables of A*2 + B*2 for scale calculate      */
-		double m_fGainPercent;
-
-		std::vector<DFilter *> m_DFBuffer;                                              /* Only used for Digital Filter                     */
-}; /* -----  end of class Algorithm  ----- */
-#endif
diff --git a/src/EVA11/AnalyzeView.cpp b/src/EVA11/AnalyzeView.cpp
deleted file mode 100644
index 25dda93..0000000
--- a/src/EVA11/AnalyzeView.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AnalyzeView.cpp
- *
- *    Description:  Implementation of AnalyzeView class
- *
- *        Version:  1.0
- *        Created:  2012年12月20日 08时59分44秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-
-#include 	"Language.h"
-#include 	"Algorithm.h"
-
-#include 	"IView.h"
-#include	"DetectView.h"
-#include 	"AnalyzeView.h"
-
-#include 	"FreeType.h"
-
-AnalyzeView::AnalyzeView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-}
-
-AnalyzeView::~AnalyzeView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view
- * =====================================================================================
- */
-void AnalyzeView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  
- * =====================================================================================
- */
-void AnalyzeView::Release_View() 
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  
- * =====================================================================================
- */
-int  AnalyzeView::Loop_View(Graphic& g)
-{
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_DetectView_Object
- *  Description:  For Alarm view draw GUI on screen 
- * =====================================================================================
- */
-void AnalyzeView::Load_View_Object(IView* obj)
-{
-	m_DetectView = dynamic_cast<DetectView *>(obj);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Swtich_View
- *  Description:  when chang the view called it
- * =====================================================================================
- */
-void AnalyzeView::Switch_View()
-{
-	if ( m_DetectView != NULL )
-		m_DetectView->Switch_View();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI Object 
- * =====================================================================================
- */
-void AnalyzeView::Init_GUI(Graphic& g)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void AnalyzeView::Destroy_GUI()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the Videw GUI object 
- * =====================================================================================
- */
-void AnalyzeView::Drawme (Graphic& g)
-{
-	if ( m_DetectView != NULL )
-		m_DetectView->Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void AnalyzeView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
diff --git a/src/EVA11/AnalyzeView.h b/src/EVA11/AnalyzeView.h
deleted file mode 100644
index 1d44f54..0000000
--- a/src/EVA11/AnalyzeView.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  AnalyzeView.h
- *
- *    Description: Analyze function
- *
- *        Version:  1.0
- *        Created:  2012年12月20日 08时57分16秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ANALYZEVIEW_INC
-#define  _ANALYZEVIEW_INC
-
-class IView;
-class DetectView;
-class AnalyzeView : public IView
-{
-	public:
-		AnalyzeView (int x,int y,int width,int heigh);
-		~AnalyzeView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View() 	;
-		virtual int  Loop_View(Graphic&);
-		virtual void Drawme (Graphic&)  ;
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		void Load_View_Object(IView* obj);
-		void Switch_View();
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		DetectView*		m_DetectView;
-	private:
-
-};
-
-#endif   /* ----- #ifndef _ANALYZEVIEW_INC  ----- */
diff --git a/src/EVA11/BasePanel.cpp b/src/EVA11/BasePanel.cpp
deleted file mode 100644
index fded375..0000000
--- a/src/EVA11/BasePanel.cpp
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  BasePanel.cpp
- *
- *    Description:  implementation of BasePanel
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 14时54分50秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Global.h"
-#include 	"Graphic.h"
-#include 	"Object.h"
-#include 	"BasePanel.h"
-
-BasePanel::BasePanel (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_gp = Global::Instance();
-	
-	m_RawBuf = new(std::nothrow) ETDATA[Global::CHANCOUNT<<1];
-}
-
-BasePanel::~BasePanel ()
-{
-	delete[] m_RawBuf;
-	m_RawBuf = NULL;
-}
-
-void BasePanel::Switch_Panel(){;}
diff --git a/src/EVA11/BasePanel.h b/src/EVA11/BasePanel.h
deleted file mode 100644
index c118b48..0000000
--- a/src/EVA11/BasePanel.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  BasePanel.h
- *
- *    Description:  Base class of all kinds of panels
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 14时52分09秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _BASEPANEL_INC
-#define  _BASEPANEL_INC
-
-class Object;
-class Graphic;
-class Global;
-
-#include 	"main.h"
-#include 	"KFInterface.h"
-class BasePanel : public Object , public BaseKFInterface , public DetectKFInterface , public AlarmKFInterface , public ParaKFInterface
-{
-	public:
-		BasePanel (int x,int y,int width,int heigh);
-		virtual ~BasePanel ();
-
-		virtual void Init_GUI(Graphic& g)   	  	      = 0;
-		virtual void Destroy_GUI() 	    	  	      = 0;
-		virtual void Drawme(Graphic& g,bool flag=true) 	      = 0;
-		virtual int  Loop_Panel(Graphic& g) 	  	      = 0;
-		virtual void Show_Help_System(Graphic& g,int x,int y) = 0;
-
-		virtual void Switch_Panel();
-
-	protected:
-		Global					*m_gp;
-		ETDATA					*m_RawBuf;
-	private:
-};
-#endif
diff --git a/src/EVA11/Basescreen.cpp b/src/EVA11/Basescreen.cpp
deleted file mode 100644
index baa2f25..0000000
--- a/src/EVA11/Basescreen.cpp
+++ /dev/null
@@ -1,286 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Basescreen.cpp
- *
- *    Description:  implementation of Basescreen class
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 13时12分12秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdlib>
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Basescreen.h"
-
-Basescreen::Basescreen (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_Msg        = new char[100];
-
-	m_Ch         = 0;
-	m_Focus      = false;
-}
-
-Basescreen::~Basescreen ()
-{
-	delete[] m_Msg;
-	m_Msg 	     = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Color
- *  Description:  Set the color of Zscreen object 
- * =====================================================================================
- */
-void Basescreen::Set_Color(LABCOLOR ct,short color)
-{
-	switch ( ct ) 
-	{
-		case LA_FG_COLOR: 
-			m_FGColor = color;
-			break;
-
-		case LA_BG_COLOR: 
-			m_BGColor = color;
-			break;
-
-		case LA_GRID_COLOR: 
-			m_GRIDColor = color;
-			break;
-
-		case LA_POINT_COLOR:
-			m_PointColor = color;
-			break;
-
-		case LA_FOCUS_COLOR:
-			m_FocusColor = color;
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawGrid
- *  Description:  Draw the grid of screen 
- * =====================================================================================
- */
-void Basescreen::DrawGrid(Graphic &g)
-{
-	int i,j;
-	j=0;
-	while(m_Center_X+LineSpace*j<m_Right)
-	{
-		i=0; 
-		while(m_Center_Y+SmallSpace*i<m_Down)
-		{
-			g.Setpixel(m_Center_X+LineSpace*j,m_Center_Y+SmallSpace*i,m_GRIDColor);	
-			i++;
-		}
-		i=0; 
-		while(m_Center_Y-SmallSpace*i>m_Up)
-		{
-			g.Setpixel(m_Center_X+LineSpace*j,m_Center_Y-SmallSpace*i,m_GRIDColor);	
-			i++;
-		}
-		j++;
-	}
-	j=0;
-	while(m_Center_X-LineSpace*j>m_Left)
-	{
-		i=0; 
-		while(m_Center_Y+SmallSpace*i<m_Down)
-		{
-			g.Setpixel(m_Center_X-LineSpace*j,m_Center_Y+SmallSpace*i,m_GRIDColor);	
-			i++;
-		}
-		i=0; 
-		while(m_Center_Y-SmallSpace*i>m_Up)
-		{
-			g.Setpixel(m_Center_X-LineSpace*j,m_Center_Y-SmallSpace*i,m_GRIDColor);	
-			i++;
-		}
-		j++;
-	}
-
-	j=0;
-	while(m_Center_Y+LineSpace*j<m_Down)
-	{
-		i=0; 
-		while(m_Center_X+SmallSpace*i<m_Right)
-		{
-			g.Setpixel(m_Center_X+SmallSpace*i,m_Center_Y+LineSpace*j,m_GRIDColor);	
-			i++;
-		}
-		i=0; 
-		while(m_Center_X-SmallSpace*i>m_Left)
-		{
-			g.Setpixel(m_Center_X-SmallSpace*i,m_Center_Y+LineSpace*j,m_GRIDColor);	
-			i++;
-		}
-		j++;
-	}
-	j=0;
-	while(m_Center_Y-LineSpace*j>m_Up)
-	{
-		i=0; 
-		while(m_Center_X+SmallSpace*i<m_Right)
-		{
-			g.Setpixel(m_Center_X+SmallSpace*i,m_Center_Y-LineSpace*j,m_GRIDColor);	
-			i++;
-		}
-		i=0; 
-		while(m_Center_X-SmallSpace*i>m_Left)
-		{
-			g.Setpixel(m_Center_X-SmallSpace*i,m_Center_Y-LineSpace*j,m_GRIDColor);	
-			i++;
-		}
-		j++;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  draw_xish_line_arrange
- *  Description:  Draw line on ZKScreen depending on the x y
- * =====================================================================================
- */
-void Basescreen::draw_xish_line_arrange(Graphic &g,int x,int y,int dx,int dy,int xdir,short ncolor)
-{
-	int dyX2=dy+dy;
-	int dyX2mdxX2=dyX2-(dx+dx);
-	int error=dyX2-dx;
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-	{
-		g.Setpixel(x, y, ncolor);
-	}
-	while (dx--) 
-	{
-		if (error >= 0) 
-		{
-			y++;
-			error += dyX2mdxX2;
-		} 
-		else 
-		{
-			error += dyX2;
-		}
-		x += xdir;
-		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-		{
-			g.Setpixel(x, y, ncolor);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  draw_yish_line_arrange
- *  Description:  Draw line on screen depending on y direct
- * =====================================================================================
- */
-void Basescreen::draw_yish_line_arrange(Graphic &g,int x,int y,int dx,int dy,int xdir,short ncolor)
-{
-	int dxX2=(dx<<1) ;
-	int dxX2mdyX2=dxX2-(dy<<1);
-	int error=dxX2-dy;
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-	{
-		g.Setpixel(x, y, ncolor);
-	}
-	while (dy--) 
-	{
-		if (error >= 0) 
-		{
-			x+= xdir;
-			error += dxX2mdyX2;
-		} else 
-		{
-			error += dxX2;
-		}
-		y++;
-		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-		{
-			g.Setpixel(x, y, ncolor);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Line_In_Arrange
- *  Description:  Draw line in screen arrange
- * =====================================================================================
- */
-void Basescreen::Draw_Line_In_Arrange(Graphic &g,int x1,int y1,int x2,int y2,short color)
-{
-	int dx,dy;
-	if ( y1 > y2) 
-	{
-		int t = y1;
-		y1 = y2;
-		y2 = t;
-		t = x1;
-		x1 = x2;
-		x2 = t;
-	}
-	dx = x2-x1;
-	dy = y2-y1;
-	if (dx > 0) 
-	{
-		if (dx > dy)
-			draw_xish_line_arrange(g,x1, y1, dx, dy, 1,color);
-		else
-			draw_yish_line_arrange(g,x1, y1, dx, dy, 1,color);
-	} 
-	else 
-	{
-		dx = -dx;
-		if (dx > dy)
-			draw_xish_line_arrange(g,x1, y1, dx, dy, -1,color);
-		else
-			draw_yish_line_arrange(g,x1, y1, dx, dy, -1,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on screen 
- * =====================================================================================
- */
-void Basescreen::Drawme(Graphic &g,bool bufflag )
-{
-	if ( bufflag == true )
-		g.Switch_Screen();
-	Refreshme(g);
-	if ( bufflag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Setpixel_In_Arrange
- *  Description:  Setpixel on screen 
- * =====================================================================================
- */
-void Basescreen::Setpixel_In_Arrange(Graphic& g,int x,int y)
-{
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-	{
-		g.Setpixel(x, y, m_FGColor);
-	}
-}
diff --git a/src/EVA11/Basescreen.h b/src/EVA11/Basescreen.h
deleted file mode 100644
index 2ae0f8e..0000000
--- a/src/EVA11/Basescreen.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Basescreen.h
- *
- *    Description:  Mange the Basescreen class
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 13时09分47秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _BASESCREEN_INC
-#define  _BASESCREEN_INC
-
-class Graphic;
-class Basescreen : public Object
-{
-	public:
-		enum LABCOLOR
-		{
-			LA_FG_COLOR,
-			LA_BG_COLOR,
-			LA_GRID_COLOR,
-			LA_POINT_COLOR,
-			LA_FOCUS_COLOR,
-		};
-		typedef enum LABCOLOR LABCOLOR;
-
-		Basescreen (int x,int y,int width,int heigh);
-		~Basescreen ();
-
-		void Drawme(Graphic &g,bool bufflag = true);
-		void Set_Color(LABCOLOR ct,short color);
-
-		virtual void Refreshme(Graphic &g) = 0;
-	protected:
-		void DrawGrid(Graphic &g);
-
-		void Setpixel_In_Arrange(Graphic& g,int x,int y);
-		void Draw_Line_In_Arrange(Graphic &g,
-				          int x1,int y1,
-				          int x2,int y2,
-					  short color
-					 );
-		void draw_xish_line_arrange(Graphic &g,
-				            int x,int y,
-					    int dx,int dy,
-					    int xdir,short ncolor
-					   );
-		void draw_yish_line_arrange(Graphic &g,
-				            int x,int y,
-					    int dx,int dy,
-					    int xdir,short ncolor
-					   );
-	protected:
-		static const int			SmallSpace  =  3;
-		static const int			LineSpace   =  33;
-		int					m_Ch;
-
-		short               			m_FGColor;		
-		short               			m_BGColor;		
-		short                   		m_GRIDColor;		
-		short                   		m_PointColor;
-		short                   		m_FocusColor;
-
-		char					*m_Msg;
-		bool					m_Focus;
-
-}; /* -----  end of class Basescreen  ----- */
-#endif   /* ----- #ifndef _BASESCREEN_INC  ----- */
diff --git a/src/EVA11/Basewin.cpp b/src/EVA11/Basewin.cpp
deleted file mode 100644
index 47d9634..0000000
--- a/src/EVA11/Basewin.cpp
+++ /dev/null
@@ -1,414 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Basewin.cpp
- *
- *    Description:  implementation of Basewin class
- *
- *        Version:  1.0
- *        Created:  2012年06月28日 10时29分06秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<new>
-
-#include 	<SDL.h>
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include	"Logic.h"
-#include	"Global.h"
-#include	"Language.h"
-#include 	"Device.h"
-#include 	"Battery.h"
-#include 	"Graphic.h"
-#include 	"Algorithm.h"
-#include	"Msgbox.h"
-#include 	"Basewin.h"
-#include 	"DataRepo.h"
-#include 	"ColorObj.h"
-
-Basewin::Basewin ()
-{
-	m_lo          = Logic::Instance();
-	m_gp          = Global::Instance();
-	m_pl          = Language::Instance();
-	m_device      = Device::Instance();
-	m_alg         = Algorithm::Instance();
-	m_repo	      = DataRepo::Instance();
-
-	m_Msg         = new(std::nothrow) char[100];
-	m_BottomFocus = 1;
-
-	m_MAXGetkeyTimes
-		      = 128;
-	m_GetKeyTimes = m_MAXGetkeyTimes;
-}  /* -----  end of method Basewin::Basewin  (constructor)  ----- */
-
-Basewin::~Basewin ()
-{
-	if 	( m_Msg != NULL )
-	{
-		delete[] m_Msg;
-		m_Msg = NULL;
-	}
-}  /* -----  end of method Basewin::Basewin  (destructor)  ----- */
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Command_Process
- *       return:  0: goto Exit;
- *                1: Cancel nothing happend
- * =====================================================================================
- */
-int Basewin::Command_Process(Graphic& g)
-{
-	m_Battery->Set_Value(g,*m_lo);
-
-	m_GetKeyTimes --;
-	if ( m_GetKeyTimes == 0 )
-		m_GetKeyTimes = m_MAXGetkeyTimes;
-	else
-		return CO_NONE;
-
-	switch ( m_lo->Get_Key() )
-	{
-		case KEY_F1:
-			return Key_F1_Fun(g);
-			break;
-
-		case KEY_F2:
-			return Key_F2_Fun(g);
-			break;
-
-		case KEY_F3:
-			return Key_F3_Fun(g);
-			break;
-
-		case KEY_F4:
-			return Key_F4_Fun(g);
-			break;
-
-		case KEY_F5:
-			return Key_F5_Fun(g);
-			break;
-
-		case KEY_F6:
-			return Key_F6_Fun(g);
-			break;
-
-		case KEY_F7:
-			return Key_F7_Fun(g);
-			break;
-
-		case KEY_BOTTOM1:
-			return Key_Bom1_Fun(g);
-			break;
-
-		case KEY_BOTTOM2:
-			return Key_Bom2_Fun(g);
-			break;
-
-		case KEY_BOTTOM3:
-			return Key_Bom3_Fun(g);
-			break;
-
-		case KEY_BOTTOM4:
-			return Key_Bom4_Fun(g);
-			break;
-
-		case KEY_BOTTOM5:
-			return Key_Bom5_Fun(g);
-			break;
-
-		case KEY_BOTTOM6:
-			return Key_Bom6_Fun(g);
-			break;
-
-		case KEY_BOTTOM7:
-			return Key_Bom7_Fun(g);
-			break;
-
-		case KEY_FUN1L:
-			return Key_NL1_Fun(g);
-			break;
-		case KEY_FUN1R:
-			return Key_NR1_Fun(g);
-			break;
-
-		case KEY_FUN2L:
-			return Key_NL2_Fun(g);
-			break;
-		case KEY_FUN2R:
-			return Key_NR2_Fun(g);
-			break;
-
-		case KEY_FUN3L:
-			return Key_NL3_Fun(g);
-			break;
-		case KEY_FUN3R:
-			return Key_NR3_Fun(g);
-			break;
-
-		case KEY_FUN4L:
-			return Key_NL4_Fun(g);
-			break;
-		case KEY_FUN4R:
-			return Key_NR4_Fun(g);
-			break;
-
-		case KEY_FUN5L:
-			return Key_NL5_Fun(g);
-			break;
-		case KEY_FUN5R:
-			return Key_NR5_Fun(g);
-			break;
-
-		case KEY_FUN6L:
-			return Key_NL6_Fun(g);
-			break;
-		case KEY_FUN6R:
-			return Key_NR6_Fun(g);
-			break;
-
-		case KEY_ENTER:
-			return Key_Enter_Fun(g);
-			break;
-
-		case KEY_ESC:
-			return Key_Esc_Fun(g);
-			break;
-	}				/* -----  end switch  ----- */
-
-	return CO_NONE;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void Basewin::Init_GUI(Graphic& g)
-{
-	ColorObj* colorobj = ColorObj::Instance();
-
-	m_Battery  = new Battery(2,445,15,32);
-	m_Battery->Set_Battery_Type(Battery::BAT_V);
-	m_Battery->Set_Battery_Handle(m_lo->Get_ADC_Handle());
-
-	m_BomSmall = new Label(18+7*85,445,25,33);
-	m_BomSmall->Set_Text("1");
-	m_BomSmall->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	m_BomSmall->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_BomSmall->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	m_BomSmall->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-
-	m_BomSmall->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
-	m_BomSmall->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
-	m_BomSmall->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
-	m_BomSmall->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
-	m_BomSmall->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
-	m_BomSmall->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
-
-	m_BomSmall->Set_Focus(false);
-	m_BomSmall->Set_Font_Size(25);
-	m_BomSmall->Set_Radius(10);
-	m_BomSmall->Set_Display_Type(Label::LA_DT_CENTER);
-	m_BomSmall->Set_Label_Type(Label::LA_QUAT);
-
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i] = new Label(18+i*85,445,84,33);
-		m_BomButton[i]->Set_Text(" ");
-
-		if 	( m_gp->Language == 1 )
-			m_BomButton[i]->Set_Font_Size(16);
-		else if ( m_gp->Language == 0 )
-			m_BomButton[i]->Set_Font_Size(25);
-
-		if 	( i == m_BottomFocus - 1 )
-			m_BomButton[i]->Set_Focus(true);
-		else
-			m_BomButton[i]->Set_Focus(false); 
-
-		m_BomButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_BomButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_BomButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_BomButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-
-		m_BomButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
-		m_BomButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
-		m_BomButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
-		m_BomButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
-		m_BomButton[i]->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
-		m_BomButton[i]->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
-
-		m_BomButton[i]->Set_Label_Type(Label::LA_HALFROUND);
-		m_BomButton[i]->Set_Display_Type(Label::LA_DT_CENTER);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void Basewin::Destroy_GUI()
-{
-	if 	( m_Battery != NULL )
-	{
-		delete m_Battery;
-		m_Battery = NULL;
-	}
-	if 	( m_BomSmall != NULL )
-	{
-		delete m_BomSmall;
-		m_BomSmall = NULL;
-	}
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		if 	( m_BomButton[i] != NULL )
-		{
-			delete m_BomButton[i];
-			m_BomButton[i] = NULL;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void Basewin::Drawme(Graphic& g)
-{
-	g.Clearscreen();
-	g.DrawFillRect(0,0,640,480,g.RGB24_16(0x00000000));
-	g.Setcolor(g_MAINFG_CO);
-	g.Rectangle(0,0,639,479);
-	m_Battery->Drawme(g);
-	m_Battery->Set_Value(g,*m_lo);
-	m_BomSmall->Drawme(g);
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-		m_BomButton[i]->Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  Switch the bottom focus status 
- * =====================================================================================
- */
-void Basewin::DrawBottomFocus(Graphic& g,int index)
-{
-	if 	( index != m_BottomFocus )
-	{
-		m_BomButton[m_BottomFocus-1]->Set_Focus(false);
-		m_BomButton[m_BottomFocus-1]->Drawme(g);
-		m_BomButton[index-1]->Set_Focus(true);
-		m_BomButton[index-1]->Drawme(g);
-		m_BottomFocus = index;
-	}
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Screen_Into_Memory
- *  Description:  Save screen from graphic buffer into memory 
- * =====================================================================================
- */
-void Basewin::Save_Screen_Into_Memory(Graphic& g)
-{
-	m_Gmem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
-	g.Load_Disp_Area(0,0,639,479,m_Gmem);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restore_Screen_From_Memory
- *  Description:  
- * =====================================================================================
- */
-void Basewin::Restore_Screen_From_Memory(Graphic& g)
-{
-	g.Restore_Disp_Area(0,0,639,479,m_Gmem);   			/* restore the graphic buffer */
-	delete[] m_Gmem;                           			/* release the buffer */
-	m_Gmem = NULL;
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Password_Confirm
- *  Description:  Need enter password to confirm nect excute 
- * =====================================================================================
- */
-int Basewin::Password_Confirm(Graphic &g)
-{
-	int result = 0;
-	PasswdMsgbox *ms;
-	if 	( m_gp->Language == 0 )
-		ms = new PasswdMsgbox(180,170,300,120,m_pl->GetText(INFO_PASSWORD));	
-	else if ( m_gp->Language == 1 )
-		ms = new PasswdMsgbox(140,170,400,120,m_pl->GetText(INFO_PASSWORD));	
-
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-
-	if 	( ms->Showme(g) == true )
-		result = 1;
-	else
-	{
-		if 	( ms->Get_Status() == PasswdMsgbox::PWCANCEL )
-			result = 2;
-	}
-	delete ms;
-	ms = NULL;
-	return result;
-}
-
-int Basewin::Key_Enter_Fun(Graphic& g){ return 0; }
-int Basewin::Key_Esc_Fun(Graphic& g){return 0;} 
-
-int Basewin::Key_F1_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F2_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F3_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F4_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F5_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F6_Fun(Graphic& g){return 0;} 
-int Basewin::Key_F7_Fun(Graphic& g){return 0;} 
-
-int Basewin::Key_Bom1_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom2_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom3_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom4_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom5_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom6_Fun(Graphic& g){return 0;}
-int Basewin::Key_Bom7_Fun(Graphic& g){return 0;}
-
-int Basewin::Key_NL1_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR1_Fun(Graphic& g){return 0;}
-int Basewin::Key_NL2_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR2_Fun(Graphic& g){return 0;}
-int Basewin::Key_NL3_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR3_Fun(Graphic& g){return 0;}
-int Basewin::Key_NL4_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR4_Fun(Graphic& g){return 0;}
-int Basewin::Key_NL5_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR5_Fun(Graphic& g){return 0;}
-int Basewin::Key_NL6_Fun(Graphic& g){return 0;}
-int Basewin::Key_NR6_Fun(Graphic& g){return 0;}
diff --git a/src/EVA11/Basewin.h b/src/EVA11/Basewin.h
deleted file mode 100644
index 62b77fc..0000000
--- a/src/EVA11/Basewin.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Basewin.h
- *
- *    Description:  Just a interface of all win class
- *
- *        Version:  1.0
- *        Created:  2012年06月28日 10时25分45秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _BASEWIN_INC
-#define  _BASEWIN_INC
-
-class Graphic;
-class Battery;
-class Language;
-class Global;
-class Logic;
-class Device;
-class Algorithm;
-class DataRepo;
-class Label;
-
-class Basewin
-{
-	public:
-		Basewin ();                             /* constructor */
-		virtual ~Basewin ();                    /* destructor  */
-
-		int Command_Process(Graphic& g);
-
-		typedef enum 
-		{
-			CO_CANCEL   = 0,
-			CO_OK       = 1,
-			CO_EXIT     = 2,
-			CO_LOADEXIT = 3,
-			CO_NONE     = 999
-		} COMMAND;				/* ----------  end of enum COMMAND  ---------- */
-	protected:
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g);
-		virtual void DrawBottomFocus(Graphic& g,int index);
-
-		virtual int Key_Enter_Fun(Graphic& g); 
-		virtual int Key_Esc_Fun(Graphic& g); 
-
-		virtual int Key_F1_Fun(Graphic& g); 
-		virtual int Key_F2_Fun(Graphic& g); 
-		virtual int Key_F3_Fun(Graphic& g); 
-		virtual int Key_F4_Fun(Graphic& g); 
-		virtual int Key_F5_Fun(Graphic& g); 
-		virtual int Key_F6_Fun(Graphic& g); 
-		virtual int Key_F7_Fun(Graphic& g); 
-
-		virtual int Key_Bom1_Fun(Graphic& g);
-		virtual int Key_Bom2_Fun(Graphic& g);
-		virtual int Key_Bom3_Fun(Graphic& g);
-		virtual int Key_Bom4_Fun(Graphic& g);
-		virtual int Key_Bom5_Fun(Graphic& g);
-		virtual int Key_Bom6_Fun(Graphic& g);
-		virtual int Key_Bom7_Fun(Graphic& g);
-
-		virtual int Key_NL1_Fun(Graphic& g);
-		virtual int Key_NR1_Fun(Graphic& g);
-		virtual int Key_NL2_Fun(Graphic& g);
-		virtual int Key_NR2_Fun(Graphic& g);
-		virtual int Key_NL3_Fun(Graphic& g);
-		virtual int Key_NR3_Fun(Graphic& g);
-		virtual int Key_NL4_Fun(Graphic& g);
-		virtual int Key_NR4_Fun(Graphic& g);
-		virtual int Key_NL5_Fun(Graphic& g);
-		virtual int Key_NR5_Fun(Graphic& g);
-		virtual int Key_NL6_Fun(Graphic& g);
-		virtual int Key_NR6_Fun(Graphic& g);
-
-		void Save_Screen_Into_Memory(Graphic& g);
-		void Restore_Screen_From_Memory(Graphic& g);
-
-		int Password_Confirm(Graphic &g);
-
-		inline void Set_MAX_Get_Key_Interval(int value) { m_MAXGetkeyTimes = value; m_GetKeyTimes = m_MAXGetkeyTimes; }
-	protected:
-		static const int  		     MAXBOMCOUNT   = 7;
-		int               		     m_BottomFocus;
-
-		unsigned int			     m_MAXGetkeyTimes;
-		unsigned int			     m_GetKeyTimes;
-
-		char				     *m_Msg;
-
-		Logic				     *m_lo;
-		Language			     *m_pl; 
-		Global				     *m_gp;
-		Device				     *m_device;
-		Algorithm			     *m_alg;
-		DataRepo			     *m_repo;
-
-		Battery          		     *m_Battery;
-		Label                                *m_BomSmall;
-		Label				     *m_BomButton[MAXBOMCOUNT];
-
-	private:
-
-		unsigned char 			     *m_Gmem;
-
-}; /* -----  end of class Basewin  ----- */
-#endif   /* ----- #ifndef _BASEWIN_INC  ----- */
diff --git a/src/EVA11/Battery.cpp b/src/EVA11/Battery.cpp
deleted file mode 100644
index 416d5ee..0000000
--- a/src/EVA11/Battery.cpp
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Battery.cpp
- *
- *    Description:  The class Battery file
- *
- *        Version:  1.0
- *        Created:  2009年11月27日 15时11分42秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Battery.h"
-#include 	"Msgbox.h"
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Logic.h"
-
-#define MAXTIMES 50
-
-Battery::Battery (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_Focus        = false;
-	m_Battery_Type = BAT_V;
-
-	m_BGFO_Color   = g_MAINBG_CO;
-	m_BGNO_Color   = g_MAINBG_CO;
-
-	m_FGNO_Color   = g_BATTARY_CO;
-	m_FGFO_Color   = g_BATTARY_CO;
-
-	m_MAXValue     = 6;
-	m_CurrentValue = 6;            /* 0~6 */
-	m_Times        = MAXTIMES;
-	m_Disp_Already = false;
-	
-	m_ADC_fd       = 0;
-	m_Sample_Counts= 100;
-}
- 
-Battery::~Battery ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Battery_Type
- *  Description:  Set the Battery Type 
- * =====================================================================================
- */
-void Battery::Set_Battery_Type(BATTERYTYPE type)
-{
-	m_Battery_Type = type; 
-}
- 
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the Battery interface
- * =====================================================================================
- */
-void Battery::Drawme(Graphic &g)
-{
-	int cent_x = m_X + ( m_Width>>1 );
-	int cent_y = m_Y + ( m_Heigh>>1 );
-	short txcolor,bgcolor;
-	short hicolor,locolor;
-
-	if ( m_Focus == true )
-	{
-		txcolor = m_FGFO_Color;
-		bgcolor = m_BGFO_Color;
-		hicolor = g_LIGHT_CO;
-		locolor = g_SHADOW_CO;
-	}
-	else
-	{
-		txcolor = m_FGNO_Color;
-		bgcolor = m_BGNO_Color;
-		hicolor = g_SHADOW_CO;
-		locolor = g_LIGHT_CO;
-	}
-
-	g.Switch_Screen();
-
-	if ( m_Battery_Type == BAT_V )
-	{
-		short sc = g.Getcolor();
-		g.Setcolor(g_MAINBG_CO);
-		g.DrawFillRect(m_X,m_Y,m_Width+1,m_Heigh);
-		g.Setcolor(txcolor);
-		g.DrawRect(m_X,m_Y+5,m_Width,m_Heigh-5);
-		g.Setcolor(sc);
-		g.DrawFillRect(cent_x-(m_Width>>2),m_Y+1,m_Width>>1,5,txcolor);
-		g.DrawFillRect(cent_x-(m_Width>>2)-2,m_Y+3,(m_Width>>1)+4,3,txcolor);
-
-		for ( int i=0;i<m_CurrentValue;i++ )
-		{
-			g.DrawFillRect(cent_x-(m_Width>>2)-2,m_Y+27-4*i,(m_Width>>1)+4,4,txcolor);
-		}
-	}
-	else if ( m_Battery_Type == BAT_H )
-	{
-		short sc = g.Getcolor();
-		g.Setcolor(g_MAINBG_CO);
-		g.DrawFillRect(m_X,m_Y,m_Width+1,m_Heigh+1);
-		g.Setcolor(txcolor);
-		g.DrawRect(m_X,m_Y,m_Width-5,m_Heigh);
-		g.Setcolor(sc);
-
-		g.DrawFillRect(m_X+m_Width-2-1,cent_y-(m_Heigh>>2),5,m_Heigh>>1,txcolor);
-		g.DrawFillRect(m_X+m_Width-2-3,cent_y-(m_Heigh>>2)-2,3,(m_Heigh>>1)+4,txcolor);
-
-		for ( int i=0;i<m_CurrentValue;i++ )
-		{
-			g.DrawFillRect(m_X+m_Width-3-27+4*i,cent_y-(m_Heigh>>2)-2,4,(m_Heigh>>1)+4,txcolor);
-		}
-	}
-
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Value
- *  Description:  Set the battery value and showing message
- *  		  Dynamic Version
- * =====================================================================================
- */
-void Battery::Set_Value(Graphic& g,Logic& lo)
-{
-	m_Sample_Counts --;
-	if ( m_Sample_Counts == 0 )
-	{
-		m_Sample_Counts = 100;
-	}
-	else
-		return;
-
-	int value = Get_Battary_Value();
-
-	if 	( value != m_CurrentValue )
-	{
-		m_CurrentValue = value;
-
-		Drawme(g);	
-		if      ( value == 0 && m_Disp_Already == false )
-		{
-			Language* pl = Language::Instance(); 
-			Msgbox *ms = new Msgbox(200,170,260,80,pl->GetText(INFORMESG08),Msgbox::MSG_AUTO);	
-			ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-			ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-			ms->Showme(g);
-			delete ms;
-			ms = NULL;
-			m_Disp_Already = true;
-		}
-	}
-
-	if 	( value == 0 && m_Disp_Already == true )
-	{
-		if 	( Get_Auto_Shutdown_Flag() == true )
-		{
-			lo.Shutdown();
-		}
-	}
-	else if ( value > 2 && m_Disp_Already == true ) /* Means re-insert power plugin */
-	{
-		m_Disp_Already = false;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Battery_Handle
- *  Description:  Set the Battery Handle 
- * =====================================================================================
- */
-void Battery::Set_Battery_Handle(int handle)
-{
-#ifdef X86
-	m_Last_Adc = 0x370;
-#else
-	m_ADC_fd = handle;
-	if ( m_ADC_fd != 0 )
-	{
-		ssize_t r = read(m_ADC_fd,&m_Last_Adc,2);
-		r = r;
-	}
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Battery_Value
- *  Description:  Get the Battery Value 
- * =====================================================================================
- */
-int  Battery::Get_Battary_Value()
-{
-#ifdef X86
-	return 6;
-#else
-	unsigned short adc_value;	
-
-	size_t re = read(m_ADC_fd,&adc_value,2);
-	re = re;
-
-	m_Last_Adc = ( ( ( adc_value - m_Last_Adc ) << 3 ) >> 8 ) + m_Last_Adc;
-
-	adc_value = m_Last_Adc;
-
-#ifdef ARM9
-	switch ( adc_value ) 
-	{
-		case 0x370 ... 0xfff: 
-			return 6;
-			break;
-
-		case 0x355 ... 0x36f: 
-			return 5;
-			break;
-
-		case 0x341 ... 0x354: 
-			return 4;
-			break;
-
-		case 0x330 ... 0x340: 
-			return 3;
-			break;
-
-		case 0x325 ... 0x32f: 
-			return 2;
-			break;
-
-		case 0x315 ... 0x324: 
-			return 1;
-			break;
-
-		case 0 ... 0x314:
-			return 0;
-			break;
-
-		default:	
-			return m_CurrentValue;
-			break;
-	}				/* -----  end switch  ----- */
-#endif
-
-#ifdef ARM11
-	switch ( adc_value )
-	{
-		case 0x328 ... 0xfff: 
-			return 6;
-			break;
-
-		case 0x307 ... 0x327: 
-			return 5;
-			break;
-
-		case 0x2f8 ... 0x306: 
-			return 4;
-			break;
-
-		case 0x2ee ... 0x2f7: 
-			return 3;
-			break;
-
-		case 0x2e1 ... 0x2ed: 
-			return 2;
-			break;
-
-		case 0x2b1 ... 0x2e0: 
-			return 1;
-			break;
-
-		case 0 ... 0x2b0:
-			return 0;
-			break;
-
-		default:	
-			return m_CurrentValue;
-			break;
-	}				/* -----  end switch  ----- */
-#endif
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Auto_Shutdown_Flag
- *  Description:  If need auto shutdown device return true 
- * =====================================================================================
- */
-bool Battery::Get_Auto_Shutdown_Flag()
-{
-#ifdef X86
-	return true;
-#else
-	unsigned short adc_value;	
-	size_t re = read(m_ADC_fd,&adc_value,2);
-	re = re;
-	if ( adc_value <= 0x285 ) return true;
-	else return false;
-#endif
-}
diff --git a/src/EVA11/Battery.h b/src/EVA11/Battery.h
deleted file mode 100644
index 207b0f9..0000000
--- a/src/EVA11/Battery.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Battery.h
- *
- *    Description:  THe head file for Battery class 
- *
- *        Version:  1.0
- *        Created:  2009年12月29日 16时13分38秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  _BATTERY_INC
-#define  _BATTERY_INC
-
-class Logic;
-class Graphic; 
-class Object;
-
-class Battery  : public Object
-{
-	public:
-		enum BATTERYTYPE 
-		{
-			BAT_V,
-			BAT_H,
-		};				/* ----------  end of enum BATTERYTYPE  ---------- */
-		typedef enum BATTERYTYPE BATTERYTYPE;
-
-		Battery (int x,int y,int width,int heigh); /* constructor Init with Graphic class */
-		~Battery ();
-		void Drawme(Graphic &g);                   /* Draw the Battery surface  	*/
-		void Set_Battery_Handle(int);		   /* Get the handle of Battery(adc)    */
-		void Set_Value(Graphic &g,Logic& lo);      /* Set the value 			*/
-		void Set_Battery_Type(BATTERYTYPE);
-		bool Get_Auto_Shutdown_Flag();
-		int  Get_Battary_Value();
-		bool m_Focus;                              /* Whether the Battery is focus 	*/
-	protected:
-	private:
-
-		/*-----------------------------------------------------------------------------
-		 *  position of Battery
-		 *-----------------------------------------------------------------------------*/
-		int          m_FontType;       		 /* The big or small of the font type */
-
-		int          m_MAXValue;
-		int          m_CurrentValue;
-		unsigned int m_Times;
-
-		short        m_BGFO_Color;
-		short        m_FGFO_Color;
-		short        m_BGNO_Color;
-		short        m_FGNO_Color;
-
-		BATTERYTYPE  m_Battery_Type;
-
-		bool         m_Disp_Already;
-
-		int	     				m_ADC_fd;
-		unsigned short                          m_Last_Adc;
-		int	     m_Sample_Counts;
-}; /* -----  end of class Battery  ----- */
-#endif   /* ----- #ifndef _BATTERY_INC  ----- */
-
diff --git a/src/EVA11/Bufferbar.cpp b/src/EVA11/Bufferbar.cpp
deleted file mode 100644
index fcf490a..0000000
--- a/src/EVA11/Bufferbar.cpp
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Bufferbar.cpp
- *
- *    Description:  Implementation of Bufferbar class
- *
- *        Version:  1.0
- *        Created:  2012年08月01日 15时39分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	"Object.h"
-#include 	"Bufferbar.h"
-#include 	"Graphic.h"
-
-Bufferbar::Bufferbar (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-}
-
-Bufferbar::~Bufferbar ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on screen 
- * =====================================================================================
- */
-void Bufferbar::Drawme(Graphic &g,uint64_t len,bool bufflag)
-{
-	if 	( bufflag == true )
-		g.Switch_Screen();
-	Refreshme(g);
-	if 	( bufflag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Bufferbar::Refreshme(Graphic &g)
-{
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BG_Color);
-	g.DrawFillRect(m_X+1,m_Y+1,m_X+1+m_Buffer_Index,m_Heigh-3+2,m_FG_Color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Color
- *  Description:  Set the Color of GUI object 
- * =====================================================================================
- */
-void Bufferbar::Set_Color(BUFCOLOR ct,short color)
-{
-	switch ( ct )
-	{
-		case BUF_FG_COLOR:
-			m_FG_Color = color;
-			break;
-		case BUF_BG_COLOR:
-			m_BG_Color = color;
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Buffer_Bar
- *  Description:  Init the buffer bar GUI object 
- *     len Unit:  Bytes
- * =====================================================================================
- */
-void Bufferbar::Init_Buffer_Bar(Graphic& g,uint64_t len)
-{
-	m_Length 		= len;
-	m_One_Step_Bytes	= len / ( m_Width - 2 );
-	m_Remain_Bytes		= len - m_One_Step_Bytes * ( m_Width - 2 );
-
-	m_Current_Bytes 	= 0;
-	m_Buffer_Index          = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Uint
- *  Description:  Draw the unit on screen 
- * =====================================================================================
- */
-void Bufferbar::Draw_Unit(Graphic& g)
-{
-	for ( int32_t i=0;i<m_Heigh-2;i++ )
-	{
-		g.Setpixel(m_X+1+m_Buffer_Index,m_Y+1+i,m_FG_Color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Bytes_Number
- *  Description:  Set the bytes count into buffer 
- * =====================================================================================
- */
-void Bufferbar::Save_Bytes_Number(Graphic& g,uint32_t count)
-{
-	m_Current_Bytes += count;
-	if 	( m_Current_Bytes >= m_One_Step_Bytes )
-	{
-		m_Current_Bytes -= m_One_Step_Bytes;
-		if 	( m_Buffer_Index < m_Width - 4 )
-		{
-			m_Buffer_Index ++;
-			Draw_Unit(g);
-		}
-		else if ( m_Buffer_Index == m_Width - 4 )
-		{
-			Draw_Unit(g);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_Buffer_Bar
- *  Description:  Call this function to clean buffer bar
- * =====================================================================================
- */
-void Bufferbar::Clean_Buffer_Bar(Graphic& g)
-{
-	Init_Buffer_Bar(g,m_Length);
-	Drawme(g,true);
-}
diff --git a/src/EVA11/Bufferbar.h b/src/EVA11/Bufferbar.h
deleted file mode 100644
index 75c3753..0000000
--- a/src/EVA11/Bufferbar.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Bufferbar.h
- *
- *    Description:  Indicate the Buffer count 
- *
- *        Version:  1.0
- *        Created:  2012年08月01日 15时35分25秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _BUFFERBAR_INC
-#define  _BUFFERBAR_INC
-
-#include 	<stdint.h>
-class Graphic;
-class Object;
-class Bufferbar : public Object
-{
-	public:
-		enum BUFCOLOR 
-		{
-			BUF_FG_COLOR,
-			BUF_BG_COLOR,
-		};
-		typedef enum BUFCOLOR BUFCOLOR;
-		Bufferbar (int x,int y,int width,int height);
-		~Bufferbar ();
-
-		void Drawme(Graphic &g,uint64_t len = 0,bool bufflag = true);
-		void Set_Color(BUFCOLOR ct,short color);
-		void Init_Buffer_Bar(Graphic& g,uint64_t len);
-		void Save_Bytes_Number(Graphic& g,uint32_t count);
-		void Draw_Unit(Graphic& g);
-		void Clean_Buffer_Bar(Graphic& g);
-	protected:
-
-	private:
-		void Refreshme(Graphic &g);
-	private:
-		short			m_BG_Color;
-		short			m_FG_Color;
-
-		uint64_t 		m_Length;
-		uint32_t		m_One_Step_Bytes;
-		uint32_t		m_Remain_Bytes;
-		uint32_t		m_Current_Bytes;
-		int32_t			m_Buffer_Index;
-};
-
-#endif
diff --git a/src/EVA11/CZKPanel.cpp b/src/EVA11/CZKPanel.cpp
deleted file mode 100644
index 71bba52..0000000
--- a/src/EVA11/CZKPanel.cpp
+++ /dev/null
@@ -1,815 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  CZKPanel.cpp
- *
- *    Description:  implementation of CZKPanel class
- *
- *        Version:  1.0
- *        Created:  2013年05月06日 16时01分28秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"BasePanel.h"
-#include 	"DZKPanel.h"
-#include 	"CZKPanel.h"
-
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-#include 	"Graphic.h"
-#include 	"Language.h"
-#include 	"Global.h"
-#include 	"Bufferbar.h"
-#include 	"Device.h"
-#include 	"DataRepo.h"
-#include 	"Label.h"
-#include 	"Msgbox.h"
-#include 	"Chart.h"
-
-#include 	"AlarmManage.h"
-#include 	"Basescreen.h"
-#include 	"ZScreen.h"
-#include 	"Language.h"
-
-#include 	"Resource.h"
-
-const static  char* AlarmText[8] = {"A","B","C","D","E","F","G","H"};
-
-CZKPanel::CZKPanel (int x,int y,int width,int heigh)
-	: DZKPanel(x,y,width,heigh)
-{
-}
-
-CZKPanel::~CZKPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void CZKPanel::Init_GUI(Graphic& g)
-{
-	DZKPanel::Init_GUI(g);
-	m_gp->bCompositeSrcPause = false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void CZKPanel::Destroy_GUI()
-{
-	DZKPanel::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void CZKPanel::Drawme(Graphic& g,bool flag)
-{
-	DZKPanel::Drawme(g,flag);
-
-	for ( int i = 0; i < 2; i += 1 ) 
-	{
-		m_Chart[i]->Drawme(g,flag);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  important function, deal with data
- * =====================================================================================
- */
-int CZKPanel::Loop_Panel(Graphic& g)
-{
-	if 	( m_gp->bCompositeSrcPause == true )
-		return 0;
-
-	m_DataProcess->Data_Process();
-	m_DataProcess->Get_Data(m_RawBuf);
-
-	int x,y;
-	int result;
-	for ( int i=0;i<2;i++ )
-	{
-		m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[(m_gp->ScrSigM[i]<<1)],m_RawBuf[(m_gp->ScrSigM[i]<<1)+1]);
-		m_Zscreen[i]->Get_SX_SY(x,y);
-		result = m_AlarmManage[i]->Is_In_Alarm(x,y);
-		if (  result != 0xff )
-		{
-			if 	( result != m_LastStatus[i] )
-			{
-				m_LabAlarmSt[i]->Set_Text(AlarmText[result]);
-				m_LabAlarmSt[i]->Drawme(g);
-				m_LastStatus[i] = result;
-			}
-		}
-		else
-		{
-			if 	( result != m_LastStatus[i] )
-			{
-				m_LabAlarmSt[i]->Set_Text(" ");
-				m_LabAlarmSt[i]->Drawme(g);
-				m_LastStatus[i] = result;
-			}
-		}
-	}
-
-	for ( int i = 0; i < 2; i += 1 ) 
-		m_Chart[i]->Draw_AScan_Signal(g,m_RawBuf[4]);
-
-	m_Bufbar->Save_Bytes_Number(g,2<<2);
-
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_ZScreen_Object
- *  Description:  Init the ZScreen GUI Object 
- * =====================================================================================
- */
-void CZKPanel::Init_ZScreen_Object(Graphic& g)
-{
-	Global *gp = Global::Instance();
-
-	m_DataProcess = new CZKDataProcess;
-
-	m_Zscreen[0] = new Zscreen(2,44,265,269);
-	m_Zscreen[1] = new Zscreen(2+265,44,265,269);
-
-	m_Zscreen[0]->Set_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
-	m_Zscreen[1]->Set_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_ID(i+1);
-
-		Refresh_ZKScreen_Focus(g,false);
-	}
-
-	m_Chart[0] = new Chart(2,313,530,65);
-	m_Chart[0]->Set_Coef(265);				   // we need switch other coe
-
-	m_Chart[1] = new Chart(2,378,530,65);
-	m_Chart[1]->Set_Coef(265);				   // we need switch other coe
-
-	m_AlarmManage[0] = new(std::nothrow) AlarmManage(2,44,265,269);
-	m_AlarmManage[1] = new(std::nothrow) AlarmManage(2+265,44,265,269);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_AlarmManage[i]->Init_Alarm_Sets(g);
-
-	gp->bCNeedResetAlarmArea = true;                    	   // Notice when init we need let OZK to load alarm para
-	Load_Alarm_Para();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_ZScreen_Object
- *  Description:  Destroy the ZScreen GUI Object
- * =====================================================================================
- */
-void CZKPanel::Destroy_ZScreen_Object()
-{
-	if 	( m_DataProcess != NULL )
-	{
-		delete m_DataProcess;
-		m_DataProcess = NULL;
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		if ( m_Zscreen[i] != NULL )
-		{
-			delete m_Zscreen[i];
-			m_Zscreen[i] = NULL;
-		}
-
-		m_AlarmManage[i]->Destroy_Alarm_Sets();
-		if ( m_AlarmManage[i] != NULL )
-		{
-			delete m_AlarmManage[i];
-			m_AlarmManage[i] = NULL;
-		}
-	}
-
-	for ( int i = 0; i < 2; i += 1 ) 
-	{
-		delete m_Chart[i];
-		m_Chart[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Panel
- *  Description:  Switch panel call this function 
- * =====================================================================================
- */
-void CZKPanel::Switch_Panel()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-
-	for ( int ch=0;ch<2;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 1;			// ECT
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-
-	for ( int ch=2;ch<4;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 3;			// EMS
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-
-	for ( int ch=4;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 0;		       // CLOSE
-		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	device->Write_Para_Driver(m_gp->Driver);
-	device->Write_Para_Offset(m_gp->Offset);
-	device->Write_Para_SignalWave(0);
-
-	device->Transfer_ECT_Parameters();
-
-	Load_Alarm_Para();
-
-	m_DataProcess->Trigger_Balacne_Process();       // very Important
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm Parameters from Global 
- *                When Load Para from device call this function
- * =====================================================================================
- */
-void CZKPanel::Load_Alarm_Para()
-{
-	Global* gp = Global::Instance();
-	if ( gp->bCNeedResetAlarmArea == true )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_AlarmManage[i]->Set_Alarm_Type(gp->CAlarmType[i]);
-			for ( int j=0;j<3;j++ )
-			{
-				m_AlarmManage[i]->Set_Alarm_Count(j,gp->CAlarmCount[i][j]);
-				m_AlarmManage[i]->Set_Alarm_Index(j,gp->CAlarmIndex[i][j]);
-			}
-			m_AlarmManage[i]->Load_Alarm_Para(gp->CAlarmPara[i]);
-		}
-
-		m_AlarmManage[0]->Create_Alarm_Area_Mask();
-		m_AlarmManage[1]->Create_Alarm_Area_Mask();
-		gp->bCNeedResetAlarmArea = false;
-	}
-}
-
-int CZKPanel::Key_Enter_Fun(Graphic& g)
-{
-	m_gp->bCompositeSrcPause = false;
-	Do_Enter_Fun(g);
-	return 0;
-}
-
-/* --------------------------------------------------------------------- */
-/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
-/* --------------------------------------------------------------------- */
-int CZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->ScrSigFocus == 0 ) gp->ScrSigFocus = 1;
-		else gp->ScrSigFocus --;
-		Refresh_ZKScreen_Focus(g,true);
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 0 )
-				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]];
-			else
-				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] -= 1; 
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
-		}
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->ScrSigFocus == 1 ) gp->ScrSigFocus = 0;
-		else gp->ScrSigFocus ++;
-		Refresh_ZKScreen_Focus(g,true);
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 7 || 
-					gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] >= gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]])
-			{
-				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 0;
-			}
-			else
-				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] += 1;
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
-		}
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 0  ) gp->CAlarmType[gp->ScrSigFocus] = 3;
-		else gp->CAlarmType[gp->ScrSigFocus] --;
-		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->CAlarmType[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 3  ) gp->CAlarmType[gp->ScrSigFocus] = 0;
-		else gp->CAlarmType[gp->ScrSigFocus] ++;
-		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->CAlarmType[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P1((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 0 )
-				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 7;
-			else
-			{
-				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] --;
-				if ( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] < gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] )
-				{
-					gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]];
-				}
-			}
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
-		}
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 7 )
-				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 0;
-			else
-				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] ++;
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
-		}
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P2((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P3((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P4((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bCNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int CZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-//	else if ( sub == 2 )
-//	{
-//		m_AlarmManage[0]->Test(g);
-//		m_AlarmManage[1]->Test(g);
-//	}
-	return 0;
-}
-int CZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-//	else if ( sub == 2 )
-//	{
-//		m_AlarmManage[0]->Test(g);
-//		m_AlarmManage[1]->Test(g);
-//	}
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_FX_Fun
- *  Description:  Shot Functions 
- * =====================================================================================
- */
-int CZKPanel::Key_F2_Fun(Graphic& g)
-{
-	if 	( m_gp->bCompositeSrcPause == false )
-		Clean_ZKScreen(g);
-	else
-	{
-		Language *m_pl = Language::Instance();
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		if 	( ms->Showme(g) == true )
-		{
-			delete ms;
-			ms = NULL;
-			m_Zscreen[m_gp->ScrSigFocus]->Clean_Photo();
-			m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
-			return 0; 
-		}
-		delete ms;
-		ms = NULL;
-	}
-	return 0;
-}
-int CZKPanel::Key_F3_Fun(Graphic& g)
-{
-	if 	( m_gp->DrawMode2[m_gp->ScrSigFocus] == 0 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 1;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::LINE);
-	}
-	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus] == 1 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 2;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::AUTO);
-	}
-	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus]== 2 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 0;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::POINT);
-	}
-	m_Zscreen[m_gp->ScrSigFocus]->Reset_Trace();
-	return 0;
-}
-int CZKPanel::Key_F4_Fun(Graphic& g)
-{
-	if 	( m_gp->bCompositeSrcPause == false )
-		m_DataProcess->Trigger_Balacne_Process();
-	else
-	{
-		m_Zscreen[m_gp->ScrSigFocus]->Save_Photo(g);
-		m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
-	}
-	return 0;
-}
-int CZKPanel::Key_F6_Fun(Graphic& g)
-{
-//	Language* m_pl = Language::Instance();
-//	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
-//	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-//	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-//	if ( ms->Showme(g) == false )
-//	{
-//		delete ms;
-//		ms = NULL;
-//		return 0;
-//	}
-//	delete ms;
-//	ms = NULL;
-//	m_Bufbar->Clean_Buffer_Bar(g);
-	return 0;
-}
-
-int CZKPanel::Key_F7_Fun(Graphic& g)
-{
-//	int callen = 10000;
-//	if 	( m_gp->bCompositeSrcPause == false )
-//	{
-//		m_gp->bCompositeSrcPause = true;
-//		Swtich_Status(g);
-//		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-//		return 0;
-//	}
-//
-//	m_Zscreen[m_gp->ScrSigFocus]->Mixing_Parameters_Calculate(g,callen,100);
-//	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-//
-//	Language* m_pl = Language::Instance();
-//	MixingManage *algm = MixingManage::Instance();
-//	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(SAVEMIXCOMFIRM),Msgbox::MSG_OKCANCEL);
-//	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-//	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-//	ms->Set_Transparce(120);
-//	if ( ms->Showme(g) == true )
-//	{
-//		algm->Sync_Mixing_Para(true);
-//		delete ms;
-//		ms = NULL;
-//	}
-//	else
-//	{
-//		algm->Sync_Mixing_Para(false);
-//		delete ms;
-//		ms = NULL;
-//		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-//	}
-	return 0;
-}
-
-int CZKPanel::Para_NL1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::LEFT,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
-	}
-	return 0;
-}
-int CZKPanel::Para_NR1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
-	}
-	return 0;
-}
-int CZKPanel::Para_NL2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::UP,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
-	}
-	return 0;
-}
-int CZKPanel::Para_NR2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::DOWN,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
-	}
-	return 0;
-}
-int CZKPanel::Para_NL3_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::LEFT,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
-	}
-	return 0;
-}
-int CZKPanel::Para_NR3_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
-	}
-	return 0;
-}
-int CZKPanel::Para_NL4_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::UP,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
-	}
-	return 0;
-}
-int CZKPanel::Para_NR4_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::DOWN,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
-	}
-	return 0;
-}
-
-int CZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // gain        
-{
-	m_gp->bCompositeSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int CZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // gain        
-{
-	m_gp->bCompositeSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int CZKPanel::Key_NL4_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bCompositeSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-
-}
-int CZKPanel::Key_NR4_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bCompositeSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Status
- *  Description:  When stop the signal switch the system status 
- * =====================================================================================
- */
-void CZKPanel::Swtich_Status(Graphic& g)
-{
-	if 	( m_gp->bCompositeSrcPause == true )
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,8,253,15);
-	}
-	else
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,9,253,15);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_ZKScreen_Focus
- *  Description:  Refresh ZKScreen Focus status
- * =====================================================================================
- */
-void CZKPanel::Refresh_ZKScreen_Focus(Graphic&g,bool flag)
-{
-	for ( int i=0;i<2;i++ )
-	{
-		if ( i == m_gp->ScrSigFocus )
-			m_Zscreen[i]->Set_Focus(g,true,flag);
-		else
-			m_Zscreen[i]->Set_Focus(g,false,flag);
-	}
-}
diff --git a/src/EVA11/CZKPanel.h b/src/EVA11/CZKPanel.h
deleted file mode 100644
index a4e9a19..0000000
--- a/src/EVA11/CZKPanel.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  CZKPanel.h
- *
- *    Description:  Declearation of CZKPanel class
- *
- *        Version:  1.0
- *        Created:  2013年05月06日 15时58分25秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  CZKPANEL_INC
-#define  CZKPANEL_INC
-
-class CZKDataProcess;
-class Chart;
-class CZKPanel : public DZKPanel
-{
-	public:
-		CZKPanel (int x,int y,int width,int heigh);
-		~CZKPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
-
-		virtual int Key_Enter_Fun(Graphic& g);
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-		virtual int Key_F7_Fun(Graphic& g);
-
-		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
-
-		virtual void Switch_Panel();
-		virtual void Swtich_Status(Graphic& g);
-	protected:
-		virtual void Init_ZScreen_Object(Graphic& g);
-		virtual void Destroy_ZScreen_Object();
-		virtual void Load_Alarm_Para();
-
-		void Refresh_ZKScreen_Focus(Graphic&g,bool flag);
-	private:
-		Chart					*m_Chart[2];
-		CZKDataProcess    			*m_DataProcess;
-};
-
-#endif   /* ----- #ifndef CZKPANEL_INC  ----- */
diff --git a/src/EVA11/CalculateCenter.cpp b/src/EVA11/CalculateCenter.cpp
deleted file mode 100644
index 7c84dac..0000000
--- a/src/EVA11/CalculateCenter.cpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  CalculateCenter.cpp
- *
- *    Description:  implementation of CalculateCenter class
- *
- *        Version:  1.0
- *        Created:  2012年11月14日 09时23分59秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include        <math.h>
-#include 	<cstdlib>
-#include 	<cstdio>
-#include 	"CalculateCenter.h"
-
-struct CalculateCenter::PImpl
-{
-#ifdef ARM9
-	const double		m_cPI = 3.1415926;
-#endif
-
-#ifdef X86
-	static const double	m_cPI = 3.1415926;
-#endif
-	bool			m_bInitial;
-	int			m_MAX_X;
-	int			m_MAX_Y;
-	int			m_MIN_X;
-	int			m_MIN_Y;
-
-	int			m_Graphic_Center_X;
-	int			m_Graphic_Center_Y;
-
-	AMPBALL                 m_LMAXAMP;
-	AMPBALL                 m_RMAXAMP;
-	RLPOINT                 m_RL_Point;
-
-	long long		m_AMP;
-	long long		m_YAMP;
-	int			m_PHA;
-};
-
-CalculateCenter::CalculateCenter () : m_Imple(new struct PImpl)
-{
-}
-
-CalculateCenter::~CalculateCenter ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Object
- *  Description:  Init the Object of CalculateCenter 
- * =====================================================================================
- */
-void CalculateCenter::Init_Object()
-{
-	m_Imple->m_bInitial           = false;
-
-	m_Imple->m_MAX_X              = 0;
-	m_Imple->m_MAX_Y              = 0;
-	m_Imple->m_MIN_X              = 0;
-	m_Imple->m_MIN_Y              = 0;
-	m_Imple->m_Graphic_Center_X   = 0;
-	m_Imple->m_Graphic_Center_Y   = 0;
-
-	m_Imple->m_LMAXAMP.X          = 0;
-	m_Imple->m_LMAXAMP.Y          = 0;
-	m_Imple->m_LMAXAMP.AMP        = 0;
-
-	m_Imple->m_RMAXAMP.X          = 0;
-	m_Imple->m_RMAXAMP.Y          = 0;
-	m_Imple->m_RMAXAMP.AMP        = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Graphic_MAX_MIN_Value
- *  Description:  
- * =====================================================================================
- */
-void CalculateCenter::Calculate_Graphic_MAX_MIN_Value(short x,short y)
-{
-	if ( m_Imple->m_bInitial == false )
-	{
-		m_Imple->m_MAX_X = x; m_Imple->m_MIN_X = x;
-		m_Imple->m_MAX_Y = y; m_Imple->m_MIN_Y = y;
-		m_Imple->m_bInitial = true;
-		return;
-	}
-
-	if ( m_Imple->m_MAX_X < x )
-	{
-		m_Imple->m_MAX_X = x;
-	}
-	else 
-	{
-		if ( m_Imple->m_MIN_X > x ) 
-		{
-			m_Imple->m_MIN_X = x;
-		}
-	}
-
-	if ( m_Imple->m_MAX_Y < y )
-	{
-		m_Imple->m_MAX_Y = y;
-	}
-	else 
-	{
-		if ( m_Imple->m_MIN_Y > y ) 
-		{
-			m_Imple->m_MIN_Y = y;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Graphic_Center
- *  Description:  Calculate the Graphic Center 
- * =====================================================================================
- */
-void CalculateCenter::Calculate_Graphic_Center()
-{
-	m_Imple->m_Graphic_Center_X = ( m_Imple->m_MIN_X + m_Imple->m_MAX_X ) >> 1;
-	m_Imple->m_Graphic_Center_Y = ( m_Imple->m_MIN_Y + m_Imple->m_MAX_Y ) >> 1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Record_MAXValue
- *  Description:  Record the Left and Right MAX AMP value
- * =====================================================================================
- */
-void CalculateCenter::Record_MAXValue(short x,short y)
-{
-	double amp;
-	if ( x > m_Imple->m_Graphic_Center_X )                   /* Right */
-	{
-		amp = sqrt(abs(x-m_Imple->m_Graphic_Center_X) * abs(x-m_Imple->m_Graphic_Center_X) +
-			    abs(y-m_Imple->m_Graphic_Center_Y) * abs(y-m_Imple->m_Graphic_Center_Y));
-
-		if ( amp > m_Imple->m_RMAXAMP.AMP )
-		{
-			m_Imple->m_RMAXAMP.AMP = amp;
-			m_Imple->m_RMAXAMP.X = x; 
-			m_Imple->m_RMAXAMP.Y = y;
-			m_Imple->m_RL_Point = RLPOINT_R;
-		}
-	}
-	else                                             /* Left */
-	{
-		amp = sqrt(abs(x-m_Imple->m_Graphic_Center_X) * abs(x-m_Imple->m_Graphic_Center_X) +
-			    abs(y-m_Imple->m_Graphic_Center_Y) * abs(y-m_Imple->m_Graphic_Center_Y));
-		if ( amp > m_Imple->m_LMAXAMP.AMP )
-		{
-			m_Imple->m_LMAXAMP.AMP = amp;
-			m_Imple->m_LMAXAMP.X = x; 
-			m_Imple->m_LMAXAMP.Y = y;
-			m_Imple->m_RL_Point = RLPOINT_L;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_AMPBALL
- *  Description:  Set the AMP points to Zero 
- * =====================================================================================
- */
-void CalculateCenter::Reset_AMPBALL()
-{
-	m_Imple->m_LMAXAMP.X   = 0;
-	m_Imple->m_LMAXAMP.Y   = 0;
-	m_Imple->m_LMAXAMP.AMP = 0;
-
-	m_Imple->m_RMAXAMP.X   = 0;
-	m_Imple->m_RMAXAMP.Y   = 0;
-	m_Imple->m_RMAXAMP.AMP = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_MAX_Point
- *  Description:  Get the MAX ponit 
- * =====================================================================================
- */
-void CalculateCenter::Get_MAX_Point(int& rx,int& ry,int& lx,int& ly)
-{
-	rx = m_Imple->m_RMAXAMP.X;
-	ry = m_Imple->m_RMAXAMP.Y;
-
-	lx = m_Imple->m_LMAXAMP.X;
-	ly = m_Imple->m_LMAXAMP.Y;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_AMP_PHA
- *  Description:  Calculate the AMP and PHA value in the digital surface
- * =====================================================================================
- */
-void CalculateCenter::Calculate_AMP_PHA()
-{
-	double dx 	= static_cast<double>(m_Imple->m_RMAXAMP.X) - static_cast<double>(m_Imple->m_LMAXAMP.X);
-	double dy 	= static_cast<double>(m_Imple->m_RMAXAMP.Y) - static_cast<double>(m_Imple->m_LMAXAMP.Y);
-	m_Imple->m_AMP  = static_cast<long long>(sqrt(dx*dx+dy*dy)); 
-	m_Imple->m_YAMP = static_cast<long long>(abs(m_Imple->m_RMAXAMP.Y-m_Imple->m_LMAXAMP.Y)); 
-	m_Imple->m_PHA  = static_cast<int>(180 * asin(static_cast<double>( m_Imple->m_YAMP ) / static_cast<double>(m_Imple->m_AMP)) / m_Imple->m_cPI);
-
-	/*-----------------------------------------------------------------------------
-	 *  4 kind situation                                   big  different from display coordicate
-	 *
-	 *  *               *        \           /
-	 *   \             /          \         /
-	 *    \           /            *       *
-	 *                                                     small
-	 *
-	 * In data coordicate    small 
-	 *                       big
-	 *-----------------------------------------------------------------------------*/
-
-	if ( m_Imple->m_RL_Point == RLPOINT_R )           /* Left point to Right */
-	{
-		if ( m_Imple->m_LMAXAMP.Y < m_Imple->m_RMAXAMP.Y ) /* Becare the compare must in hardware data arrange */
-		{
-			m_Imple->m_PHA += 180;
-		}
-		else
-		{
-			m_Imple->m_PHA = 180 - m_Imple->m_PHA;
-		}
-	}
-	else                                     /* Right point to Left */
-	{
-		if ( m_Imple->m_LMAXAMP.Y < m_Imple->m_RMAXAMP.Y )
-		{
-			m_Imple->m_PHA += 0;
-		}
-		else
-		{
-			m_Imple->m_PHA = 360 - m_Imple->m_PHA;
-		}
-	}
-
-	if 	( m_Imple->m_PHA < 0 ) m_Imple->m_PHA += 360;
-	else if ( m_Imple->m_PHA > 360 ) m_Imple->m_PHA -= 360;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_PHA
- *  Description:   
- * =====================================================================================
- */
-int CalculateCenter::Get_PHA()
-{
-	return m_Imple->m_PHA;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_AMP
- *  Description:  
- * =====================================================================================
- */
-long long CalculateCenter::Get_AMP()
-{
-	return m_Imple->m_AMP;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Center_Point
- *  Description:  Get the Center point 
- * =====================================================================================
- */
-void CalculateCenter::Get_Center_Point(int& x,int& y)
-{
-	x = m_Imple->m_Graphic_Center_X;
-	y = m_Imple->m_Graphic_Center_Y;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_LR_Point
- *  Description:  Get the Left and Right Point 
- *       result:  true  	Left
- *                false 	Right
- * =====================================================================================
- */
-bool CalculateCenter::Get_LR_Point()
-{
-	if 	( m_Imple->m_RL_Point == RLPOINT_L )
-		return true;
-	else if ( m_Imple->m_RL_Point == RLPOINT_R )
-		return false;
-	else 
-		return false;
-	return false;
-}
diff --git a/src/EVA11/CalculateCenter.h b/src/EVA11/CalculateCenter.h
deleted file mode 100644
index 9eaf0f5..0000000
--- a/src/EVA11/CalculateCenter.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  CalculateCenter.h
- *
- *    Description:  It is a temp class only used to calculate the Graphic center
- *
- *        Version:  1.0
- *        Created:  2012年11月14日 09时22分21秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _CALCULATECENTER_INC
-#define  _CALCULATECENTER_INC
-
-#include 	<memory>	
-class CalculateCenter
-{
-	public:
-		typedef struct 
-		{
-			short X;
-			short Y;
-			double AMP;
-		}AMPBALL;
-
-		typedef enum 
-		{
-			RLPOINT_L=0,
-			RLPOINT_R=1,
-		} RLPOINT;
-
-		CalculateCenter ();
-		~CalculateCenter ();
-
-		void Init_Object();
-		void Calculate_Graphic_MAX_MIN_Value(short x,short y);
-		void Calculate_Graphic_Center();
-		void Record_MAXValue(short x,short y);
-		void Reset_AMPBALL();
-
-		void Get_MAX_Point(int& rx,int& ry,int& lx,int& ly);
-		void Get_Center_Point(int& x,int& y);
-
-		void Calculate_AMP_PHA();
-
-		int Get_PHA();
-		long long Get_AMP();
-
-		bool Get_LR_Point();
-	protected:
-
-	private:
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif
diff --git a/src/EVA11/Chart.cpp b/src/EVA11/Chart.cpp
deleted file mode 100644
index 35f947a..0000000
--- a/src/EVA11/Chart.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Chart.cpp
- *
- *    Description:  Implementation of Chart class
- *
- *        Version:  1.0
- *        Created:  2012年11月08日 15时48分13秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"Object.h"
-#include 	"Chart.h"
-#include 	"Global.h"
-
-Chart::Chart (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_FGColor    = g_MOVBFG_CO;
-	m_BGColor    = g_MOVBBG_CO;
-	m_TXColor    = g_MOVBTX_CO;
-	m_ChartType  = HORIZONTAL;
-	m_Step       = 0;
-
-	if 	( m_ChartType == VERTICAL )
-	{
-		m_Mid_Point  = m_X + ( m_Width >> 1 );
-		m_Half_Width = ( m_Width >> 1 ) - 1;
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		m_Mid_Point  = m_Y + ( m_Heigh >> 1 );
-		m_Half_Height = ( m_Heigh >> 1 ) - 1;
-	}
-
-	m_gp = Global::Instance();
-}
-
-Chart::~Chart ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the Chart object on screen 
- * =====================================================================================
- */
-void Chart::Drawme(Graphic &g,bool bufdraw)
-{
-	if 	( bufdraw == true )
-		g.Switch_Screen();
-
-	short co;
-	co = g.Getcolor();
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
-	g.Setcolor(m_FGColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
-	g.Setcolor(co);
-	m_Step = 0;
-	m_AScan_Position    = 1;
-	m_AScan_Speed_Count = 0;
-
-	if 	( bufdraw == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Roll_Bar
- *  Description:  Roll the moving bar 
- * =====================================================================================
- */
-void Chart::Roll_Bar(Graphic& g)
-{
-	g.Setcolor(m_BGColor);
-	if 	( m_ChartType == VERTICAL )
-	{
-		g.Movemem(m_X+1,m_Y+(m_Heigh-3)-m_Step,-1,m_Width-2);
-		if 	( m_Step == m_Heigh-4 ) m_Step = 0;
-		else m_Step ++;
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		g.MovememH(m_X+(m_Width-3)-m_Step,m_Y+1,m_Heigh-2,+1);
-		if ( m_Step == m_Width-4 ) m_Step = 0;
-		else m_Step ++;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Coef
- *  Description:  Set Coef value 
- * =====================================================================================
- */
-void Chart::Set_Coef(int value)
-{
-	if 	( m_ChartType == VERTICAL )
-		m_Rate = static_cast<double>( m_Width>>1 )  / static_cast<double>( ( (value >> 1) - 1 ) ) ;
-	else if ( m_ChartType == HORIZONTAL )
-		m_Rate = static_cast<double>( m_Heigh>>1 )  / static_cast<double>( ( (value >> 1) - 1 ) ) ;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mapping_Value
- *  Description:  Mapping the value to chart 
- * =====================================================================================
- */
-void Chart::Mapping_Value(Graphic &g,int value)
-{
-	int t = static_cast<int>(value * m_Rate);  
-
-	if 	( m_ChartType == VERTICAL )
-	{
-		if 	( t >= m_Half_Width || t <= -m_Half_Width )
-			return;
-		g.Setpixel(m_Mid_Point+t,m_Y+1,m_TXColor);
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		if 	( t >= m_Half_Height || t <= -m_Half_Height )
-			return;
-		g.Setpixel(m_X+1,m_Mid_Point+t,m_TXColor);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_TimeScale
- *  Description:  When 1 second set a time scale  
- * =====================================================================================
- */
-void Chart::Set_TimeScale(Graphic& g)
-{
-	if 	( m_ChartType == VERTICAL )
-	{
-		g.Setpixel(m_X+1,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+2,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+3,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+4,m_Y+1,m_FGColor);
-
-		g.Setpixel(m_X+m_Width-2,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+m_Width-3,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+m_Width-4,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+m_Width-5,m_Y+1,m_FGColor);
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		g.Setpixel(m_X+1,m_Y+1,m_FGColor);
-		g.Setpixel(m_X+1,m_Y+2,m_FGColor);
-		g.Setpixel(m_X+1,m_Y+3,m_FGColor);
-
-		g.Setpixel(m_X+1,m_Y+m_Heigh-2,m_FGColor);
-		g.Setpixel(m_X+1,m_Y+m_Heigh-3,m_FGColor);
-		g.Setpixel(m_X+1,m_Y+m_Heigh-4,m_FGColor);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_AScan_Signal
- *  Description:  Draw the signalgnal as AScanning type
- * =====================================================================================
- */
-void Chart::Draw_AScan_Signal(Graphic &g,int value)
-{
-	int t = static_cast<int>(value * m_Rate);  
-
-	if 	( m_ChartType == VERTICAL )
-	{
-//		if 	( t >= m_Half_Width || t <= -m_Half_Width )
-//			return;
-//		g.Setpixel(m_Mid_Point+t,m_Y+1,m_TXColor);
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		if 	( m_AScan_Speed_Count == m_gp->AScanSpeed )
-		{
-			m_AScan_Speed_Count = 0;
-			m_AScan_Position ++;
-			if 	( m_AScan_Position >=  m_Width - 2 )
-				m_AScan_Position = 1;
-		}
-		else
-			m_AScan_Speed_Count ++;
-
-		if 	( t >= m_Half_Height || t <= -m_Half_Height )
-			return;
-
-		g.CleanArea(m_X+m_AScan_Position,m_Y+1,m_X+m_AScan_Position,m_Y+1+m_Heigh-4);
-		g.Setpixel(m_X+m_AScan_Position,m_Mid_Point+t,m_TXColor);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Chart_Direct
- *  Description:  Set the Chart Direct
- * =====================================================================================
- */
-void Chart::Set_Chart_Direct(CHARTTYPE type)
-{
-	m_ChartType = type;
-
-	if 	( m_ChartType == VERTICAL )
-	{
-		m_Mid_Point  = m_X + ( m_Width >> 1 );
-		m_Half_Width = ( m_Width >> 1 ) - 1;
-	}
-	else if ( m_ChartType == HORIZONTAL )
-	{
-		m_Mid_Point  = m_Y + ( m_Heigh >> 1 );
-		m_Half_Height = ( m_Heigh >> 1 ) - 1;
-	}
-}
diff --git a/src/EVA11/Chart.h b/src/EVA11/Chart.h
deleted file mode 100644
index 5be53e3..0000000
--- a/src/EVA11/Chart.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Chart.h
- *
- *    Description:  manage the chart scan class
- *
- *        Version:  1.0
- *        Created:  2012年11月08日 15时45分47秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _CHART_INC
-#define  _CHART_INC
-
-class Global;
-class Chart : public Object
-{
-	public:
-		enum CHARTTYPE 
-		{
-			VERTICAL   = 0,
-			HORIZONTAL = 1,
-		};
-		typedef enum CHARTTYPE CHARTTYPE;
-
-		Chart (int x,int y,int width,int heigh);                             /* constructor */
-		~Chart ();                            				     /* destructor  */
-
-		void Drawme(Graphic &g,bool bufdraw=false);
-		void Roll_Bar(Graphic &g);
-		void Set_Coef(int value);
-		void Set_TimeScale(Graphic& g);
-		void Mapping_Value(Graphic &g,int value);
-
-		void Draw_AScan_Signal(Graphic &g,int value);
-
-		void Set_Chart_Direct(CHARTTYPE);
-	protected:
-
-	private:
-
-		short			 m_FGColor;
-		short			 m_BGColor;
-		short			 m_TXColor;
-		ColorObj::ColorV*	 m_ColorP;
-
-		int			 m_Mid_Point;
-		int			 m_Step;
-		int			 m_Half_Width;
-		int			 m_Half_Height;
-		double 			 m_Rate;
-
-		int			 m_AScan_Position;
-		int			 m_AScan_Speed_Count;
-
-		CHARTTYPE		 m_ChartType;
-
-		Global*		 	 m_gp;
-};
-
-#endif   /* ----- #ifndef _CHART_INC  ----- */
diff --git a/src/EVA11/Color3DScan.cpp b/src/EVA11/Color3DScan.cpp
deleted file mode 100644
index 269c15c..0000000
--- a/src/EVA11/Color3DScan.cpp
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Color3DScan.cpp
- *
- *    Description:  Implementation of Color3DScan class 
- *
- *        Version:  1.0
- *        Created:  2012年08月16日 10时29分08秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Color3DScan.h"
-#include 	"FreeType.h"
-
-Color3DScan::Color3DScan (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-{
-}
-
-Color3DScan::~Color3DScan ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Color3DScan::Refreshme(Graphic& g)
-{
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
-
-	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
-
-	int x = m_X + m_Width - 65;
-	int y = m_Y + m_Heigh - 48;
-
-	g.Line(x,y,x,y-40,g.RGB24_16(0xffffff));
-	g.Line(x,y,x+50,y,g.RGB24_16(0xffffff));
-	g.Line(x,y,x-26,y+26,g.RGB24_16(0xffffff));
-
-	FreeType* ft = FreeType::Instance();
-	ft->Set_Color(FreeType::FGCOLOR,g.RGB24_16(0xffffff));
-	ft->Set_Color(FreeType::BGCOLOR,m_BGColor);
-	ft->Set_Transparce(true);
-	ft->Set_Font_Size(14);
-	ft->Text(x+40,y-20+12,"x");
-	ft->Text(x+7,y-45+12,"z");
-	ft->Text(x-15,y+20+12,"y");
-
-	g.Setcolor(co);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Color_Scan_Parameters
- *  Description:  Init the Color scan object parameters 
- * =====================================================================================
- */
-void Color3DScan::Init_Color_Scan_Parameters(int scan_chan_count)
-{
-	m_Scan_Chan_Count = scan_chan_count;
-	m_vBorderArray.clear();
-	BORDER border;
-	int step     = ( m_Width - 4 ) >> 1;
-	int substep  = step / m_Scan_Chan_Count;
-	int temp     = step - substep * m_Scan_Chan_Count;
-
-	border.Left  = 0 + ( m_Width >> 1 ) - 10;
-	border.Right = 1 + ( m_Width >> 1 ) - 10;
-
-	for ( int i=0;i<m_Scan_Chan_Count;i++ )
-	{
-		if ( i < temp )
-		{
-			border.Left  = border.Right + 1;
-			border.Right = border.Left + substep;
-		}
-		else
-		{
-			border.Left  = border.Right + 1;
-			border.Right = border.Left + substep - 1;
-		}
-		m_vBorderArray.push_back(border);
-	}
-
-	m_MaxScanPosIndex = ((m_Heigh-3)>>1)+50;
-	for ( int i=0;i<m_MaxScanPosIndex;i++ )
-	{
-		m_vScanPos.push_back(m_Y+i+((m_Heigh)>>2)-15);
-	}
-	m_ScanPosIndex = 0;
-	m_vOffset      = 0;
-
-	m_ZHeigh       = 80;
-
-	m_Fact	       = static_cast<double>(m_ZHeigh) / 512;
-	m_Count        = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Fact_Value
- *  Description:  Set the class attribe 
- * =====================================================================================
- */
-void Color3DScan::Set_Fact_Value(int value)
-{
-	m_Fact	       = static_cast<double>(m_ZHeigh) / value;
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_ScanSpeed
- *  Description:  Set the class attribe 
- * =====================================================================================
- */
-void Color3DScan::Set_ScanSpeed_Value(int value)
-{
-	m_ScanSpeed    = value;
-	m_Count	       = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_ZHeigh_Value
- *  Description:  Set ZHeigh Value 
- * =====================================================================================
- */
-void Color3DScan::Set_ZHeigh_Value(int value)
-{
-	m_ZHeigh = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Data_On_Scan
- *  Description:  Draw Data on screen as 3D mode 
- * =====================================================================================
- */
-void Color3DScan::Draw_Data_On_Scan(Graphic& g,int i,short color,int colorindex)
-{
-	g.HLine_Fast(m_X-m_vOffset+m_vBorderArray[i].Left,
-		     m_X-m_vOffset+m_vBorderArray[i].Right,
-		     m_vScanPos[m_ScanPosIndex]-colorindex*m_Fact,color);
-
-	if	( i == 0 )
-	{
-		m_Count ++;
-
-		if 	( m_Count == m_ScanSpeed )
-		{
-			m_Count = 0;
-
-			m_ScanPosIndex ++;
-			m_vOffset ++;
-
-			if ( m_ScanPosIndex == m_MaxScanPosIndex )
-			{
-				m_ScanPosIndex = 0;
-				m_vOffset = 0;
-				Refreshme(g);
-			}
-		}
-	}
-}
diff --git a/src/EVA11/Color3DScan.h b/src/EVA11/Color3DScan.h
deleted file mode 100644
index 8bd2734..0000000
--- a/src/EVA11/Color3DScan.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Color3DScan.h
- *
- *    Description:  Display Data on screen as 3D mode
- *
- *        Version:  1.0
- *        Created:  2012年08月16日 10时24分18秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _COLOR3DSCAN_INC
-#define  _COLOR3DSCAN_INC
-
-#include 	<vector>
-
-class Basescreen;
-class Color3DScan : public Basescreen
-{
-	public:
-		struct BORDER 
-		{
-			int Left;
-			int Right;
-		};
-		typedef struct BORDER BORDER;
-
-		Color3DScan (int x,int y,int width,int heigh);
-		~Color3DScan ();
-
-		void Init_Color_Scan_Parameters(int scan_chan_count);
-
-		void Draw_Data_On_Scan(Graphic& g,int i,short color,int colorindex);
-		void Set_Fact_Value(int);
-		void Set_ScanSpeed_Value(int);
-
-		void Set_ZHeigh_Value(int);
-	protected:
-		virtual void Refreshme(Graphic& g);
-
-	private:
-		int				m_Scan_Chan_Count;
-		std::vector<BORDER>		m_vBorderArray;
-		std::vector<int>		m_vScanPos;
-		int				m_ScanPosIndex;
-		int				m_MaxScanPosIndex;
-		int				m_vOffset;
-		int				m_Count;
-		int				m_ScanSpeed;
-		int				m_ZHeigh;
-		double				m_Fact;
-}; /* -----  end of class Color3DScan  ----- */
-
-#endif   /* ----- #ifndef _COLOR3DSCAN_INC  ----- */
diff --git a/src/EVA11/ColorObj.cpp b/src/EVA11/ColorObj.cpp
deleted file mode 100644
index 7da4beb..0000000
--- a/src/EVA11/ColorObj.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorObj.cpp
- *
- *    Description:  implementation of ColorObj class 
- *
- *        Version:  1.0
- *        Created:  2013年01月18日 11时44分42秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<SDL.h>
-#include 	"ColorObj.h"
-
-std::auto_ptr<ColorObj> ColorObj::m_Instance;
-
-struct ColorObj::PImpl
-{
-	static const int	MAXPENCOUNT 	= 32;
-	ColorV 			Pen[MAXPENCOUNT];
-};
-
-ColorObj::ColorObj () : m_Imple(new struct PImpl)
-{
-}
-
-ColorObj::~ColorObj ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-ColorObj* ColorObj::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new ColorObj() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Object
- *  Description:  initialization of Color Object
- * =====================================================================================
- */
-bool ColorObj::Init_Object()
-{
-	m_Imple->Pen[0].color32  = 0x000000ff;
-	m_Imple->Pen[1].color32  = 0x45660b9f;
-	m_Imple->Pen[2].color32  = 0x0000ffff;
-	m_Imple->Pen[3].color32  = 0x00ff00ff;
-	m_Imple->Pen[4].color32  = 0xffff00ff;
-	m_Imple->Pen[5].color32  = 0xff7a00ff;
-	m_Imple->Pen[6].color32  = 0xff00ffff;
-	m_Imple->Pen[7].color32  = 0x00ffffff;
-	m_Imple->Pen[8].color32  = 0x7d9953ff;
-	m_Imple->Pen[9].color32  = 0xfffab3ff;
-	m_Imple->Pen[10].color32 = 0x000000ff;
-	m_Imple->Pen[11].color32 = 0xffff00ff;
-	m_Imple->Pen[12].color32 = 0xff0000ff;
-	m_Imple->Pen[13].color32 = 0xffffffff;
-	m_Imple->Pen[14].color32 = 0xffffffff;
-	m_Imple->Pen[15].color32 = 0xffffffff;
-	m_Imple->Pen[16].color32 = 0xf5ffccff;
-	m_Imple->Pen[17].color32 = 0x45660bff;
-	m_Imple->Pen[18].color32 = 0xd7d7d7ff;
-	m_Imple->Pen[19].color32 = 0x000000ff;
-	m_Imple->Pen[20].color32 = 0x000000ff;
-	m_Imple->Pen[21].color32 = 0xffffffff;
-	m_Imple->Pen[22].color32 = 0x000000ff;
-	m_Imple->Pen[23].color32 = 0xfffab3ff;
-	m_Imple->Pen[24].color32 = 0xff0000ff;
-	m_Imple->Pen[25].color32 = 0xf5ffccff;
-	m_Imple->Pen[26].color32 = 0x000000ff;
-	m_Imple->Pen[27].color32 = 0xff0000ff;
-	m_Imple->Pen[28].color32 = 0x000000ff;
-	m_Imple->Pen[29].color32 = 0xefe559ff;
-	m_Imple->Pen[30].color32 = 0x000000ff;
-	m_Imple->Pen[31].color32 = 0xffffffff;
-
-	SDL_Surface* p24ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,24,0xff0000,0x00ff00,0x0000ff,0x0);
-	if 	( p24ColorSurface == NULL )
-	{
-		printf("SDL Create color surface fail: %s\n",SDL_GetError());
-		return false; 
-	}
-	SDL_Surface* p16ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,16,0xf800,0x07e0,0x001f,0);
-	if 	( p16ColorSurface == NULL )
-	{
-		SDL_FreeSurface(p24ColorSurface);
-		printf("SDL Create color surface fail: %s\n",SDL_GetError());
-		return false; 
-	}
-
-	for ( int i=0;i<m_Imple->MAXPENCOUNT;i++ )
-	{
-		m_Imple->Pen[i].index = i;
-		m_Imple->Pen[i].r = (m_Imple->Pen[i].color32>>24)&0xff;
-		m_Imple->Pen[i].g = (m_Imple->Pen[i].color32>>16)&0xff;
-		m_Imple->Pen[i].b = (m_Imple->Pen[i].color32>>8 )&0xff;
-		m_Imple->Pen[i].a = (m_Imple->Pen[i].color32>>0 )&0xff;
-		m_Imple->Pen[i].color24 =  SDL_MapRGB(p24ColorSurface->format,m_Imple->Pen[i].r,m_Imple->Pen[i].g,m_Imple->Pen[i].b);
-		m_Imple->Pen[i].color16 =  SDL_MapRGB(p16ColorSurface->format,m_Imple->Pen[i].r,m_Imple->Pen[i].g,m_Imple->Pen[i].b);
-	}
-
-	SDL_FreeSurface(p16ColorSurface);
-	SDL_FreeSurface(p24ColorSurface);
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_Object
- *  Description:  Destroy the Color Object 
- * =====================================================================================
- */
-void ColorObj::Destroy_Object()
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_ColorVP
- *  Description:  Get the Color Variables Point 
- * =====================================================================================
- */
-ColorObj::ColorV* ColorObj::Get_ColorVP(const int index)
-{
-	return &m_Imple->Pen[index];
-}
diff --git a/src/EVA11/ColorObj.h b/src/EVA11/ColorObj.h
deleted file mode 100644
index 840a661..0000000
--- a/src/EVA11/ColorObj.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorObj.h
- *
- *    Description:  Manage Color 
- *
- *        Version:  1.0
- *        Created:  2013年01月18日 11时41分44秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  COLOROBJ_INC
-#define  COLOROBJ_INC
-
-#include 	<inttypes.h>
-#include 	<memory>
-
-class ColorObj
-{
-	public:
-		struct ColorV 
-		{
-			uint32_t	index;
-			uint32_t	color32;
-			uint32_t	color24;
-			uint16_t	color16;
-			uint8_t		r;
-			uint8_t		g;
-			uint8_t		b;
-			uint8_t		a;
-		};
-		typedef struct ColorV ColorV;
-
-		static ColorObj* Instance();
-
-		bool Init_Object();
-		void Destroy_Object();
-		ColorV* Get_ColorVP(const int);
-	protected:
-
-	private:
-		ColorObj ();
-		ColorObj (const ColorObj&);
-		ColorObj& operator = (const ColorObj&);
-		~ColorObj ();
-
-	private:
-		friend class std::auto_ptr<ColorObj>;
-		static std::auto_ptr<ColorObj>		m_Instance;
-
-		struct PImpl;
-		std::auto_ptr<struct PImpl>		m_Imple;
-
-}; /* -----  end of class ColorObj  ----- */
-#endif   /* ----- #ifndef COLOROBJ_INC  ----- */
diff --git a/src/EVA11/ColorPanel.cpp b/src/EVA11/ColorPanel.cpp
deleted file mode 100644
index 8fd588a..0000000
--- a/src/EVA11/ColorPanel.cpp
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorPanel.cpp
- *
- *    Description:  implementation of ColorPanel class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 15时03分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Device.h"
-#include 	"Global.h"
-#include 	"Algorithm.h"
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Color3DScan.h"
-#include 	"ColorScan.h"
-#include 	"Colorbar.h"
-#include 	"Rule.h"
-
-#include 	"BasePanel.h"
-#include 	"ColorPanel.h"
-
-#include 	"FreeType.h"
-
-ColorPanel::ColorPanel (int x,int y,int width,int heigh)
-	: BasePanel(x,y,width,heigh)
-{
-}
-
-ColorPanel::~ColorPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Create the GUI object in memory 
- * =====================================================================================
- */
-void ColorPanel::Init_GUI(Graphic& g)
-{
-	m_Colorbar = new Colorbar(2,2,530,25);
-	m_Colorbar->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Colorbar->Set_Color(Basescreen::LA_BG_COLOR,g_SCTX_CO);
-	m_Colorbar->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Colorbar->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Colorbar->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
-	m_Colorbar->Calculate_Color_Bar_Value(g);
-
-	m_Colorscan = new ColorScan(2,2+24,530,393);
-	m_Colorscan->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Colorscan->Set_Color(Basescreen::LA_BG_COLOR,g_BUBGNO_CO);
-	m_Colorscan->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Colorscan->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Colorscan->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
-	m_Colorscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
-
-	m_Color3Dscan = new Color3DScan(2,2+24,530,393);
-	m_Color3Dscan->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Color3Dscan->Set_Color(Basescreen::LA_BG_COLOR,g_BUBGNO_CO);
-	m_Color3Dscan->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Color3Dscan->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Color3Dscan->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
-	m_Color3Dscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
-	m_Color3Dscan->Set_Fact_Value(m_Colorbar->Get_IndexCount());
-
-	Global *gp = Global::Instance();
-	m_Color3Dscan->Set_ScanSpeed_Value(gp->ColorSpotScanSpeed);
-
-	m_Rule     = new Rule(2,418,530,25);
-	m_Rule->Init_Rule_Color(g);
-
-	m_DataProcess = new ColorSpotDataProcess;
-	m_DataProcess->Reset_InTimer();
-	m_DataProcess->Reset_OutTimer();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI object 
- * =====================================================================================
- */
-void ColorPanel::Destroy_GUI()
-{
-	if ( m_Colorscan != NULL )
-	{
-		delete m_Colorscan;
-		m_Colorscan = NULL;
-	}
-
-	if ( m_Color3Dscan != NULL )
-	{
-		delete m_Color3Dscan;
-		m_Color3Dscan = NULL;
-	}
-
-	if ( m_Colorbar != NULL )
-	{
-		delete m_Colorbar;
-		m_Colorbar = NULL;
-	}
-
-	if ( m_Rule != NULL )
-	{
-		delete m_Rule;
-		m_Rule = NULL;
-	}
-
-	if ( m_DataProcess != NULL )
-	{
-		delete m_DataProcess;
-		m_DataProcess = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw GUI object on screen 
- * =====================================================================================
- */
-void ColorPanel::Drawme(Graphic& g,bool flag)
-{
-	if 	( m_gp->ColorSpotDispMode == 0 )
-	{
-		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-		m_Colorscan->Drawme(g,flag);
-	}
-	else
-	{
-		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-		m_Color3Dscan->Drawme(g,flag);
-	}
-
-	m_Colorbar->Drawme(g,flag);
-	m_Rule->Drawme(g,flag);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  important function, deal with data
- * =====================================================================================
- */
-int  ColorPanel::Loop_Panel(Graphic& g)
-{
-	m_DataProcess->Data_Process();
-
-	unsigned long long timer = 0;
-	if 	( m_gp->ColorSpotSampleType == 0 )
-	{
-		m_DataProcess->Get_InTimer(timer);
-		if 	( ( timer - m_InsideTimer_Value ) >= m_gp->ColorSpotSampIntervalClock )
-		{
-			m_DataProcess->Get_Data(m_RawBuf);
-			if 	( m_gp->ColorSpotDispMode == 0 )
-			{
-				for ( int i=0;i<Global::CHANCOUNT;i++ )
-				{
-					m_Colorscan->Draw_Data_On_Scan(g,i,m_Colorbar->Mapping_Color(m_RawBuf[i]));
-				}
-			}
-			else
-			{
-				short color;
-				int colorindex;
-				for ( int i=0;i<Global::CHANCOUNT;i++ )
-				{
-					m_Colorbar->Mapping_Color_Value(m_RawBuf[i],color,colorindex);
-					m_Color3Dscan->Draw_Data_On_Scan(g,i,color,colorindex);
-				}
-			}
-		}
-		m_InsideTimer_Value = timer;
-	}
-	else if ( m_gp->ColorSpotSampleType == 1 )
-	{
-		m_DataProcess->Get_OutTimer(timer);
-
-		if 	( ( timer - m_OutsideTimer_Value ) >= m_gp->ColorSPotSampOutPuls )
-		{
-			m_DataProcess->Get_Data(m_RawBuf);
-
-			if 	( m_gp->ColorSpotDispMode == 0 )
-			{
-				for ( int i=0;i<Global::CHANCOUNT;i++ )
-				{
-					m_Colorscan->Draw_Data_On_Scan(g,i,m_Colorbar->Mapping_Color(m_RawBuf[i]));
-				}
-			}
-			else
-			{
-				short color;
-				int colorindex;
-				for ( int i=0;i<Global::CHANCOUNT;i++ )
-				{
-					m_Colorbar->Mapping_Color_Value(m_RawBuf[i],color,colorindex);
-					m_Color3Dscan->Draw_Data_On_Scan(g,i,color,colorindex);
-				}
-			}
-		}
-		m_OutsideTimer_Value = timer;
-	}
-
-	return 0;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void ColorPanel::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-
-	font->Text(x+30,y+90,pl->GetText(HELPB1F1));
-	font->Text(x+30,y+110,pl->GetText(HELPB1F2));
-	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
-
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fx_Fun
- *  Description:  Dealwith Fx function 
- * =====================================================================================
- */
-int ColorPanel::Key_F2_Fun(Graphic& g)
-{
-	if 	( m_gp->ColorSpotDispMode == 0 )
-	{
-		m_Colorscan->Drawme(g);
-		m_Colorscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
-	}
-	else
-	{
-		m_Color3Dscan->Drawme(g);
-		m_Color3Dscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
-	}
-
-	m_DataProcess->Reset_InTimer();
-	m_DataProcess->Reset_OutTimer();
-
-	m_InsideTimer_Value  = 0;
-	m_OutsideTimer_Value = 0;
-	
-	return 0;
-}
-int ColorPanel::Key_F4_Fun(Graphic& g)
-{
-	m_DataProcess->Trigger_Balacne_Process();
-	return 0;
-}
-
-int ColorPanel::Key_NL6_Fun(Graphic& g,int sub)
-{
-	if 	( m_gp->ColorSpotDispMode == 0 )
-	{
-		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-	}
-	else if ( m_gp->ColorSpotDispMode == 1 )
-	{
-		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-	}
-	return 0;
-}
-
-int ColorPanel::Key_NR6_Fun(Graphic& g,int sub)
-{
-	if 	( m_gp->ColorSpotDispMode == 0 )
-	{
-		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-	}
-	else if ( m_gp->ColorSpotDispMode == 1 )
-	{
-		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
-	}
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Panel
- *  Description:  Switch panel call this function 
- * =====================================================================================
- */
-void ColorPanel::Switch_Panel()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-
-	for ( int ch=0;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 1;			// ECT
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	device->Write_Para_Driver(m_gp->Driver);
-	device->Write_Para_Offset(m_gp->Offset);
-	device->Write_Para_SignalWave(0);
-
-	device->Transfer_ECT_Parameters();
-
-	m_DataProcess->Trigger_Balacne_Process();       // very Important
-}
diff --git a/src/EVA11/ColorPanel.h b/src/EVA11/ColorPanel.h
deleted file mode 100644
index ab7707c..0000000
--- a/src/EVA11/ColorPanel.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorPanel.h
- *
- *    Description:  Declear of ColorPanel class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 15时00分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _COLORPANEL_INC
-#define  _COLORPANEL_INC
-
-class BasePanel;
-class Color3DScan;
-class ColorScan;
-class Colorbar;
-class Rule;
-class ColorSpotDataProcess;
-
-class ColorPanel : public BasePanel
-{
-	public:
-		ColorPanel (int x,int y,int width,int heigh);
-		~ColorPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-		virtual void Switch_Panel();
-	protected:
-	private:
-		Color3DScan		*m_Color3Dscan;
-		ColorScan		*m_Colorscan;
-		Colorbar		*m_Colorbar;
-
-		Rule			*m_Rule;
-		ColorSpotDataProcess    *m_DataProcess;
-
-		unsigned long long      m_InsideTimer_Value;
-		unsigned long long      m_OutsideTimer_Value;
-};
-
-#endif
diff --git a/src/EVA11/ColorScan.cpp b/src/EVA11/ColorScan.cpp
deleted file mode 100644
index 6e5eb5e..0000000
--- a/src/EVA11/ColorScan.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorScan.cpp
- *
- *    Description:  Implementaion of ColorScan class
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 15时54分31秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"ColorScan.h"
-#include 	"Graphic.h"
-
-ColorScan::ColorScan (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-{
-}
-
-ColorScan::~ColorScan ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void ColorScan::Refreshme(Graphic& g)
-{
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
-
-	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
-	g.Setcolor(co);
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Color_Scan_Parameters
- *  Description:  Init the Color scan object parameters 
- * =====================================================================================
- */
-void ColorScan::Init_Color_Scan_Parameters(int scan_chan_count)
-{
-	m_Scan_Chan_Count = scan_chan_count;
-	m_vBorderArray.clear();
-	BORDER border;
-	int step     = m_Width - 4;
-	int substep  = step / m_Scan_Chan_Count;
-	int temp     = step - substep * m_Scan_Chan_Count ;
-
-	border.Left  = 0;
-	border.Right = 1;
-
-	for ( int i=0;i<m_Scan_Chan_Count;i++ )
-	{
-		if ( i < temp )
-		{
-			border.Left  = border.Right + 1;
-			border.Right = border.Left + substep;
-		}
-		else	
-		{
-			border.Left  = border.Right + 1;
-			border.Right = border.Left + substep - 1;
-		}
-		m_vBorderArray.push_back(border);
-	}
-
-	for ( int i=0;i<m_Heigh-3;i++ )
-	{
-		m_vScanPos.push_back(m_Y+2+i);
-	}
-	m_ScanPosIndex = 0;
-	m_MaxScanPosIndex = m_Heigh-3;
-
-	m_Count        = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_ScanSpeed
- *  Description:  Set the class attribe 
- * =====================================================================================
- */
-void ColorScan::Set_ScanSpeed_Value(int value)
-{
-	m_ScanSpeed = value;
-	m_Count	    = 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Color_Bar
- *  Description:  Draw Color Bar 
- * =====================================================================================
- */
-void ColorScan::Draw_Data_On_Scan(Graphic& g,int i,short color)
-{
-	g.HLine_Fast(m_X+m_vBorderArray[i].Left,m_X+m_vBorderArray[i].Right,m_vScanPos[m_ScanPosIndex],color);
-
-	if ( i == 0 )
-	{
-		m_Count ++;
-		if 	( m_Count == m_ScanSpeed )
-		{
-			m_Count = 0;
-
-			m_ScanPosIndex ++;
-			if ( m_ScanPosIndex == m_MaxScanPosIndex )
-				m_ScanPosIndex = 0;
-		}
-
-	}
-}
diff --git a/src/EVA11/ColorScan.h b/src/EVA11/ColorScan.h
deleted file mode 100644
index 4c0a7c1..0000000
--- a/src/EVA11/ColorScan.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ColorScan.h
- *
- *    Description:  Declare of color scan bar 
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 15时51分59秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _COLORSCAN_INC
-#define  _COLORSCAN_INC
-
-#include 	<vector>
-class Basescreen;
-class ColorScan : public Basescreen 
-{
-	public:
-		struct BORDER 
-		{
-			int Left;
-			int Right;
-		};
-		typedef struct BORDER BORDER;
-
-		ColorScan (int x,int y,int width,int heigh);
-		~ColorScan ();
-
-		void Init_Color_Scan_Parameters(int scan_chan_count);
-
-		void Draw_Data_On_Scan(Graphic& g,int i,short color);
-		void Set_ScanSpeed_Value(int);
-	protected:
-		virtual void Refreshme(Graphic& g);
-
-	private:
-		int				m_Scan_Chan_Count;
-		std::vector<BORDER>		m_vBorderArray;
-		std::vector<int>		m_vScanPos;
-		int				m_ScanPosIndex;
-		int				m_MaxScanPosIndex;
-		int				m_Count;
-		int				m_ScanSpeed;
-};
-#endif
diff --git a/src/EVA11/Colorbar.cpp b/src/EVA11/Colorbar.cpp
deleted file mode 100644
index 06c16d7..0000000
--- a/src/EVA11/Colorbar.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Colorbar.cpp
- *
- *    Description:  Implemntation of Colorbar
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 16时55分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Colorbar.h"
-#include 	"Graphic.h"
-
-Colorbar::Colorbar (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-{
-	m_IndexCount = m_Width - 2; 
-	m_ColorIndex = new unsigned short[m_IndexCount];
-}
-
-Colorbar::~Colorbar ()
-{
-	if ( m_ColorIndex != NULL )
-	{
-		delete[] m_ColorIndex;
-		m_ColorIndex = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Colorbar::Refreshme(Graphic& g)
-{
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-
-	Draw_Color_Bar(g);
-
-	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
-	g.Setcolor(co);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Color_Bar
- *  Description:  Draw the color bar on screen 
- * =====================================================================================
- */
-void Colorbar::Draw_Color_Bar(Graphic& g)
-{
-	for ( int i=0;i<m_IndexCount;i++ )
-	{
-		g.Line(m_X+1+i,m_Y+1,m_X+1+i,m_Y+m_Heigh-2,m_ColorIndex[i]);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Color_Bar_Value
- *  Description:  Calulate the Color index of color bar 
- * =====================================================================================
- */
-void Colorbar::Calculate_Color_Bar_Value(Graphic& g)
-{
-	unsigned char R = 0,G = 0,B = 0;
-	unsigned int rgb = 0;
-	int temp1 = m_IndexCount - 512;
-	temp1 = temp1 >> 1;
-	int temp2 = m_IndexCount >> 1;
-
-	for ( int i=0;i<temp2-temp1;i++ )
-	{
-		Get_RGB_Value(i*2,R,G,B);
-		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
-		m_ColorIndex[i] = g.RGB24_16(rgb);
-	}
-	for ( int i=temp2-temp1;i<temp2+temp1;i++ )
-	{
-		Get_RGB_Value(temp2-temp1+i,R,G,B);
-		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
-		m_ColorIndex[i] = g.RGB24_16(rgb);
-	}
-	for ( int i=temp2+temp1;i<m_IndexCount;i++ )
-	{
-		Get_RGB_Value(2*(i-temp1),R,G,B);
-		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
-		m_ColorIndex[i] = g.RGB24_16(rgb);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_RGB_Value
- *  Description:  Get the RGB value coording to the index 
- *        index:  0~1023
- * =====================================================================================
- */
-void Colorbar::Get_RGB_Value(int index,unsigned char &R,unsigned char &G,unsigned char &B)
-{
-	if 	( index >= 0 && index < 256 )
-	{
-		B = 255;
-		R = 0;
-		G = index;
-	}
-	else if ( index >= 256 && index < 512 )
-	{
-		B = 255 - ( index - 256 );
-		R = 0;
-		G = 255;
-	}
-	else if ( index >= 512 && index < 768 )
-	{
-		B = 0; 
-		R = index - 512;
-		G = 255;
-	}
-	else if ( index >= 768 && index < 1024 )
-	{
-		B = 0; 
-		R = 255;
-		G = 255 - ( index - 768 );
-	}
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mapping_Color
- *  Description:  Mapping ETDATA value to color index 
- * =====================================================================================
- */
-short Colorbar::Mapping_Color(const ETDATA& value)
-{
-	int tmp = 0;
-	tmp = static_cast<int>( m_IndexCount * ( ( static_cast<double>(value) - m_MINValue ) / ( m_MAXValue - m_MINValue ) ) );
-
-	if ( tmp < 0 ) tmp = 0;
-	if ( tmp >= m_IndexCount ) tmp = m_IndexCount - 1;
-
-	return m_ColorIndex[tmp];
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mapping_Color_Value
- *  Description:  Mapping ETDATA value to color index 
- * =====================================================================================
- */
-void Colorbar::Mapping_Color_Value(const ETDATA& value,short& color,int& colorindex)
-{
-	int tmp = 0;
-	tmp = static_cast<int>( m_IndexCount * ( ( static_cast<double>(value) - m_MINValue ) / ( m_MAXValue - m_MINValue ) ) );
-
-	if ( tmp < 0 ) tmp = 0;
-	if ( tmp >= m_IndexCount ) tmp = m_IndexCount - 1;
-
-	colorindex = tmp - ( m_IndexCount >> 1 );
-	color = m_ColorIndex[tmp];
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_IndexCount
- *  Description:  Get the Index Count Value 
- * =====================================================================================
- */
-int Colorbar::Get_IndexCount()
-{
-	return m_IndexCount;
-}
diff --git a/src/EVA11/Colorbar.h b/src/EVA11/Colorbar.h
deleted file mode 100644
index 5d53fa6..0000000
--- a/src/EVA11/Colorbar.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Colorbar.h
- *
- *    Description:  Display the relationship between color and eddy value
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 16时50分10秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _COLORBAR_INC
-#define  _COLORBAR_INC
-
-#include 	"main.h"
-
-class Basescreen;
-class Colorbar : public Basescreen
-{
-	public:
-		Colorbar (int x,int y,int width,int heigh);
-		~Colorbar ();
-
-		void Calculate_Color_Bar_Value(Graphic& g);
-		short Mapping_Color(const ETDATA& value);
-
-		void Mapping_Color_Value(const ETDATA& value,short& color,int& colorindex);
-		int Get_IndexCount();	
-	protected:
-		virtual void Refreshme(Graphic& g);
-
-	private:
-		void Draw_Color_Bar(Graphic& g);
-		void Get_RGB_Value(int index,unsigned char &R,unsigned char &G,unsigned char &B);	
-
-	private:
-		unsigned short 		*m_ColorIndex;
-		int			m_IndexCount;
-
-		static const int	m_MAXValue = 150;			
-		static const int	m_MINValue = -150;			
-};
-#endif
diff --git a/src/EVA11/ConcreteDataProcess.cpp b/src/EVA11/ConcreteDataProcess.cpp
deleted file mode 100644
index f694f15..0000000
--- a/src/EVA11/ConcreteDataProcess.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ConcreteDataProcess.cpp
- *
- *    Description:  Implemntaion of ZKDataProcess class
- *
- *        Version:  1.0
- *        Created:  2012年07月16日 14时30分59秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cmath>
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-#include 	"Algorithm.h"
-#include 	"DataRepo.h"
-#include 	"MixingManage.h"
-
-ZKDataProcess::ZKDataProcess ()
-{
-}
-
-ZKDataProcess::~ZKDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ZKDataProcess
- *  Description:  ZKDataProcess function sets 
- * =====================================================================================
- */
-void ZKDataProcess::Data_Process()
-{
-	IDataProcess::Data_Process();
-	m_repo->Save_Data_Into_Repo(m_ETData);
-	for ( int index = 0;index < 1;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-		}
-		else
-		{
-			m_Double_X[index] = ( m_ETData[index<<1] )     * m_gp->SoftGain[index];
-			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
-					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-			m_ET_Y[index] = 0 - m_ET_Y[index];
-		}
-		m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  Get Data from device 
- * =====================================================================================
- */
-void ZKDataProcess::Get_Data(ETDATA *rawdata)
-{
-	for ( int i=0;i<1;i++ )
-	{
-		rawdata[i<<1] 	  = m_ET_X[i] ; 
-		rawdata[(i<<1)+1] = m_ET_Y[i] ; 
-	}
-}
-
-/*     ------------------------------------------------------------------------      */
-
-DZKDataProcess::DZKDataProcess ()
-{
-}
-
-DZKDataProcess::~DZKDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ZKDataProcess
- *  Description:  ZKDataProcess function sets 
- * =====================================================================================
- */
-void DZKDataProcess::Data_Process()
-{
-	IDataProcess::Data_Process();
-	m_repo->Save_Data_Into_Repo(m_ETData);
-
-	bool flag = false;
-	for ( int index = 0;index < 2;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-			flag = true;
-		}
-		else
-		{
-			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
-					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-			m_ET_Y[index] = 0 - m_ET_Y[index];
-			m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
-		}
-	}
-
-	m_mixm->Mixing(0,m_ETData[0],m_ETData[1],m_ETData[2],m_ETData[3]);
-
-	m_ETData[4] = m_ETData[2];
-	m_ETData[5] = m_ETData[3];
-	int index = 2;
-	if ( flag == false )
-	{
-		m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftMixGain[index-2];
-		m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftMixGain[index-2];
-		m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-		m_alg->Rotation(m_gp->MixDegree[index-2],m_Double_X[index],
-				m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-		m_ET_Y[index] = 0 - m_ET_Y[index];
-	}
-	else
-	{
-		m_ET_X[index] = 0;
-		m_ET_Y[index] = 0;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  Get Data from device 
- * =====================================================================================
- */
-void DZKDataProcess::Get_Data(ETDATA *rawdata)
-{
-	for ( int i=0;i<3;i++ )
-	{
-		rawdata[i<<1] 	  = m_ET_X[i]; 
-		rawdata[(i<<1)+1] = m_ET_Y[i]; 
-	}
-}
-
-/*     ------------------------------------------------------------------------      */
-
-CZKDataProcess::CZKDataProcess ()
-{
-}
-
-CZKDataProcess::~CZKDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  CZKDataProcess
- *  Description:  CZKDataProcess function sets 
- * =====================================================================================
- */
-void CZKDataProcess::Data_Process()
-{
-	IDataProcess::Data_Process();
-	m_repo->Save_Data_Into_Repo(m_ETData);
-
-	bool flag = false;
-	for ( int index = 0;index < 2;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-			flag = true;
-		}
-		else
-		{
-			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
-					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-			m_ET_Y[index] = 0 - m_ET_Y[index];
-			m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
-		}
-	}
-
-	for ( int index = 2;index < 3;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-			flag = true;
-		}
-		else
-		{
-			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
-
-			m_ET_X[index] = static_cast<ETDATA>(m_Double_X[index]);
-			m_ET_Y[index] = 0;
-		}
-	}
-
-//	m_mixm->Mixing(0,m_ETData[0],m_ETData[1],m_ETData[2],m_ETData[3]);
-//
-//	m_ETData[4] = m_ETData[2];
-//	m_ETData[5] = m_ETData[3];
-//	int index = 2;
-//	if ( flag == false )
-//	{
-//		m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftMixGain[index-2];
-//		m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftMixGain[index-2];
-//		m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-//		m_alg->Rotation(m_gp->MixDegree[index-2],m_Double_X[index],
-//				m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-//		m_ET_Y[index] = 0 - m_ET_Y[index];
-//	}
-//	else
-//	{
-//		m_ET_X[index] = 0;
-//		m_ET_Y[index] = 0;
-//	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  Get Data from device 
- * =====================================================================================
- */
-void CZKDataProcess::Get_Data(ETDATA *rawdata)
-{
-	for ( int i=0;i<4;i++ )
-	{
-		rawdata[i<<1] 	  = m_ET_X[i]; 
-		rawdata[(i<<1)+1] = m_ET_Y[i]; 
-	}
-
-//	printf ( " EMS x = %d\n", m_ET_X[2]);
-}
-
-/*     ------------------------------------------------------------------------      */
-
-ColorSpotDataProcess::ColorSpotDataProcess ()
-{
-}
-
-ColorSpotDataProcess::~ColorSpotDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Data_Process
- *  Description:  Data Process function sets 
- * =====================================================================================
- */
-void ColorSpotDataProcess::Data_Process()
-{
-	IDataProcess::Data_Process();
-	for ( int index = 0;index < Global::CHANCOUNT;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-		}
-		else
-		{
-			m_ET_X[index] = ( m_ETData[index<<1] )     * m_gp->ColorSoftGain;
-			m_ET_Y[index] = ( m_ETData[(index<<1)+1] ) * m_gp->ColorSoftGain;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  After Processing Data, Get Data by this function
- * =====================================================================================
- */
-void ColorSpotDataProcess::Get_Data(ETDATA *rawdata)
-{
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-	{
-		rawdata[i] = m_ET_Y[i]; 
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Timer
- *  Description:  Get the Timer value  
- * =====================================================================================
- */
-void ColorSpotDataProcess::Get_InTimer(unsigned long long &value)
-{
-	value = m_InTimer[0];
-}
-void ColorSpotDataProcess::Get_OutTimer(unsigned long long &value)
-{
-	value = m_OutTimer[0];
-}
-
-/*     ------------------------------------------------------------------------      */
-
-OZKDataProcess::OZKDataProcess ()
-{
-}
-
-OZKDataProcess::~OZKDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ZKDataProcess
- *  Description:  ZKDataProcess function sets 
- * =====================================================================================
- */
-void OZKDataProcess::Data_Process()
-{
-	IDataProcess::Data_Process();
-	m_repo->Save_Data_Into_Repo(m_ETData);
-	for ( int index = 0;index < 16;index ++ )
-	{
-		if ( m_gp->ProbeFun[index] == 0 )
-		{
-			m_ET_X[index] = 0;
-			m_ET_Y[index] = 0;
-		}
-		else
-		{
-			m_Double_X[index] = ( m_ETData[index<<1] )     * m_gp->SoftGain[index];
-			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
-			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
-			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
-					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
-			m_ET_Y[index] = 0 - m_ET_Y[index];
-		}
-		m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  After Processing Data, Get Data by this function
- * =====================================================================================
- */
-void OZKDataProcess::Get_Data(ETDATA *rawdata)
-{
-	uint64_t temp1  = 0;
-	uint64_t temp2  = 0;
-	ETDATA   temp3  = 0;
-	for ( int i=0;i<8;i++ )
-	{
-		temp1 = static_cast<uint64_t>(m_ET_X[i<<1])*static_cast<uint64_t>(m_ET_X[i<<1]) + static_cast<uint64_t>(m_ET_Y[i<<1])*static_cast<uint64_t>(m_ET_Y[i<<1]);
-		temp2 = static_cast<uint64_t>(m_ET_X[(i<<1)+1])*static_cast<uint64_t>(m_ET_X[(i<<1)+1]) + static_cast<uint64_t>(m_ET_Y[(i<<1)+1])*static_cast<uint64_t>(m_ET_Y[(i<<1)+1]);
-		temp3 = static_cast<ETDATA>(sqrt(temp1+temp2)*m_gp->SoftCrossGain[i]);
-
-		m_alg->Rotation(m_gp->CrossDegree[i],0,
-						    temp3,
-						    rawdata[i<<1],
-						    rawdata[(i<<1)+1]);
-	}
-}
diff --git a/src/EVA11/ConcreteDataProcess.h b/src/EVA11/ConcreteDataProcess.h
deleted file mode 100644
index af4088a..0000000
--- a/src/EVA11/ConcreteDataProcess.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ConcreteDataProcess.h
- *
- *    Description:  Manage ZK Data procession
- *
- *        Version:  1.0
- *        Created:  2012年07月16日 14时28分10秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _CONCREATEDATAPROCESS_INC
-#define  _CONCREATEDATAPROCESS_INC
-
-#include 	"main.h"
-class IDataProcess;
-class ZKDataProcess : public IDataProcess
-{
-	public:
-		ZKDataProcess ();
-		virtual ~ZKDataProcess ();
-
-		virtual void Data_Process();
-		void Get_Data(ETDATA *rawdata);
-	protected:
-		ETDATA			m_ET_X[1];
-		ETDATA			m_ET_Y[1];
-
-		double			m_Double_X[1];
-		double			m_Double_Y[1];
-	private:
-};
-
-class DZKDataProcess : public IDataProcess
-{
-	public:
-		DZKDataProcess ();
-		virtual ~DZKDataProcess ();
-		virtual void Data_Process();
-		 
-		void Get_Data(ETDATA *rawdata);
-	protected:
-		ETDATA			m_ET_X[3];
-		ETDATA			m_ET_Y[3];
-
-		double			m_Double_X[3];
-		double			m_Double_Y[3];
-	private:
-};
-
-class CZKDataProcess : public IDataProcess
-{
-	public:
-		CZKDataProcess ();
-		virtual ~CZKDataProcess ();
-		virtual void Data_Process();
-		 
-		void Get_Data(ETDATA *rawdata);
-	protected:
-		ETDATA			m_ET_X[4];
-		ETDATA			m_ET_Y[4];
-
-		double			m_Double_X[4];
-		double			m_Double_Y[4];
-	private:
-};
-
-class ColorSpotDataProcess : public IDataProcess
-{
-	public:
-		ColorSpotDataProcess ();
-		virtual ~ColorSpotDataProcess ();
-		virtual void Data_Process ();
-
-		void Get_Data(ETDATA *rawdata);
-		void Get_InTimer(unsigned long long&);
-		void Get_OutTimer(unsigned long long&);
-	protected:
-		ETDATA			m_ET_X[Global::CHANCOUNT];
-		ETDATA			m_ET_Y[Global::CHANCOUNT];
-
-	private:
-};
-
-class OZKDataProcess : public IDataProcess
-{
-	public:
-		OZKDataProcess ();
-		virtual ~OZKDataProcess ();
-		virtual void Data_Process ();
-
-		void Get_Data(ETDATA *rawdata);
-	protected:
-		ETDATA			m_ET_X[16];
-		ETDATA			m_ET_Y[16];
-
-		double			m_Double_X[16];
-		double			m_Double_Y[16];
-	private:
-
-};
-
-#endif
diff --git a/src/EVA11/ConvertCode.cpp b/src/EVA11/ConvertCode.cpp
deleted file mode 100644
index d7c5344..0000000
--- a/src/EVA11/ConvertCode.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ConvertCode.cpp
- *
- *    Description:  Implementation of ConvertCode class
- *
- *        Version:  1.0
- *        Created:  2012年11月02日 13时52分33秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdio>
-#include 	"ConvertCode.h"
-std::auto_ptr<ConvertCode> ConvertCode::m_Instance;
-
-ConvertCode::ConvertCode ()
-{
-	m_CCode = 0;
-}
-
-ConvertCode::~ConvertCode ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-ConvertCode* ConvertCode::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new ConvertCode() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_CodeConvert
- *  Description:  Init the Code Convert Class 
- *  from and to:  utf-8                  vim code
- *                WCHAR_T                wide text  FreeType used
- *                gb18030>gbk>gb2312     normal program text
- * =====================================================================================
- */
-bool ConvertCode::Init_CodeConvert(const char* from,const char* to)
-{
-	m_CCode = 0;
-	m_CCode = iconv_open(to,from);
-	if ( m_CCode == 0 )
-	{
-		perror("Cant' open iconv");
-		return false;
-	}
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_CodeConvert
- *  Description:  Destroy the Code Convert class 
- * =====================================================================================
- */
-void ConvertCode::Destory_CodeConvert()
-{
-	if ( m_CCode != 0 )
-	{
-		iconv_close(m_CCode);
-		m_CCode = 0;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Code_Convert
- *  Description:  Code Convert Function
- * =====================================================================================
- */
-bool ConvertCode::Code_Convert(char *inbuf,int inlen,char *outbuf,int& outlen)
-{
-	char **pin = &inbuf;
-	char **pout = &outbuf;
-	if ( static_cast<int>((iconv(m_CCode,pin,(size_t *)&inlen,pout,(size_t *)&outlen))) == -1 )
-	{
-		perror("Convert fail");
-		return false;
-	}
-	return true;
-}
diff --git a/src/EVA11/ConvertCode.h b/src/EVA11/ConvertCode.h
deleted file mode 100644
index f929b74..0000000
--- a/src/EVA11/ConvertCode.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ConvertCode.h
- *
- *    Description:  Manage Convert Code to other Code
- *
- *        Version:  1.0
- *        Created:  2012年11月02日 13时47分59秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _CONVERTCODE_INC
-#define  _CONVERTCODE_INC
-
-#include 	<memory>
-#include 	<iconv.h>
-
-class ConvertCode
-{
-	public:
-		static ConvertCode* Instance();
-
-		bool Init_CodeConvert(const char* from,const char* to);
-		void Destory_CodeConvert();
-
-		bool Code_Convert(char *inbuf,int inlen,char *outbuf,int& outlen);
-	protected:
-
-	private:
-		ConvertCode ();                             /* constructor */
-		~ConvertCode ();                            /* destructor  */
-		ConvertCode (const ConvertCode&);           /* constructor */
-		ConvertCode operator = (const ConvertCode&);
-
-	private:
-		friend class std::auto_ptr<ConvertCode>;
-		static std::auto_ptr<ConvertCode>	    m_Instance;
-
-		iconv_t 				    m_CCode;
-};
-
-#endif   /* ----- #ifndef _CONVERTCODE_INC  ----- */
diff --git a/src/EVA11/DEPS/README b/src/EVA11/DEPS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/DFilter.cpp b/src/EVA11/DFilter.cpp
deleted file mode 100644
index e001e25..0000000
--- a/src/EVA11/DFilter.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DFilter.cpp
- *
- *    Description:  Implementation of DFilter class 
- *
- *        Version:  1.0
- *        Created:  2013年06月14日 15时59分17秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include	<cstdio>
-#include 	"main.h"
-#include	"DFilter.h"
-
-struct DFilter::DFP 
-{
-	ETDATA              *bufx;
-	ETDATA              *bufy;
-	int                 capacity;
-	int                 max;
-	unsigned long long  sumx;
-	unsigned long long  sumy;
-	unsigned char       shiftv;
-	int                 index;
-	bool                overf;
-};
-
-struct DFilter::PImpl
-{
-	DFP 		dfp;
-};
-
-DFilter::DFilter() : m_Imple(new struct PImpl)
-{
-	m_Imple->dfp.capacity   = 256;
-	m_Imple->dfp.max        = m_Imple->dfp.capacity;
-	m_Imple->dfp.index      = 0; 
-	m_Imple->dfp.overf      = false;
-	m_Imple->dfp.sumx       = 0;
-	m_Imple->dfp.sumy       = 0;
-	m_Imple->dfp.shiftv     = 8;
-	m_Imple->dfp.bufx       = NULL; 
-	m_Imple->dfp.bufy       = NULL; 
-
-	m_Imple->dfp.bufx        = new ETDATA[m_Imple->dfp.capacity];
-	m_Imple->dfp.bufy        = new ETDATA[m_Imple->dfp.capacity];
-
-	for ( int index=0;index<m_Imple->dfp.max;index++ )
-	{
-		m_Imple->dfp.bufx[index] = 0;
-		m_Imple->dfp.bufy[index] = 0;
-	}
-}
-
-DFilter::~DFilter()
-{
-	if ( m_Imple->dfp.bufx != NULL ) 
-	{
-		delete[] m_Imple->dfp.bufx;
-		m_Imple->dfp.bufx = NULL;
-	}
-	if ( m_Imple->dfp.bufy != NULL ) 
-	{
-		delete[] m_Imple->dfp.bufy;
-		m_Imple->dfp.bufy = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_MAX_Value
- *  Description:  When chang the signal channel call this function init the parameters 
- *  Note:
- *                value:   from 0 to 7 
- * =====================================================================================
- */
-void DFilter::Reset_MAX_Value(int value)
-{
-	if 	( value == 0 )
-	{
-		m_Imple->dfp.max = 0;
-		return;
-	}
-
-	m_Imple->dfp.max    = (1<<value);
-	m_Imple->dfp.index  = 0; 
-	m_Imple->dfp.overf  = false;
-	m_Imple->dfp.shiftv = value;
-	m_Imple->dfp.sumx   = 0;
-	m_Imple->dfp.sumy   = 0;
-
-	for ( int index=0;index<m_Imple->dfp.max;index++ )
-	{
-		m_Imple->dfp.bufx[index] = 0;
-		m_Imple->dfp.bufy[index] = 0;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Digital_Filter_Value
- *  Description:  Calculate the Digital Filter Value of device
- * =====================================================================================
- */
-void DFilter::Calculate_Digital_Filter_Value(ETDATA& x,ETDATA& y)
-{
-	if 	( m_Imple->dfp.max == 0 ) return;
-
-	if 	( m_Imple->dfp.overf == false ) 
-	{
-		m_Imple->dfp.bufx[m_Imple->dfp.index] = x;
-		m_Imple->dfp.bufy[m_Imple->dfp.index] = y;
-
-		m_Imple->dfp.sumx += x;
-		m_Imple->dfp.sumy += y;
-		m_Imple->dfp.index ++;
-
-		if 	( m_Imple->dfp.index == m_Imple->dfp.max )
-		{
-			m_Imple->dfp.overf = true;
-			m_Imple->dfp.index = 0;
-		}
-	}
-	else
-	{
-		m_Imple->dfp.sumx = m_Imple->dfp.sumx + x - m_Imple->dfp.bufx[m_Imple->dfp.index];
-		m_Imple->dfp.sumy = m_Imple->dfp.sumy + y - m_Imple->dfp.bufy[m_Imple->dfp.index];
-
-		m_Imple->dfp.bufx[m_Imple->dfp.index] = x;
-		m_Imple->dfp.bufy[m_Imple->dfp.index] = y;
-
-		m_Imple->dfp.index ++;
-
-		if ( m_Imple->dfp.index == m_Imple->dfp.max )
-		{
-			m_Imple->dfp.index = 0;
-		}
-		x = ( m_Imple->dfp.sumx >> m_Imple->dfp.shiftv ); 
-		y = ( m_Imple->dfp.sumy >> m_Imple->dfp.shiftv ); 
-	}
-}
diff --git a/src/EVA11/DFilter.h b/src/EVA11/DFilter.h
deleted file mode 100644
index dccb8e9..0000000
--- a/src/EVA11/DFilter.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DFilter.h
- *
- *    Description:  For the Digital Filter Algorithm
- *
- *        Version:  1.0
- *        Created:  2010年03月26日 19时07分26秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  DFilter_INC
-#define  DFilter_INC
-
-#include 	<memory>	
-#include 	"main.h"
-
-class DFilter
-{
-	public:
-		DFilter ();                             /* constructor */
-		~DFilter ();                            /* destructor  */
-
-		void Reset_MAX_Value(int value);
-		void Calculate_Digital_Filter_Value(ETDATA& x,ETDATA& y);
-	protected:
-
-	private:
-		struct DFP;
-		struct PImpl;
-		std::auto_ptr<struct PImpl>		m_Imple;
-
-}; /* -----  end of class DFilter  ----- */
-
-#endif   /* ----- #ifndef DFilter_INC  ----- */
diff --git a/src/EVA11/DZKPanel.cpp b/src/EVA11/DZKPanel.cpp
deleted file mode 100644
index 9119f52..0000000
--- a/src/EVA11/DZKPanel.cpp
+++ /dev/null
@@ -1,1155 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DZKPanel.cpp
- *
- *    Description:  Manage of DZKPanel class 
- *
- *        Version:  1.0
- *        Created:  2012年08月08日 09时33分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<new>
-#include 	<sstream>
-#include 	<string>	
-
-#include 	"Object.h"
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Global.h"
-#include 	"Bufferbar.h"
-#include 	"Device.h"
-#include 	"DataRepo.h"
-#include 	"Label.h"
-#include 	"FreeType.h"
-
-#include 	"Msgbox.h"
-
-#include 	"AlarmManage.h"
-#include	"MixingManage.h"
-#include 	"Basescreen.h"
-#include 	"ZScreen.h"
-#include 	"Language.h"
-#include 	"Algorithm.h"
-
-#include 	"BasePanel.h"
-#include 	"DZKPanel.h"
-
-#include 	"Logic.h"
-
-#include 	"Resource.h"
-
-const static  std::string AlarmText[8] = {CSTRING_A,CSTRING_B,CSTRING_C,CSTRING_D,CSTRING_E,CSTRING_F,CSTRING_G,CSTRING_H};
-
-DZKPanel::DZKPanel (int x,int y,int width,int heigh)
-	: BasePanel(x,y,width,heigh)
-{
-}
-
-DZKPanel::~DZKPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void DZKPanel::Init_GUI(Graphic& g)
-{
-	Global *gp = Global::Instance();
-
-	Init_ZScreen_Object(g);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		if 	( gp->DrawMode2[i] == 0 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
-		else if ( gp->DrawMode2[i] == 1 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
-		else if ( gp->DrawMode2[i] == 2 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::AUTO);
-	}
-
-	m_Bufbar = new Bufferbar(2,2,532,6);
-	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
-	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
-	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
-
-	m_LabAlarmSt[0] = new Label(3,9,30,32);
-	m_LabAlarmSt[1] = new Label(235+265+2,9,30,32);
-
-	m_LabFreMsg[1] = new Label(131+1*265+1,8,104,18);
-	m_LabAMPMsg[1] = new Label(131+1*265+1,25,104,18);
-	m_LabPHAMsg[1] = new Label(42+1*265+1,25,90,18);
-	m_LabCHAMsg[1] = new Label(42+1*265+1,8,90,18);
-
-	m_LabFreMsg[0] = new Label(131+0*265-8,8,104,18);
-	m_LabAMPMsg[0] = new Label(131+0*265-8,25,104,18);
-	m_LabPHAMsg[0] = new Label(42+0*265-8,25,90,18);
-	m_LabCHAMsg[0] = new Label(42+0*265-8,8,90,18);
-
-	for ( int i=0;i<2;i++ )
-	{
-		m_LabFreMsg[i]->Set_Label_Type(Label::LA_THIN);
-		m_LabFreMsg[i]->Set_Font_Size(16);
-		m_LabFreMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_LabFreMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-		m_LabFreMsg[i]->Set_Text(" ");
-
-		m_LabAMPMsg[i]->Set_Label_Type(Label::LA_THIN);
-		m_LabAMPMsg[i]->Set_Font_Size(16);
-		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_LabAMPMsg[i]->Set_Focus(true);
-		m_LabAMPMsg[i]->Set_Text(" ");
-
-		m_LabPHAMsg[i]->Set_Label_Type(Label::LA_THIN);
-		m_LabPHAMsg[i]->Set_Font_Size(16);
-		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_LabPHAMsg[i]->Set_Focus(true);
-		m_LabPHAMsg[i]->Set_Text(" ");
-
-		m_LabCHAMsg[i]->Set_Label_Type(Label::LA_THIN);
-		m_LabCHAMsg[i]->Set_Font_Size(16);
-		m_LabCHAMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_LabCHAMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-		m_LabCHAMsg[i]->Set_Display_Type(Label::LA_DT_LEFT);
-		m_LabCHAMsg[i]->Set_Text(" ");
-
-		m_LastStatus[i] = 0xff;
-
-		m_LabAlarmSt[i]->Set_Label_Type(Label::LA_THIN);
-		m_LabAlarmSt[i]->Set_Font_Size(24);
-		m_LabAlarmSt[i]->Set_Text(" ");
-		m_LabAlarmSt[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_LabAlarmSt[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	}
-
-	m_gp->bDoubleSrcPause = false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm Parameters from Global 
- *                When Load Para from device call this function
- * =====================================================================================
- */
-void DZKPanel::Load_Alarm_Para()
-{
-	Global* gp = Global::Instance();
-	if ( gp->bDNeedResetAlarmArea == true )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_AlarmManage[i]->Set_Alarm_Type(gp->DAlarmType[i]);
-			for ( int j=0;j<3;j++ )
-			{
-				m_AlarmManage[i]->Set_Alarm_Count(j,gp->DAlarmCount[i][j]);
-				m_AlarmManage[i]->Set_Alarm_Index(j,gp->DAlarmIndex[i][j]);
-			}
-			m_AlarmManage[i]->Load_Alarm_Para(gp->DAlarmPara[i]);
-		}
-
-		m_AlarmManage[0]->Create_Alarm_Area_Mask();
-		m_AlarmManage[1]->Create_Alarm_Area_Mask();
-		gp->bDNeedResetAlarmArea = false;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void DZKPanel::Destroy_GUI()
-{
-	for ( int i=0;i<2;i++ )
-	{
-		if ( m_LabFreMsg[i] != NULL )
-		{
-			delete m_LabFreMsg[i];
-			m_LabFreMsg[i] = NULL;
-		}
-
-		if ( m_LabAMPMsg[i] != NULL )
-		{
-			delete m_LabAMPMsg[i];
-			m_LabAMPMsg[i] = NULL;
-		}
-
-		if ( m_LabPHAMsg[i] != NULL )
-		{
-			delete m_LabPHAMsg[i];
-			m_LabPHAMsg[i] = NULL;
-		}
-
-		if ( m_LabCHAMsg[i] != NULL )
-		{
-			delete m_LabCHAMsg[i];
-			m_LabCHAMsg[i] = NULL;
-		}
-
-		if ( m_LabAlarmSt[i] != NULL )
-		{
-			delete m_LabAlarmSt[i];
-			m_LabAlarmSt[i] = NULL;
-		}
-	}
-
-	if ( m_Bufbar != NULL )
-	{
-		delete m_Bufbar;
-		m_Bufbar = NULL;
-	}
-
-	Destroy_ZScreen_Object();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_ZScreen_Object
- *  Description:  Init the ZScreen GUI Object 
- * =====================================================================================
- */
-void DZKPanel::Init_ZScreen_Object(Graphic& g)
-{
-	Global *gp = Global::Instance();
-
-	m_DataProcess = new DZKDataProcess;
-
-	m_Zscreen[0] = new Zscreen(2,13+31,265,399);
-	m_Zscreen[1] = new Zscreen(2+265,13+31,265,399);
-
-	m_Zscreen[0]->Set_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
-	m_Zscreen[1]->Set_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_ID(i+1);
-
-		Refresh_ZKScreen_Focus(g,false);
-	}
-
-	m_AlarmManage[0] = new(std::nothrow) AlarmManage(2,13+31,265,430-31);
-	m_AlarmManage[1] = new(std::nothrow) AlarmManage(2+265,13+31,265,430-31);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_AlarmManage[i]->Init_Alarm_Sets(g);
-
-	gp->bDNeedResetAlarmArea = true;                    // Notice when init we need let OZK to load alarm para
-	Load_Alarm_Para();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_ZScreen_Object
- *  Description:  Destroy the ZScreen GUI Object
- * =====================================================================================
- */
-void DZKPanel::Destroy_ZScreen_Object()
-{
-	if 	( m_DataProcess != NULL )
-	{
-		delete m_DataProcess;
-		m_DataProcess = NULL;
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		if ( m_Zscreen[i] != NULL )
-		{
-			delete m_Zscreen[i];
-			m_Zscreen[i] = NULL;
-		}
-
-		m_AlarmManage[i]->Destroy_Alarm_Sets();
-		if ( m_AlarmManage[i] != NULL )
-		{
-			delete m_AlarmManage[i];
-			m_AlarmManage[i] = NULL;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void DZKPanel::Drawme(Graphic& g,bool flag)
-{
-	DataRepo *datarepo = DataRepo::Instance();
-	if ( flag == true )
-		g.Switch_Screen();
-
-	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
-
-	Refresh_FREQ(g);
-	Refresh_Signal(g);
-	Swtich_Status(g);
-
-	for ( int i=0;i<2;i++ )
-	{
-		m_LabFreMsg[i]->Drawme(g,false);
-		m_LabAMPMsg[i]->Drawme(g,false);
-		m_LabPHAMsg[i]->Drawme(g,false);
-		m_LabCHAMsg[i]->Drawme(g,false);
-		m_LabAlarmSt[i]->Drawme(g,false);
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Drawme(g,false);
-		m_AlarmManage[i]->Draw_Alarm_Sets(g,false);
-	}
-
-//	m_Chart->Drawme(g,false);
-
-	if ( flag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_ZKScreen
- *  Description:  Clean the ZKScreen 
- * =====================================================================================
- */
-void DZKPanel::Clean_ZKScreen(Graphic&g)
-{
-	m_LabFreMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-	m_LabCHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-	m_LabAlarmSt[m_gp->ScrSigFocus]->Drawme(g,true);
-
-	m_LabAMPMsg[m_gp->ScrSigFocus]->Set_Text(" ");
-	m_LabPHAMsg[m_gp->ScrSigFocus]->Set_Text(" ");
-	m_LabAMPMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-	m_LabPHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-
-	m_Zscreen[m_gp->ScrSigFocus]->Drawme(g,true);
-	m_AlarmManage[m_gp->ScrSigFocus]->Draw_Alarm_Sets(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  important function, deal with data
- * =====================================================================================
- */
-int DZKPanel::Loop_Panel(Graphic& g)
-{
-	if 	( m_gp->bDoubleSrcPause == true )
-		return 0;
-	m_DataProcess->Data_Process();
-	m_DataProcess->Get_Data(m_RawBuf);
-	int x,y;
-	int result;
-	for ( int i=0;i<2;i++ )
-	{
-		m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[(m_gp->ScrSigM[i]<<1)],m_RawBuf[(m_gp->ScrSigM[i]<<1)+1]);
-		m_Zscreen[i]->Get_SX_SY(x,y);
-		result = m_AlarmManage[i]->Is_In_Alarm(x,y);
-		if 	(  result != 0xff )
-		{
-			if 	( result != m_LastStatus[i] )
-			{
-				m_LabAlarmSt[i]->Set_Text(AlarmText[result].c_str());
-				m_LabAlarmSt[i]->Drawme(g);
-				m_LastStatus[i] = result;
-			}
-		}
-		else
-		{
-			if 	( result != m_LastStatus[i] )
-			{
-				m_LabAlarmSt[i]->Set_Text(" ");
-				m_LabAlarmSt[i]->Drawme(g);
-				m_LastStatus[i] = result;
-			}
-		}
-	}
-	m_Bufbar->Save_Bytes_Number(g,2<<2);
-
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void DZKPanel::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor  = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-	font->Text(x+30,y+90,pl->GetText(HELPB1F2));
-	font->Text(x+30,y+110,pl->GetText(HELPB1F3));
-	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
-	font->Text(x+30,y+150,pl->GetText(HELPB1F5));
-	font->Text(x+30,y+170,pl->GetText(HELPB1F6));
-	font->Text(x+30,y+190,pl->GetText(HELPB1F7));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Panel
- *  Description:  Switch panel call this function 
- * =====================================================================================
- */
-void DZKPanel::Switch_Panel()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-
-	for ( int ch=0;ch<2;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 1;			// ECT
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int ch=2;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 0;		       // CLOSE
-		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	device->Write_Para_Driver(m_gp->Driver);
-	device->Write_Para_Offset(m_gp->Offset);
-	device->Write_Para_SignalWave(0);
-
-	device->Transfer_ECT_Parameters();
-
-	Load_Alarm_Para();
-
-	m_DataProcess->Trigger_Balacne_Process();       // very Important
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_AMP_PHA
- *  Description:  Display the AMP and PHA value 
- * =====================================================================================
- */
-void DZKPanel::Refresh_AMP_PHA(Graphic& g)
-{
-	std::stringstream strtmp;
-	strtmp<<"A:"<<m_Zscreen[m_gp->ScrSigFocus]->Get_AMP();
-	std::string str(strtmp.str());
-	m_LabAMPMsg[m_gp->ScrSigFocus]->Set_Text(str.c_str());
-	m_LabAMPMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-
-	strtmp.clear();
-	strtmp.str("");
-	str.clear();
-
-	strtmp<<"P:"<<m_Zscreen[m_gp->ScrSigFocus]->Get_PHA();
-	str = strtmp.str();
-	m_LabPHAMsg[m_gp->ScrSigFocus]->Set_Text(str.c_str());
-	m_LabPHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_FREQ
- *  Description:  Display Frequence value 
- * =====================================================================================
- */
-void DZKPanel::Refresh_FREQ(Graphic& g)
-{
-	char *msg = new char[100];
-
-	Logic *m_lo = Logic::Instance();
-	if ( m_gp->ScrSigM[0] < 2 )
-		m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[0]]],msg);
-	else
-		sprintf(msg,"%s"," ");
-	m_LabFreMsg[0]->Set_Text(msg);
-
-	if ( m_gp->ScrSigM[1] < 2 )
-		m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[1]]],msg);
-	else 
-		sprintf(msg,"%s"," ");
-	m_LabFreMsg[1]->Set_Text(msg);
-
-	delete[] msg;
-	msg = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Signal
- *  Description:  
- * =====================================================================================
- */
-void DZKPanel::Refresh_Signal(Graphic& g)
-{
-	char *msg = new char[100];
-
-	if 	( m_gp->ScrSigM[0] < 2 )
-	{
-		if 	( m_gp->ProbeFun[m_gp->ScrSigM[0]] == 0 )
-			sprintf(msg," S%d OFF",m_gp->ScrSigM[0]+1);
-		else
-		{
-			Logic *m_lo = Logic::Instance();
-			m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[0]+1,m_gp->ProbeFun[m_gp->ScrSigM[0]],m_gp->FreqIndex[m_gp->ScrSigM[0]]+1,msg);
-		}
-	}
-	else
-	{
-		if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[0]-2]] == 0 ||  
-			  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[0]-2]] == 0 )
-		{
-			sprintf(msg,"%s"," M%d:SX OFF");
-		}
-		else
-			sprintf(msg," M%d:S%d-S%d",m_gp->ScrSigM[0]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[0]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[0]-2]+1);
-	}
-	m_LabCHAMsg[0]->Set_Text(msg);
-
-	if 	( m_gp->ScrSigM[1] < 2 )
-	{
-		if 	( m_gp->ProbeFun[m_gp->ScrSigM[1]] == 0 )
-			sprintf(msg," S%d OFF",m_gp->ScrSigM[1]+1);
-		else
-		{
-			Logic *m_lo = Logic::Instance();
-			m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[1]+1,m_gp->ProbeFun[m_gp->ScrSigM[1]],m_gp->FreqIndex[m_gp->ScrSigM[1]]+1,msg);
-		}
-	}
-	else
-	{
-		if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[1]-2]] == 0 ||  
-			  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[1]-2]] == 0 )
-		{
-			sprintf(msg,"%s"," M%d:SX OFF");
-		}
-		else
-			sprintf(msg," M%d:S%d-S%d",m_gp->ScrSigM[1]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[1]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[1]-2]+1);
-	}
-	m_LabCHAMsg[1]->Set_Text(msg);
-
-	delete[] msg;
-	msg = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Status
- *  Description:  When stop the signal switch the system status 
- * =====================================================================================
- */
-void DZKPanel::Swtich_Status(Graphic& g)
-{
-	if 	( m_gp->bDoubleSrcPause == true )
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,8,253,15);
-	}
-	else
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,9,253,15);
-	}
-}
-
-int DZKPanel::Key_NL2_Fun(Graphic& g,int sub)
-{
-	Refresh_Signal(g);
-	Refresh_FREQ(g);
-	m_LabCHAMsg[0]->Drawme(g,true);
-	m_LabCHAMsg[1]->Drawme(g,true);
-	m_LabFreMsg[0]->Drawme(g,true);
-	m_LabFreMsg[1]->Drawme(g,true);
-	return 0;
-}
-int DZKPanel::Key_NR2_Fun(Graphic& g,int sub)
-{
-	Refresh_Signal(g);
-	Refresh_FREQ(g);
-	m_LabCHAMsg[0]->Drawme(g,true);
-	m_LabCHAMsg[1]->Drawme(g,true);
-	m_LabFreMsg[0]->Drawme(g,true);
-	m_LabFreMsg[1]->Drawme(g,true);
-	return 0;
-}
-int DZKPanel::Key_NL4_Fun(Graphic& g,int sub)         // gain
-{
-	m_gp->bDoubleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int DZKPanel::Key_NR4_Fun(Graphic& g,int sub)         // gain
-{
-	m_gp->bDoubleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int DZKPanel::Key_NL5_Fun(Graphic& g,int sub)
-{
-	Refresh_FREQ(g);
-	m_LabFreMsg[0]->Drawme(g,true);
-	m_LabFreMsg[1]->Drawme(g,true);
-	return 0;
-}
-int DZKPanel::Key_NR5_Fun(Graphic& g,int sub)
-{
-	Refresh_FREQ(g);
-	m_LabFreMsg[0]->Drawme(g,true);
-	m_LabFreMsg[1]->Drawme(g,true);
-	return 0;
-}
-int DZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bDoubleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int DZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bDoubleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
-	Refresh_AMP_PHA(g);
-	return 0;
-}
-int DZKPanel::Key_Enter_Fun(Graphic& g)
-{
-	m_gp->bDoubleSrcPause = false;
-	Do_Enter_Fun(g);
-	return 0;
-}
-		
-void DZKPanel::Do_Enter_Fun(Graphic& g)
-{
-	Swtich_Status(g);
-
-	m_LabFreMsg[0]->Drawme(g,true);
-	m_LabCHAMsg[0]->Drawme(g,true);
-	m_LabAlarmSt[0]->Drawme(g,true);
-
-	m_LabFreMsg[1]->Drawme(g,true);
-	m_LabCHAMsg[1]->Drawme(g,true);
-	m_LabAlarmSt[1]->Drawme(g,true);
-
-	m_LabAMPMsg[0]->Set_Text(" ");
-	m_LabPHAMsg[0]->Set_Text(" ");
-	m_LabAMPMsg[0]->Drawme(g,true);
-	m_LabPHAMsg[0]->Drawme(g,true);
-
-	m_LabAMPMsg[1]->Set_Text(" ");
-	m_LabPHAMsg[1]->Set_Text(" ");
-	m_LabAMPMsg[1]->Drawme(g,true);
-	m_LabPHAMsg[1]->Drawme(g,true);
-
-	m_Zscreen[0]->Drawme(g,true);
-	m_Zscreen[1]->Drawme(g,true);
-	m_AlarmManage[0]->Draw_Alarm_Sets(g,true);
-	m_AlarmManage[1]->Draw_Alarm_Sets(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_FX_Fun
- *  Description:  Shot Functions 
- * =====================================================================================
- */
-int DZKPanel::Key_F2_Fun(Graphic& g)
-{
-	if 	( m_gp->bDoubleSrcPause == false )
-		Clean_ZKScreen(g);
-	else
-	{
-		Language *m_pl = Language::Instance();
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		if 	( ms->Showme(g) == true )
-		{
-			delete ms;
-			ms = NULL;
-			m_Zscreen[m_gp->ScrSigFocus]->Clean_Photo();
-			m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
-			return 0; 
-		}
-		delete ms;
-		ms = NULL;
-	}
-	return 0;
-}
-int DZKPanel::Key_F3_Fun(Graphic& g)
-{
-	if 	( m_gp->DrawMode2[m_gp->ScrSigFocus] == 0 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 1;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::LINE);
-	}
-	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus] == 1 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 2;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::AUTO);
-	}
-	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus]== 2 )
-	{
-		m_gp->DrawMode2[m_gp->ScrSigFocus] = 0;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::POINT);
-	}
-	m_Zscreen[m_gp->ScrSigFocus]->Reset_Trace();
-	return 0;
-}
-int DZKPanel::Key_F4_Fun(Graphic& g)
-{
-	if 	( m_gp->bDoubleSrcPause == false )
-		m_DataProcess->Trigger_Balacne_Process();
-	else
-	{
-		m_Zscreen[m_gp->ScrSigFocus]->Save_Photo(g);
-		m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
-	}
-	return 0;
-}
-int DZKPanel::Key_F6_Fun(Graphic& g)
-{
-	Language* m_pl = Language::Instance();
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == false )
-	{
-		delete ms;
-		ms = NULL;
-		return 0;
-	}
-	delete ms;
-	ms = NULL;
-	m_Bufbar->Clean_Buffer_Bar(g);
-	return 0;
-}
-
-int DZKPanel::Key_F7_Fun(Graphic& g)
-{
-	int callen = 10000;
-	if 	( m_gp->bDoubleSrcPause == false )
-	{
-		m_gp->bDoubleSrcPause = true;
-		Swtich_Status(g);
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-		return 0;
-	}
-
-	m_Zscreen[m_gp->ScrSigFocus]->Mixing_Parameters_Calculate(g,callen,100);
-	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-
-	Language* m_pl = Language::Instance();
-	MixingManage *algm = MixingManage::Instance();
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(SAVEMIXCOMFIRM),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	ms->Set_Transparce(120);
-	if ( ms->Showme(g) == true )
-	{
-		algm->Sync_Mixing_Para(true);
-		delete ms;
-		ms = NULL;
-	}
-	else
-	{
-		algm->Sync_Mixing_Para(false);
-		delete ms;
-		ms = NULL;
-		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
-	}
-	return 0;
-}
-
-/* --------------------------------------------------------------------- */
-/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
-/* --------------------------------------------------------------------- */
-int DZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->ScrSigFocus == 0 ) gp->ScrSigFocus = 1;
-		else gp->ScrSigFocus --;
-		Refresh_ZKScreen_Focus(g,true);
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 0 )
-				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]];
-			else
-				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] -= 1; 
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
-		}
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->ScrSigFocus == 1 ) gp->ScrSigFocus = 0;
-		else gp->ScrSigFocus ++;
-		Refresh_ZKScreen_Focus(g,true);
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 7 || 
-					gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] >= gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]])
-			{
-				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 0;
-			}
-			else
-				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] += 1;
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
-		}
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 0  ) gp->DAlarmType[gp->ScrSigFocus] = 3;
-		else gp->DAlarmType[gp->ScrSigFocus] --;
-		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->DAlarmType[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 3  ) gp->DAlarmType[gp->ScrSigFocus] = 0;
-		else gp->DAlarmType[gp->ScrSigFocus] ++;
-		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->DAlarmType[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P1((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 0 )
-				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 7;
-			else
-			{
-				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] --;
-				if ( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] < gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] )
-				{
-					gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]];
-				}
-			}
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
-		}
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 7 )
-				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 0;
-			else
-				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] ++;
-			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
-		}
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P2((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P3((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage[gp->ScrSigFocus]->Adj_P4((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
-		Drawme(g,true);
-		gp->bDNeedResetAlarmArea = true;
-	}
-	return 0;
-}
-int DZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-//	else if ( sub == 2 )
-//	{
-//		m_AlarmManage[0]->Test(g);
-//		m_AlarmManage[1]->Test(g);
-//	}
-	return 0;
-}
-int DZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-//	else if ( sub == 2 )
-//	{
-//		m_AlarmManage[0]->Test(g);
-//		m_AlarmManage[1]->Test(g);
-//	}
-	return 0;
-}
-
-int DZKPanel::Para_NL1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::LEFT,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
-	}
-	return 0;
-}
-int DZKPanel::Para_NR1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
-	}
-	return 0;
-}
-int DZKPanel::Para_NL2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::UP,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
-	}
-	return 0;
-}
-int DZKPanel::Para_NR2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::DOWN,3);
-		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
-	}
-	return 0;
-}
-int DZKPanel::Para_NL3_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::LEFT,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
-	}
-	return 0;
-}
-int DZKPanel::Para_NR3_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
-	}
-	return 0;
-}
-int DZKPanel::Para_NL4_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::UP,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
-	}
-	return 0;
-}
-int DZKPanel::Para_NR4_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::DOWN,3);
-		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
-	}
-	return 0;
-}
-
-int DZKPanel::Key_NL1_Fun(Graphic& g,int sub)
-{
-	Refresh_ZKScreen_Focus(g,true);
-	return 0;
-}
-int DZKPanel::Key_NR1_Fun(Graphic& g,int sub)
-{
-	Refresh_ZKScreen_Focus(g,true);
-	return 0;
-}
-void DZKPanel::Refresh_ZKScreen_Focus(Graphic&g,bool flag)
-{
-	for ( int i=0;i<2;i++ )
-	{
-		if ( i == m_gp->ScrSigFocus )
-			m_Zscreen[i]->Set_Focus(g,true,flag);
-		else
-			m_Zscreen[i]->Set_Focus(g,false,flag);
-	}
-}
diff --git a/src/EVA11/DZKPanel.h b/src/EVA11/DZKPanel.h
deleted file mode 100644
index 39bdffb..0000000
--- a/src/EVA11/DZKPanel.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DZKPanel.h
- *
- *    Description:  Double ZK Panel manage class 
- *
- *        Version:  1.0
- *        Created:  2012年08月08日 09时30分46秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _DZKPANEL_INC
-#define  _DZKPANEL_INC
-
-class BasePanel;
-class Zscreen;
-class Bufferbar;
-class DZKDataProcess;
-class AlarmManage;
-class Label;
-class Chart;
-class DZKPanel : public BasePanel
-{
-	public:
-		DZKPanel (int x,int y,int width,int heigh);
-		~DZKPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-		virtual int Key_F7_Fun(Graphic& g);
-
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
-
-		virtual void Switch_Panel();
-		virtual void Swtich_Status(Graphic& g);
-	protected:
-		virtual void Init_ZScreen_Object(Graphic& g);
-		virtual void Destroy_ZScreen_Object();
-		virtual void Load_Alarm_Para();
-
-		void Refresh_ZKScreen_Focus(Graphic&g,bool flag);
-		void Clean_ZKScreen(Graphic&g);
-		void Refresh_AMP_PHA(Graphic& g);
-		void Refresh_FREQ(Graphic& g);
-		void Refresh_Signal(Graphic& g);
-
-		void Do_Enter_Fun(Graphic& g);
-
-	protected:
-		const static int			m_cMAXScreenCount = 2;
-		Label*					m_LabFreMsg[2];
-		Label*					m_LabAMPMsg[2];
-		Label*					m_LabPHAMsg[2];
-		Label*					m_LabCHAMsg[2];
-
-		Label*					m_LabAlarmSt[2];
-		Bufferbar				*m_Bufbar;
-		Zscreen					*m_Zscreen[m_cMAXScreenCount];
-		AlarmManage				*m_AlarmManage[m_cMAXScreenCount];
-		int					m_LastStatus[2];
-	private:
-		DZKDataProcess    			*m_DataProcess;
-};
-#endif
diff --git a/src/EVA11/DataRepo.cpp b/src/EVA11/DataRepo.cpp
deleted file mode 100644
index fcbd8ea..0000000
--- a/src/EVA11/DataRepo.cpp
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DataRepo.cpp
- *
- *    Description:  Implemntaion of DataRepo class
- *
- *        Version:  1.0
- *        Created:  2012年07月17日 17时11分34秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdlib>
-#include 	<cstdio>
-#include 	<fstream>
-#include 	<new>
-
-#include 	<zlib.h>
-
-#include 	"DataRepo.h"
-
-std::auto_ptr<DataRepo> DataRepo::m_Instance;
-DataRepo::DataRepo ()
-{
-}
-
-DataRepo::~DataRepo ()
-{
-	m_Instance->Release_Data_Repo();
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-DataRepo* DataRepo::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new DataRepo() );
-		if ( m_Instance.get()->Init_Data_Repo(m_cMAXCapacity) == false )
-			printf ( "Init data fail\n" );
-	}
-	return m_Instance.get();
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Data_Repo
- *  Description:  Init the Data Repo 
- * =====================================================================================
- */
-bool DataRepo::Init_Data_Repo(uint64_t capacity)
-{
-	m_Capacity        = capacity;
-	m_Buffer_Overflow = false;
-	m_Data_Index	  = 0;
-	m_Data_MAXCount   = m_Capacity;
-	m_Each_Loop_Count = 16;
-	
-	m_Each_Loop_ShiftCount = 0;
-	while( m_Each_Loop_Count != 1 )
-	{
-		m_Each_Loop_ShiftCount ++;
-		m_Each_Loop_Count = m_Each_Loop_Count >> 1;
-	}
-	m_Each_Loop_Count = 16;
-
-	m_Data_Buffer     = new(std::nothrow) ETDATA[m_Capacity];
-	if ( m_Data_Buffer == NULL )
-		return false;
-
-	if 	( m_Data_Buffer != NULL )
-	{
-		for ( uint64_t i=0;i<(m_Capacity>>1);i++ )
-		{
-			*(uint64_t  *)(m_Data_Buffer+(i<<1)) = 0;
-		}
-		return true;
-	}
-
-	return false;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_Data_Repo
- *  Description:  Release the Data Repo 
- * =====================================================================================
- */
-void DataRepo::Release_Data_Repo()
-{
-	if ( m_Data_Buffer != NULL )
-	{
-		delete[] m_Data_Buffer;
-		m_Data_Buffer = NULL;
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_Data_Repo
- *  Description:  When User changer the databuffer, call it
- *          len:  words count
- * =====================================================================================
- */
-void DataRepo::Reset_Data_Repo(uint64_t len,int32_t loop_count)
-{
-	m_Buffer_Overflow = false;
-	m_Data_Index	  = 0;
-	m_Data_MAXCount   = len;
-	m_Each_Loop_Count = loop_count;
-	m_Each_Loop_ShiftCount = 0;
-	while( m_Each_Loop_Count != 1 )
-	{
-		m_Each_Loop_ShiftCount ++;
-		m_Each_Loop_Count = m_Each_Loop_Count >> 1;
-	}
-	m_Each_Loop_Count = loop_count;
-	for ( uint64_t i=0;i<(len>>1);i++ )
-	{
-		*(uint64_t  *)(m_Data_Buffer+(i<<1)) = 0;
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Data_Into_Repo
- *  Description:  Save the data into Repository 
- * =====================================================================================
- */
-void DataRepo::Save_Data_Into_Repo(ETDATA *data)
-{
-	if ( m_Data_Index == m_Data_MAXCount )
-	{
-	       	m_Data_Index = 0; m_Buffer_Overflow = true;
-	}
-	for ( int32_t i=0;i<m_Each_Loop_Count;i++ )
-	{
-		m_Data_Buffer[m_Data_Index+i] = data[i];
-	}
-	m_Data_Index += m_Each_Loop_Count;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_2_File
- *  Description:  Write the data into flash
- * =====================================================================================
- */
-void DataRepo::Write_2_File(std::fstream& filestream)
-{
-	if 	( m_Buffer_Overflow == false )
-	{
-		filestream.write((char *)m_Data_Buffer,(m_Data_Index<<1));
-	}
-	else
-	{
-		filestream.write((char *)&m_Data_Buffer[m_Data_Index],(m_Data_MAXCount-m_Data_Index)<<1);
-		filestream.write((char *)m_Data_Buffer,(m_Data_Index<<1));
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Wgzip_2_File
- *  Description:  Compress data buffer into file
- *  		  No finish yet
- * =====================================================================================
- */
-void DataRepo::Wgzip_2_File(const char* path)
-{
-	gzFile fp = NULL;
-	fp=gzopen(path,"wb");
-	gzwrite(fp,(char *)m_Data_Buffer,(m_Data_Index<<1));
-	// becareful there are two status
-	gzclose(fp);
-	fp = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Rgzip_4_Memo
- *  Description:  Read data from compress file 
- *  		  No finish yet
- * =====================================================================================
- */
-void DataRepo::Rgzip_4_Memo(const char* path)
-{
-	gzFile fp = NULL;
-	fp=gzopen(path,"rb");
-	gzread(fp,(char *)m_Data_Buffer,(m_Data_Index<<1));
-	// becareful there are two status
-	gzclose(fp);
-	fp = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Read_2_Memory
- *  Description:  Load Data from flash into memory
- * =====================================================================================
- */
-void DataRepo::Read_2_Memory(std::fstream& filestream)
-{
-	using namespace std;
-	uint64_t datalenth;                                  /* save the file length */
-	filestream.seekp(0,ios::end);                      /* seek the end of file */
-	datalenth = static_cast<uint64_t>(filestream.tellp()) - 2048; /* subtract the length of file head */
-	if 	( datalenth ==  ( m_Data_MAXCount  << 1 ) )
-	{
-		m_Buffer_Overflow = true;
-		filestream.seekp(2048,ios::beg);           /* seek over the file head */
-		filestream.read((CHAR *)m_Data_Buffer,datalenth);    /* Low Byte High Byte */
-		m_Data_Index = 0;
-
-	}
-	else if ( datalenth < ( m_Data_MAXCount  << 1 ) )
-	{
-		m_Buffer_Overflow = false;
-		filestream.seekp(2048,ios::beg);           /* seek over the file head */
-		filestream.read((CHAR *)m_Data_Buffer,datalenth);    /* Low Byte High Byte */
-		m_Data_Index = ( datalenth>>1 );
-	}
-	else if ( datalenth > ( m_Data_MAXCount  << 1 ) )
-	{
-		m_Buffer_Overflow = true;
-		filestream.seekp(2048,ios::beg);           /* seek over the file head */
-		filestream.read((CHAR *)m_Data_Buffer,( m_Data_MAXCount  << 1 ));    /* Low Byte High Byte */
-		m_Data_Index = 0;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bytes_Of_Buffer
- *  Description:  Get the bytes of Buffer 
- * =====================================================================================
- */
-uint64_t  DataRepo::Get_Bytes_Of_Buffer()
-{
-	return ( m_Data_Index << 1 );
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  GetLoopCount
- *  Description:  Get the Loop Count of Data Repo 
- * =====================================================================================
- */
-uint64_t DataRepo::GetLoopCount()
-{
-	if 	( m_Buffer_Overflow == false ) return m_Data_Index / m_Each_Loop_Count;
-	else 	return m_Data_MAXCount / m_Each_Loop_Count;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_One_Loop_Back
- *  Description:  Get any one loop from data repos 
- *  Note:
- *                You must comfirm that the offset not over the buffer arrange 
- * =====================================================================================
- */
-void DataRepo::Get_One_Loop_Back(ETDATA *data,uint64_t offsetloop)
-{
-	if 	( m_Buffer_Overflow == false )
-	{
-		for ( int i=0;i<m_Each_Loop_Count;i++ )
-		{
-			data[i] = m_Data_Buffer[m_Data_Index - ( offsetloop<<m_Each_Loop_ShiftCount ) + i];
-		}
-	}
-	else
-	{
-		offsetloop = m_Data_Index - ( offsetloop << m_Each_Loop_ShiftCount );
-		if 	( offsetloop < 0 )
-		{
-			offsetloop = offsetloop + m_Data_MAXCount;
-		}
-		for ( int i=0;i<m_Each_Loop_Count;i++ )
-		{
-			data[i] = m_Data_Buffer[offsetloop + i];
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Each_Loop_Word_Count
- *  Description:  Get the Each Loop Word Count 
- * =====================================================================================
- */
-int DataRepo::Get_Each_Loop_Word_Count()
-{
-	return m_Each_Loop_Count;
-}
diff --git a/src/EVA11/DataRepo.h b/src/EVA11/DataRepo.h
deleted file mode 100644
index 12c2342..0000000
--- a/src/EVA11/DataRepo.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DataRepo.h
- *
- *    Description:  Mange data class 
- *
- *        Version:  1.0
- *        Created:  2012年07月17日 17时07分41秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  datarepo_INC
-#define  datarepo_INC
-
-#include 	<memory>
-#include 	<iosfwd>
-#include 	<stdint.h>
-
-#include 	"main.h"
-class DataRepo
-{
-	public:
-		static DataRepo* Instance();
-
-		void Reset_Data_Repo(uint64_t len,int32_t loop_count);
-		void Save_Data_Into_Repo(ETDATA *data);
-
-		void Write_2_File(std::fstream& filestream);
-		void Read_2_Memory(std::fstream& filestream);
-
-		void Wgzip_2_File(const char* path);
-		void Rgzip_4_Memo(const char* path);
-
-		uint64_t  Get_Bytes_Of_Buffer();
-		uint64_t  GetLoopCount();
-		void Get_One_Loop_Back(ETDATA* data,uint64_t offsetloop);
-		int Get_Each_Loop_Word_Count();
-	protected:
-
-	private:
-		DataRepo ();
-		~DataRepo ();
-		DataRepo (const DataRepo&);
-		DataRepo& operator = (const DataRepo&);
-
-		bool Init_Data_Repo(uint64_t);
-		void Release_Data_Repo();
-
-	private:
-		friend class std::auto_ptr<DataRepo>;
-		static std::auto_ptr<DataRepo>		m_Instance;
-		const static uint64_t         		m_cMAXCapacity = 5 * 1024 * 1024;
-		/*-----------------------------------------------------------------------------
-		 *  variables used for mangement of data
-		 *-----------------------------------------------------------------------------*/
-		ETDATA			  	        *m_Data_Buffer;
-		bool 			  	        m_Buffer_Overflow;
-		uint64_t	  	        	m_Capacity;
-
-		uint64_t 	  	        	m_Data_Index;
-		uint64_t 	  	        	m_Data_MAXCount;
-		int32_t			  	        m_Each_Loop_Count;
-		int32_t					m_Each_Loop_ShiftCount;
-};
-#endif   /* ----- #ifndef datarepo_INC  ----- */
diff --git a/src/EVA11/Datawin.cpp b/src/EVA11/Datawin.cpp
deleted file mode 100644
index e715681..0000000
--- a/src/EVA11/Datawin.cpp
+++ /dev/null
@@ -1,638 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Datawin.cpp
- *
- *    Description:  Implementation of Datawin class
- *
- *        Version:  1.0
- *        Created:  2012年07月24日 11时09分06秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<sys/stat.h>
-#include	<fstream>
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"Basewin.h"
-#include 	"Datawin.h"
-#include 	"Graphic.h"
-
-#include 	"Language.h"
-#include 	"Global.h"
-#include 	"DataRepo.h"
-#include 	"Msgbox.h"
-
-Datawin::Datawin (DATAWINTYPE type,char flag,int index)
-{
-	m_Type        = type;
-	m_Flag	      = flag;
-	m_Index	      = index;
-
-	for ( int i=0;i<m_cMAXItem;i++ )
-	{
-		m_Itemtime[i].flag 
-			= false;
-	}
-
-	m_BottomFocus = 1;
-	m_NormalFocus = 1;
-	m_CurrentPage = 0;
-}
-
-Datawin::~Datawin ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object
- * =====================================================================================
- */
-void Datawin::Init_GUI(Graphic& g)
-{
-	Basewin::Init_GUI(g);
-
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-	}	
-	m_BomButton[0]->Set_Focus(true);
-	char temp[4];
-	sprintf(temp,"%d",m_CurrentPage+1);
-	m_BomSmall->Set_Text(temp);
-
-	for ( int i=0;i<10;i++ )
-	{
-		m_NorLable[i] = new Label(4,53+39*i,315,38);
-		m_NorLable[i]->Set_Label_Type(Label::LA_3D); 
-		m_NorLable[i]->Set_Text(" ");
-		m_NorLable[i]->Set_Font_Size(18);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_NorLable[i]->Set_Display_Type(Label::LA_DT_LEFT);
-	}
-	for ( int i=0;i<10;i++ )
-	{
-		m_NorLable[10+i] = new Label(7+315,53+39*i,315,38);
-		m_NorLable[10+i]->Set_Label_Type(Label::LA_3D); 
-		m_NorLable[10+i]->Set_Text(" ");
-		m_NorLable[10+i]->Set_Font_Size(18);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_NorLable[10+i]->Set_Display_Type(Label::LA_DT_LEFT);
-	}
-
-	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-
-	if 	( m_Type == DA_SAVE ) 
-	{
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Label_Type(Label::LA_NONE); 
-		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
-	}
-	else if ( m_Type == DA_LOAD ) 
-	{
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Label_Type(Label::LA_NONE); 
-		m_Title->Set_Text(m_pl->GetText(LOADDATA));
-	}
-	else if ( m_Type == DA_DELE ) 
-	{
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Label_Type(Label::LA_NONE); 
-		m_Title->Set_Text(m_pl->GetText(DELEDATA));
-	}
-
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_Title->Set_Font_Size(26);
-
-	m_SubTitle = new Label(550,25,80,22);
-	m_SubTitle->Set_Label_Type(Label::LA_NONE); 
-	m_SubTitle->Set_Text(" ");
-	m_SubTitle->Set_Font_Size(16);
-	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-
-	if 	( m_gp->Language == 1 )
-		m_Page = new Label(10,25,100,22);
-	else
-		m_Page = new Label(10,25,80,22);
-
-	m_Page->Set_Label_Type(Label::LA_NONE); 
-	m_Page->Set_Text(m_pl->GetText(PAGE5));
-	m_Page->Set_Font_Size(16);
-	m_Page->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Page->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-
-	Init_Normal_Lines();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy thr GUI object
- * =====================================================================================
- */
-void Datawin::Destroy_GUI()
-{
-	Basewin::Destroy_GUI();
-	for ( int i=0;i<m_cMAXItem;i++ )
-	{
-		if 	( m_NorLable[i] != NULL )
-		{
-			delete m_NorLable[i];
-			m_NorLable[i] = NULL;
-		}
-	}
-	if 	( m_Title != NULL )
-	{
-		delete m_Title; 
-		m_Title = NULL;
-	}
-	if	( m_SubTitle != NULL )
-	{
-		delete m_SubTitle;
-		m_SubTitle = NULL;
-	}
-	if 	( m_Page != NULL )
-	{
-		delete m_Page;
-		m_Page = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- * Description:  Evey Windows class ues this function to draw himself on screen
- * =====================================================================================
- */
-void Datawin::Drawme(Graphic &g)
-{
-	Basewin::Drawme(g);
-
-	for ( int i=0;i<m_cMAXItem;i++ )
-	{
-		m_NorLable[i]->Drawme(g,false);
-	}
-	m_Title->Drawme(g);
-	m_SubTitle->Drawme(g);
-	m_Page->Drawme(g);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function
- * =====================================================================================
- */
-int  Datawin::Loopwindow(Graphic &g)
-{
-	Save_Screen_Into_Memory(g);
-	int result    = 0;
-	m_BottomFocus = 1;
-	m_NormalFocus = 1;
-
-	Init_GUI(g);
-	Drawme(g);
-
-	while( 1 )
-	{
-		result = Command_Process(g);
-		if 	( result == CO_EXIT )
-			goto Exit;
-		else if ( result == CO_OK )
-		{
-			result = CO_OK;
-			goto Exit;
-		}
-	}
-
-Exit:
-	Destroy_GUI();
-	Restore_Screen_From_Memory(g);
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  As the input parameter index to set the bottoms button status  
- * =====================================================================================
- */
-void Datawin::DrawBottomFocus(Graphic& g,int index)
-{
-	Basewin::DrawBottomFocus(g,index);
-
-	switch ( index ) {
-		case 1:                         /* previouse */
-			{
-				if 	( m_NormalFocus == 1 )
-				{
-				        m_NormalFocus = m_cMAXItem;
-					m_NorLable[0]->Set_Focus(false);
-					m_NorLable[0]->Drawme(g);
-					m_NorLable[19]->Set_Focus(true);
-					m_NorLable[19]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus--;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-
-			}
-			break;
-		case 2:                         /* next */
-			{
-				if ( m_NormalFocus == m_cMAXItem )
-				{
-				        m_NormalFocus = 1;
-					m_NorLable[19]->Set_Focus(false);
-					m_NorLable[19]->Drawme(g);
-					m_NorLable[0]->Set_Focus(true);
-					m_NorLable[0]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus++;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 3:                         /* left  */
-			{
-				if ( m_NormalFocus < 11 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-
-			break;
-
-		case 4:                         /* right */
-			{
-				if ( m_CurrentPage == 0 ) m_CurrentPage = 4;
-				else m_CurrentPage --;
-				Init_Normal_Lines();
-				for ( int i=0;i<m_cMAXItem;i++ )
-				{
-					m_NorLable[i]->Drawme(g,true);
-				}
-				char t[4];
-				sprintf(t,"%d",m_CurrentPage+1);
-				m_BomSmall->Set_Text(t);
-				m_BomSmall->Drawme(g);
-			}
-			break;
-		case 5:
-			{
-				if ( m_CurrentPage == 4 ) m_CurrentPage = 0;
-				else m_CurrentPage ++;
-				Init_Normal_Lines();
-				for ( int i=0;i<m_cMAXItem;i++ )
-				{
-					m_NorLable[i]->Drawme(g,true);
-				}
-				char t[4];
-				sprintf(t,"%d",m_CurrentPage+1);
-				m_BomSmall->Set_Text(t);
-				m_BomSmall->Drawme(g);
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bom_Text
- *  Description:  Return the Bom button text 
- *        index: from 0 to 6
- * =====================================================================================
- */
-const char* Datawin::Get_Bom_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0: 
-			return m_pl->GetText(PREVIOUSE);
-			break;
-
-		case 1: 
-			return m_pl->GetText(NEXT);
-			break;
-
-		case 2: 
-			return m_pl->GetText(CHCOL);
-			break;
-
-		case 3: 
-			return m_pl->GetText(PGUP);
-			break;
-
-		case 4: 
-			return m_pl->GetText(PGDN);
-			break;
-
-		case 5: 
-			return m_pl->GetText(COMFIRM);
-			break;
-
-		case 6: 
-			return m_pl->GetText(CANCEL);
-			break;
-
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}
-
-	return m_pl->GetText(NONE);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_One_Line
- *  Description:  Init one Line value 
- * =====================================================================================
- */
-void Datawin::Init_Normal_One_Line(int i)
-{
-	std::fstream m_filestream;
-	char *databuf = new char[60];
-	char *filename = new char[60];
-
-	sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem);
-	m_filestream.open(filename,std::ios::binary|std::ios::in);
-	if 	( !m_filestream )
-	{
-		m_Itemtime[i].flag = false;
-		sprintf(databuf,"%s %c%02d%02d.dat         %s",m_pl->GetText(DATAFILE),m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem,m_pl->GetText(BLANK));
-		m_NorLable[i]->Set_Text(databuf);
-	}
-	else
-	{
-		struct stat info;
-		time_t seconds;
-		struct tm *p;
-		stat(filename,&info);
-		seconds             = info.st_mtime;
-		p                   = localtime(&seconds);
-		m_Itemtime[i].year  = p->tm_year + 1900;
-		m_Itemtime[i].month = p->tm_mon + 1;
-		m_Itemtime[i].day   = p->tm_mday;
-		m_Itemtime[i].flag  = true;
-		m_filestream.close();
-		sprintf(databuf,"%s %c%02d%02d.dat    %d/%d/%d",m_pl->GetText(DATAFILE),m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem,m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
-		m_NorLable[i]->Set_Text(databuf);
-	}
-
-	delete[] databuf;
-	databuf = NULL;
-	delete[] filename;
-	filename = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_Lines
- *  Description:  according the currentpage paramter initial the normal lines of screen 
- * =====================================================================================
- */
-void Datawin::Init_Normal_Lines()
-{
-	for ( int i=0;i<m_cMAXItem;i++ )
-	{
-		Init_Normal_One_Line(i);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Real_Do_Save_Staff
- *  Description:  Real do the save staff job 
- * =====================================================================================
- */
-void Datawin::Real_Do_Save_Staff(Graphic& g)
-{
-	char *filename = new char[100];
-	sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
-
-	std::fstream m_filestream;
-	m_filestream.open(filename,std::ios::binary|std::ios::in|std::ios::out|std::ios::trunc);
-	if 	( !m_filestream )
-	{
-		perror("can't open the input data file\n");
-		delete[] filename;
-		filename = NULL;
-		return;
-	}
-
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
-	g.Load_Disp_Area(0,0,639,479,mem);
-	Label *lab = new Label(220,230,250,25);
-	lab->Set_Label_Type(Label::LA_THIN);
-	lab->Set_Text(m_pl->GetText(SAVEDATA1));
-	lab->Set_Font_Size(16);
-	lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	lab->Drawme(g);
-	delete lab;
-	lab = NULL;
-
-	m_repo->Write_2_File(m_filestream);
-	m_filestream.close();
-	sync();
-
-	delete[] filename;
-	filename = NULL;
-
-	g.Restore_Disp_Area(0,0,639,479,mem);     /* restore the graphic buffer */
-	delete[] mem;                             /* release the buffer */
-	mem = NULL;
-
-	Init_Normal_One_Line(m_NormalFocus-1);
-	m_NorLable[m_NormalFocus-1]->Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Real_Do_Load_Staff
- *  Description:  Real do the Load staff job 
- * =====================================================================================
- */
-void Datawin::Real_Do_Load_Staff(Graphic& g)
-{
-	m_repo->Wgzip_2_File("/tmp/test.gz");
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Real_Do_Dele_Staff
- *  Description:  Real do the Dele staff job 
- * =====================================================================================
- */
-void Datawin::Real_Do_Dele_Staff(Graphic& g)
-{
-	if ( Password_Confirm(g) == 1 )
-	{
-		char *filename = new char[100];
-		sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
-
-		if ( remove(filename) == 0 )
-		{
-			Init_Normal_One_Line(m_NormalFocus-1);
-			m_NorLable[m_NormalFocus-1]->Drawme(g);
-		}
-
-		delete[] filename;
-		filename = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Datawin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-	return CO_NONE;
-}
-int Datawin::Key_Bom2_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,2);
-	return CO_NONE;
-}
-int Datawin::Key_Bom3_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,3);
-	return CO_NONE;
-}
-int Datawin::Key_Bom4_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,4);
-	return CO_NONE;
-}
-int Datawin::Key_Bom5_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,5);
-	return CO_NONE;
-}
-int Datawin::Key_Bom6_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,6);
-	switch ( m_Type )
-	{
-		case DA_LOAD:
-			{
-				if ( m_Itemtime[m_NormalFocus-1].flag == true)
-				{
-					Real_Do_Load_Staff(g);
-				}
-				else
-				{
-					Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					ms->Showme(g); 
-					delete ms;
-					ms = NULL;
-				}
-			}
-			break;
-
-		case DA_SAVE:
-			{
-				if ( m_Itemtime[m_NormalFocus-1].flag == true)
-				{
-					Msgbox *ms = new Msgbox(200,170,280,80,m_pl->GetText(OVERWRITECHECK),Msgbox::MSG_OKCANCEL);	
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					if ( ms->Showme(g) == false )
-					{
-						delete ms;
-						ms = NULL;
-					}
-					else
-					{
-						Real_Do_Save_Staff(g);
-						delete ms;
-						ms = NULL;
-					}
-				}
-				else
-				{
-					Real_Do_Save_Staff(g);
-				}
-			}
-			break;
-
-		case DA_DELE:
-			{
-				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
-				{
-					Real_Do_Dele_Staff(g);
-				}
-				else
-				{       Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					ms->Showme(g); 
-					delete ms;
-					ms = NULL;
-				}
-			}
-			break;
-	}
-
-	return CO_NONE;
-}
-int Datawin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Datawin::Key_Enter_Fun(Graphic& g)
-{
-	return Key_Bom6_Fun(g);
-}
-int Datawin::Key_Esc_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
diff --git a/src/EVA11/Datawin.h b/src/EVA11/Datawin.h
deleted file mode 100644
index 35478f9..0000000
--- a/src/EVA11/Datawin.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Datawin.h
- *
- *    Description:  Implementation of Datawin class
- *
- *        Version:  1.0
- *        Created:  2012年07月24日 11时02分57秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _DATAWIN_INC
-#define  _DATAWIN_INC
-
-#include 	<string>
-
-class Datawin : public Basewin
-{
-	public:
-		enum DATAWINTYPE 
-		{
-			DA_LOAD,
-			DA_SAVE,
-			DA_DELE,
-		};
-		typedef enum DATAWINTYPE DATAWINTYPE;
-
-		struct ITEMTIME 
-		{
-			bool flag;
-			short year;
-			short month;
-			short day;
-		};
-		typedef struct ITEMTIME ITEMTIME;
-
-		Datawin (DATAWINTYPE,char,int);
-		virtual ~Datawin ();
-
-		virtual int  Loopwindow(Graphic &g);
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-		void Drawme(Graphic &g);
-
-		virtual const char*Get_Bom_Text(int);
-		void Init_Normal_Lines();
-
-		virtual int Key_Bom1_Fun(Graphic& g) ;
-		virtual int Key_Bom2_Fun(Graphic& g) ;
-		virtual int Key_Bom3_Fun(Graphic& g) ;
-		virtual int Key_Bom4_Fun(Graphic& g) ;
-		virtual int Key_Bom5_Fun(Graphic& g) ;
-		virtual int Key_Bom6_Fun(Graphic& g) ;
-		virtual int Key_Bom7_Fun(Graphic& g) ;
-
-		virtual int Key_Esc_Fun(Graphic& g)  ;
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual void DrawBottomFocus(Graphic& g,int index);
-
-		virtual void Init_Normal_One_Line(int index);
-	private:
-
-		void Real_Do_Save_Staff(Graphic& g);
-		void Real_Do_Load_Staff(Graphic& g);
-		void Real_Do_Dele_Staff(Graphic& g);
-
-	protected:
-		static const int		     m_cMAXItem = 20;
-		DATAWINTYPE			     m_Type;
-
-		Label  				    *m_NorLable[m_cMAXItem];
-		Label  				    *m_Title;
-		Label  				    *m_SubTitle;
-		Label				    *m_Page;
-
-		int 				     m_BottomFocus;
-		int 				     m_NormalFocus;
-		int 				     m_CurrentPage;
-		ITEMTIME 			     m_Itemtime[m_cMAXItem];
-
-		char				     m_Flag;
-		int				     m_Index;
-};
-#endif
diff --git a/src/EVA11/DebugView.cpp b/src/EVA11/DebugView.cpp
deleted file mode 100644
index b5d26f7..0000000
--- a/src/EVA11/DebugView.cpp
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DebugView.cpp
- *
- *    Description:  implementation of DebugView class
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 10时46分25秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<etio.h>
-
-#include 	"Graphic.h"
-#include	"Global.h"
-#include 	"Device.h"
-#include 	"Language.h"
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Sinscreen.h"
-
-#include 	"IView.h"
-#include 	"DebugView.h"
-
-#include 	"FreeType.h"
-#include 	"main.h"
-
-DebugView::DebugView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-}
-DebugView::~DebugView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void DebugView::Drawme(Graphic &g)
-{
-	m_Sinscreen->Drawme(g);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void DebugView::Init_GUI(Graphic& g)
-{
-	m_Sinscreen = new Sinscreen(m_X,m_Y,m_Width,m_Heigh);
-	m_Sinscreen->Set_Color(Sinscreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Sinscreen->Set_Color(Sinscreen::LA_BG_COLOR,g_SCBG_CO);
-	m_Sinscreen->Set_Color(Sinscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Sinscreen->Set_Color(Sinscreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Sinscreen->Set_Color(Sinscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void DebugView::Destroy_GUI()
-{
-	if ( m_Sinscreen != NULL )
-	{
-		delete m_Sinscreen;
-		m_Sinscreen = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view of Debug function 
- * =====================================================================================
- */
-void DebugView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_PCB_SIN_Function
- *  Description:  Set the PCB to SIN function  
- * =====================================================================================
- */
-void DebugView::Set_PCB_SIN_Function()
-{
-	m_device->Write_Para_Func(Device::SIN);	
-	m_device->Transfer_ECT_Parameters();
-	m_device->Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  Release the view of Debug function 
- * =====================================================================================
- */
-void DebugView::Release_View()
-{
-	Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  Very important function of loop view 
- * =====================================================================================
- */
-int  DebugView::Loop_View(Graphic& g)
-{
-	if 	( m_device->Get_Chan_Function(m_gp->DebugChan) > 0 )
-	{
-		int datalen = m_device->Get_SampDataN();
-		int *databuf = new int[datalen];
-		m_device->Sample_Sin_Data(databuf,datalen);	
-		m_Sinscreen->Draw_SIN_Wave(g,databuf,datalen);
-		delete[] databuf;
-		databuf = NULL;
-	}
-	else
-		m_Sinscreen->Drawme(g);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_View
- *  Description:  When Swtich view call this function
- *  		 Very important function
- * =====================================================================================
- */
-void DebugView::Switch_View()
-{
-	Set_PCB_SIN_Function();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void DebugView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
diff --git a/src/EVA11/DebugView.h b/src/EVA11/DebugView.h
deleted file mode 100644
index 0c6b80c..0000000
--- a/src/EVA11/DebugView.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DebugView.h
- *
- *    Description:  Manage functions view 
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 10时41分38秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef  _DEBUGVIDEW_INC
-#define  _DEBUGVIDEW_INC
-
-class Sinscreen;
-class IView;
-class Etio;
-
-class DebugView : public IView
-{
-	public:
-		DebugView (int x,int y,int width,int heigh);
-		~DebugView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		/* -----  Enter the DebugView call the sets function to init the view  ----- */
-
-		virtual void Drawme (Graphic&);
-		virtual void Switch_View(); 
-
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-		void Set_PCB_SIN_Function();
-	private:
-		Sinscreen				     *m_Sinscreen;
-		Etio					     *m_Etio;
-};
-#endif
diff --git a/src/EVA11/DetectView.cpp b/src/EVA11/DetectView.cpp
deleted file mode 100644
index 84f7ec2..0000000
--- a/src/EVA11/DetectView.cpp
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DetectView.cpp
- *
- *    Description:  implementation of DetectView class
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 14时23分25秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Device.h"
-#include 	"Language.h"
-#include 	"Global.h"
-
-#include 	"Algorithm.h"
-
-#include 	"BasePanel.h"
-#include 	"ZKPanel.h"
-#include 	"VideoPanel.h"
-#include 	"DZKPanel.h"
-#include 	"ColorPanel.h"
-#include 	"OZKPanel.h"
-#include 	"CZKPanel.h"
-
-#include 	"Logic.h"
-
-#include 	"IView.h"
-#include 	"DetectView.h"
-
-DetectView::DetectView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh) , m_PanelType(0)
-{
-}
-
-DetectView::~DetectView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Panel_Type
- *  Description:  Set the panel type 
- * =====================================================================================
- */
-void DetectView::Set_Panel_Type(int type)
-{
-	m_PanelType = type;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object on screen 
- * =====================================================================================
- */
-void DetectView::Init_GUI(Graphic& g)
-{
-	m_ViewDisBuffer = new unsigned char[g.Get_Disp_Area_Bytes(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1)]; 
-
-	m_Panel[0] = new ColorPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[0]->Init_GUI(g);
-
-	m_Panel[1] = new VideoPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[1]->Init_GUI(g);
-
-	m_Panel[2] = new ZKPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[2]->Init_GUI(g);
-
-	m_Panel[3] = new DZKPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[3]->Init_GUI(g);
-
-	m_Panel[4] = new OZKPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[4]->Init_GUI(g);
-
-	m_Panel[5] = new CZKPanel(m_X,m_Y,m_Width,m_Heigh);
-	m_Panel[5]->Init_GUI(g);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void DetectView::Destroy_GUI()
-{
-	if ( m_ViewDisBuffer != NULL )
-	{
-		delete[] m_ViewDisBuffer;
-		m_ViewDisBuffer = NULL;
-	}
-
-	for ( int i=0;i<m_cMAXPanelCount;i++ )
-	{
-		m_Panel[i]->Destroy_GUI();
-		delete m_Panel[i];
-		m_Panel[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view of Debug function 
- * =====================================================================================
- */
-void DetectView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  Release the view of Debug function 
- * =====================================================================================
- */
-void DetectView::Release_View()
-{
-	Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void DetectView::Drawme(Graphic &g)
-{
-	g.Switch_Screen();
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0xFFFFFF));
-	m_Panel[m_PanelType]->Drawme(g,false);
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_F2_Fun
- *  Description:  Do F2 KEY function 
- * =====================================================================================
- */
-int DetectView::Key_F2_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F2_Fun(g);
-}
-int DetectView::Key_F3_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F3_Fun(g);
-}
-int DetectView::Key_F4_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F4_Fun(g);
-}
-int DetectView::Key_F5_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F5_Fun(g);
-}
-int DetectView::Key_F6_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F6_Fun(g);
-}
-int DetectView::Key_F7_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_F7_Fun(g);
-}
-
-int DetectView::Key_Enter_Fun(Graphic& g)
-{
-	return m_Panel[m_PanelType]->Key_Enter_Fun(g);
-}
-
-int DetectView::Key_NL1_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL1_Fun(g,sub);
-}
-int DetectView::Key_NR1_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR1_Fun(g,sub);
-}
-int DetectView::Key_NL2_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL2_Fun(g,sub);
-}
-int DetectView::Key_NR2_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR2_Fun(g,sub);
-}
-int DetectView::Key_NL3_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL3_Fun(g,sub);
-}
-int DetectView::Key_NR3_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR3_Fun(g,sub);
-}
-int DetectView::Key_NL4_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL4_Fun(g,sub);
-}
-int DetectView::Key_NR4_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR4_Fun(g,sub);
-}
-int DetectView::Key_NL5_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL5_Fun(g,sub);
-}
-int DetectView::Key_NR5_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR5_Fun(g,sub);
-}
-int DetectView::Key_NL6_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NL6_Fun(g,sub);
-}
-int DetectView::Key_NR6_Fun(Graphic& g,int sub)
-{
-	return m_Panel[m_PanelType]->Key_NR6_Fun(g,sub);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void DetectView::Show_Help_System(Graphic& g,int x,int y)
-{
-	m_Panel[m_PanelType]->Show_Help_System(g,x,y);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  Very important function of loop view 
- * =====================================================================================
- */
-int  DetectView::Loop_View(Graphic& g)
-{
-	m_Panel[m_PanelType]->Loop_Panel(g);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Lock_View
- *  Description:  Stop the View refresh
- * =====================================================================================
- */
-void DetectView::Lock_View(Graphic& g)
-{
-	Algorithm *alg = Algorithm::Instance();
-	g.Load_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,m_ViewDisBuffer);
-	for ( int i=m_X;i<=((m_X+m_Width-1)>>1);i++ )
-	{
-		for ( int j=m_Y;j<m_Y+m_Heigh-1;j++ )
-		{
-			g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(239,60,25,80,g.Getpixel(i,j))));
-			g.Setpixel(m_X+m_Width-i-1,j,g.RGB24_16(alg->Alpha_Color(239,60,25,80,g.Getpixel(m_X+m_Width-i-1,j))));
-		}
-	}
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  UnLock_View
- *  Description:  Restart the view refresh 
- * =====================================================================================
- */
-void DetectView::UnLock_View(Graphic& g)
-{
-	g.Restore_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,m_ViewDisBuffer);
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_View
- *  Description:  When Swtich view call this function 
- *                Very important function
- * =====================================================================================
- */
-void DetectView::Switch_View()
-{
-	Set_Panel_Type(m_gp->PanelType);
-	m_Panel[m_PanelType]->Switch_Panel();
-
-	Logic *lo = Logic::Instance();
-	lo->Reset_Data_Repo();
-}
diff --git a/src/EVA11/DetectView.h b/src/EVA11/DetectView.h
deleted file mode 100644
index f787854..0000000
--- a/src/EVA11/DetectView.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  DetectView.h
- *
- *    Description:  implementation of Detect View class
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 14时14分36秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _DETECTVIEW_INC
-#define  _DETECTVIEW_INC
-
-class BasePanel; 
-class IView;
-class AlarmView;
-class ParaView;
-class DetectView : public IView
-{
-	public:
-		DetectView (int x,int y,int width,int heigh);
-		~DetectView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F5_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-		virtual int Key_F7_Fun(Graphic& g);
-
-		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		virtual void Lock_View(Graphic& g);
-		virtual void UnLock_View(Graphic& g);
-
-		/* -----  Enter the DebugView call the sets function to init the view  ----- */
-
-		virtual void Switch_View();
-		virtual void Drawme (Graphic&);
-		void Set_Panel_Type(int type);
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-	private:
-		friend class 			    AlarmView; 
-		friend class 			    ParaView; 
-		unsigned char			    *m_ViewDisBuffer;
-		static const int		    m_cMAXPanelCount 	= 	6;
-		int				    m_PanelType;
-		BasePanel			    *m_Panel[m_cMAXPanelCount];
-}; /* -----  end of class DetectView  ----- */
-#endif   /* ----- #ifndef _DETECTVIEW_INC  ----- */
diff --git a/src/EVA11/Device.cpp b/src/EVA11/Device.cpp
deleted file mode 100644
index e2fb598..0000000
--- a/src/EVA11/Device.cpp
+++ /dev/null
@@ -1,688 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Device.cpp
- *
- *    Description:  Class for Operating hardware, special for ECT board data reading
- *
- *        Version:  1.0
- *        Created:  2010年03月06日 22时19分33秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-
-/*-----------------------------------------------------------------------------
- * 	PiFj:  i[0 8]  Probe     ||    j[1  8]  Frequence
- * 	    
- *
- *    SignalID[ch] = 0        Close the channel
- *
- *
- *    SignalID[ch] = ( i - 1 ) * 8  + j
- *
- *
- *    SignalID:
- *    0      P=0  closed
- *
- *    1-8    P=1
- *    9-16   P=2
- *    17-24  P=3
- *    .
- *    .
- *    .
- *   
- *    SignalN  is always  8
- *
- *    caution:
- *    There are two API 
- *    For 8 	channels used SetET()
- *    For 128 	channels used SetET2()
- *-----------------------------------------------------------------------------*/
-
-
-#include 	<cstdlib>
-#include 	"Device.h"
-#include 	"main.h"
-#include 	"etio.h"
-
-/*-----------------------------------------------------------------------------
- *  ECT BOARD parameters
- *-----------------------------------------------------------------------------*/
-std::auto_ptr<Device> Device::m_Instance;
-
-Device::Device ()
-{
-	m_IntBuf = new int[1024];
-
-	m_Etio = Etio::Instance();
-}
-
-Device::~Device ()
-{
-	delete[] m_IntBuf;
-	m_IntBuf = NULL;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Device* Device::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Device() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_ET_Board
- *  Description:  Before used the ECT board, call this function initiate the Board 
- * =====================================================================================
- */
-bool Device::Init_ET_Board()
-{
-	return m_Etio->InitiateETIO();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  UnInit_ET_Board
- *  Description:  After using the ECT board, call this function to release some resource 
- *                used by ET board
- * =====================================================================================
- */
-void Device::UnInit_ET_Board()
-{
-	m_Etio->UnInitiateETIO();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data_From_ECT_2
- *  Description:  Get the Data from ECT board noblock mode 
- * =====================================================================================
- */
-int Device::Get_Data_From_ECT_2(short* databuf)
-{
-	m_Etio->Sample_Chan_Data(m_IntBuf,Etio::RAWECT);
-	int n = sizeof(databuf);
-	for ( int i = 0; i < n; i += 1 ) 
-	{
-		databuf[i] = (m_IntBuf[i]>>16);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data_From_ECT
- *  Description:  Get Data from ECT board no-block mode 
- * =====================================================================================
- */
-int Device::Get_Data_From_ECT(int* databuf)
-{
-	m_Etio->Sample_Chan_Data(databuf,Etio::RAWECT);
-}
-
-int Device::Get_Data_From_ECT_Timer(int* databuf)
-{
-	m_Etio->Sample_Chan_Data(databuf,Etio::ALLECT);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Sin_Data
- *  Description:  Just Get the Sin Data Value from FPGA 
- * =====================================================================================
- */
-int Device::Sample_Sin_Data(int* databuf,int len)
-{
-	return m_Etio->Sample_Sin_Data(databuf,len);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Transfer_ECT_Parameters
- *  Description:  Transfer the m_Par parameters to PCB
- * =====================================================================================
- */
-void Device::Transfer_ECT_Parameters()
-{
-	m_Etio->Set_ET();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_par_Default_value
- *  Description:  The function must be called after Init_ET_Board function 
- *  		  because m_Par must be initiate before
- * =====================================================================================
- */
-void Device::Init_Par_Default_Value()
-{
-	m_Etio->Init_Default_Value();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Frequnce_Index
- *  Description:  Return the frequnce index in m_Par parameters 
- * =====================================================================================
- */
-int Device::Get_Frequence_Index(int frequnce)
-{
-	return m_Etio->Get_Frequence_Index(frequnce);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Frequence
- *  Description:  Return the index of frequence in m_par parameters
- * =====================================================================================
- */
-int Device::Get_Frequence(int index)
-{
-	return m_Etio->Get_Frequence(index);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_SignalID
- *  Description:  Set the SignalID parameters into PCB 
- * =====================================================================================
- */
-void Device::Set_Para_SignalID(int chan,unsigned char probe,unsigned char freqno)
-{
-	Write_Para_SignalID(chan,probe,freqno);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_Frequence
- *  Description:  Set the channel parameters frequence 
- * =====================================================================================
- */
-void Device::Set_Para_Frequence_Value(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_Frequence_Value(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_Frequence
- *  Description:  Write the channel parameters frequence 
- * =====================================================================================
- */
-void Device::Write_Para_Frequence_Value(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_Frequence_Value(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_HiFilter
- *  Description:  Set the channel parameters High filter 
- *  		  chan: channel index 
- *  		  value: new high filter value
- * =====================================================================================
- */
-void Device::Set_Para_HiFilter(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_HighFilter(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_HiFilter
- *  Description:  Write the channel parameters High filter 
- *  		  chan: channel index 
- *  		  value: new high filter value
- * =====================================================================================
- */
-void Device::Write_Para_HiFilter(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_HighFilter(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_LowFilter
- *  Description:  Set the channel parameters Low filter 
- *  		  chan: channel index 
- *  		  value: new low filter value
- * =====================================================================================
- */
-void Device::Set_Para_LowFilter(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_LowFilter(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_LowFilter
- *  Description:  Write the channel parameters Low filter 
- *  		  chan: channel index 
- *  		  value: new low filter value
- * =====================================================================================
- */
-void Device::Write_Para_LowFilter(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_LowFilter(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_SignalWave
- *  Description:  Select which channel debug signal wanted to be showed
- * =====================================================================================
- */
-void Device::Set_Para_SignalWave(int value)
-{
-	m_Etio->Interface_Select_Sin_Channel(value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_SignalWave
- *  Description:  Just as title 
- * =====================================================================================
- */
-void Device::Write_Para_SignalWave(int value)
-{
-	m_Etio->Interface_Select_Sin_Channel(value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_HDGain
- *  Description:  Set the channel parameters of HDGain
- *        value:  0~7
- * =====================================================================================
- */
-void Device::Set_Para_HDGain(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_ProbeGain(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_HDGain
- *  Description:  
- * =====================================================================================
- */
-void Device::Write_Para_HDGain(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_ProbeGain(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_DriverBal
- *  Description:  Write the Parameters of DriverBalance into FPGA
- *                跟随探头编码。1-15:显示“-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7
- * =====================================================================================
- */
-void Device::Set_Para_DriverBal(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_ProbeBalance(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_DriverBal
- *  Description:  Write the Parameters of DriverBalance into FPGA
- *                跟随探头编码。1-15:显示“-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7
- * =====================================================================================
- */
-void Device::Write_Para_DriverBal(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_ProbeBalance(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_DriveA_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Write_Para_DriveA_ID(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_CoilNumforDriverA(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_PickA_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Write_Para_PickA_ID(int chan,int value)
-{
-    	m_Etio->Interface_Set_Channels_CoilNumforPickA(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_DriveB_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Write_Para_DriveB_ID(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_CoilNumforDriverB(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_PickB_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Write_Para_PickB_ID(int chan,int value)
-{
-    	m_Etio->Interface_Set_Channels_CoilNumforPickB(chan,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_DriveA_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Set_Para_DriveA_ID(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_CoilNumforDriverA(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_PickA_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Set_Para_PickA_ID(int chan,int value)
-{
-    	m_Etio->Interface_Set_Channels_CoilNumforPickA(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_DriveB_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Set_Para_DriveB_ID(int chan,int value)
-{
-	m_Etio->Interface_Set_Channels_CoilNumforDriverB(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_PickB_ID
- *  Description:  
- * =====================================================================================
- */
-void Device::Set_Para_PickB_ID(int chan,int value)
-{
-    	m_Etio->Interface_Set_Channels_CoilNumforPickB(chan,value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_Driver
- *  Description:  Set the Driver of ECT board  
- * =====================================================================================
- */
-void Device::Set_Para_Driver(int value)
-{
-	m_Etio->Interface_Set_Channels_SineAmplitude(value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_Driver
- *  Description:  Set the Parameters of ECT board 
- * =====================================================================================
- */
-void Device::Write_Para_Driver(int value)
-{
-	m_Etio->Interface_Set_Channels_SineAmplitude(value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_Offset
- *  Description:  Set the Offset of ECT board  
- * =====================================================================================
- */
-void Device::Set_Para_Offset(int value)
-{
-	m_Etio->Interface_Set_Channels_Offset(value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_Offset
- *  Description:  Set the Offset of ECT board  
- * =====================================================================================
- */
-void Device::Write_Para_Offset(int value)
-{
-	m_Etio->Interface_Set_Channels_Offset(value);
-	Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Read_Port
- *  Description:  Read the port data 
- * =====================================================================================
- */
-unsigned char Device::Read_Port(int addr)	
-{
-	return m_Etio->PEEKB_TC(addr); 
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Port
- *  Description:  Write data into port  
- * =====================================================================================
- */
-void Device::Write_Port(int addr,unsigned char value)
-{
-	m_Etio->POKEB_TC(addr,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_SampDataN
- *  Description:  Get the sample data pointers 
- * =====================================================================================
- */
-int Device::Get_SampDataN()
-{
-	return m_Etio->Sample_DataN();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_SampDataNGet_SignalWave
- *  Description:  In Debug mode some time we will want to get signal wave 
- * =====================================================================================
- */
-int Device::Get_SignalWave()
-{
-	return m_Etio->Interface_Get_Sin_Channel();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Module_Version
- *  Description:  Get the Module of ETIO version 
- * =====================================================================================
- */
-int Device::Get_Module_Version()
-{
-	return m_Etio->Get_Version(); 
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_FPGA_Version
- *  Description:  Get the FPGA versiob 
- * =====================================================================================
- */
-int Device::Get_FPGA_Version()
-{
-	unsigned char low  =  m_Etio->PEEKB_TC(0);
-	unsigned char high =  m_Etio->PEEKB_TC(1);
-	return ( high << 8 ) + low;
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_New_Frequence
- *  Description:  Return the next frequence index 
- *                dir: false  Decrease
- *                     true   Increase
- * =====================================================================================
- */
-unsigned int Device::Calculate_New_Frequence(bool dir,int value,unsigned int step)
-{
-	if ( dir == false )                     /* Decrease */
-	{
-		for ( unsigned int i=0;i<step;i++ )
-		{
-			if ( value != 0 ) value --;
-		}
-	}
-	else                                    /* Increase */
-	{
-		for ( unsigned int i=0;i<step;i++ )
-		{
-			if ( value != m_Etio->Get_Max_Frequence_Length()-1 ) value ++;
-		}
-	}
-	return value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_SignalID
- *  Description:  Fill the SignalID acoording to the probe and freqNo 
- *  Note:
- *                probefun: 0-3   freqno: 1-8
- * =====================================================================================
- */
-void Device::Write_Para_SignalID(int ch,unsigned char probefun,unsigned char freqno)
-{
-	if 	( probefun == 0 )
-		m_Etio->Interface_Set_Channels_Type(ch,Etio::CLOSE);
-	else
-	{
-		switch ( probefun ) 
-		{
-			case 1:
-				m_Etio->Interface_Set_Channels_Type(ch,Etio::ECT);
-				break;
-
-			case 2:
-				m_Etio->Interface_Set_Channels_Type(ch,Etio::FECT);
-				break;
-
-			case 3:
-				m_Etio->Interface_Set_Channels_Type(ch,Etio::EMS);
-				break;
-
-			default:	
-				m_Etio->Interface_Set_Channels_Type(ch,Etio::ECT);
-				break;
-		}				/* -----  end switch  ----- */
-
-		m_Etio->Interface_Set_Channels_Map_Index(ch,freqno-1);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Para_Func
- *  Description:  Changing m_Par parameters Func   
- * =====================================================================================
- */
-void Device::Write_Para_Func(ETIO_FUN value)
-{
-	if 	( value == SIN )
-		m_Etio->Set_Work_Mode(Etio::SIN);
-	else 
-		m_Etio->Set_Work_Mode(Etio::NORMAL);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Chan_Function
- *  Description:  For Display Sin wave 
- * =====================================================================================
- */
-int Device::Get_Chan_Function(int index)
-{
-	return m_Etio->Interface_Get_Channels_Fun(index);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Para_RF_Filter
- *  Description:  Enable the RF Filter or not
- * =====================================================================================
- */
-void Device::Set_Para_RF_Filter(bool v)
-{
-	m_Etio->Interface_Set_RF_Filter_Enable_Switch(v);
-	m_Etio->Set_ET();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Timers_Data
- *  Description:  Get the Intimers Extimers1 Extimer2
- * =====================================================================================
- */
-void Device::Get_Timers_Data(int *databuf)
-{
-	m_Etio->Sample_Chan_Data(databuf,Etio::TIMERS);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_TImers
- *  Description:  
- * =====================================================================================
- */
-void Device::Clean_Timers()
-{
-	for ( int i = 0; i < 3; i += 1 ) 
-		m_Etio->Clear_Timers(i);
-}
-
diff --git a/src/EVA11/Device.h b/src/EVA11/Device.h
deleted file mode 100644
index 82bbcbb..0000000
--- a/src/EVA11/Device.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Device.h
- *
- *    Description:  Class for operating hardware including TC board
- *
- *        Version:  1.0
- *        Created:  2010年03月06日 19时09分56秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-
-
-/*
- * =====================================================================================
- *        Class:  Device
- *  Description:  Operating Hardware,manage the ETIO function operation 
- * =====================================================================================
- */
-
-#ifndef  _DEVICE_INC
-#define  _DEVICE_INC
-
-#include 	<memory>	
-
-class Etio;
-class Device
-{
-	public:
-		enum ETIO_FUN 
-		{
-			NORMAL,
-			SIN
-		};			        /* ----------  end of enum ETIO_FUN  ---------- */
-		typedef enum ETIO_FUN ETIO_FUN;
-
-		enum CHANMODE 
-		{
-			CLOSE   =        0,
-			ECT     =        1,
-			FECT    =        2,
-			EMS     =        3
-		};				/* ----------  end of enum CHANMODE  ---------- */
-
-		typedef enum CHANMODE CHANMODE;
-
-		static Device* Instance();
-
-		/*-----------------------------------------------------------------------------
-		 *  Get module version
-		 *-----------------------------------------------------------------------------*/
-		int Get_Module_Version();
-		int Get_FPGA_Version();
-		/*-----------------------------------------------------------------------------
-		 *  Operation function of Par , the parameters of ECT board
-		 *-----------------------------------------------------------------------------*/
-		bool Init_ET_Board();
-		void UnInit_ET_Board();
-		void Init_Par_Default_Value();
-
-		void Write_Para_Func(ETIO_FUN);
-		void Write_Para_Frequence_Value(int chan,int value);
-		void Write_Para_HiFilter(int chan,int value);
-		void Write_Para_LowFilter(int chan,int value);
-		void Write_Para_SignalWave(int value);
-		void Write_Para_HDGain(int chan,int value);
-
-		void Write_Para_DriverBal(int chan,int value);
-
-		void Write_Para_DriveA_ID(int chan,int value);
-		void Write_Para_PickA_ID(int chan,int value);
-		void Write_Para_DriveB_ID(int chan,int value);
-		void Write_Para_PickB_ID(int chan,int value);
-
-		void Write_Para_Driver(int value);
-		void Write_Para_Offset(int value);
-		void Write_Para_SignalID(int chan,unsigned char probefun,unsigned char freqno);
-
-		void Transfer_ECT_Parameters();                    /* Transfer the ECT parameters to ECT board */
-		int Get_Data_From_ECT_2(short* databuf);           /* Get the Sample data from ECT board */
-
-		int Get_Data_From_ECT(int* databuf);	   	   /* it is the 32 bit transfer mode */
-		int Get_Data_From_ECT_Timer(int* databuf);
-		void Get_Timers_Data(int *databuf);
-		void Clean_Timers();
-
-		int Sample_Sin_Data(int*,int);
-
-		int Get_Frequence_Index(int); 
-		int Get_Frequence(int index);
-		int Get_SampDataN();                               /* Return this sample data pointers  */
-		int Get_SignalWave();                              /* In Debug mode get the signal index */
-		/*-----------------------------------------------------------------------------
-		 *  Channel parameters Setting
-		 *-----------------------------------------------------------------------------*/
-		unsigned int Calculate_New_Frequence(bool dir,int value,unsigned int step);
-
-		void Set_Para_Frequence_Value(int chan,int value);
-		void Set_Para_HiFilter(int chan,int value);
-		void Set_Para_LowFilter(int chan,int value);
-
-		void Set_Para_SignalWave(int value);
-		void Set_Para_HDGain(int chan,int value);
-
-		void Set_Para_DriverBal(int chan,int value);
-		void Set_Para_DriveA_ID(int chan,int value);
-		void Set_Para_PickA_ID(int chan,int value);
-		void Set_Para_DriveB_ID(int chan,int value);
-		void Set_Para_PickB_ID(int chan,int value);
-
-		void Set_Para_ChanMode(int chan,CHANMODE value);
-
-		void Set_Para_Driver(int value);
-		void Set_Para_Offset(int value);
-		void Set_Para_SignalID(int chan,unsigned char probe,unsigned char freqno);
-
-		void Set_Para_RF_Filter(bool);
-		/*-----------------------------------------------------------------------------
-		 *  Low IO operation
-		 *-----------------------------------------------------------------------------*/
-	   	unsigned char Read_Port(int addr);	
-		void Write_Port(int,unsigned char);
-
-		int Get_Chan_Function(int);
-	protected:
-	private:
-		/* ====================  LIFECYCLE     ======================================= */
-		Device ();                              	   /* constructor */
-		~Device ();                             	   /* destructor */
-		Device( const Device& );
-		Device& operator = (const Device&);
-
-		static const int	MAXCHAN = 128;
-
-		friend class std::auto_ptr<Device>;
-		static std::auto_ptr<Device>		m_Instance;
-
-		int*					m_IntBuf;
-
-		Etio*					m_Etio;
-}; /* -----  end of class Device  ----- */
-#endif   /* ----- #ifndef _DEVICE_H_INC  ----- */
diff --git a/src/EVA11/Filte.cpp b/src/EVA11/Filte.cpp
deleted file mode 100644
index 45d1e30..0000000
--- a/src/EVA11/Filte.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Filte.cpp
- *
- *    Description:  Implementation of 
- *
- *        Version:  1.0
- *        Created:  2013年09月11日 15时02分49秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Filte.h"
-
-Filte::Filte()
-{
-}
-
-Filte::~Filte()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Algorithm1_Data_Structure
- *  Description:  Init Algorithm1 Data Structure 
- * =====================================================================================
- */
-void Filte::Init_Algorithm1_Data_Structure()
-{
-	for ( int i = 0; i < 1024; ++i )
-	{
-		m_A1_X[i] = 0;
-		m_A1_Y[i] = 0;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Algorithm1
- *  Description:  First Calculate Algorithm 
- * =====================================================================================
- */
-void Filte::Calculate_Algorithm1(int *data,int len)
-{
-	for ( int i = 0; i < len; ++i )
-	{
-		m_A1_Y[i] = data[i];
-
-		data[i] = static_cast<int>(( ( static_cast<double>(data[i]) - m_A1_X[i] ) * 0.9) + m_A1_X[i]);
-
-		m_A1_X[i] = m_A1_Y[i];
-	}
-}
diff --git a/src/EVA11/Filte.h b/src/EVA11/Filte.h
deleted file mode 100644
index 0d75aed..0000000
--- a/src/EVA11/Filte.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Filte.h
- *
- *    Description:  For Test Filter Algorithm 
- *
- *        Version:  1.0
- *        Created:  2012年07月12日 14时01分50秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  FILTE_INC
-#define  Filte_INC
-
-class Filte
-{
-	public:
-		Filte ();                             /* constructor */
-		~Filte ();                            /* destructor  */
-
-		void Init_Algorithm1_Data_Structure();
-		void Calculate_Algorithm1(int *data,int len);
-	protected:
-
-	private:
-		int				m_A1_X[1024];
-		int				m_A1_Y[1024];
-}; /* -----  end of class Filte  ----- */
-
-#endif   /* ----- #ifndef Filte_INC  ----- */
diff --git a/src/EVA11/Fit.c b/src/EVA11/Fit.c
deleted file mode 100644
index 912beb0..0000000
--- a/src/EVA11/Fit.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  fit.c
- *
- *    Description:  This is_heap for noline fiting test
- *
- *        Version:  1.0
- *        Created:  2013年01月08日 14时49分47秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<math.h>
-#include	<gsl/gsl_vector.h> 
-#include	<gsl/gsl_matrix.h> 
-
-#include 	"FitHead.h"
-
-int expb_f(const gsl_vector* x,void* data,gsl_vector* f)
-{
-	size_t len = ((DATA *)data)->n;
-	double *x2 = ((DATA *)data)->x1;     // becareful
-	double *y2 = ((DATA *)data)->y1;
-	double *x1 = ((DATA *)data)->x2;
-	double *y1 = ((DATA *)data)->y2;
-	double *yr = ((DATA *)data)->yr;
-
-	double *sigma = ((DATA *) data)->sigma;
-
-	double a = gsl_vector_get (x, 0);
-	double b = gsl_vector_get (x, 1);
-	double c = gsl_vector_get (x, 2);
-	double d = gsl_vector_get (x, 3);
-
-	int i;
-	double Yi;
-	for (i = 0; i < len; i++)
-	{
-		Yi = a*x1[i]*b*y1[i]+a*a*x1[i]*x1[i]-x2[i]*a*x1[i]+b*a*x1[i]*y1[i]+b*b*y1[i]*y1[i]-b*y1[i]*x2[i]-a*x1[i]*x2[i]-b*y1[i]*x2[i]
-			+x2[i]*x2[i]+c*c*y1[i]*y1[i]+c*d*y1[i]*x1[i]-y2[i]*c*y1[i]+c*d*x1[i]*y1[i]+d*d*x1[i]*x1[i]-d*x1[i]*y2[i]-c*y1[i]*y2[i]-
-			d*x1[i]*y2[i]+y2[i]*y2[i];
-
-		gsl_vector_set (f, i, (Yi - yr[i])/sigma[i]);
-	}
-
-	return GSL_SUCCESS;
-}
-
-int expb_df(const gsl_vector* x,void* data,gsl_matrix* J)
-{
-	size_t len = ((DATA *)data)->n;
-	double *x2 = ((DATA *)data)->x1;
-	double *y2 = ((DATA *)data)->y1;   // becareful
-	double *x1 = ((DATA *)data)->x2;
-	double *y1 = ((DATA *)data)->y2;
-	double *sigma = ((DATA *) data)->sigma;
-
-	double a = gsl_vector_get (x, 0);
-	double b = gsl_vector_get (x, 1);
-	double c = gsl_vector_get (x, 2);
-	double d = gsl_vector_get (x, 3);
-
-	size_t i;
-	double s;
-	for (i = 0; i < len; i++)
-	{
-		s = sigma[i];
-
-		gsl_matrix_set (J, i, 0, (x1[i]*y1[i]*b+2*a*x1[i]*x1[i]-x2[i]*x1[i]+b*x1[i]*y1[i]-x1[i]*x2[i])/s);
-		gsl_matrix_set (J, i, 1, (a*x1[i]*y1[i]+a*x1[i]*y1[i]+2*y1[i]*y1[i]*b-y1[i]*x2[i]-y1[i]*x2[i])/s);
-		gsl_matrix_set (J, i, 2, (2*c*y1[i]*y1[i]+d*y1[i]*x1[i]-y1[i]*y2[i]+d*x1[i]*y1[i]-y1[i]*y2[i])/s);
-		gsl_matrix_set (J, i, 3, (c*y1[i]*x1[i]+c*x1[i]*y1[i]+2*d*x1[i]*x1[i]-x1[i]*y2[i]-x1[i]*y2[i])/s);
-	}
-
-	return GSL_SUCCESS;
-}
-
-int expb_fdf(const gsl_vector* x,void* data,gsl_vector* f,gsl_matrix* J)
-{
-	expb_f(x,data,f);
-	expb_df(x,data,J);
-	return GSL_SUCCESS;
-}
diff --git a/src/EVA11/FitHead.h b/src/EVA11/FitHead.h
deleted file mode 100644
index 303a680..0000000
--- a/src/EVA11/FitHead.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Head.h
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2013年01月08日 15时31分53秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _HEAD_INC
-#define  _HEAD_INC
-
-#include 	"inttypes.h"
-
-typedef struct
-{
-	int32_t n;
-	double* x1;
-	double* y1;
-	double* x2;
-	double* y2;
-	double* yr;
-	double* sigma;
-} DATA;
-
-const double pi = 3.1415926;
-
-#endif   /* ----- #ifndef _HEAD_INC  ----- */
diff --git a/src/EVA11/FreeType.cpp b/src/EVA11/FreeType.cpp
deleted file mode 100644
index fe7c99b..0000000
--- a/src/EVA11/FreeType.cpp
+++ /dev/null
@@ -1,468 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  FreeType.cpp
- *
- *    Description:  Implementation of FreeType class 
- *
- *        Version:  1.0
- *        Created:  2012年10月16日 14时25分04秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	"FreeType.h"
-#include 	"Graphic.h"
-
-#include 	<wchar.h>
-#include 	<locale>
-#include 	"assert.h"
-
-#include 	"ConvertCode.h"
-
-#include 	<boost/foreach.hpp>     /* becareful this is boost library */
-
-class FreeType::Impl
-{
-public:
-	FT_Library 		m_library;
-	FT_Face 		m_face;
-	FT_GlyphSlot 		m_slot;
-	int 			m_lastp;
-	ConvertCode*		m_CC;
-
-	int			m_scrw;
-	int			m_scrh;
-	Graphic*		m_g;
-
-	short 			m_fgcolor_R;
-	short 			m_fgcolor_G;
-	short 			m_fgcolor_B;
-
-	short			m_bgcolor_R;
-	short			m_bgcolor_G;
-	short			m_bgcolor_B;
-
-	int			m_fontsize;
-	bool			m_bTranspare;
-};
-
-std::auto_ptr<FreeType> FreeType::m_Instance;
-
-FreeType::FreeType () : m_pimpl(new Impl)
-{
-}
-
-FreeType::~FreeType ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-FreeType* FreeType::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new FreeType() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_FreeType
- *  Description:  Call this function when init freetype 
- * =====================================================================================
- */
-bool FreeType::Init_FreeType(Graphic& g,const char* path)
-{
-	int error;
-	m_pimpl->m_CC = ConvertCode::Instance();
-	if ( !m_pimpl->m_CC->Init_CodeConvert("gb18030","WCHAR_T") )  
-	{
-		perror("Can't Init Convert Code");
-		return false;
-	}
-
-	error = FT_Init_FreeType(&(m_pimpl->m_library));
-	if ( error )
-	{
-		perror("Can't Init FreeType Library");
-		return false;
-	}
-	error = FT_New_Face(m_pimpl->m_library,
-			    path,
-			    0,
-			    &(m_pimpl->m_face));
-	if ( error == FT_Err_Unknown_File_Format )
-	{
-		perror("Unknown File Format");
-		return false;
-	}
-	else if ( error )
-	{
-		perror("Other File error");
-		return false;
-	}
-
-	m_pimpl->m_fontsize      = 10;
-
-	error = FT_Set_Pixel_Sizes(m_pimpl->m_face,
-			m_pimpl->m_fontsize,
-			0
-			);
-
-	error = FT_Select_Charmap( m_pimpl->m_face,FT_ENCODING_UNICODE);
-	m_pimpl->m_slot = m_pimpl->m_face->glyph;
-
-	m_pimpl->m_scrw		= 	g.Get_Screen_Width();
-	m_pimpl->m_scrh  	= 	g.Get_Screen_Height();
-	m_pimpl->m_g		= 	&g;
-
-	m_pimpl->m_bgcolor_R	=       0;
-	m_pimpl->m_bgcolor_G	=       0;
-	m_pimpl->m_bgcolor_B	=       0;
-
-	m_pimpl->m_fgcolor_R	= 	(g.RGB24_16(0xff0000)>>11) & 0x1f;
-	m_pimpl->m_fgcolor_G	= 	((g.RGB24_16(0xff0000))>>5) & 0x3f;
-	m_pimpl->m_fgcolor_B	= 	g.RGB24_16(0xff0000) & 0x1f;
-
-	m_pimpl->m_bTranspare   =       false;
-
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_FreeType
- *  Description:  Destroy the FreeType library 
- * =====================================================================================
- */
-void FreeType::Destroy_FreeType()
-{
-	m_pimpl->m_CC->Destory_CodeConvert();
-	FT_Done_Face(m_pimpl->m_face);
-	FT_Done_FreeType(m_pimpl->m_library);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Text_One_Char
- *  Description:  Just Show One Charactor 
- * =====================================================================================
- */
-int FreeType::Text_One_Char(int& x,int& y,FT_ULong word)
-{
-	int error;
-	FT_UInt glyph_index = FT_Get_Char_Index(m_pimpl->m_face,word);
-
-	error = FT_Load_Glyph(m_pimpl->m_face,
-			      glyph_index,
-			      FT_LOAD_FORCE_AUTOHINT);
-//			      FT_LOAD_DEFAULT|FT_LOAD_NO_HINTING);
-
-	if 	( error )
-	{
-		perror("Load Glyph error");
-		return 0;
-	}
-
-	error = FT_Render_Glyph(m_pimpl->m_face->glyph,FT_RENDER_MODE_NORMAL);
-	if 	( error )
-	{
-		perror("Render Glyph error");
-		return 0;
-	}
-
-	for ( int j=0;j<m_pimpl->m_slot->bitmap.rows;j++ )
-	{
-		for ( int i=0;i<m_pimpl->m_slot->bitmap.width;i++ )
-		{
-			Set_One_Pixel(x+m_pimpl->m_slot->bitmap_left+i,y-m_pimpl->m_slot->bitmap_top+j,m_pimpl->m_slot->bitmap.buffer[i+j*m_pimpl->m_slot->bitmap.width]);
-		}
-	}
-
-	x += m_pimpl->m_slot->advance.x>>6;
-	y += m_pimpl->m_slot->advance.y>>6;
-
-	return 1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_One_Pixel
- *  Description:  Set the one pixel of screen 
- * =====================================================================================
- */
-void FreeType::Set_One_Pixel(const int x,const int y,const short value)
-{
-	unsigned char *loc = m_pimpl->m_g->Get_Screen_Ptr() + (y * m_pimpl->m_scrw * 2 + x * 2);
-	if 	( value == 0 )
-	{
-		if ( m_pimpl->m_bTranspare == false )
-			*(unsigned short *)loc = Create_BG_Color(0xff); 
-	}
-	else
-		*(unsigned short *)loc = Create_FG_Color(value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Color
- *  Description:  Set the Color of FreeType 
- * =====================================================================================
- */
-void FreeType::Set_Color(ESETCOLOR type,short color)
-{
-	switch ( type ) 
-	{
-		case FreeType::BGCOLOR: 
-			{
-				m_pimpl->m_bgcolor_R = (color >> 11) & 0x1f;
-				m_pimpl->m_bgcolor_G = ( color >> 5 ) & 0x3f; 
-				m_pimpl->m_bgcolor_B = color & 0x1f; 
-			}
-			break;
-
-		case FreeType::FGCOLOR:
-			{
-				m_pimpl->m_fgcolor_R = (color >> 11) & 0x1f;
-				m_pimpl->m_fgcolor_G = ( color >> 5 ) & 0x3f; 
-				m_pimpl->m_fgcolor_B = color & 0x1f; 
-			}
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Create_Color of background color or forground color
- *  Description:  Acoordinate the gray index to create new color 
- * =====================================================================================
- */
-short FreeType::Create_FG_Color(const uint8_t value )
-{
-	uint16_t r = ((( m_pimpl->m_fgcolor_R - m_pimpl->m_bgcolor_R ) * value) >> 8) + m_pimpl->m_bgcolor_R;
-	uint16_t g = ((( m_pimpl->m_fgcolor_G - m_pimpl->m_bgcolor_G ) * value) >> 8) + m_pimpl->m_bgcolor_G;
-	uint16_t b = ((( m_pimpl->m_fgcolor_B - m_pimpl->m_bgcolor_B ) * value) >> 8) + m_pimpl->m_bgcolor_B;
-	return  ( r << 11 ) + ( g << 5 ) + b;
-}
-short FreeType::Create_BG_Color(const uint8_t value )
-{
-	uint16_t r = ( m_pimpl->m_bgcolor_R * value ) >> 8 ;
-	uint16_t g = ( m_pimpl->m_bgcolor_G * value ) >> 8 ;
-	uint16_t b = ( m_pimpl->m_bgcolor_B * value ) >> 8 ;
-	return  ( r << 11 ) + ( g << 5 ) + b;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Text_Char
- *  Description:  Text char out 
- * =====================================================================================
- */
-void FreeType::Text_Char(const int& x,const int& y,const wchar_t* str)
-{
-	int px = x;
-	int py = y;
-	size_t len = wcslen(str);
-	for ( size_t i=0;i<len;i++ )
-	{
-		Text_One_Char(px,py,FT_ULong(str[i]));
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Font_Size
- *  Description:  Set the font size 
- * =====================================================================================
- */
-void FreeType::Set_Font_Size( int value )
-{
-	int error;
-	m_pimpl->m_fontsize = value;
-	error = FT_Set_Pixel_Sizes(m_pimpl->m_face,
-			m_pimpl->m_fontsize,
-			0
-			);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Transparce
- *  Description:  Set the Transparece of class 
- * =====================================================================================
- */
-void FreeType::Set_Transparce(bool value) 
-{ 
-	m_pimpl->m_bTranspare = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Transparce
- *  Description:  Get the Transparece status 
- * =====================================================================================
- */
-bool FreeType::Get_Transparce()
-{
-	return m_pimpl->m_bTranspare;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  utf8towcs
- *  Description:  Convert utf8 char to wchat_t 
- * =====================================================================================
- */
-bool FreeType::utf8towcs(const uint8_t *utf8, size_t length, wchar_t* outbuf)
-{
-	if(!utf8 || length == 0) return true;
-	const uint8_t* pc = (const uint8_t*)utf8;
-	const uint8_t* last = pc + length;
-	uint b;
-	uint num_errors = 0;
-	int i = 0;
-	while (pc < last)
-	{
-		b = *pc++;
-
-		if( !b ) break; // 0 - is eos in all utf encodings
-
-		if ((b & 0x80) == 0)
-		{
-			//1-byte sequence: 000000000xxxxxxx = 0xxxxxxx
-				;
-		}
-		else if ((b & 0xe0) == 0xc0)
-		{
-			// 2-byte sequence: 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
-			if(pc == last) { outbuf[i++]='?'; ++num_errors; break; }
-			b = (b & 0x1f) << 6;
-			b |= (*pc++ & 0x3f);
-		}
-		else if ((b & 0xf0) == 0xe0)
-		{
-			// 3-byte sequence: zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
-			if(pc >= last - 1) { outbuf[i++]='?'; ++num_errors; break; }
-
-			b = (b & 0x0f) << 12;
-			b |= (*pc++ & 0x3f) << 6;
-			b |= (*pc++ & 0x3f);
-			if(b == 0xFEFF &&
-					i == 0) // bom at start
-				continue; // skip it
-		}
-		else if ((b & 0xf8) == 0xf0)
-		{
-			// 4-byte sequence: 11101110wwwwzzzzyy + 110111yyyyxxxxxx = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
-			if(pc >= last - 2) { outbuf[i++]='?'; break; }
-
-			b = (b & 0x07) << 18;
-			b |= (*pc++ & 0x3f) << 12;
-			b |= (*pc++ & 0x3f) << 6;
-			b |= (*pc++ & 0x3f);
-			// b shall contain now full 21-bit unicode code point.
-			assert((b & 0x1fffff) == b);
-			if((b & 0x1fffff) != b)
-			{
-				outbuf[i++]='?';
-				++num_errors;
-				continue;
-			}
-			if( sizeof(wchar_t) == 16 ) // Seems like Windows, wchar_t is utf16 code units sequence there.
-			{
-				outbuf[i++] = wchar_t(0xd7c0 + (b >> 10));
-				outbuf[i++] = wchar_t(0xdc00 | (b & 0x3ff));
-			}
-			else if( sizeof(wchar_t) >= 21 ) // wchar_t is full ucs-4
-			{
-				outbuf[i++] = wchar_t(b);
-			}
-			else
-			{
-				assert(0); // what? wchar_t is single byte here?
-			}
-		}
-		else
-		{
-			assert(0); //bad start for UTF-8 multi-byte sequence"
-			++num_errors;
-			b = '?';
-		}
-		outbuf[i++] = wchar_t(b);
-	}
-	return num_errors == 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Text
- *  Description:  Draw the text on screen 
- * =====================================================================================
- */
-void FreeType::Text(int x,int y,const char* str)
-{
-	int len = strlen(str);
-	int rc = ((len+1)<<2);                           // 4 *  length is the unicode code number
-	wchar_t *wout = new wchar_t[rc]; 
-
-	char *cstr = new char[len+1];
-	for ( int i=0;i<=len;i++ )
-	{
-		cstr[i] = str[i];        		 //  include the '\0' charactor
-	}
-
-	if ( m_pimpl->m_CC->Code_Convert(cstr,len+1,(char *)wout,rc) == true )   // len+1 : because need to point out the end of string
-		Text_Char(x,y,wout);
-	else 
-		perror("Can't convert charactor");
-
-	delete[] wout;
-	wout = NULL;
-
-	delete[] cstr;
-	cstr = NULL;
-}
-
-//void  FreeType::Test(Graphic& g)
-//{
-//	char utf_16le[] = "中国GB中华人民共和国"; 
-//	char out[100];
-//	int rc;
-//
-//	ConvertCode* cc = ConvertCode::Instance();
-//	if ( cc->Init_CodeConvert("utf-8","gbk") )  // utf-8   gb18030>gbk>gb2312   UCS-2LE
-//	{
-//		cc->Code_Convert(utf_16le,sizeof(utf_16le),out,100);
-//		g.Textout(100,20,out,g_BUTXNO_CO,g_BUBGNO_CO);
-//		cc->Destory_CodeConvert();
-//	}
-
-
-//	char utf_16le[] = TEST; 
-//	char out[100];
-//	int rc=100;
-//	wchar_t wout[100];
-//
-//	ConvertCode* cc = ConvertCode::Instance();
-//	if ( cc->Init_CodeConvert("gb18030","WCHAR_T") )  
-//	{
-//		if ( cc->Code_Convert(utf_16le,sizeof(utf_16le),(char *)wout,rc) == true )
-//		{
-//			Text_Char(300,50,wout);
-//		}
-//		else 
-//			printf ( "BAD\n" );
-//		cc->Destory_CodeConvert();
-//	}
-//}
diff --git a/src/EVA11/FreeType.h b/src/EVA11/FreeType.h
deleted file mode 100644
index 9c554e6..0000000
--- a/src/EVA11/FreeType.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  FreeType.h
- *
- *    Description:  Manage freetype fonts 
- *
- *        Version:  1.0
- *        Created:  2012年10月16日 14时23分30秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  FREETYPE_INC
-#define  FREETYPE_INC
-
-#include 	<memory>
-
-#include 	<ft2build.h>
-#include 	<freetype/freetype.h>                       /* Becareful the head file define from FT_MACRO  */
-#include 	<stdint.h>
-
-class Graphic;
-class FreeType
-{
-	public:
-		typedef enum
-		{
-			BGCOLOR,
-			FGCOLOR,
-		} ESETCOLOR;
-
-		static FreeType* Instance();                /* only used this function to visit variables   */
-
-		bool Init_FreeType(Graphic& g,const char* path);
-		void Destroy_FreeType();
-
-		void Text_Char(const int &x,const int &y,const wchar_t* str);
-		void Set_Color(ESETCOLOR type,short color);
-		void Set_Transparce(bool value);
-		bool Get_Transparce();
-		void Set_Font_Size( int value );
-		void Text(int x,int y,const char*);
-
-//		void  Test(Graphic& g);
-	protected:
-
-	private:
-		FreeType ();
-		~FreeType ();
-		FreeType (const FreeType&);
-		FreeType& operator = (const FreeType&);
-
-		int Text_One_Char(int& x,int& y,FT_ULong word);
-		void Set_One_Pixel(const int x,const int y,const short value);
-
-		inline short Create_FG_Color(const uint8_t value );
-		inline short Create_BG_Color(const uint8_t value );
-
-		bool utf8towcs(const uint8_t *utf8, size_t length, wchar_t* outbuf);
-	private:
-		friend class std::auto_ptr<FreeType>;
-		static std::auto_ptr<FreeType>		m_Instance;
-
-		class Impl;
-		std::auto_ptr<class Impl>		m_pimpl;
-};
-#endif
diff --git a/src/EVA11/GUILowCode.hpp b/src/EVA11/GUILowCode.hpp
deleted file mode 100644
index 0dca1a5..0000000
--- a/src/EVA11/GUILowCode.hpp
+++ /dev/null
@@ -1,850 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  GUILowCode.hpp
- *
- *    Description:  Recreate the GUILowCode class with template
- *                  and with the singleton pattern 
- *                  it is a template file
- *
- *        Version:  1.0
- *        Created:  2012年08月10日 17时09分48秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  GUILowCode_inc
-#define  GUILowCode_inc
-
-#include 	<fcntl.h> 
-#include        <unistd.h> 
-#include        <sys/ioctl.h>
-#include 	<memory>
-#include        <linux/fb.h> 
-#include 	<sys/mman.h> 
-#include 	<inttypes.h>
-
-/*-----------------------------------------------------------------------------
- *  BP type:    16bit: uint16_t 
- *       	 8bit: uint8_t 
- *       	 1bit: bool
- *-----------------------------------------------------------------------------*/
-class GUIInterface;
-template <typename BP>
-class GUILowCode
-{
-	public:
-		typedef enum
-		{
-			MODE_SRC,
-			MODE_SRC_XOR_DST,
-		} CopyMode;
-
-		static GUILowCode* Instance();
-
-		void Init_GUILowCode_Parameters(int,int,int,int,uint8_t*,uint8_t*,GUILowCode<BP>::CopyMode);
-
-		void Setpixel(int,int,BP);
-		void Line(int,int,int,int,BP);
-		void Dot_Line(int,int,int,int,BP);
-		void HLine_Fast(int,int,int,BP);
-
-		void Set_Area_Color(int,int,int,int,BP);
-		void Rectangle(int,int,int,int,BP);
-		void DrawRect(int,int,int,int,BP);
-
-		void Screen_Copy(int left,int up,int right,int down,int flag);
-		void Switch_Screen();
-
-		int Get_Disp_Area_Bytes(int left,int up,int right,int down);
-
-		void Movemem(short,short,short,short);
-		void MovememH(short,short,short,short,int);
-
-		void SetMode(CopyMode m);
-		CopyMode GetMode();
-	protected:
-
-	private:
-		GUILowCode ();
-		~GUILowCode ();
-		GUILowCode ( const GUILowCode& );
-		GUILowCode& operator = ( const GUILowCode& );
-
-		friend class std::auto_ptr< GUILowCode<BP> >;
-		static std::auto_ptr< GUILowCode<BP> >		m_Instance;
-
-		void draw_xish_line(int x,int y,int dx,int dy,int xdir,BP color);
-		void draw_yish_line(int x,int y,int dx,int dy,int ydir,BP color);
-
-		void draw_xdot_line(int x,int y,int dx,int dy,int xdir,BP color);
-		void draw_ydot_line(int x,int y,int dx,int dy,int xdir,BP color);
-
-		void WholeCircle(int,int,int,int,BP);
-		void Plot_Circle(int,int,int,int,BP,double);
-		void Word_Memcpy(uint8_t *des,uint8_t *src,int len);
-
-	private:
-		friend	class 					GUIInterface;
-		int						m_Screen_Width;
-		int						m_Screen_Height;
-		int						m_BPP;
-		int						m_BPP_Shift;
-		int						m_Buffer_Len;
-		uint8_t					       *m_Ptr;
-		uint8_t					       *m_Shadow_Ptr;
-		CopyMode					Mode;
-};
-
-template <typename BP>
-std::auto_ptr< GUILowCode<BP> > GUILowCode<BP>::m_Instance;
-
-template <typename BP>
-GUILowCode<BP>::GUILowCode()
-{
-}
-
-template <typename BP>
-GUILowCode<BP>::~GUILowCode()
-{
-}
-
-template <typename BP>
-GUILowCode<BP>* GUILowCode<BP>::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new GUILowCode<BP> );
-	}
-	return m_Instance.get();
-}
-
-template <typename BP>
-void GUILowCode<BP>::Init_GUILowCode_Parameters(int w,int h,int bpp,int len,uint8_t* ptr,uint8_t* show_ptr,CopyMode mode)
-{
-	m_Screen_Width 	= w;
-	m_Screen_Height	= h;
-	m_BPP		= bpp;
-
-	if 	( m_BPP == 1 )
-		m_BPP_Shift = 0;
-	else if ( m_BPP == 8 )
-		m_BPP_Shift = 1;
-	else if ( m_BPP == 16 )
-		m_BPP_Shift = 2;
-	else 
-		printf ( "BPP is not 1,8,16" );
-
-	m_Buffer_Len    = len;
-	m_Ptr		= ptr;
-	m_Shadow_Ptr    = show_ptr;
-	Mode		= mode;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Setpixel
- *  Description:  Draw a pixel on screen
- * =====================================================================================
- */
-template <>
-void GUILowCode<uint16_t>::Setpixel(int x,int y,uint16_t color)
-{
-	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
-	    return;
-
-	switch ( Mode )
-	{
-		case MODE_SRC:
-			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) = color; 
-			break;
-		case MODE_SRC_XOR_DST:
-			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) ^= color;
-			break;
-		default:	
-			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) = color;
-			break;
-	}
-}
-
-template <>
-void GUILowCode<uint8_t>::Setpixel(int x,int y,uint8_t color)
-{
-	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
-	    return;
-
-	switch ( Mode )
-	{
-		case MODE_SRC:
-			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) = color;
-			break;
-		case MODE_SRC_XOR_DST:
-			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) ^= color;
-			break;
-		default:	
-			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) = color;
-			break;
-	}
-}
-
-static uint8_t masktab[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
-template <>
-void GUILowCode<bool>::Setpixel(int x,int y,bool color)
-{
-	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
-	    return;
-
-	switch ( Mode )
-	{
-		case MODE_SRC:
-			if ( color == true )
-				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) |= masktab[x&0x07];
-			else               
-				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) &= ~masktab[x&0x07];
-			break;
-		case MODE_SRC_XOR_DST:
-			if ( color == true )
-				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) ^= masktab[x&0x07];
-			break;
-		default:
-			if ( color == true )
-				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) |= masktab[x&0x07];
-			else               
-				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) &= ~masktab[x&0x07];
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  HLine_Fast
- *  Description:  Fast Draw H-Line 
- * =====================================================================================
- */
-template <>
-void GUILowCode<uint16_t>::HLine_Fast(int x1,int x2,int y,uint16_t color)
-{
-	uint16_t *loc = (uint16_t *)( m_Ptr + ( ( y * m_Screen_Width ) << 1) );
-	for ( int i=x1;i<=x2;i++ )
-		*(loc+i) = color; 
-}
-template <>
-void GUILowCode<uint8_t>::HLine_Fast(int x1,int x2,int y,uint8_t color)
-{
-	uint8_t * loc = m_Ptr + ( y * m_Screen_Width );
-	if ( (x1&0x0001) )
-	{
-		*(loc + x1) = color;
-	}
-	else
-	{
-		*((uint16_t *)( loc ) + (x1>>1) ) = ( color<<8 ) | color;
-	}
-	if ( (x2&0x0001) )
-	{
-		*((uint16_t *)( loc ) + (x2>>1) ) = ( color<<8 ) | color;
-	}
-	else 
-	{
-		*(loc + x2) = color;
-	}
-	for ( int index = (x1>>1)+1;index < (x2>>1);index ++ ) 
-	{
-		*((uint16_t *)(loc) + index ) = ( color<<8 ) | color;
-	}
-}
-template <>
-void GUILowCode<bool>::HLine_Fast(int x1,int x2,int y,bool color)
-{
-	int x1_m = ( x1 >> 3 ) + 1;
-	int x2_m = x2 >> 3;
-	int x1_r = x1 & 0x0007;
-	int x2_r = x2 & 0x0007;
-
-	uint8_t * loc = m_Ptr + y * ( m_Screen_Width >> 3 );
-
-	if 	( color == true )
-	{
-		for ( int i=x1_m;i<x2_m;i++ )
-		{
-			*(loc+i) |= 0xff; 
-		}
-		if ( x2_m >= x1_m )
-		{
-			*(loc+x1_m-1) |= ( 0xff >> x1_r ); 
-			*(loc+x2_m)   |= ( 0xff << ( 7 - x2_r ) ); 
-		}
-		else
-		{
-			Line(x1,y,x2,y,color);
-		}
-	}
-	else
-	{
-		for ( int i=x1_m;i<x2_m;i++ )
-		{
-			*(loc+i) &= 0x00; 
-		}
-		if ( x2_m >= x1_m )
-		{
-			*(loc+x1_m-1) &= ~( 0xff >> x1_r ); 
-			*(loc+x2_m)   &= ~( 0xff << ( 7 - x2_r ) ); 
-		}
-		else
-		{
-			Line(x1,y,x2,y,color);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Area_Color
- *  Description:  Set the area's color 
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Set_Area_Color(int x1,int y1,int x2,int y2,BP color)
-{
-	for (int i=y1;i<=y2;i++ )
-	{
-		HLine_Fast(x1,x2,i,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  darw_xish_line
- *  Description:  Draw line on screen depending on the x y
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::draw_xish_line(int x,int y,int dx,int dy,int xdir,BP color)
-{
-	int dyX2=dy*2;
-	int dyX2mdxX2=dyX2-(dx*2);
-	int error=dyX2-dx;
-	Setpixel(x, y, color);
-	while (dx--) 
-	{
-		if (error >= 0) 
-		{
-			y++;
-			error += dyX2mdxX2;
-		}
-		else 
-		{
-			error += dyX2;
-		}
-		x += xdir;
-		Setpixel(x,y,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  darw_xdot_line
- *  Description:  Draw Dot line on screen depending on the x y
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::draw_xdot_line(int x,int y,int dx,int dy,int xdir,BP color)
-{
-	int dyX2=dy*2;
-	int dyX2mdxX2=dyX2-(dx*2);
-	int error=dyX2-dx;
-
-	int maxspace = 1;
-	int space = maxspace;
-
-	Setpixel(x, y, color);
-	while (dx--) 
-	{
-		if (error >= 0) 
-		{
-			y++;
-			error += dyX2mdxX2;
-		}
-		else 
-		{
-			error += dyX2;
-		}
-		x += xdir;
-
-		if ( space == 0 )
-		{
-			Setpixel(x,y,color);
-			space = maxspace;
-		}
-		else
-			space --;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  darw_yish_line
- *  Description:  Draw line on screen depending on the x y
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::draw_yish_line(int x,int y,int dx,int dy,int xdir,BP color)
-{
-	int dxX2=dx*2;
-	int dxX2mdyX2=dxX2-(dy*2);
-	int error=dxX2-dy;
-	Setpixel(x, y,color);
-	while (dy--) 
-	{
-		if (error >= 0) 
-		{
-			x+= xdir;
-			error += dxX2mdyX2;
-		} else 
-		{
-			error += dxX2;
-		}
-		y++;
-		Setpixel(x,y,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  darw_ydot_line
- *  Description:  Draw Dot line on screen depending on the x y
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::draw_ydot_line(int x,int y,int dx,int dy,int xdir,BP color)
-{
-	int dxX2=dx*2;
-	int dxX2mdyX2=dxX2-(dy*2);
-	int error=dxX2-dy;
-
-	int maxspace = 1;
-	int space = maxspace;
-
-	Setpixel(x, y,color);
-	while (dy--) 
-	{
-		if (error >= 0) 
-		{
-			x+= xdir;
-			error += dxX2mdyX2;
-		} else 
-		{
-			error += dxX2;
-		}
-		y++;
-
-		if ( space == 0 )
-		{
-			Setpixel(x,y,color);
-			space = maxspace;
-		}
-		else
-			space --;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Line
- *  Description:  Draw a line on screen, (x1 y1) (x2 y2)  with color
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Line(int x1,int y1,int x2,int y2,BP color)
-{
-	int dx,dy;
-	if ( y1 > y2) 
-	{
-		int t = y1;
-		y1 = y2;
-		y2 = t;
-		t = x1;
-		x1 = x2;
-		x2 = t;
-	}
-	dx = x2-x1;
-	dy = y2-y1;
-	if (dx > 0) 
-	{
-		if (dx > dy)
-			draw_xish_line(x1, y1, dx, dy, 1,color);
-		else
-			draw_yish_line(x1, y1, dx, dy, 1,color);
-	} 
-	else 
-	{
-		dx = -dx;
-		if (dx > dy)
-			draw_xish_line(x1, y1, dx, dy, -1,color);
-		else
-			draw_yish_line(x1, y1, dx, dy, -1,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Dot_Line
- *  Description:  Draw a dot line on screen, (x1 y1) (x2 y2)  with color
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Dot_Line(int x1,int y1,int x2,int y2,BP color)
-{
-	int dx,dy;
-	if ( y1 > y2 )
-	{
-		int t = y1;
-		y1 = y2;
-		y2 = t;
-		t = x1;
-		x1 = x2;
-		x2 = t;
-	}
-	dx = x2-x1;
-	dy = y2-y1;
-	if (dx > 0) 
-	{
-		if (dx > dy)
-			draw_xdot_line(x1, y1, dx, dy, 1,color);
-		else
-			draw_ydot_line(x1, y1, dx, dy, 1,color);
-	} 
-	else 
-	{
-		dx = -dx;
-		if (dx > dy)
-			draw_xdot_line(x1, y1, dx, dy, -1,color);
-		else
-			draw_ydot_line(x1, y1, dx, dy, -1,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Rectangle
- *  Description:  Draw a ractangel on screen
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Rectangle(int x1,int y1,int x2,int y2,BP color)
-{
-	Line(x1,y1,x2,y1,color);
-	Line(x2,y1,x2,y2,color);
-	Line(x2,y2,x1,y2,color);
-	Line(x1,y2,x1,y1,color);
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawRect
- *  Description:  Draw the Rectangle sharp 
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::DrawRect(int x,int y,int width,int height,BP color)
-{
-	Rectangle(x,y,x+width-1,y+height-1,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  WholeCircle
- *  Description:  The second circle drawing meathod
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::WholeCircle(int xc,int yc,int x,int y,BP color)
-{
-	Setpixel(xc+x,yc+y,color);
-	Setpixel(xc-x,yc+y,color);
-	Setpixel(xc+x,yc-y,color);
-	Setpixel(xc-x,yc-y,color);
-
-	Setpixel(xc+y,yc+x,color);
-	Setpixel(xc-y,yc+x,color);
-	Setpixel(xc+y,yc-x,color);
-	Setpixel(xc-y,yc-x,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Plot_Circle
- *  Description:  Used for Drawing ecllipse GUILowCode 
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Plot_Circle(int x,int y,
-		 	      int x_center,int y_center,
-		 	      BP co,double ratio)
-{
-	int startx,endx,x1,starty,endy,y1;
-	starty=static_cast<int>(y*ratio); endy=static_cast<int>((y+1)*ratio);
-	startx=static_cast<int>(x*ratio); endx=static_cast<int>((x+1)*ratio);
-	for (x1=startx;x1<endx;++x1)
-	{
-		Setpixel(x1+x_center,y+y_center,co);
-		Setpixel(x1+x_center,-y+y_center,co);
-		Setpixel(-x1+x_center,-y+y_center,co);
-		Setpixel(-x1+x_center,y+y_center,co);
-	}
-	for (y1=starty;y1<endy;++y1)
-	{
-		Setpixel(y1+x_center,x+y_center,co);
-		Setpixel(y1+x_center,-x+y_center,co);
-		Setpixel(-y1+x_center,-x+y_center,co);
-		Setpixel(-y1+x_center,x+y_center,co);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Screen
- *  Description:  Switch the screen ptr 
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Switch_Screen()
-{
-	uint8_t *temp;
-	temp = m_Shadow_Ptr;	
-	m_Shadow_Ptr = m_Ptr;
-	m_Ptr = temp;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Word_Memcpy
- *  Description:  Copy memory to showmemory as word length
- * =====================================================================================
- */
-template <>
-void GUILowCode<uint16_t>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
-{
-	uint16_t *des_w,*src_w;
-	len = len >> 1;
-	des_w = (uint16_t *)des;
-	src_w = (uint16_t *)src;
-	while(len--)
-		*des_w++ = *src_w++;
-}
-
-template <>
-void GUILowCode<uint8_t>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
-{
-	if ( len == 1 )
-		while(len--)
-			*des++ = *src++;
-	else
-	{
-		uint16_t *des_w,*src_w;
-		int sub=0;
-		if ( ((int)des & 0x0001) )
-		{
-			*des = *src;
-			sub++;
-			des_w = (uint16_t *)(des+1);
-			src_w = (uint16_t *)(src+1);
-		}
-		else
-		{
-			*des     = *src;
-			*(des+1) = *(src+1);
-			sub += 2;
-			des_w = (uint16_t *)(des+2);
-			src_w = (uint16_t *)(src+2);
-		}
-		if ( ( (int)( des + len - 1 ) & 0x0001 ) )
-		{
-			*(des + len - 2) = *(src + len - 2);
-			*(des + len - 1) = *(src + len - 1);
-			sub += 2;
-		}
-		else
-		{
-			*(des + len - 1) = *(src + len - 1);
-			sub++;
-		}
-		len = ((len - sub) >> 1);
-		while(len--)
-			*des_w++ = *src_w++;
-	}
-}
-
-template <>
-void GUILowCode<bool>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Screen_Copy
- *  Description:  Screen Copy function for copy scr buffer to scr shadow buffer 
- *  	   Flag: false shadow->real
- *               true  real->shadow
- * =====================================================================================
- */
-template <typename BP>
-void GUILowCode<BP>::Screen_Copy(int left,int up,int right,int down,int flag)
-{
-	if 	( flag == false )
-	{
-		for ( int i = up;i <= down;i ++ )
-		{
-			Word_Memcpy( m_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
-				    m_Shadow_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
-				    m_BPP_Shift * ( right - left + 1 ) );
-		}
-	}
-	else
-	{
-		for ( int i = up;i <= down;i ++ )
-		{
-			Word_Memcpy( m_Shadow_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
-				    m_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
-				    m_BPP_Shift * ( right - left + 1 ) );
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Disp_Area_Bytes
- *  Description:  Get the display area byres number
- * =====================================================================================
- */
-template <>
-int GUILowCode<uint16_t>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
-{
-	return 2 * ( right - left + 1) * ( down - up + 1 );
-}
-template <>
-int GUILowCode<uint8_t>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
-{
-	return ( right - left + 1) * ( down - up + 1 );
-}
-template <>
-int GUILowCode<bool>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
-{
-	return ( ( right - left + 1) * ( down - up + 1 ) ) >> 3;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Movemen
- *  Description:  Move GUI memory of screen 
- * =====================================================================================
- */
-template <>
-void GUILowCode<uint16_t>::Movemem(short x,short y,short height,short width)
-{
-	int nBytes;
-	int nCount;
-   	short dir = ( height<0 );
-   	if ( dir ) height = -height;
-
-	nBytes=height*m_Screen_Width*2;
-	nCount=width * 2;
-	if ( dir )  //Down Scroll
-	{ 
-		memmove(m_Ptr+((x+y*m_Screen_Width)*2)+nBytes,m_Ptr+((x+y*m_Screen_Width)*2),nCount);
-		memset(m_Ptr+((x+y*m_Screen_Width)*2),0,nCount);
-	}
-	else        //Up Scroll
-	{   
-		memmove(m_Ptr+(x+y*m_Screen_Width)*2-nBytes,m_Ptr+(x+y*m_Screen_Width)*2,nCount);
-		memset(m_Ptr+((x+y*m_Screen_Width)*2),0,nCount);
-	}
-}
-template <>
-void GUILowCode<uint8_t>::Movemem(short x,short y,short height,short width)
-{
-	int nBytes;
-	int nCount;
-   	short dir = ( height<0 );
-   	if ( dir ) height = -height;
-
-	nBytes=height*m_Screen_Width*1;
-	nCount=width * 1;
-	if ( dir )  //Down Scroll
-	{ 
-		memmove(m_Ptr+((x+y*m_Screen_Width)*1)+nBytes,m_Ptr+((x+y*m_Screen_Width)*1),nCount);
-		memset(m_Ptr+((x+y*m_Screen_Width)*1),0,nCount);
-	}
-	else        //Up Scroll
-	{   
-		memmove(m_Ptr+(x+y*m_Screen_Width)*1-nBytes,m_Ptr+(x+y*m_Screen_Width)*1,nCount);
-		memset(m_Ptr+((x+y*m_Screen_Width)*1),0,nCount);
-	}
-}
-template <>
-void GUILowCode<bool>::Movemem(short x,short y,short height,short width)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  MovemenH
- *  Description:  Move GUI memory of horizon screen 
- * =====================================================================================
- */
-template <>
-void GUILowCode<uint16_t>::MovememH(short x,short y,short height,short width,int color)
-{
-	for ( int i=0; i<height; i++ )
-	{
-		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x+width)<<1))) = 
-		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x)<<1)));
-		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x)<<1))) = color; 
-	}
-}
-template <>
-void GUILowCode<uint8_t>::MovememH(short x,short y,short height,short width,int color)
-{
-	for ( int i=0; i<height; i++ )
-	{
-		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x+width)) = 
-		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x));
-		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x)) = color; 
-	}
-}
-template <>
-void GUILowCode<bool>::MovememH(short x,short y,short height,short width,int color)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SetMode
- *  Description:  SetMode of Draw Screen
- * =====================================================================================
- */
-template<typename BP>
-void GUILowCode<BP>::SetMode(CopyMode m)
-{
-	Mode = m;	
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  GetMode
- *  Description:  Return the Mode of GUILowCode class drawmode 
- *      Caution:  typename very important
- * =====================================================================================
- */
-template<typename BP>
-typename GUILowCode<BP>::CopyMode GUILowCode<BP>::GetMode()
-{
-	return Mode;
-}
-#endif
diff --git a/src/EVA11/Gif.cpp b/src/EVA11/Gif.cpp
deleted file mode 100644
index ca2f709..0000000
--- a/src/EVA11/Gif.cpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Gif.cpp
- *
- *    Description:  Imaplementation of Gif class
- *
- *        Version:  1.0
- *        Created:  2013年09月04日 10时54分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdlib>
-#include 	<cstring>
-
-#include 	<SDL.h>
-
-#include 	"Gif.h"
-#include 	"Graphic.h"
-
-#define PROGRAM_NAME	"EVA11"
-#define GIF_MESSAGE(Msg) fprintf(stderr, "\n%s: %s\n", PROGRAM_NAME, Msg)
-#define GIF_EXIT(Msg)    { GIF_MESSAGE(Msg); exit(-3); }
-
-Gif::Gif() : m_DelayMSecond(100)
-{
-	g = Graphic::Instance();
-}
-
-Gif::~Gif()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Read_Gif_File
- *  Description:  Read the gif file and display it on screen  
- * =====================================================================================
- */
-void Gif::Read_Gif_File(const char* path,const int& x,const int& y)
-{
-	int Error;
-    	int Size, Row, Col, Width, Height, ExtCode, Count;
-	GifRecordType RecordType;
-	GifByteType *Extension;
-	GifRowType *ScreenBuffer;
-	GifFileType *GifFile;
-	ColorMapObject *ColorMap;
-	int
-		InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */
-		InterlacedJumps[] = { 8, 8, 4, 2 };    /* be read - offsets and jumps... */
-	int ImageNum = 0;
-
-	if ((GifFile = DGifOpenFileName(path, &Error)) == NULL) 
-	{
-		PrintGifError(Error);
-		return;
-	}
-
-	if ((ScreenBuffer = (GifRowType *)
-				malloc(GifFile->SHeight * sizeof(GifRowType))) == NULL)
-		GIF_EXIT("Failed to allocate memory required, aborted.");
-
-	Size = GifFile->SWidth * sizeof(GifPixelType);/* Size in bytes one row.*/
-	if ((ScreenBuffer[0] = (GifRowType) malloc(Size)) == NULL) /* First row. */
-		GIF_EXIT("Failed to allocate memory required, aborted.");
-
-	for (int i = 0; i < GifFile->SWidth; i++)  /* Set its color to BackGround. */
-		ScreenBuffer[0][i] = GifFile->SBackGroundColor;
-	for (int i = 1; i < GifFile->SHeight; i++) {
-		/* Allocate the other rows, and set their color to background too: */
-		if ((ScreenBuffer[i] = (GifRowType) malloc(Size)) == NULL)
-			GIF_EXIT("Failed to allocate memory required, aborted.");
-
-		memcpy(ScreenBuffer[i], ScreenBuffer[0], Size);
-	}
-
-//	unsigned char *mem = new unsigned char[g->Get_Disp_Area_Bytes(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1)];
-//	g->Load_Disp_Area(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1,mem); 	   /* save the screen graphic buffer */
-
-	/* Scan the content of the GIF file and load the image(s) in: */
-	do {
-		if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) 
-		{
-			PrintGifError(GifFile->Error);
-			break;
-		}
-		switch (RecordType) 
-		{
-			case IMAGE_DESC_RECORD_TYPE:
-				if (DGifGetImageDesc(GifFile) == GIF_ERROR) 
-				{
-					PrintGifError(GifFile->Error);
-					goto Fail_Exit;
-				}
-
-				Row = GifFile->Image.Top; /* Image Position relative to Screen. */
-				Col = GifFile->Image.Left;
-				Width = GifFile->Image.Width;
-				Height = GifFile->Image.Height;
-
-				if (GifFile->Image.Left + GifFile->Image.Width > GifFile->SWidth ||
-						GifFile->Image.Top + GifFile->Image.Height > GifFile->SHeight) 
-				{
-					fprintf(stderr, "Image %d is not confined to screen dimension, aborted.\n",0);
-					goto Fail_Exit;
-				}
-				if (GifFile->Image.Interlace) 
-				{
-					/* Need to perform 4 passes on the images: */
-					for (int i = 0; i < 4; i++)
-						for (int j = Row + InterlacedOffset[i]; j < Row + Height;
-								j += InterlacedJumps[i]) 
-						{
-							if (DGifGetLine(GifFile, &ScreenBuffer[j][Col],
-										Width) == GIF_ERROR) 
-							{
-								PrintGifError(GifFile->Error);
-								goto Fail_Exit;
-							}
-						}
-				}
-				else
-				{
-					for (int i = 0; i < Height; i++) 
-					{
-						if (DGifGetLine(GifFile, &ScreenBuffer[Row++][Col],
-									Width) == GIF_ERROR) 
-						{
-							PrintGifError(GifFile->Error);
-							goto Fail_Exit;
-						}
-					}
-				}
-
-				ColorMap = (GifFile->Image.ColorMap
-						? GifFile->Image.ColorMap
-						: GifFile->SColorMap);
-
-				if (ColorMap == NULL)
-				{
-					fprintf(stderr, "Gif Image does not have a colormap\n");
-					goto Fail_Exit;
-				}
-
-				Dump2Screen(x,y,
-					    ColorMap,
-					    ScreenBuffer, 
-					    GifFile->SWidth, 
-					    GifFile->SHeight);
-
-				SDL_Delay(m_DelayMSecond);
-
-				break;
-			case EXTENSION_RECORD_TYPE:
-				/* Skip any extension blocks in file: */
-				if (DGifGetExtension(GifFile, &ExtCode, &Extension) == GIF_ERROR) 
-				{
-					PrintGifError(GifFile->Error);
-					goto Fail_Exit;
-				}
-				while (Extension != NULL) 
-				{
-					if (DGifGetExtensionNext(GifFile, &Extension) == GIF_ERROR) 
-					{
-						PrintGifError(GifFile->Error);
-						goto Fail_Exit;
-					}
-				}
-				break;
-			case TERMINATE_RECORD_TYPE:
-				break;
-			default:		    /* Should be trapped by DGifGetRecordType. */
-				break;
-		}
-	} while (RecordType != TERMINATE_RECORD_TYPE);
-
-//	g->Restore_Disp_Area(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1,mem); /* restore the graphic buffer */
-//	delete[] mem;                                                 /* release the buffer */
-//	mem = NULL;
-
-	(void)free(ScreenBuffer);
-
-Fail_Exit:
-
-	if (DGifCloseFile(GifFile) == GIF_ERROR) 
-	{
-		PrintGifError(GifFile->Error);
-		return;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  PrintGifError
- *  Description:  Printf Error Message  
- * =====================================================================================
- */
-void Gif::PrintGifError(int ErrorCode)
-{
-	char *Err = GifErrorString(ErrorCode);
-
-	if (Err != NULL)
-		fprintf(stderr, "GIF-LIB error: %s.\n", Err);
-	else
-		fprintf(stderr, "GIF-LIB undefined error %d.\n", ErrorCode);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Dump2Screen
- *  Description:  Show Gif file on screen 
- * =====================================================================================
- */
-void Gif::Dump2Screen(int x,int y,ColorMapObject *ColorMap, GifRowType *ScreenBuffer, int ScreenWidth, int ScreenHeight)
-{
-	uint16_t *BufferP = (uint16_t *)g->Get_Screen_Ptr() + x + y * g->Get_Screen_Width();
-
-	GifRowType GifRow;
-	GifColorType *ColorMapEntry;
-	for (int i = 0; i < ScreenHeight; i++) 
-	{
-		GifRow = ScreenBuffer[i];
-		for (int j = 0; j < ScreenWidth; j++) 
-		{
-			ColorMapEntry = &(ColorMap->Colors[GifRow[j]]);
-			*BufferP++ = g->RGB24_16((ColorMapEntry->Red<<16)+(ColorMapEntry->Green<<8)+(ColorMapEntry->Blue<<0));
-		}
-		BufferP = (uint16_t *)g->Get_Screen_Ptr() + x + y * g->Get_Screen_Width() + ( i + 1 ) * g->Get_Screen_Width();
-	}
-#ifdef X86
-	g->Update_Rect(x,y,ScreenWidth,ScreenHeight);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Delay_MSecond
- *  Description:  Set Delay MSecond 
- * =====================================================================================
- */
-void Gif::Set_Delay_MSecond(int count)
-{
-	m_DelayMSecond = count;
-}
diff --git a/src/EVA11/Gif.h b/src/EVA11/Gif.h
deleted file mode 100644
index 2d18db1..0000000
--- a/src/EVA11/Gif.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Gif.h
- *
- *    Description:  Manage Gif picture process class
- *
- *        Version:  1.0
- *        Created:  2013年09月04日 10时52分57秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  GIF_INC
-#define  GIF_INC
-
-#include 	<gif_lib.h>	
-class Graphic;
-class Gif
-{
-	public:
-		Gif ();                             				/* constructor */
-		~Gif ();                            				/* destructor  */
-		void Read_Gif_File(const char* path,const int& x,const int& y);
-		void Set_Delay_MSecond(int count);
-
-	private:	
-		void PrintGifError(int ErrorCode);
-		void Dump2Screen(int x,int y,ColorMapObject *ColorMap, GifRowType *ScreenBuffer, int ScreenWidth, int ScreenHeight);
-	private:
-		Graphic*				g;
-		int					m_DelayMSecond;
-};
-
-#endif   /* ----- #ifndef GIF_INC  ----- */
diff --git a/src/EVA11/Global.cpp b/src/EVA11/Global.cpp
deleted file mode 100644
index f45af0c..0000000
--- a/src/EVA11/Global.cpp
+++ /dev/null
@@ -1,752 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Global.cpp
- *
- *    Description:  implementation of Gobal class
- *
- *        Version:  1.0
- *        Created:  2012年06月07日 09时05分33秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cmath>
-#include	<stdio.h>
-#include	<iostream>
-#include	<fstream>
-
-#include	"Global.h" 
-
-std::auto_ptr<Global> Global::m_Instance;
-
-Global::Global ()
-{
-	Tick        = 0;
-	bTickStop   = false;
-	bTickPasuse = false;
-	RunTimer.restart();
-	Time_start  = boost::posix_time::second_clock::universal_time();
-}  /* -----  end of method Global::Global  (constructor)  ----- */
-
-Global::~Global ()
-{
-}  /* -----  end of method Global::Global  (destructor)  ----- */
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Global* Global::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Global() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Global_Variables
- *  Description:  Save the Gloabal variables into nand flash 
- * =====================================================================================
- */
-bool Global::Save_Global_Variables(std::string path)
-{
-	bool result = false;
-	std::ofstream oo;
-	oo.open(path.c_str(),std::ofstream::binary|std::ofstream::trunc);
-	if ( !oo )
-	{
-		perror("can't save para file");
-		result = false;
-	}
-	else
-	{
-		oo<<*this;
-		result = true;
-		oo.flush();
-		oo.close();
-		sync();
-	}
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Global_Variables
- *  Description:  Load the Global variables from nand flash 
- * =====================================================================================
- */
-bool Global::Load_Global_Variables(std::string path)
-{
-	bool result = false;
-	std::ifstream io;
-	io.open(path.c_str(),std::ifstream::binary);
-	if ( !io.is_open() )
-	{
-		perror("can't load para file");
-		result = false;
-	}
-	else
-	{
-		io>>*this;
-		result = true;
-		io.close();
-		sync();
-	}
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Global_Variable
- *  Description:  Init the GLobal variables 
- * =====================================================================================
- */
-void Global::Init_Global_Variables()
-{
-	for ( int i=0;i<CHANCOUNT;i++ )
-	{
-		HDGain[i]    = 4;
-		Degree[i]    = 0;
-		Gain[i]      = 250;
-		HiFilter[i]  = 0;
-		LoFilter[i]  = -1;
-		DFilter[i]   = 0;
-		ProbeFun[i]  = 0;       //0:close 1:ET 2:FET 3:EMS
-		FreqIndex[i] = 0;
-
-		DriverBal[i] = 8;
-		DriverA_ID[i]= 0;
-		DriverB_ID[i]= 1;
-		PickA_ID[i]  = 0;
-		PickB_ID[i]  = 1;
-	}
-
-	for ( int i=0;i<FREQCOUNT;i++ )
-	{
-		FreqValue[i] = 100000;  //100000
-	}
-
-	FreqValue[0] = 25000;
-	FreqValue[1] = 50000;
-	FreqValue[2] = 75000;
-
-	ProbeFun[0]  = 1;
-	ProbeFun[1]  = 1;
-	Gain[2]      = 450;
-
-	for ( int i=0;i<MIXCOUNT;i++ )
-	{
-		MixDegree[i]  =  0;
-		MixGain[i]    =  250;
-		MixPrimarySig[i] 
-			      =  0;
-		MixSecondarySig[i] 
-			      =  1;
-		MixAlgVersion[i]
-			      =  0;
-
-		Sx[i]         =  1;
-		Sy[i]         =  1;
-		Cos[i]        =  1;       
-		Sin[i]        =  0;
-
-		a[i]         =  1;
-		b[i]         =  0;
-		c[i]         =  1;       
-		d[i]         =  0;
-	}
-
-	for ( int i=0;i<CROSSCOUNT;i++ )
-	{
-		CrossDegree[i]
-			      = 0;
-		CrossGain[i]
-			      = 250;
-	}
-
-
-	for ( int i=0;i<CROSSCOUNT;i++ )
-	{
-		OCTCentX[i]  = 0;
-		OCTCentY[i]  = 0;
-	}
-	
-	Driver		     = 4;
-	Offset		     = 0;
-	Precision            = 16;
-	Language	     = 0;
-	DataBufLength        = 20 * 1024 * 1024;
-	PanelType	     = 3;
-	DrawMode	     = 1;
-	DrawMode2[0]	     = 1;
-	DrawMode2[1]	     = 1;
-	ODrawMode	     = 2;
-	ColorGain	     = 250;
-	Auto_Disappear	     = 30;
-	
-	for ( int i=0;i<SCREENCOUNT2;i++ )
-	{
-		ScrSigM[i]   = i;
-	}
-	ScrSigFocus	     = 0;
-
-	ColorSpotSampleType  = 0;
-	ColorSpotSampIntervalClock
-		             = 5000;
-	ColorSPotSampOutPuls = 50;
-	ColorSpotFreqIndex   = 0;
-	ColorSpotDispMode    = 0;
-	ColorSpotScanSpeed   = 36;
-
-	SAlarmType	     = 3;
-	for ( int i=0;i<3;i++ )
-	{
-		SAlarmCount[i]= 0;
-		SAlarmIndex[i]= 0;
-	}
-	for ( int j=0;j<8;j++ )
-	{
-		SAlarmPara[0][j][0] = 30+15*j;
-		SAlarmPara[0][j][1] = 40+15*j;
-		SAlarmPara[0][j][2] = 50;
-		SAlarmPara[0][j][3] = 50;
-
-		SAlarmPara[1][j][0] = 30+15*j;
-		SAlarmPara[1][j][1] = 40+15*j;
-		SAlarmPara[1][j][2] = 50;
-		SAlarmPara[1][j][3] = 50;
-
-		SAlarmPara[2][j][0] = 100+80+10*j; 
-		SAlarmPara[2][j][1] = 60+80+10*j; 
-		SAlarmPara[2][j][2] = 100+160+10*j; 
-		SAlarmPara[2][j][3] = 60+160+10*j; 
-	}
-
-	for ( int index=0;index<2;index++ )
-	{
-		DAlarmType[index]	     = 2;
-		for ( int i=0;i<3;i++ )
-		{
-			DAlarmCount[index][i]= 0;
-			DAlarmIndex[index][i]= 0;
-		}
-		for ( int j=0;j<8;j++ )
-		{
-			DAlarmPara[index][0][j][0] = 30+15*j;
-			DAlarmPara[index][0][j][1] = 40+15*j;
-			DAlarmPara[index][0][j][2] = 50;
-			DAlarmPara[index][0][j][3] = 50;
-
-			DAlarmPara[index][1][j][0] = 30+15*j;
-			DAlarmPara[index][1][j][1] = 40+15*j;
-			DAlarmPara[index][1][j][2] = 50;
-			DAlarmPara[index][1][j][3] = 50;
-
-			DAlarmPara[index][2][j][0] = 80+300*index+10*j; 
-			DAlarmPara[index][2][j][1] = 80+10*j; 
-			DAlarmPara[index][2][j][2] = 160+300*index+10*j; 
-			DAlarmPara[index][2][j][3] = 160+10*j; 
-		}
-	}
-
-	for ( int index=0;index<2;index++ )
-	{
-		CAlarmType[index]	     = 2;
-		for ( int i=0;i<3;i++ )
-		{
-			CAlarmCount[index][i]= 0;
-			CAlarmIndex[index][i]= 0;
-		}
-		for ( int j=0;j<8;j++ )
-		{
-			CAlarmPara[index][0][j][0] = 30+15*j;
-			CAlarmPara[index][0][j][1] = 40+15*j;
-			CAlarmPara[index][0][j][2] = 50;
-			CAlarmPara[index][0][j][3] = 50;
-
-			CAlarmPara[index][1][j][0] = 30+15*j;
-			CAlarmPara[index][1][j][1] = 40+15*j;
-			CAlarmPara[index][1][j][2] = 50;
-			CAlarmPara[index][1][j][3] = 50;
-
-			CAlarmPara[index][2][j][0] = 80+300*index+10*j; 
-			CAlarmPara[index][2][j][1] = 80+10*j; 
-			CAlarmPara[index][2][j][2] = 160+300*index+10*j; 
-			CAlarmPara[index][2][j][3] = 160+10*j; 
-		}
-	}
-
-	AlarmBeep 	= false;
-	AlarmOutput	= false;
-	AlarmDisplay	= false;
-
-	KeyBeep		= true;
-
-	TimeScaleDisp   = 1;
-	TimeScaleSpeed  = 3;
-
-	for ( int i=0;i<8;i++ )
-	{
-		OAlarmPara[i]
-			= 0;
-	}
-
-	SingleCentX	= 0;
-	SingleCentY	= 0;
-	DoubleCentX1	= 0;
-	DoubleCentY1	= 0;
-	DoubleCentX2	= 0;
-	DoubleCentY2	= 0;
-
-	CompositeCentX1	= 0;
-	CompositeCentY1	= 0;
-	CompositeCentX2	= 0;
-	CompositeCentY2	= 0;
-
-	AScanMapChan[0] = 2;
-	AScanMapChan[1] = 3;
-
-	GainRatio       = 10;
-	AScanSpeed      = 16;
-	/*    ----------------- don't need save into flash -----------------    */
-
-	DebugChan	     = 0;
-	DParaChan	     = 0;
-
-	AlarmStatus.reset();
-	AlarmMainSwitch      = true;
-
-	SingleFocusSignal    = 0;
-
-	bSingleSrcPause      = false;
-	bDoubleSrcPause      = false;
-	bQuadSrcPause	     = false;
-	bCompositeSrcPause   = false;
-
-	bSNeedResetAlarmArea  = true;
-	bDNeedResetAlarmArea  = true;
-	bONeedResetAlarmArea  = true;
-	bCNeedResetAlarmArea  = true;
-	ScopeChan	     = 0;
-	QuadChan 	     = 0;
-	CompositeChan        = 0;
-	
-	bRFFilterEnable      = false;
-}
-
-std::ofstream& operator<<(std::ofstream& oo,const Global& ob)
-{
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-	{
-		oo<<ob.HDGain[i]<<' '
-		  <<ob.Degree[i]<<' '
-		  <<ob.Gain[i]<<' '
-		  <<ob.HiFilter[i]<<' '
-		  <<ob.LoFilter[i]<<' '
-		  <<ob.DFilter[i]<<' '
-		  <<ob.ProbeFun[i]<<' '
-		  <<ob.FreqIndex[i]<<' '
-		  <<ob.DriverBal[i]<<' '
-		  <<ob.DriverA_ID[i]<<' '
-		  <<ob.DriverB_ID[i]<<' '
-		  <<ob.PickA_ID[i]<<' '
-		  <<ob.PickB_ID[i]<<' '
-		  ;
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		oo<<ob.FreqValue[i]<<' '
-			;
-	}
-
-	for ( int i=0;i<Global::MIXCOUNT;i++ )
-	{
-		oo<<ob.MixDegree[i]<<' ';
-		oo<<ob.MixGain[i]<<' ';
-		oo<<ob.MixPrimarySig[i]<<' ';
-		oo<<ob.MixSecondarySig[i]<<' ';
-		oo<<ob.MixAlgVersion[i]<<' ';
-
-		oo<<ob.Sx[i]<<' ';
-		oo<<ob.Sy[i]<<' '; 
-		oo<<ob.Cos[i]<<' ';
-		oo<<ob.Sin[i]<<' '; 
-
-		oo<<ob.a[i]<<' ';
-		oo<<ob.b[i]<<' '; 
-		oo<<ob.c[i]<<' ';
-		oo<<ob.d[i]<<' '; 
-	}
-
-	for ( int i=0;i<Global::CROSSCOUNT;i++ )
-	{
-		oo<<ob.CrossDegree[i]<<' ';
-		oo<<ob.CrossGain[i]<<' ';
-
-		oo<<ob.OCTCentX[i]<<' ';
-		oo<<ob.OCTCentY[i]<<' ';
-	}
-
-	oo<<ob.Driver<<' '
-	  <<ob.Offset<<' '
-	  <<ob.Precision<<' '
-	  <<ob.Language<<' '
-	  <<ob.DataBufLength<<' '
-	  <<ob.PanelType<<' '
-	  <<ob.DrawMode<<' '
-	  <<ob.DrawMode2[0]<<' '
-	  <<ob.DrawMode2[1]<<' '
-	  <<ob.ODrawMode<<' '
-	  <<ob.ColorGain<<' ' 
-	  <<ob.Auto_Disappear<<' ';
-
-	for ( int i=0;i<Global::SCREENCOUNT2;i++ )
-	{
-	  	oo<<ob.ScrSigM[i]<<' ';
-	}
-	oo<<ob.ScrSigFocus<<' ';
-
-	oo<<ob.ColorSpotSampleType<<' ';
-	oo<<ob.ColorSpotSampIntervalClock<<' ';
-	oo<<ob.ColorSPotSampOutPuls<<' ';
-	oo<<ob.ColorSpotFreqIndex<<' ';
-	oo<<ob.ColorSpotDispMode<<' ';
-	oo<<ob.ColorSpotScanSpeed<<' ';
-
-	oo<<ob.SAlarmType<<' ';
-	for ( int i=0;i<3;i++ )
-	{
-		oo<<ob.SAlarmCount[i]<<' ';
-		oo<<ob.SAlarmIndex[i]<<' ';
-	}
-	for ( int i=0;i<8;i++ )
-	{
-		oo<<ob.SAlarmPara[0][i][0]<<' ';
-		oo<<ob.SAlarmPara[0][i][1]<<' ';
-		oo<<ob.SAlarmPara[0][i][2]<<' ';
-		oo<<ob.SAlarmPara[0][i][3]<<' ';
-
-		oo<<ob.SAlarmPara[1][i][0]<<' ';
-		oo<<ob.SAlarmPara[1][i][1]<<' ';
-		oo<<ob.SAlarmPara[1][i][2]<<' ';
-		oo<<ob.SAlarmPara[1][i][3]<<' ';
-
-		oo<<ob.SAlarmPara[2][i][0]<<' ';
-		oo<<ob.SAlarmPara[2][i][1]<<' ';
-		oo<<ob.SAlarmPara[2][i][2]<<' ';
-		oo<<ob.SAlarmPara[2][i][3]<<' ';
-	}
-	for ( int index=0;index<2;index++ )
-	{
-		oo<<ob.DAlarmType[index]<<' ';
-		for ( int i=0;i<3;i++ )
-		{
-			oo<<ob.DAlarmCount[index][i]<<' ';
-			oo<<ob.DAlarmIndex[index][i]<<' ';
-		}
-		for ( int i=0;i<8;i++ )
-		{
-			oo<<ob.DAlarmPara[index][0][i][0]<<' ';
-			oo<<ob.DAlarmPara[index][0][i][1]<<' ';
-			oo<<ob.DAlarmPara[index][0][i][2]<<' ';
-			oo<<ob.DAlarmPara[index][0][i][3]<<' ';
-
-			oo<<ob.DAlarmPara[index][1][i][0]<<' ';
-			oo<<ob.DAlarmPara[index][1][i][1]<<' ';
-			oo<<ob.DAlarmPara[index][1][i][2]<<' ';
-			oo<<ob.DAlarmPara[index][1][i][3]<<' ';
-
-			oo<<ob.DAlarmPara[index][2][i][0]<<' ';
-			oo<<ob.DAlarmPara[index][2][i][1]<<' ';
-			oo<<ob.DAlarmPara[index][2][i][2]<<' ';
-			oo<<ob.DAlarmPara[index][2][i][3]<<' ';
-		}
-	}
-	for ( int index=0;index<2;index++ )
-	{
-		oo<<ob.CAlarmType[index]<<' ';
-		for ( int i=0;i<3;i++ )
-		{
-			oo<<ob.CAlarmCount[index][i]<<' ';
-			oo<<ob.CAlarmIndex[index][i]<<' ';
-		}
-		for ( int i=0;i<8;i++ )
-		{
-			oo<<ob.CAlarmPara[index][0][i][0]<<' ';
-			oo<<ob.CAlarmPara[index][0][i][1]<<' ';
-			oo<<ob.CAlarmPara[index][0][i][2]<<' ';
-			oo<<ob.CAlarmPara[index][0][i][3]<<' ';
-
-			oo<<ob.CAlarmPara[index][1][i][0]<<' ';
-			oo<<ob.CAlarmPara[index][1][i][1]<<' ';
-			oo<<ob.CAlarmPara[index][1][i][2]<<' ';
-			oo<<ob.CAlarmPara[index][1][i][3]<<' ';
-
-			oo<<ob.CAlarmPara[index][2][i][0]<<' ';
-			oo<<ob.CAlarmPara[index][2][i][1]<<' ';
-			oo<<ob.CAlarmPara[index][2][i][2]<<' ';
-			oo<<ob.CAlarmPara[index][2][i][3]<<' ';
-		}
-	}
-
-	oo<<ob.AlarmOutput<<' ';
-	oo<<ob.AlarmBeep<<' ';
-	oo<<ob.AlarmDisplay<<' ';
-	oo<<ob.KeyBeep<<' ';
-	oo<<ob.TimeScaleDisp<<' ';
-	oo<<ob.TimeScaleSpeed<<' ';
-
-	for ( int i=0;i<8;i++ )
-		oo<<ob.OAlarmPara[i]<<' ';
-
-	oo<<ob.SingleCentX<<' ';
-	oo<<ob.SingleCentY<<' ';
-	oo<<ob.DoubleCentX1<<' ';
-	oo<<ob.DoubleCentY1<<' ';
-	oo<<ob.DoubleCentX2<<' ';
-	oo<<ob.DoubleCentY2<<' ';
-
-	oo<<ob.CompositeCentX1<<' ';
-	oo<<ob.CompositeCentY1<<' ';
-	oo<<ob.CompositeCentX2<<' ';
-	oo<<ob.CompositeCentY2<<' ';
-
-	for ( int i = 0; i < 2; i += 1 ) 
-		oo<<ob.AScanMapChan[i]<<' ';
-
-	oo<<ob.GainRatio<<' ';
-	oo<<ob.AScanSpeed<<' ';
-	return oo;
-}
-
-std::ifstream& operator>>(std::ifstream& io,Global& ob)
-{
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-	{
-		io>>ob.HDGain[i]
-		  >>ob.Degree[i]
-		  >>ob.Gain[i]
-		  >>ob.HiFilter[i]
-		  >>ob.LoFilter[i]
-		  >>ob.DFilter[i]
-		  >>ob.ProbeFun[i]
-		  >>ob.FreqIndex[i]
-
-		  >>ob.DriverBal[i]
-		  >>ob.DriverA_ID[i]
-		  >>ob.DriverB_ID[i]
-		  >>ob.PickA_ID[i]
-		  >>ob.PickB_ID[i]
-		  ;
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		io>>ob.FreqValue[i]
-			;
-	}
-
-	for ( int i=0;i<Global::MIXCOUNT;i++ )
-	{
-		io>>ob.MixDegree[i];
-		io>>ob.MixGain[i];
-		io>>ob.MixPrimarySig[i];
-		io>>ob.MixSecondarySig[i];
-		io>>ob.MixAlgVersion[i];
-
-		io>>ob.Sx[i];
-		io>>ob.Sy[i]; 
-		io>>ob.Cos[i];
-		io>>ob.Sin[i]; 
-
-		io>>ob.a[i];
-		io>>ob.b[i]; 
-		io>>ob.c[i];
-		io>>ob.d[i]; 
-	}
-
-	for ( int i=0;i<Global::CROSSCOUNT;i++ )
-	{
-		io>>ob.CrossDegree[i];
-		io>>ob.CrossGain[i];
-
-		io>>ob.OCTCentX[i];
-		io>>ob.OCTCentY[i];
-	}
-
-	io>>ob.Driver
-	  >>ob.Offset
-	  >>ob.Precision
-	  >>ob.Language
-	  >>ob.DataBufLength
-	  >>ob.PanelType
-	  >>ob.DrawMode
-	  >>ob.DrawMode2[0]
-	  >>ob.DrawMode2[1]
-	  >>ob.ODrawMode
-	  >>ob.ColorGain
-	  >>ob.Auto_Disappear;
-
-	for ( int i=0;i<Global::SCREENCOUNT2;i++ )
-	{
-	  	io>>ob.ScrSigM[i];
-	}
-	io>>ob.ScrSigFocus;
-
-	io>>ob.ColorSpotSampleType;
-	io>>ob.ColorSpotSampIntervalClock;
-	io>>ob.ColorSPotSampOutPuls;
-	io>>ob.ColorSpotFreqIndex;
-	io>>ob.ColorSpotDispMode;
-	io>>ob.ColorSpotScanSpeed;
-
-	io>>ob.SAlarmType;
-	for ( int i=0;i<3;i++ )
-	{
-		io>>ob.SAlarmCount[i];
-		io>>ob.SAlarmIndex[i];
-	}
-	for ( int i=0;i<8;i++ )
-	{
-		io>>ob.SAlarmPara[0][i][0];
-		io>>ob.SAlarmPara[0][i][1];
-		io>>ob.SAlarmPara[0][i][2];
-		io>>ob.SAlarmPara[0][i][3];
-
-		io>>ob.SAlarmPara[1][i][0];
-		io>>ob.SAlarmPara[1][i][1];
-		io>>ob.SAlarmPara[1][i][2];
-		io>>ob.SAlarmPara[1][i][3];
-
-		io>>ob.SAlarmPara[2][i][0];
-		io>>ob.SAlarmPara[2][i][1];
-		io>>ob.SAlarmPara[2][i][2];
-		io>>ob.SAlarmPara[2][i][3];
-	}
-
-	for ( int index=0;index<2;index++ )
-	{
-		io>>ob.DAlarmType[index];
-		for ( int i=0;i<3;i++ )
-		{
-			io>>ob.DAlarmCount[index][i];
-			io>>ob.DAlarmIndex[index][i];
-		}
-		for ( int i=0;i<8;i++ )
-		{
-			io>>ob.DAlarmPara[index][0][i][0];
-			io>>ob.DAlarmPara[index][0][i][1];
-			io>>ob.DAlarmPara[index][0][i][2];
-			io>>ob.DAlarmPara[index][0][i][3];
-
-			io>>ob.DAlarmPara[index][1][i][0];
-			io>>ob.DAlarmPara[index][1][i][1];
-			io>>ob.DAlarmPara[index][1][i][2];
-			io>>ob.DAlarmPara[index][1][i][3];
-
-			io>>ob.DAlarmPara[index][2][i][0];
-			io>>ob.DAlarmPara[index][2][i][1];
-			io>>ob.DAlarmPara[index][2][i][2];
-			io>>ob.DAlarmPara[index][2][i][3];
-		}
-	}
-
-	for ( int index=0;index<2;index++ )
-	{
-		io>>ob.CAlarmType[index];
-		for ( int i=0;i<3;i++ )
-		{
-			io>>ob.CAlarmCount[index][i];
-			io>>ob.CAlarmIndex[index][i];
-		}
-		for ( int i=0;i<8;i++ )
-		{
-			io>>ob.CAlarmPara[index][0][i][0];
-			io>>ob.CAlarmPara[index][0][i][1];
-			io>>ob.CAlarmPara[index][0][i][2];
-			io>>ob.CAlarmPara[index][0][i][3];
-
-			io>>ob.CAlarmPara[index][1][i][0];
-			io>>ob.CAlarmPara[index][1][i][1];
-			io>>ob.CAlarmPara[index][1][i][2];
-			io>>ob.CAlarmPara[index][1][i][3];
-
-			io>>ob.CAlarmPara[index][2][i][0];
-			io>>ob.CAlarmPara[index][2][i][1];
-			io>>ob.CAlarmPara[index][2][i][2];
-			io>>ob.CAlarmPara[index][2][i][3];
-		}
-	}
-
-	io>>ob.AlarmOutput;
-	io>>ob.AlarmBeep;
-	io>>ob.AlarmDisplay;
-	io>>ob.KeyBeep;
-	io>>ob.TimeScaleDisp;
-	io>>ob.TimeScaleSpeed;
-
-	for ( int i=0;i<8;i++ )
-		io>>ob.OAlarmPara[i];
-
-	io>>ob.SingleCentX;
-	io>>ob.SingleCentY;
-	io>>ob.DoubleCentX1;
-	io>>ob.DoubleCentY1;
-	io>>ob.DoubleCentX2;
-	io>>ob.DoubleCentY2;
-
-	io>>ob.CompositeCentX1;
-	io>>ob.CompositeCentY1;
-	io>>ob.CompositeCentX2;
-	io>>ob.CompositeCentY2;
-
-	for ( int i = 0; i < 2; i += 1 ) 
-		io>>ob.AScanMapChan[i];
-
-	io>>ob.GainRatio;
-	io>>ob.AScanSpeed;
-	return io;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Gian
- *  Description:  Calculate Soft Gain 
- * =====================================================================================
- */
-void Global::Calculate_Gain()
-{
-	double temp_gain;
-	for ( int i=0;i<CHANCOUNT;i++ )
-	{
-		temp_gain = static_cast<double>(Gain[i])/static_cast<double>(200);      
-		SoftGain[i] = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
-
-		SoftGain[i] = SoftGain[i];
-	}
-
-	temp_gain = static_cast<double>(ColorGain)/static_cast<double>(200);      
-	ColorSoftGain = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
-
-	for ( int i=0;i<MIXCOUNT;i++ )
-	{
-		temp_gain = static_cast<double>(MixGain[i])/static_cast<double>(200);      
-		SoftMixGain[i] = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
-	}
-
-	for ( int i=0;i<CROSSCOUNT;i++ )
-	{
-		temp_gain = static_cast<double>(CrossGain[i])/static_cast<double>(200);      
-		SoftCrossGain[i] = 14 * ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax); 
-	}
-}
diff --git a/src/EVA11/Global.h b/src/EVA11/Global.h
deleted file mode 100644
index 6c07183..0000000
--- a/src/EVA11/Global.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Global.h
- *
- *    Description:  Declearation of Global variables class
- *
- *        Version:  1.0
- *        Created:  2012年06月07日 09时00分25秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _GLOBAL_INC
-#define  _GLOBAL_INC
-
-#include 	<memory>
-#include	<cstdlib>
-#include	<iomanip>
-#include	<string>
-#include 	<iosfwd>
-#include 	<bitset>
-
-#include 	<boost/timer.hpp>
-#include 	<boost/date_time/posix_time/posix_time.hpp>
-
-/*
- * =====================================================================================
- *        Class:  Global
- *  Description:  the class manage all global variables which only be Instanced only once 
- * =====================================================================================
- */
-//using namespace std;
-class Global
-{
-	public:
-		static Global* Instance();             	      /* only used this function to visit variables   */
-
-		void Init_Global_Variables();          	      /* Init the Global variables 		      */
-		bool Save_Global_Variables(std::string path);
-		bool Load_Global_Variables(std::string path);
-
-		friend std::ofstream& operator<<(std::ofstream& oo,const Global& ob);
-		friend std::ifstream& operator>>(std::ifstream& oo,Global& ob);
-
-		void Calculate_Gain();
-	public:
-		static int const 	CHANCOUNT           = 128;
-		static int const 	MIXCOUNT            = 1;
-		static int const 	FREQCOUNT           = 4;
-		static int const 	SCREENCOUNT2        = 2;
-		static int const 	CROSSCOUNT	    = 8;
-
-		/* ---------- need to save ---------- */
-
-		int              	HDGain[CHANCOUNT];
-		int              	Degree[CHANCOUNT];
-		int              	Gain[CHANCOUNT];
-		int              	HiFilter[CHANCOUNT];
-		int              	LoFilter[CHANCOUNT];
-		int              	DFilter[CHANCOUNT];
-		int			ProbeFun[CHANCOUNT];
-
-		int			DriverBal[CHANCOUNT];
-		int			PickA_ID[CHANCOUNT];
-		int			PickB_ID[CHANCOUNT];
-		int			DriverA_ID[CHANCOUNT];
-		int			DriverB_ID[CHANCOUNT];
-
-		int		 	FreqIndex[CHANCOUNT];
-		int		 	FreqValue[FREQCOUNT];
-
-		int			MixDegree[MIXCOUNT];
-		int			MixGain[MIXCOUNT];
-		int			MixPrimarySig[MIXCOUNT];
-		int			MixSecondarySig[MIXCOUNT];
-		int			MixAlgVersion[MIXCOUNT];
-
-		double			Sx[MIXCOUNT];
-		double			Sy[MIXCOUNT];
-		double			Cos[MIXCOUNT];
-		double			Sin[MIXCOUNT];
-
-		double			a[MIXCOUNT];
-		double			b[MIXCOUNT];
-		double			c[MIXCOUNT];
-		double			d[MIXCOUNT];
-
-		int			CrossDegree[CROSSCOUNT];
-		int			CrossGain[CROSSCOUNT];
-		int			OCTCentX[CROSSCOUNT];
-		int			OCTCentY[CROSSCOUNT];
-
-		int		 	Driver;
-		int		 	Offset;
-		int			Precision;
-		int	 	 	Language;             /* 0: Chinese 1: English  	      */
-		unsigned long long	DataBufLength;
-		int			PanelType;	      /* 0:3D/2D  1:video  2:signal  3:double */
-		int			DrawMode;	      /* 0:Point  1:Line  2:Auto   	      */
-		int			DrawMode2[2];	      /* 0:Point  1:Line  2:Auto   	      */
-		int			ODrawMode;	      /* 0:Point  1:Line  2:Spec   	      */
-		int			ColorGain;
-		int			Auto_Disappear;
-		int			ScrSigM[SCREENCOUNT2];
-		int			ScrSigFocus;
-		int			ColorSpotSampleType;  /* 0: InsideClock  1:Outside Plus       */
-		unsigned long long	ColorSpotSampIntervalClock;
-		unsigned long long	ColorSPotSampOutPuls;	
-		int			ColorSpotFreqIndex;   /* only used for colorspot display mode */
-		int			ColorSpotDispMode;
-		int			ColorSpotScanSpeed;
-
-		int			SAlarmType;	      /* 0: Amp  1: Half Amp  2: Rect 3: close */
-		int			SAlarmCount[3];
-		int			SAlarmIndex[3];
-		int			SAlarmPara[3][8][4];
-
-		int			DAlarmType[2];
-		int			DAlarmCount[2][3];
-		int			DAlarmIndex[2][3];
-		int			DAlarmPara[2][3][8][4];
-		int			TimeScaleSpeed;
-
-		int			CAlarmType[2];
-		int			CAlarmCount[2][3];
-		int			CAlarmIndex[2][3];
-		int			CAlarmPara[2][3][8][4];
-
-		int			OAlarmPara[8];	      /* only for signal Limit Alarm          */
-
-		bool			AlarmOutput;
-		bool			AlarmBeep;
-		bool			AlarmDisplay;
-
-		bool			KeyBeep;
-		int			TimeScaleDisp;        /* Display TimeScale signal X or Y or close; 0:X  1:Y  2:close  */
-
-		int			SingleCentX;
-		int			SingleCentY;
-		int			DoubleCentX1;
-		int			DoubleCentY1;
-		int			DoubleCentX2;
-		int			DoubleCentY2;
-
-		int			CompositeCentX1;
-		int			CompositeCentY1;
-		int			CompositeCentX2;
-		int			CompositeCentY2;
-
-		int			AScanMapChan[2];
-
-		int			GainRatio;
-		int			AScanSpeed;
-
-
-		/* ---------- don't need to save ---------- */
-
-		/* ---------- control tick thread --------- */
-		unsigned char	  	Tick;
-		bool			bTickStop;
-		bool		        bTickPasuse;
-
-		/* ---------- normal data --------- */
-		int		 	DebugChan;            /* When enter debug function, it deside which signal channel to display */
-
-		int			DParaChan;	      /* Double Signal Channel Parameters Adjust 			      */
-
-		int			MultiKey; 	      /* Multi Key Enter 						      */
-
-		int			ScopeChan;	      /*  Used by Cross display 					      */
-
-		int			QuadChan;	      /*  Focus the base channel for Cross Channel                            */
-
-		int			CompositeChan;        /*  Focus the base channel for Composite Channel			      */
-
-		double			SoftGain[CHANCOUNT];
-		double			ColorSoftGain;
-		double			SoftMixGain[MIXCOUNT];
-		double			SoftCrossGain[CROSSCOUNT];
-
-		std::bitset<8>		AlarmStatus;	      /* 0-7: Alarm1-Alarm8  	     */
-		bool			AlarmMainSwitch;      /* Control Alarm Output        */
-
-		int			SingleFocusSignal;
-
-		boost::timer	        RunTimer;
-
-		boost::posix_time::ptime Time_start,Time_now;
-
-		bool			bSingleSrcPause;
-		bool			bDoubleSrcPause;
-		bool			bQuadSrcPause;
-		bool			bCompositeSrcPause;
-
-		bool			bSNeedResetAlarmArea;
-		bool			bDNeedResetAlarmArea;
-		bool			bCNeedResetAlarmArea;
-		bool			bONeedResetAlarmArea;
-
-		bool			bRFFilterEnable;
-
-		bool                    sos;
-	protected:
-
-	private:
-		Global ();
-		~Global ();
-		Global (const Global&);
-		Global& operator = (const Global&);
-
-		friend class std::auto_ptr<Global>;
-		static std::auto_ptr<Global>		m_Instance;
-		static const int	GAINmax	= 2010;
-		static const int	DAfact  = 8;
-}; /* -----  end of class Global  ----- */
-#endif   /* ----- #ifndef _GLOBAL_INC  ----- */
diff --git a/src/EVA11/Gradual.cpp b/src/EVA11/Gradual.cpp
deleted file mode 100644
index ea39466..0000000
--- a/src/EVA11/Gradual.cpp
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Gradual.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年11月15日 10时09分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"Object.h"
-#include 	"Gradual.h"
-#include 	"Algorithm.h"
-
-struct Gradual::PImpl
-{
-	int		m_R;
-	int		m_G;
-	int		m_B;
-	short		m_BGColor;
-	TYPE		m_Type;
-};
-
-Gradual::Gradual (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh) , m_Imple(new struct PImpl)
-{
-	m_Imple->m_R	  = 137;
-	m_Imple->m_G      = 167;
-	m_Imple->m_B      = 82;
-	m_Imple->m_BGColor 
-			  = 0xffff;
-	m_Imple->m_Type   = HTYPE;
-}
-
-Gradual::~Gradual ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the Object on screen 
- * =====================================================================================
- */
-void Gradual::Drawme(Graphic& g)
-{
-	Algorithm *alg = Algorithm::Instance();
-
-	if 	( m_Imple->m_Type == HTYPE )
-	{
-		for ( int i=m_X;i<m_X+m_Width;i++ )
-		{
-			for ( int j=m_Y;j<m_Y+m_Heigh;j++ )
-			{
-				g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(m_Imple->m_R,m_Imple->m_G,m_Imple->m_B,((i-m_X)*255)/m_Width,m_Imple->m_BGColor)));
-			}
-		}
-	}
-	else if ( m_Imple->m_Type == VTYPE )
-	{
-		for ( int j=m_Y;j<m_Y+m_Heigh;j++ )
-		{
-			for ( int i=m_X;i<m_X+m_Width;i++ )
-			{
-				g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(m_Imple->m_R,m_Imple->m_G,m_Imple->m_B,((j-m_Y)*255)/m_Width,m_Imple->m_BGColor)));
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_LColor
- *  Description:  Set the Left Color 
- * =====================================================================================
- */
-void Gradual::Set_RColor(short color)
-{
-	m_Imple->m_R = ( color >> 11 ) & 0x1f;
-	m_Imple->m_G = ( color >> 5 ) & 0x3f;
-	m_Imple->m_B = ( color ) & 0x1f;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_RColor
- *  Description:  Set Right Color 
- * =====================================================================================
- */
-void Gradual::Set_LColor(short color)
-{
-	m_Imple->m_BGColor = color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Type
- *  Description:  Set the Label Type 
- * =====================================================================================
- */
-void Gradual::Set_Type(TYPE type)
-{
-	m_Imple->m_Type = type;
-}
diff --git a/src/EVA11/Gradual.h b/src/EVA11/Gradual.h
deleted file mode 100644
index bf03071..0000000
--- a/src/EVA11/Gradual.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Gradual.h
- *
- *    Description:  Gradual of color 
- *
- *        Version:  1.0
- *        Created:  2012年11月15日 10时07分05秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _GRADUAL_INC
-#define  _GRADUAL_INC
-
-#include 	<memory>	
-class Object;
-class Graphic;
-class Gradual : public Object
-{
-	public:
-		enum TYPE 
-		{
-			HTYPE = 0,
-			VTYPE = 1
-		};
-
-		typedef enum TYPE TYPE;
-		Gradual (int x,int y,int width,int heigh);
-		~Gradual ();
-		void Drawme(Graphic& g);
-
-		void Set_LColor(short);
-		void Set_RColor(short);
-		void Set_Type(TYPE);
-	protected:
-	private:
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif
diff --git a/src/EVA11/Graphic.cpp b/src/EVA11/Graphic.cpp
deleted file mode 100644
index 25cb4b5..0000000
--- a/src/EVA11/Graphic.cpp
+++ /dev/null
@@ -1,985 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Graphic.cpp
- *
- *    Description:  Drawing screen class
- *
- *        Version:  1.0
- *        Created:  2009年07月03日 09时21分10秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-#include        <string.h>
-#include        <sys/types.h> 
-#include        <sys/stat.h> 
-#include        <sys/ioctl.h>
-#include        <linux/fb.h> 
-#include        <unistd.h> 
-#include 	<fcntl.h> 
-#include        <math.h>
-#include 	<sys/mman.h> 
-#include        <fstream>
-#include        <iostream>
-
-#include 	<termio.h>
-
-#include 	<SDL.h>
-#include 	<SDL/SDL_gfxPrimitives.h>
-#include 	<SDL/SDL_gfxBlitFunc.h>
-#include 	<SDL/SDL_rotozoom.h>
-#include 	<SDL/SDL_image.h>
-
-#include        "Algorithm.h"
-
-#include	"Graphic.h"
-#include 	"GUILowCode.hpp"
-
-#define         FD_STDIN 0
-
-std::auto_ptr<Graphic> Graphic::m_Instance;
-
-struct Graphic::PImpl
-{
-	SDL_Surface*		m_pSurface;
-	SDL_Surface*		m_pShadowSurface;
-	SDL_Surface*		m_p32ColorSurface;
-	int			m_MaxW;
-	int			m_MaxH;
-	int			m_Bpp;
-	CopyMode 		m_Mode; 
-	int			m_Transpare;
-	int			m_Buffer_Len;
-	int			m_Color;
-	uint8_t*		m_Scr_Ptr;
-	uint8_t*		m_Shadow_Scr_Ptr;
-	GUILowCode<uint16_t>*	gc;
-	ColorObj*		cobj;
-	
-	struct termios 		new_settings;
-	struct termios		store_settings;
-	int 			m_keyflag;
-};
-
-Graphic::Graphic() : m_Imple(new struct PImpl)
-{
-	m_Imple->m_Transpare = 255;
-	m_Imple->m_Color     = 0; 
-	m_Imple->m_Mode      = MODE_SRC;
-	m_Imple->m_Scr_Ptr   = 0;
-}
-
-Graphic::~Graphic()
-{
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Graphic* Graphic::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Graphic() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Initgraph
- *  Description:  Init the screen file and font file
- * =====================================================================================
- */
-bool Graphic::Initgraph(void)
-{
-	SDL_version compiled;
-	SDL_VERSION(&compiled);
-	int m = compiled.major;
-	int n = compiled.minor;
-	int p = compiled.patch;
-	std::cout<<"SDL Version: "<<m<<"."<<n<<"."<<p<<std::endl;
-
-	SDL_IMAGE_VERSION(&compiled);
-	m = compiled.major;
-	n = compiled.minor;
-	p = compiled.patch;
-	std::cout<<"SDL Image Version: "<<m<<"."<<n<<"."<<p<<std::endl;
-
-	if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
-	{
-		printf("SDL init fail!: %s\n",SDL_GetError());
-		return false; 
-	}
-
-	SDL_ShowCursor(0);
-
-	m_Imple->m_pSurface 	     = NULL;
-	m_Imple->m_pShadowSurface    = NULL;
-	m_Imple->m_MaxW     	     = 640;
-	m_Imple->m_MaxH     	     = 480;
-	m_Imple->m_Bpp      	     = 16;
-
-#ifdef X86
-	uint32_t flag = SDL_SWSURFACE;
-#else
-	uint32_t flag = SDL_HWSURFACE;
-#endif
-
-	if ( !SDL_VideoModeOK(m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,flag) )
-	{
-		printf("SDL init parameters is not support: %s\n",SDL_GetError());
-		return false;
-	}
-
-	m_Imple->m_pSurface = SDL_SetVideoMode(m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,flag);
-	if ( m_Imple->m_pSurface == NULL )
-	{
-		printf("SDL set video mode fail: %s\n",SDL_GetError());
-		return false;
-	}
-
-	char *devicename = new char[100];
-	if ( SDL_VideoDriverName(devicename,100) != NULL )
-		printf ( "Device Name:%s\n",devicename );
-	delete[] devicename;
-	devicename = NULL;
-
-	m_Imple->m_p32ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,32,0xff000000,0x00ff0000,0x0000ff00,0x000000ff);
-	if ( m_Imple->m_p32ColorSurface == NULL )
-	{
-		printf("SDL Create color surface fail: %s\n",SDL_GetError());
-		return false; 
-	}
-
-	m_Imple->m_MaxW  = m_Imple->m_pSurface->w;         		     /* get the screen width and height from system screen */
-	m_Imple->m_MaxH = m_Imple->m_pSurface->h;
-	m_Imple->m_Bpp 	      = m_Imple->m_pSurface->format->BitsPerPixel;
-	m_Imple->m_Buffer_Len  = m_Imple->m_MaxW*m_Imple->m_MaxH*(m_Imple->m_pSurface->format->BytesPerPixel);
-	m_Imple->m_Scr_Ptr    = static_cast<unsigned char *>(m_Imple->m_pSurface->pixels);
-
-	int result = system("/sbin/hwclock -s");                	     /* set the hardware time from system time   */
-	result = result;
-
-	m_Imple->cobj = ColorObj::Instance();
-	m_Imple->cobj->Init_Object();
-
-	Clearscreen();
-	Initkey();                                         		     /* Init the standard input environment, enable read key return immediately */
-
-	m_Imple->m_pShadowSurface = SDL_CreateRGBSurface(flag,m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,0xff000000,0x00ff0000,0x0000ff00,0x000000ff);
-	if ( m_Imple->m_pShadowSurface == NULL )
-	{
-		printf("SDL Create shadow surface fail: %s\n",SDL_GetError());
-		return false; 
-	}
-
-	m_Imple->m_Shadow_Scr_Ptr = static_cast<unsigned char *>(m_Imple->m_pShadowSurface->pixels);
-	/*-----------------------------------------------------------------------------
-	 *  Initiate the globle color
-	 *-----------------------------------------------------------------------------*/
-	Init_Color_System(m_Imple->m_Bpp);
-
-	m_Imple->gc = GUILowCode<uint16_t>::Instance();
-
-	m_Imple->gc->Init_GUILowCode_Parameters(m_Imple->m_MaxW,
-			                    	m_Imple->m_MaxH,
-					    	m_Imple->m_Bpp,
-					    	m_Imple->m_Buffer_Len,
-					    	m_Imple->m_Scr_Ptr,
-					    	m_Imple->m_Shadow_Scr_Ptr,
-					    	GUILowCode<uint16_t>::MODE_SRC);
-  	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Closegraph
- *  Description:  Close the screen file and Chinese font file
- * =====================================================================================
- */
-void Graphic::Closegraph()
-{
-	m_Imple->cobj->Destroy_Object();
-
-	SDL_FreeSurface(m_Imple->m_p32ColorSurface);
-	SDL_FreeSurface(m_Imple->m_pShadowSurface);
-	SDL_FreeSurface(m_Imple->m_pSurface);
-
-	if ( SDL_WasInit(SDL_INIT_VIDEO) != 0 )
-		atexit(SDL_Quit);
-	Restorekey();                           			     /* Let the environment variables to be normal */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clearscreen
- *  Description:  Clear the whole screen
- * =====================================================================================
- */
-void Graphic::Clearscreen(void)
-{
-	boxColor(m_Imple->m_pSurface,0,0,m_Imple->m_MaxW-1,m_Imple->m_MaxH-1,m_Imple->cobj->Get_ColorVP(30)->color32);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  CleanArea
- *  Description:  Clean one area 
- * =====================================================================================
- */
-void Graphic::CleanArea(int x1,int y1,int x2,int y2)
-{
-	m_Imple->gc->Set_Area_Color(x1,y1,x2,y2,m_Imple->cobj->Get_ColorVP(26)->color16);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  GetColor
- *  Description:  Set the color of front
- * =====================================================================================
- */
-int Graphic::Getcolor()
-{
-	return m_Imple->m_Color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SetColor
- *  Description:  Set the color of front
- * =====================================================================================
- */
-void Graphic::Setcolor(short color)
-{
-	m_Imple->m_Color = color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Getpixel
- *  Description:  Get Pixel Value of Screen 
- * =====================================================================================
- */
-short Graphic::Getpixel(int x,int y)
-{
-	unsigned char * loc = m_Imple->m_Scr_Ptr + ((y * m_Imple->m_MaxW*2 + x*2 ));
-	return *(unsigned short *)loc; 
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Setpixel
- *  Description:  Draw a pixel on screen
- * =====================================================================================
- */
-void Graphic::Setpixel(int x,int y,short color)
-{
-	m_Imple->gc->Setpixel(x,y,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Line
- *  Description:  Draw a line on screen, (x1 y1) (x2 y2) 
- * =====================================================================================
- */
-void Graphic::Line(int x1,int y1,int x2,int y2)
-{
-	m_Imple->gc->Line(x1,y1,x2,y2,m_Imple->m_Color);
-}
-
-void Graphic::DoLine(int x1,int y1,int x2,int y2)
-{
-	m_Imple->gc->Dot_Line(x1,y1,x2,y2,m_Imple->m_Color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Line
- *  Description:  Draw a line on screen, (x1 y1) (x2 y2)  with color
- * =====================================================================================
- */
-void Graphic::Line(int x1,int y1,int x2,int y2,short color)
-{
-	m_Imple->gc->Line(x1,y1,x2,y2,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Rectangle
- *  Description:  Draw a ractangel on screen
- * =====================================================================================
- */
-void Graphic::Rectangle(int x1, int y1, int x2, int y2)
-{
-	Line(x1, y1, x2, y1);
-	Line(x2, y1, x2, y2);
-	Line(x2, y2, x1, y2);
-	Line(x1, y2, x1, y1);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawRect
- *  Description:  Draw rectangle with X Y width height
- * =====================================================================================
- */
-void Graphic::DrawRect(int x,int y,int width,int height)
-{
-	Rectangle(x,y,x+width-1,y+height-1);
-}
-void Graphic::DrawRect(int x,int y,int width,int height,short color)
-{
-	short save_color = m_Imple->m_Color;
-	m_Imple->m_Color = color;
-	Rectangle(x,y,x+width-1,y+height-1);
-	m_Imple->m_Color = save_color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawFillRect
- *  Description:  Draw filled rectangle on screen
- * =====================================================================================
- */
-void Graphic::DrawFillRect(int x,int y,int width,int height)
-{
-	for ( int i = y; i < y+height-1; i += 1 ) 
-	{
-		m_Imple->gc->HLine_Fast(x,x+width-1,i,m_Imple->m_Color);
-	}
-}
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawFillRect
- *  Description:  Draw filled rectangle on screen
- * =====================================================================================
- */
-void Graphic::DrawFillRect(int x,int y,int width,int height,short color)
-{
-	int save_color = m_Imple->m_Color;
-	m_Imple->m_Color = color;
-	for ( int i = y; i < y+height-1; i += 1 )
-	{
-		m_Imple->gc->HLine_Fast(x,x+width-1,i,m_Imple->m_Color);
-	}
-	m_Imple->m_Color = save_color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  FillRect
- *  Description:  Draw filled rectangle on screen
- * =====================================================================================
- */
-void Graphic::FillRect(int x1,int y1,int x2,int y2)
-{
-	for(int j=y1;j<y2;j++)
-	{
-		HLine_Fast(x1,x2-1,j,m_Imple->m_Color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SetMode
- *  Description:  Set the drawing mode
- * =====================================================================================
- */
-void Graphic::SetMode(CopyMode mode)
-{
-	m_Imple->m_Mode = mode;
-
-	switch ( mode ) 
-	{
-		case MODE_SRC: 
-			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC);
-			break;
-
-		case MODE_SRC_XOR_DST: 
-			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC_XOR_DST);
-			break;
-
-		default:	
-			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  GetMode
- *  Description:  Get the drawing mode
- * =====================================================================================
- */
-Graphic::CopyMode Graphic::GetMode(void) const
-{
-	return 	m_Imple->m_Mode;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Initkey
- *  Description:  Init the stdin environment, for reading key value return immediatele
- * =====================================================================================
- */
-void Graphic::Initkey(void)
-{
-        tcgetattr(FD_STDIN,&m_Imple->store_settings);             /* save the current key environment variables in memory  */
-	m_Imple->new_settings = m_Imple->store_settings;                   /* set the new environment variables in memory */
-        m_Imple->new_settings.c_lflag &= (~ICANON);
-        m_Imple->new_settings.c_lflag &= (~ECHO);
-        m_Imple->new_settings.c_cc[VTIME] = 0;
-        m_Imple->new_settings.c_cc[VMIN] = 1;
-        tcsetattr(FD_STDIN,TCSANOW,&m_Imple->new_settings);       /* enable the new value immediately */
-	m_Imple->m_keyflag = fcntl(FD_STDIN,F_GETFL);             /* get the F_GETFL variable from environment  */
-        fcntl(FD_STDIN,F_SETFL,m_Imple->m_keyflag | O_NONBLOCK ); /* set the read key type to be NONBLOCK */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restorekey
- *  Description:  Restore the environment variables to the last saving time 
- * =====================================================================================
- */
-void Graphic::Restorekey(void)
-{
-	fcntl(FD_STDIN,F_SETFL,m_Imple->m_keyflag);
-        tcsetattr(FD_STDIN,TCSANOW,&m_Imple->store_settings);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  MovememH
- *  Description:  Move the memory of screen display from one place to another
- * =====================================================================================
- */
-void Graphic::MovememH(int x,int y,int height,int width)
-{
-	m_Imple->gc->MovememH(x,y,height,width,m_Imple->m_Color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Movemem
- *  Description:  Move the memory of screen display from one place to another
- * =====================================================================================
- */
-void Graphic::Movemem(int x,int y,int height,int width)
-{
-	m_Imple->gc->Movemem(x,y,height,width);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  BresenhamCircle
- *  Description:  The second drawing circle algorithmic
- * =====================================================================================
- */
-void Graphic::BresenhamCircle(int xc,int yc,int radius,uint32_t color)
-{
-	aacircleColor(m_Imple->m_pSurface,xc,yc,radius,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Screen_Ptr
- *  Description:  Get the screen ptr from Graphic class templately
- * =====================================================================================
- */
-unsigned char * Graphic::Get_Screen_Ptr()
-{
-	return m_Imple->m_Scr_Ptr;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_Disp_Area
- *  Description:  Clean and Initial the display area  Flag: false shadow->real true
- *                real->shadow
- * =====================================================================================
- */
-void Graphic::Screen_Copy(int left,int up,int right,int down,bool flag)
-{
-	m_Imple->gc->Screen_Copy(left,up,right,down,flag);
-}
-
-void Graphic::Screen_Copy_Alpha(int left,int up,int right,int down,bool flag)
-{
-	int temp_bpp;
-	temp_bpp = m_Imple->m_Bpp >> 3;
-
-	if ( flag == false )
-	{
-		for (int i = up;i<down+1;i++)
-		{
-			Word_Memcpy_Alpha(m_Imple->m_Scr_Ptr+m_Imple->m_MaxW*temp_bpp*i+temp_bpp*(left),
-				    m_Imple->m_Shadow_Scr_Ptr+m_Imple->m_MaxW*temp_bpp*i+temp_bpp*(left),
-				    temp_bpp*(right-left+1));
-		}
-		
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Word_Memcpy_Alpha
- *  Description:  Memory copy word by word 
- * =====================================================================================
- */
-void Graphic::Word_Memcpy_Alpha(unsigned char *des,unsigned char *src,long len)
-{
-	short *des_w,*src_w;
-	len = len >> 1;
-	des_w = (short *)des;
-	src_w = (short *)src;
-	Algorithm* alm = Algorithm::Instance();
-	while( len-- )
-	{
-		*des_w++ = RGB24_16(alm->Alpha_Color(*src_w++,m_Imple->m_Transpare,*des_w)); 
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Screen
- *  Description:  Switch between real screen and shadow screen
- * =====================================================================================
- */
-void Graphic::Switch_Screen()
-{
-	unsigned char *temp;
-	temp = m_Imple->m_Shadow_Scr_Ptr;
-	m_Imple->m_Shadow_Scr_Ptr = m_Imple->m_Scr_Ptr;
-	m_Imple->m_Scr_Ptr = temp;
-
-	m_Imple->gc->Switch_Screen();
-	Switch_Surface();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Color_System
- *  Description:  Init the system color
- * =====================================================================================
- */
-void Graphic::Init_Color_System(int b)
-{
-	if ( b == 8 )
-	{
-		for ( int i=0;i<32;i++ )
-		{
-			g_Pen[i] = 224+i;
-		}
-	}
-	else if ( b == 16 )
-	{
-		for ( int i=0;i<32;i++ )
-		{
-			g_Pen[i] = m_Imple->cobj->Get_ColorVP(i)->color16;
-		}
-	}
-
-	switch ( b )
-	{
-		case 16:
-			/*-----------------------------------------------------------------------------
-			 *  308 used color system
-			 *-----------------------------------------------------------------------------*/
-			g_BATTARY_CO = g_Pen[9];
-
-			g_SCBG_CO   = g_Pen[10]; 
-			g_SCFG_CO   = g_Pen[11]; 
-			g_SCTX_CO   = g_Pen[12]; 
-
-			g_BUTXNO_CO = g_Pen[16]; 
-			g_BUBGNO_CO = g_Pen[17];
-			g_BUBGFO_CO = g_Pen[18];
-			g_BUTXFO_CO = g_Pen[19];
-
-			g_LIGHT_CO  = g_Pen[21];
-			g_SHADOW_CO = g_Pen[20];
-
-			g_MAINBG_CO = g_Pen[22];
-			g_MAINFG_CO = g_Pen[23];
-			g_BUFFFG_CO = g_Pen[24];
-
-			g_MOVBFG_CO = g_Pen[25];
-			g_MOVBBG_CO = g_Pen[26];
-			g_MOVBTX_CO = g_Pen[27];
-
-			break;
-		case 8:	
-			/*-----------------------------------------------------------------------------
-			 *  308 used color system
-			 *-----------------------------------------------------------------------------*/
-			g_BATTARY_CO = g_Pen[9];
-
-			g_SCBG_CO   = g_Pen[10]; 
-			g_SCFG_CO   = g_Pen[11]; 
-			g_SCTX_CO   = g_Pen[12]; 
-
-			g_BUTXNO_CO = g_Pen[16]; 
-			g_BUTXFO_CO = g_Pen[19];
-			g_BUBGNO_CO = g_Pen[17];
-			g_BUBGFO_CO = g_Pen[18];
-
-			g_LIGHT_CO  = g_Pen[21];
-			g_SHADOW_CO = g_Pen[20];
-
-			g_MAINBG_CO = g_Pen[22];
-			g_MAINFG_CO = g_Pen[23];
-			g_BUFFFG_CO = g_Pen[24];
-
-			g_MOVBFG_CO = g_Pen[25];
-			g_MOVBBG_CO = g_Pen[26];
-			g_MOVBTX_CO = g_Pen[27];
-
-			g_SCBG_CO   = g_Pen[10];
-			g_SCFG_CO   = g_Pen[11];
-			g_SCTX_CO   = g_Pen[12];
-
-		        break;  
-		case 1:	
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Disp_Area_Bytes
- *  Description:  Get the display area byres number
- * =====================================================================================
- */
-int Graphic::Get_Disp_Area_Bytes(int left,int up,int right,int down) /* on the frame */
-{
-	return m_Imple->gc->Get_Disp_Area_Bytes(left,up,right,down);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Disp_Area
- *  Description:  Load the graphic memory to memory 
- * =====================================================================================
- */
-void Graphic::Load_Disp_Area(int left,int up,int right,int down,unsigned char * mem)
-{
-	if ( m_Imple->m_Bpp == 8 )
-	{
-		for ( int j=up;j<=down;j++ )
-		{
-			for ( int i=left;i<=right;i++ )
-			{
-				*mem = *( m_Imple->m_Scr_Ptr + ( i + j * m_Imple->m_MaxW ) ); 
-				mem ++;
-			}
-		}
-	}
-	else if ( m_Imple->m_Bpp == 16 )
-	{
-		for ( int j=up;j<=down;j++ )
-		{
-			for ( int i=left;i<=right;i++ )
-			{
-				*(unsigned short *)mem = *(unsigned short *)( m_Imple->m_Scr_Ptr + (( i + j * m_Imple->m_MaxW ) << 1) ); 
-				mem += 2;
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restore_Disp_Area
- *  Description:  Restore the memory to Graphic memory 
- * =====================================================================================
- */
-void Graphic::Restore_Disp_Area(int left,int up,int right,int down,unsigned char * mem)
-{
-	if ( m_Imple->m_Bpp == 8 )                                 /* bpp 16 8 */
-	{
-		for ( int j=up;j<=down;j++ )
-		{
-			for ( int i=left;i<=right;i++ )
-			{
-				*( m_Imple->m_Scr_Ptr + ( i + j * m_Imple->m_MaxW ) ) = *mem; 
-				mem ++;
-			}
-		}
-	}
-	else if ( m_Imple->m_Bpp == 16 )
-	{
-		for ( int j=up;j<=down;j++ )
-		{
-			for ( int i=left;i<=right;i++ )
-			{
-				*(unsigned short *)( m_Imple->m_Scr_Ptr + (( i + j * m_Imple->m_MaxW )<<1) ) = *(unsigned short *)mem; 
-				mem += 2;
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  HLine_Fast
- *  Description:  Fast Draw H-Line 
- *  Note:
- *                Only used by 8-bits color system
- *                0           1
- *                low         high
- * =====================================================================================
- */
-void Graphic::HLine_Fast(int x1,int x2,int y,short color)
-{
-	m_Imple->gc->HLine_Fast(x1,x2,y,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Rect_Fast
- *  Description:  Draw Rectangle as new algorithmic 
- * =====================================================================================
- */
-void Graphic::Rect_Fast(int x1,int y1,int x2,int y2,short color)
-{
-	for ( int j=y1;j<=y2;j++ )
-	{
-		HLine_Fast(x1,x2,j,color);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  RGB24_16
- *  Description:  Convert RGB24 to RGB 16 ( RGB:5:6:5 ) 
- * =====================================================================================
- */
-unsigned short Graphic::RGB24_16(unsigned int rgb)
-{
-	return SDL_MapRGB(m_Imple->m_pSurface->format,( rgb >> 16 ) & 0xff,( rgb >> 8 ) & 0xff,rgb & 0xff);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  FillBox
- *  Description:  FillBox with color 
- * =====================================================================================
- */
-void Graphic::FillBox(int x,int y,int w,int h,int r,uint32_t color)
-{
-	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-	aacircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
-	aacircleColor(m_Imple->m_pSurface,x+r,y+h-r,r,color);
-	aacircleColor(m_Imple->m_pSurface,x+w-r,y+h-r,r,color);
-
-	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
-	filledCircleColor(m_Imple->m_pSurface,x+r,y+h-r,r,color);
-	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+h-r,r,color);
-
-	boxColor(m_Imple->m_pSurface,x+r,y+r,x+w-r,y+h-r,color);
-	boxColor(m_Imple->m_pSurface,x+r,y,x+w-r,y+r,color);
-	boxColor(m_Imple->m_pSurface,x+r,y+h-r,x+w-r,y+h,color);
-	boxColor(m_Imple->m_pSurface,x,y+r,x+r,y+h-r,color);
-	boxColor(m_Imple->m_pSurface,x+w-r,y+r,x+w,y+h-r,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  HalfFillBox
- *  Description:  HalfFillBox with color 
- * =====================================================================================
- */
-void Graphic::HalfFillBox(int x,int y,int w,int h,int r,uint32_t color)
-{
-	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-	aacircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
-
-	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
-
-	boxColor(m_Imple->m_pSurface,x,y+r,x+w,y+h-r,color);
-	boxColor(m_Imple->m_pSurface,x+r,y,x+w-r,y+r,color);
-	boxColor(m_Imple->m_pSurface,x,y+h-r,x+w,y+h,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  QuatFillBox
- *  Description:  Quat Fill Box with color 
- * =====================================================================================
- */
-void Graphic::QuatFillBox(int x,int y,int w,int h,int r,uint32_t color)
-{
-	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-
-	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
-
-	boxColor(m_Imple->m_pSurface,x+r,y+r,x+w-r,y+h-r,color);
-
-	boxColor(m_Imple->m_pSurface,x,y+r,x+r,y+h-r,color);
-	boxColor(m_Imple->m_pSurface,x+w-r,y+r,x+w,y+h-r,color);
-
-	boxColor(m_Imple->m_pSurface,x+r,y,x+w,y+r,color);
-	boxColor(m_Imple->m_pSurface,x,y+h-r,x+w,y+h,color);
-}
-
-void Graphic::Switch_Surface()
-{
-	SDL_Surface* tmp = m_Imple->m_pShadowSurface;
-	m_Imple->m_pShadowSurface = m_Imple->m_pSurface;
-	m_Imple->m_pSurface = tmp; 
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  MapColor
- *  Description:  Map the color to SDL color system 
- * =====================================================================================
- */
-int  Graphic::MapColor(int r,int g,int b)
-{
-	return SDL_MapRGB(m_Imple->m_p32ColorSurface->format,r,g,b);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  FillPolygonColor
- *  Description:  FilledPolygonColor with specail color
- * =====================================================================================
- */
-void Graphic::FillPolygonColor(int16_t* x,int16_t* y,int n,uint32_t color)
-{
-	filledPolygonColor(m_Imple->m_pSurface,x,y,n,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  PolygonColor
- *  Description:  Just draw the polygon with color 
- * =====================================================================================
- */
-void Graphic::PolygonColor(int16_t* x,int16_t* y,int n,uint32_t color)
-{
-	aapolygonColor(m_Imple->m_pSurface,x,y,n,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Ascii
- *  Description:  Display the ASCII charactor on screen 
- * =====================================================================================
- */
-void Graphic::Ascii(int x,int y,char c,uint32_t color)
-{
-	characterColor(m_Imple->m_pSurface,x,y,c,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SmallString
- *  Description:  Display String On Screen
- * =====================================================================================
- */
-void Graphic::SmallString(int x,int y,const char* str,uint32_t color)
-{
-	stringColor(m_Imple->m_pSurface,x,y,str,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get/Set_Screen_XXX
- *  Description:  Screen Parameters set or get
- * =====================================================================================
- */
-int Graphic::Get_Screen_Width()
-{
-	return m_Imple->m_MaxW;
-}
-int Graphic::Get_Screen_Height()
-{
-	return m_Imple->m_MaxH;
-}
-void Graphic::Set_Screen_Width(int value)
-{
-	m_Imple->m_MaxW = value;
-}
-void Graphic::Set_Screen_Height(int value)
-{
-	m_Imple->m_MaxH = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Transparce / Get_Transparce
- *  Description:  Set the Transparce parameters 
- * =====================================================================================
- */
-void Graphic::Set_Transparce(int v)
-{
-	m_Imple->m_Transpare = v;
-}
-int Graphic::Get_Transparce()
-{
-	return m_Imple->m_Transpare;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_bpp
- *  Description:  Get the Device BPP
- * =====================================================================================
- */
-int Graphic::Get_bpp()
-{
-	return m_Imple->m_Bpp;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_BMP_File
- *  Description:  Load the BMP formate file on screen with SDL_image module 
- *	   Note:  support picture type:
- *	   	  gif     only one frame
- *		  ico
- *		  bmp
- *		  jpeg
- *		  png
- *
- *		  SDL_image库的支持
- * =====================================================================================
- */
-void Graphic::Load_Picture_File(int x,int y,const char* path)
-{
-	SDL_Surface *surface = IMG_Load(path);
-	if ( !surface )
-		printf("IMG_Load %s\n",IMG_GetError());
-
-	SDL_Rect offset;
-	offset.x = x;
-	offset.y = y;
-
-	SDL_BlitSurface(surface,NULL,m_Imple->m_pSurface,&offset);
-	SDL_UpdateRect(m_Imple->m_pSurface,0,0,639,479);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Update_Rect
- *  Description:  The function only used by x86 platform 
- * =====================================================================================
- */
-void Graphic::Update_Rect(int x,int y,int w,int h)
-{
-	SDL_UpdateRect(m_Imple->m_pSurface,x,y,w,h);
-}
diff --git a/src/EVA11/Graphic.h b/src/EVA11/Graphic.h
deleted file mode 100644
index 70d4f0d..0000000
--- a/src/EVA11/Graphic.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Graphic.h
- *
- *    Description:  Drawing screen directly and Init key environment variables for 
- *       	    getchar key return immediately
- *
- *        Version:  1.0
- *        Created:  2009年07月03日 09时25分31秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-#ifndef GRAPHIC_H
-#define GRAPHIC_H
-
-#include 	<stdint.h>
-#include 	<cstdio>
-#include 	<cstdlib>
-#include 	<memory>	
-#include 	<unistd.h>
-#include 	<fcntl.h>
-
-#include 	"main.h"
-#include 	"ColorObj.h"
-
-class Graphic
-{
-	public:
-		typedef enum 
-		{                                        	      /* copy mode type for drawing screen */
-			MODE_SRC,
-			MODE_SRC_XOR_DST,
-			InvalidMode
-		} CopyMode;
-
-		static Graphic* Instance();
-
-                bool Initgraph();               		      /* Init the graphic screen */
-		void Closegraph();              		      /* Close the graphic screen */
-
-		void Clearscreen();             		      /* reset the screen */
-		void CleanArea(int,int,int,int);
-
-		void Setcolor(short color);     	              /* Set the front color */
-		int Getcolor(void);     			      /* Get the front color */
-		void Setpixel(int x,int y,short Color); 	      /* Draw pixel on screen */
-		short Getpixel(int x,int y);
-
-		void Line(int x1,int y1,int x2,int y2);       /* Draw line on screen */
-		void DoLine(int x1,int y1,int x2,int y2);     /* Draw line on screen */
-		void Line(int x1,int y1,int x2,int y2,short color); 
-		                                                      /* Draw line on screen */
-
-		void Rectangle(int x1,int y1,int x2,int y2);  /* Draw ractangel on screen */
-		void DrawRect(int x,int y,int width,int height); 
-								      /* Draw rectangel on screen with x y width height */
-		void DrawRect(int x,int y,int width,int height,short color); 
-								      /* Draw rectangel on screen with x y width height */
-		void DrawFillRect(int x,int y,int width,int height); 	     
-								      /* Draw filled rectangle */
-		void DrawFillRect(int x,int y,int width,int height,short color); 
-								      /* Draw filled rectangle */
-		void FillBox(int x,int y,int width,int height,int radius,uint32_t color);
-		void HalfFillBox(int x,int y,int width,int height,int radius,uint32_t color);
-		void QuatFillBox(int x,int y,int width,int height,int radius,uint32_t color);
-		void BresenhamCircle(int xc,int yc,int radius,uint32_t color); 
-								      /* draw circle on screen 2 edition*/
-		void FillRect(int x1,int y1,int x2,int y2);   /* Draw filled rectangle */
-
-		void SetMode(CopyMode);   		              /* Set the drawing mode  */
-		CopyMode GetMode(void) const;   		      /* Get the drawing mode  */
-
-		void Movemem(int x,int y,int height,int width);       /* Move the screen memory from one address to the other */
-		void MovememH(int x,int y,int height,int width);      /* Move the screen memory from one address to the other */
-		unsigned char* Get_Screen_Ptr();   		      /* Get the screen ptr right now  */
-		void Screen_Copy(int left,int up,int right,int down,bool flag);   /* screen copy flag: false shadow->real true real->shadow */
-		void Screen_Copy_Alpha(int left,int up,int right,int down,bool flag);   /* screen copy flag: false shadow->real true real->shadow */
-		void Switch_Screen();                 		      /* switch between real screen and shadow screen  */
-		void Switch_Surface();
-
-		int Get_Disp_Area_Bytes(int left,int up,int right,int down); 
-								      /* According the bpp calculate the length of display area btes */
-		void Load_Disp_Area(int left,int up,int right,int down,unsigned char *mem);
-		void Restore_Disp_Area(int left,int up,int right,int down,unsigned char *mem);
-
-		void HLine_Fast(int x1,int x2,int y,short color);
-		void Rect_Fast(int x1,int y1,int x2,int y2,short color);
-
-		/*-----------------------------------------------------------------------------
-		 *  Memory operation
-		 *-----------------------------------------------------------------------------*/
-		void Word_Memcpy_Alpha(unsigned char *des,unsigned char *src,long len); 
-
-		/*-----------------------------------------------------------------------------
-		 * Class Parameters get/set 
-		 *-----------------------------------------------------------------------------*/
-		void Set_Transparce(int v);			      /* Set transpare parameters */
-		int  Get_Transparce();       
-
-		int Get_Screen_Width();
-		int Get_Screen_Height();
-		void Set_Screen_Width(int v);
-		void Set_Screen_Height(int v);
-		/*-----------------------------------------------------------------------------
-		 * Color convert 
-		 *-----------------------------------------------------------------------------*/
-		unsigned short RGB24_16(unsigned int rgb);
-		int  MapColor(int r,int g,int b);
-
-		int Get_bpp();
-
-		void FillPolygonColor(int16_t* x,int16_t* y,int n,uint32_t color);
-		void PolygonColor(int16_t* x,int16_t* y,int n,uint32_t color);
-		void Ascii(int x,int y,char c,uint32_t color);
-		void SmallString(int x,int y,const char* c,uint32_t color);
-
-		/*-----------------------------------------------------------------------------
-		 *  Picture Load functionns
-		 *-----------------------------------------------------------------------------*/
-		void Load_Picture_File(int,int,const char*);
-
-		/*-----------------------------------------------------------------------------
-		 * Only Used by x86 platform 
-		 *-----------------------------------------------------------------------------*/
-		void Update_Rect(int,int,int,int);
-	private:
-		Graphic ();                     		      /* constructor */
- 		~Graphic ();					      /* destructor  */
-		Graphic (const Graphic&);          		      /* constructor */
-		Graphic& operator = (const Graphic&);    
-
-		void Init_Color_System(int bpp);       		      /* Initiate the system color */
-
-		/*-----------------------------------------------------------------------------
-		 *  Init key used variables 
-		 *-----------------------------------------------------------------------------*/
-		void Initkey(void);             		      /* Init the stdio attribution for reading key value, return immediately  */
-		void Restorekey(void);          		      /* restore the current environment to be last save time */
-	public:
-	protected:
-	private:
-		friend class std::auto_ptr<Graphic>;
-		static std::auto_ptr<Graphic>			m_Instance;
-
-		struct PImpl;
-		std::auto_ptr<struct PImpl>			m_Imple;
-
-}; /* -----  end of class Graphic  ----- */
-#endif
diff --git a/src/EVA11/Helpwin.cpp b/src/EVA11/Helpwin.cpp
deleted file mode 100644
index 1378c3e..0000000
--- a/src/EVA11/Helpwin.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Helpwin.cpp
- *
- *    Description:  implementation of Help Windows class
- *
- *        Version:  1.0
- *        Created:  2012年09月27日 15时46分42秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"Basewin.h"
-#include 	"Helpwin.h"
-#include	"JpegOper.h"
-#include 	"Logic.h"
-#include 	"Graphic.h"
-#include	"Language.h"
-#include 	"Msgbox.h"
-
-#include 	"main.h"
-
-Helpwin::Helpwin ()
-{
-}
-
-Helpwin::~Helpwin ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object of screen 
- * =====================================================================================
- */
-void Helpwin::Init_GUI(Graphic &g)
-{
-	Basewin::Init_GUI(g);
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Help_Text(i));
-	}	
-	m_BomSmall->Set_Text("X");
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object
- * =====================================================================================
- */
-void  Helpwin::Destroy_GUI()
-{
-	Basewin::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- *      Caution:  a00_hlp.jpeg
- *                638 * 440     
- * =====================================================================================
- */
-void Helpwin::Drawme(Graphic& g)
-{
-	Basewin::Drawme(g);
-	sprintf(m_Msg,"%s%c%02d_hlp.jpeg",HELP_PATH,m_Flag,m_Index);
-	if ( access(m_Msg,0) != 0 )
-	{
-		Label *lab = new Label(200,220,220,30); 
-		lab->Set_Font_Size(18);
-		lab->Set_Focus(false);
-		lab->Set_Label_Type(Label::LA_NONE);
-		lab->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0x00000000));
-		lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		lab->Set_Text(m_pl->GetText(INFORMESG21));
-		lab->Drawme(g);
-		delete lab;
-		lab = NULL;
-	}
-	else
-	{
-		JpegOper *m_Jpeg     = new JpegOper;
-		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
-
-		m_Jpeg->JpegSetJpegPara(m_Msg,5,5,JCS_RGB);
-		m_Jpeg->JpegReadJpegFile();
-		m_Jpeg->JpegPlayJpeg(0,0,1,1,638,440);
-
-		delete m_Jpeg;
-		m_Jpeg = NULL;
-	}
-
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Help_Text
- *  Description:  Get the help screen buttons text
- * =====================================================================================
- */
-const char *Helpwin::Get_Help_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0: 
-			return m_pl->GetText(DELETE);
-			break;
-		case 1: 
-			return m_pl->GetText(NONE);
-			break;
-		case 2: 
-			return m_pl->GetText(NONE);
-			break;
-		case 3: 
-			return m_pl->GetText(NONE);
-			break;
-		case 4: 
-			return m_pl->GetText(NONE);
-			break;
-		case 5: 
-			return m_pl->GetText(NONE);
-			break;
-		case 6: 
-			return m_pl->GetText(BACKOUT);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  
- * =====================================================================================
- */
-int Helpwin::Loopwindow (Graphic &g)
-{
-	int result    = 0;
-	Save_Screen_Into_Memory(g);
-	m_BottomFocus = 7;
-	Init_GUI(g);
-	Drawme(g);
-
-	while( 1 )
-	{
-		result = Command_Process(g);
-		if 	( result == CO_EXIT )
-			goto Exit;
-	}
-Exit:
-	Destroy_GUI();
-	Restore_Screen_From_Memory(g);
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Delete_Help_Documentation
- *  Description:  Delete the help Documentation 
- * =====================================================================================
- */
-void Helpwin::Delete_Help_Documentation(Graphic& g)
-{
-	sprintf(m_Msg,"%s%c%02d_hlp.jpeg",HELP_PATH,m_Flag,m_Index);
-	if ( access(m_Msg,0) != 0 )
-	{
-		Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g); 
-		delete ms;
-		ms = NULL;
-	}
-	else
-	{
-		if ( Password_Confirm(g) == 1 )
-		{
-			if ( remove(m_Msg) == 0 )
-			{
-				Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(DELETEHELP),Msgbox::MSG_OK);	
-				ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-				ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-				ms->Showme(g); 
-				delete ms;
-				ms = NULL;
-				Drawme(g);
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Helpwin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-	Delete_Help_Documentation(g);
-	return CO_NONE;
-}
-int Helpwin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Helpwin::Key_Enter_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Helpwin::Key_Esc_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Helpwin::Key_F1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
diff --git a/src/EVA11/Helpwin.h b/src/EVA11/Helpwin.h
deleted file mode 100644
index c0c5342..0000000
--- a/src/EVA11/Helpwin.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Helpwin.h
- *
- *    Description:  Manage of Showing Help message class
- *
- *        Version:  1.0
- *        Created:  2012年09月27日 15时44分40秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef  _HELPWIN_INC
-#define  _HELPWIN_INC
-
-class Helpwin : public Basewin
-{
-	public:
-		Helpwin ();
-		virtual ~Helpwin ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g);
-
-		int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
-		inline void Set_Flag(const char& flag) { m_Flag = flag; }
-		inline void Set_Index(const int& index) { m_Index = index; }
-	protected:
-		virtual int Key_Bom1_Fun(Graphic& g) ;
-		virtual int Key_Bom7_Fun(Graphic& g) ;
-
-		virtual int Key_Esc_Fun(Graphic& g)  ;
-		virtual int Key_Enter_Fun(Graphic& g);
-		virtual int Key_F1_Fun(Graphic& g)   ;
-
-	private:
-		void Delete_Help_Documentation(Graphic& g);
-		const char*  Get_Help_Text(int);
-	private:
-		char		m_Flag;
-		int		m_Index;
-};
-
-#endif
diff --git a/src/EVA11/IDataProcess.cpp b/src/EVA11/IDataProcess.cpp
deleted file mode 100644
index 17ae3be..0000000
--- a/src/EVA11/IDataProcess.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  IDataProcess.cpp
- *
- *    Description:  Implementation of IDataProcess
- *
- *        Version:  1.0
- *        Created:  2012年07月13日 17时22分17秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Device.h"
-#include 	"DataRepo.h"
-#include 	"IDataProcess.h"
-#include 	"Algorithm.h"
-#include 	"MixingManage.h"
-
-IDataProcess::IDataProcess ()
-{
-	m_device = Device::Instance();
-	m_gp     = Global::Instance();
-	m_repo   = DataRepo::Instance();
-	m_alg	 = Algorithm::Instance();
-	m_mixm   = MixingManage::Instance();
-}
-
-IDataProcess::~IDataProcess ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Trigger_Balance_Process
- *  Description:  Get the Balacen point value 
- * =====================================================================================
- */
-void IDataProcess::Trigger_Balacne_Process()
-{
-	m_device->Get_Data_From_ECT(m_ETtemp);
-	int offset=0;
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-	{
-		if ( m_gp->ProbeFun[i] == 0 )
-		{
-			m_BalanceX[i] = 0; 
-			m_BalanceY[i] = 0; 
-		}
-		else
-		{
-			m_BalanceX[i] = ( m_ETtemp[offset<<1]>>m_gp->Precision );
-			m_BalanceY[i] = ( m_ETtemp[(offset<<1)+1]>>m_gp->Precision );
-			offset++;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Data_Process
- *  Description:  Base class Data Process , balance and save data into buffer  
- * =====================================================================================
- */
-void IDataProcess::Data_Process()
-{
-	m_device->Get_Data_From_ECT_Timer(m_ETtemp);
-
-	int offset=0;
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-	{
-		if ( m_gp->ProbeFun[i] == 0 )
-		{
-			m_ETData[i<<1]     = 0;
-			m_ETData[(i<<1)+1] = 0;
-		}
-		else
-		{
-			m_ETData[i<<1]     =  static_cast<ETDATA>( ( ( m_ETtemp[offset<<1]>>m_gp->Precision )     - m_BalanceX[i] ) );
-			m_ETData[(i<<1)+1] =  static_cast<ETDATA>( ( ( m_ETtemp[(offset<<1)+1]>>m_gp->Precision ) - m_BalanceY[i] ) );
-			offset ++;
-		}
-	}
-
-	m_InTimer[0]  -= m_ETtemp[(offset<<1)+0];
-	m_InTimer[1]  -= m_ETtemp[(offset<<1)+0];
-
-	m_OutTimer[0] -= m_ETtemp[(offset<<1)+1];
-	m_OutTimer[1] -= m_ETtemp[(offset<<1)+2];
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_Timer
- *  Description:  Reset inside ot outside timers 
- * =====================================================================================
- */
-void IDataProcess::Reset_InTimer()
-{
-	int data[3];
-	m_device->Get_Timers_Data(data);
-
-	m_InTimer[0]  = data[0]; 
-	m_InTimer[1]  = data[0];
-}
-void IDataProcess::Reset_OutTimer()
-{
-	int data[3];
-	m_device->Get_Timers_Data(data);
-
-	m_OutTimer[0] = data[1];
-	m_OutTimer[1] = data[2];
-}
diff --git a/src/EVA11/IDataProcess.h b/src/EVA11/IDataProcess.h
deleted file mode 100644
index c737cab..0000000
--- a/src/EVA11/IDataProcess.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  IDataProcess.h
- *
- *    Description:  Interface of data process
- *
- *        Version:  1.0
- *        Created:  2012年07月13日 17时19分11秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _IDATAPROCESS_INC
-#define  _IDATAPROCESS_INC
-
-#include 	"main.h"
-#include 	"Global.h"
-class Device;
-class DataRepo;
-class Algorithm;
-class MixingManage;
-
-class IDataProcess
-{
-	public:
-		IDataProcess ();
-		virtual ~IDataProcess ();
-
-		virtual void Data_Process();
-		void Trigger_Balacne_Process();
-
-		void Reset_InTimer();
-		void Reset_OutTimer();
-	protected:
-		ETDATA 			m_ETData[(Global::CHANCOUNT<<1)+16];
-		ETDATA 			m_ETtemp[(Global::CHANCOUNT<<1)+16];
-
-		ETDATA			m_BalanceX[Global::CHANCOUNT];
-		ETDATA			m_BalanceY[Global::CHANCOUNT];
-
-		Device			*m_device;
-		Global			*m_gp;
-		DataRepo		*m_repo;
-		Algorithm		*m_alg;
-		MixingManage 		*m_mixm;
-
-		ETDATA			m_InTimer[2];
-		ETDATA			m_OutTimer[2];
-};
-
-#endif   /* ----- #ifndef _IDATAPROCESS_INC  ----- */
diff --git a/src/EVA11/IView.cpp b/src/EVA11/IView.cpp
deleted file mode 100644
index 89f5894..0000000
--- a/src/EVA11/IView.cpp
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  IView.cpp
- *
- *    Description:  implementation of IView
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 09时26分21秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include	"Global.h"
-#include 	"Device.h"
-#include 	"Graphic.h"
-#include 	"Language.h"
-#include 	"Algorithm.h"
-#include 	"Logic.h"
-#include 	"Label.h"
-#include 	"Resource.h"
-#include 	"FreeType.h"
-
-#include 	"IView.h"
-
-#include 	<boost/format.hpp>
-
-IView::IView(int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-	m_gp          = Global::Instance();
-	m_device      = Device::Instance();
-}
-IView::~IView() { }
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Do_Key_Event
- *  Description:  Do key event for view class 
- * =====================================================================================
- */
-int IView::Do_Key_Event(int key,Graphic& g)
-{
-	switch ( key ) 
-	{
-		case KEY_F1:
-			return Key_F1_Fun(g);
-			break;
-
-		case KEY_F2:
-			return Key_F2_Fun(g);
-			break;
-
-		case KEY_F3:
-			return Key_F3_Fun(g);
-			break;
-
-		case KEY_F4:
-			return Key_F4_Fun(g);
-			break;
-
-		case KEY_F5:
-			return Key_F5_Fun(g);
-			break;
-
-		case KEY_F6:
-			return Key_F6_Fun(g);
-			break;
-
-		case KEY_F7:
-			return Key_F7_Fun(g);
-			break;
-	}
-	return CO_NONE;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Real show the help system 
- * =====================================================================================
- */
-void IView::Show_Help_System(Graphic& g,int x,int y)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_F1_Fun
- *  Description:  Help system box 
- * =====================================================================================
- */
-int IView::Key_F1_Fun(Graphic& g)
-{
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
-	g.Load_Disp_Area(0,0,639,479,mem);
-
-	Language  *pl     = Language::Instance();
-	Logic	  *lo     = Logic::Instance();
-	Algorithm *alg    = Algorithm::Instance();
-
-	int ft            = 16;
-	int key           = 0;
-	UINT32 x          = 70,y = 70,width = 400,heigh = 285+50;
-	UINT32 centx      = x + ( width >> 1 );
-	UINT32 centy      = y + ( heigh >> 1 );
-	COLORTYPE bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-
-	g.DrawFillRect(x,y,width,heigh,bgcolor);
-	COLORTYPE co_sa;
-	g.Setcolor(fgcolor);
-	g.DrawRect(x,y,width,heigh);
-	g.DrawRect(x+1,y+1,width-2,heigh-2);
-	g.Setcolor(g.RGB24_16(0x000000));
-	g.DrawRect(x+2,y+2,width-4,heigh-4);
-	g.DrawRect(x+3,y+3,width-6,heigh-6);
-	g.Setcolor(fgcolor);
-	g.DrawRect(x+4,y+4,width-8,heigh-8);
-	g.Setcolor(co_sa);
-
-	Resource *res = Resource::Instance();
-	res->Show_Resource_Png(g,7,x+8,y+6);
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,g_BUTXNO_CO);
-	font->Set_Color(FreeType::BGCOLOR,g_BUBGNO_CO);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-	std::string v = str(boost::format("Ver:%s")%PROVERSION);
-	font->Text(x+55,y+35,v.c_str());
-
-	Label *button = new Label(centx-2*ft-4,y+heigh-40,4*ft,ft+8);
-	button->Set_Text(pl->GetText(COMFIRM));
-	button->Set_Font_Size(18);
-	button->Set_Label_Type(Label::LA_3D);
-	button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	button->Drawme(g);
-
-	m_gp->Time_now  = boost::posix_time::second_clock::universal_time();
-	boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
-
-	int second = time_elapse.total_seconds();
-	int hour   = second / 3600;
-	int min    = ( second - hour * 3600 ) / 60;
-	second     = second - hour * 3600 - min * 60;
-
-	std::string s = str(boost::format("%02d:%02d:%02d")%hour%min%second);
-
-	Label *runtime = new Label(x+width-110,y+20,100,20);
-	runtime->Set_Label_Type(Label::LA_NONE);
-	runtime->Set_Font_Size(16);
-	runtime->Set_Text(s.c_str());
-	runtime->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	runtime->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	runtime->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	runtime->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	runtime->Drawme(g,false);
-
-	Show_Help_System(g,x,y+50);
-
-	while( key!= KEY_ENTER && key!= KEY_ESC && key!= KEY_F1 )
-	{
-		key = lo->Get_Key();
-
-		if ( key == KEY_F5 )
-			lo->Screen_Shoot(g);
-
-		m_gp->Time_now  = boost::posix_time::second_clock::universal_time();
-		time_elapse = m_gp->Time_now - m_gp->Time_start;
-
-		second = time_elapse.total_seconds();
-		hour   = second / 3600;
-		min    = ( second - hour * 3600 ) / 60;
-		second     = second - hour * 3600 - min * 60;
-		s = str(boost::format("%02d:%02d:%02d")%hour%min%second);
-		runtime->Set_Text(s.c_str());
-		runtime->Drawme(g,true);
-
-		alg->MDelay(70);	
-	}
-	button->Set_Focus(true);
-	button->Drawme(g);
-	alg->MDelay(100);
-	delete button;
-	button = NULL;
-
-	delete runtime;
-	runtime = NULL;
-
-	g.Restore_Disp_Area(0,0,639,479,mem);
-	delete[] mem;
-	mem = NULL;
-}
-
-int IView::Key_Enter_Fun(Graphic& g){;}
-int IView::Key_F2_Fun(Graphic& g){;}
-int IView::Key_F3_Fun(Graphic& g){;}
-int IView::Key_F4_Fun(Graphic& g){;}
-int IView::Key_F5_Fun(Graphic& g){;}
-int IView::Key_F6_Fun(Graphic& g){;}
-int IView::Key_F7_Fun(Graphic& g){;}
-
-int IView::Key_NL1_Fun(Graphic& g,int sub){;}
-int IView::Key_NR1_Fun(Graphic& g,int sub){;}
-int IView::Key_NL2_Fun(Graphic& g,int sub){;}
-int IView::Key_NR2_Fun(Graphic& g,int sub){;}
-int IView::Key_NL3_Fun(Graphic& g,int sub){;}
-int IView::Key_NR3_Fun(Graphic& g,int sub){;}
-int IView::Key_NL4_Fun(Graphic& g,int sub){;}
-int IView::Key_NR4_Fun(Graphic& g,int sub){;}
-int IView::Key_NL5_Fun(Graphic& g,int sub){;}
-int IView::Key_NR5_Fun(Graphic& g,int sub){;}
-int IView::Key_NL6_Fun(Graphic& g,int sub){;}
-int IView::Key_NR6_Fun(Graphic& g,int sub){;}
-
-void IView::Lock_View(Graphic&){;}
-void IView::UnLock_View(Graphic&){;}
-void IView::Set_Panel_Type(int type) {;}
-void IView::Switch_View() {;}
-void IView::Load_View_Object(IView* obj) {;}
diff --git a/src/EVA11/IView.h b/src/EVA11/IView.h
deleted file mode 100644
index b75d310..0000000
--- a/src/EVA11/IView.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  IView.h
- *
- *    Description:  Interface of many kindd View
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 14时24分38秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _IVIEW_INC
-#define  _IVIEW_INC
-
-class Graphic;
-class Device;
-class Global;
-class Object;
-
-class IView : public Object
-{
-	public:
-		IView(int x,int y,int width,int heigh);
-		virtual ~IView() 		 	= 0;
-
-		virtual void Init_View(Graphic&) 	= 0;
-		virtual void Release_View() 	 	= 0;
-		virtual int  Loop_View(Graphic&) 	= 0;
-		virtual void Drawme (Graphic&)   	= 0;
-
-		virtual void Lock_View(Graphic&);
-		virtual void UnLock_View(Graphic&);
-
-		virtual void Set_Panel_Type(int);
-
-		int Do_Key_Event(int key,Graphic& g);
-
-		typedef enum {
-			CO_OK       = 1,
-			CO_NONE     = 999
-		} COMMAND;					/* ----------  end of enum COMMAND  ---------- */
-
-		virtual int Key_F1_Fun(Graphic& g); 
-		virtual int Key_F2_Fun(Graphic& g); 
-		virtual int Key_F3_Fun(Graphic& g); 
-		virtual int Key_F4_Fun(Graphic& g); 
-		virtual int Key_F5_Fun(Graphic& g); 
-		virtual int Key_F6_Fun(Graphic& g); 
-		virtual int Key_F7_Fun(Graphic& g); 
-
-		virtual int Key_Enter_Fun(Graphic& g); 
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y) ;
-		virtual void Switch_View(); 
-
-		virtual void Load_View_Object(IView* obj);
-	protected:
-
-	protected:
-		Global				     *m_gp;
-		Device				     *m_device;
-};
-#endif   /* ----- #ifndef iview_INC  ----- */
diff --git a/src/EVA11/Iconbutton.cpp b/src/EVA11/Iconbutton.cpp
deleted file mode 100644
index e34c151..0000000
--- a/src/EVA11/Iconbutton.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Iconbutton.cpp
- *
- *    Description:  implementation of Icon button class
- *
- *        Version:  1.0
- *        Created:  2012年07月20日 14时39分05秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	"Object.h"
-#include 	"Iconbutton.h"
-#include 	"Graphic.h"
-#include 	"Label.h"
-#include 	"Resource.h"
-
-#define      SHADOW	  2
-Iconbutton::Iconbutton (int x,int y,int width,int height)
-	: Object(x,y,width,height)
-{
-	m_Focus 	= false;
-	m_ResourceIndex = 0xffff;
-}
-
-Iconbutton::~Iconbutton ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init GUI function 
- * =====================================================================================
- */
-void Iconbutton::Init_GUI()
-{
-	m_labText = NULL;
-	m_labText = new Label(m_X+3,m_Y+m_Heigh-28,m_Width-6,20);
-	m_labText->Set_Text(" ");
-	m_labText->Set_Label_Type(Label::LA_NONE);
-
-	m_labText->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGNoColor);
-	m_labText->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGNoColor);
-
-	m_labText->Set_Label_Color(Label::LA_BGFO_COLOR,m_FGFoColor);
-	m_labText->Set_Label_Color(Label::LA_FGFO_COLOR,m_BGFoColor);
-
-	m_labText->Set_Font_Size(16);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  
- * =====================================================================================
- */
-void Iconbutton::Destroy_GUI()
-{
-	if 	( m_labText != NULL )
-	{
-		delete m_labText;
-		m_labText = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the iconbutton class
- * =====================================================================================
- */
-void Iconbutton::Drawme(Graphic& g)
-{
-	COLORTYPE txcolor,bgcolor;
-	COLORTYPE hicolor,locolor;
-
-	m_LightColor  = g.RGB24_16(0xffffff); 
-	m_ShadowColor = g.RGB24_16(0x000000); 
-
-	if ( m_Focus == true )
-	{
-		txcolor = m_FGFoColor;
-		bgcolor = m_FGFoColor;
-		hicolor = m_LightColor;
-		locolor = m_ShadowColor; 
-
-		m_labText->Set_Focus(true);
-	}
-	else
-	{
-		txcolor = m_FGNoColor;
-		bgcolor = m_BGNoColor;
-		hicolor = m_ShadowColor;
-		locolor = m_LightColor;
-
-		m_labText->Set_Focus(false);
-	}
-
-	g.DrawFillRect(m_X,m_Y,m_Width+SHADOW,m_Heigh+SHADOW,hicolor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
-	g.DrawFillRect(m_X+SHADOW,m_Y+SHADOW,m_Width-SHADOW,m_Heigh-SHADOW,bgcolor);
-
-	m_labText->Drawme(g);
-
-	if ( m_ResourceIndex != 0xffff )
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Jpeg(g,m_ResourceIndex,0,0,m_X+27,m_Y+15,320,240);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Text
- *  Description:  Set the Text of iconbutton 
- * =====================================================================================
- */
-void Iconbutton::Set_Text(const char* text)
-{
-	m_labText->Set_Text(text);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Resource_Index
- *  Description:  Set the resource index for Iconbutton class 
- * =====================================================================================
- */
-void Iconbutton::Set_Resource_Index(int index)
-{
-	m_ResourceIndex = index;
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_IconColor
- *  Description:  The color of Icon 
- * =====================================================================================
- */
-void Iconbutton::Set_IconColor(ICONCOLOR type,short color)
-{
-	switch ( type ) 
-	{
-		case BGFO_COLOR:
-			m_BGFoColor = color;
-			break;
-
-		case BGNO_COLOR:
-			m_BGNoColor = color;
-			break;
-
-		case FGFO_COLOR:
-			m_FGFoColor = color;
-			break;
-
-		case FGNO_COLOR:
-			m_FGNoColor = color;
-			break;
-
-	}				/* -----  end switch  ----- */
-}
diff --git a/src/EVA11/Iconbutton.h b/src/EVA11/Iconbutton.h
deleted file mode 100644
index 057409a..0000000
--- a/src/EVA11/Iconbutton.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Iconbutton.h
- *
- *    Description:  Manage the Icon button class
- *
- *        Version:  1.0
- *        Created:  2012年07月20日 14时37分33秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ICONBUTTON_INC
-#define  _ICONBUTTON_INC
-
-class Object;
-class Graphic;
-class Label;
-
-class Iconbutton : public Object
-{
-	public:
-		enum ICONCOLOR 
-		{
-			BGFO_COLOR,
-			BGNO_COLOR,
-			FGFO_COLOR,
-			FGNO_COLOR,
-		};
-		typedef enum ICONCOLOR ICONCOLOR;
-		Iconbutton (int x,int y,int width,int height);
-		~Iconbutton ();
-		void Set_IconColor(ICONCOLOR,short);
-
-		void Drawme(Graphic& g);
-		void Init_GUI();
-		void Destroy_GUI();
-
-		void Set_Text(const char*);
-		void Set_Resource_Index(int index);
-
-	public:
-		bool			m_Focus;
-	protected:
-
-	private:
-		Label			*m_labText;
-		int			m_ResourceIndex;
-
-		short 			m_FGFoColor;
-		short 			m_BGFoColor;
-
-		short 			m_FGNoColor;
-		short 			m_BGNoColor;
-
-		short 			m_LightColor;
-		short			m_ShadowColor;
-}; /* -----  end of class Iconbutton  ----- */
-#endif   /* ----- #ifndef _ICONBUTTON_INC  ----- */
diff --git a/src/EVA11/Initfacade.cpp b/src/EVA11/Initfacade.cpp
deleted file mode 100644
index e2d2e86..0000000
--- a/src/EVA11/Initfacade.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Initfacade.cpp
- *
- *    Description:  implementation of Initfacade class
- *
- *        Version:  1.0
- *        Created:  2012年07月23日 14时54分56秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<stdlib.h>
-#include 	<unistd.h>
-#include 	<sys/ioctl.h>
-#include 	<fcntl.h>
-#include 	<sys/stat.h>
-#include 	<sys/mman.h>
-
-#include 	"main.h"
-
-#include 	"Graphic.h"
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Splashscreen.h"
-#include	"Global.h"	
-#include	"Logic.h"
-#include 	"Language.h"
-#include 	"Algorithm.h"
-#include 	"DataRepo.h"
-#include 	"Initfacade.h"
-#include 	"FreeType.h"
-#include 	"MixingManage.h"
-
-Initfacade::Initfacade ()
-{
-}
-
-Initfacade::~Initfacade ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  System_Init
- *  Description:  System Init Process 
- * =====================================================================================
- */
-bool Initfacade::Standard_ET_System_Init()
-{
-	Create_Inside_Directoies();
-	Graphic *g = Graphic::Instance(); 
-	if 	( g->Initgraph() == false ) 
-	{
-		perror("Error! Can't init the environment");
-		return false;
-	}
-	ft = FreeType::Instance();
-	if ( ft->Init_FreeType(*g,FONT_FILE_PATH) == false )
-	{
-		perror("Error! Can't init the FreeType");
-		g->Closegraph();
-		return false;
-	}
-	ft->Set_Transparce(false);
-
-	Splashscreen *splash = new Splashscreen(150,110,340,260);
-	splash->Drawme(*g);
-	splash->Show_Info(*g,"Starting the EVA-11 System");
-
-	lo = Logic::Instance();
-	lo->Init_Hardware(*g);
-
-	gp = Global::Instance();
-	pl = Language::Instance();
-
-	gp->Init_Global_Variables();
-
-	splash->Show_Info(*g,"Load System Parameters    ");
-
-	      /* Load par.nam */
-	gp->Load_Global_Variables(PAR_FILE_PATH);
-	      /* Load par.nam */
-
-	lo->Set_Global_Variables_Into_PCB();
-	alg = Algorithm::Instance();
-
-	for ( int i=0;i<Global::CHANCOUNT;i++ )
-		alg->Reset_MAX_Value(i,gp->DFilter[i]);
-
-	mixm = MixingManage::Instance();
-	mixm->Init_Object();
-	mixm->Sync_Mixing_Para(false);
-
-	alg->Calculate_Gain_Ratio(gp->GainRatio);
-
-	splash->Show_Info(*g,"Init Hardware and D-Buffer");
-	dpo = DataRepo::Instance();
-	lo->Set_Global_Variables_Into_System();
-
-	delete splash;
-	splash = NULL;
-
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  System_Destroy
- *  Description:  System Destroy Process 
- * =====================================================================================
- */
-void Initfacade::Standard_ET_System_Destroy()
-{
-	      /* Save par.nam */
-	gp->Save_Global_Variables(PAR_FILE_PATH);
-	      /* Save par.nam */
-	gp->bTickStop = true;
-
-	lo->Release_Hardware();
-
-	mixm->Destroy_Object();
-
-	ft->Destroy_FreeType();
-
-	Graphic *g = Graphic::Instance(); 
-	g->Closegraph();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Standard_TCP_System_Init
- *  Description:  Standard TCP System Init process 
- * =====================================================================================
- */
-bool Initfacade::Standard_TCP_System_Init()
-{
-	Graphic *g = Graphic::Instance(); 
-	if 	( g->Initgraph() == false ) 
-	{
-		perror("Error! Can't init the environment");
-		return false;
-	}
-
-	ft = FreeType::Instance();
-	if ( ft->Init_FreeType(*g,"/tmp/wqy-zenhei.ttc") == false )
-	{
-		perror("Error! Can't init the FreeType");
-		return false;
-	}
-
-	lo = Logic::Instance();
-	lo->Init_Hardware(*g);
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Standard_TCP_System_Destroy
- *  Description:  Standard TCP system Destroy Process 
- * =====================================================================================
- */
-void Initfacade::Standard_TCP_System_Destroy()
-{
-	ft->Destroy_FreeType();
-	lo->Release_Hardware();
-
-	Graphic *g = Graphic::Instance(); 
-	g->Closegraph();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Create_Inside_Directories
- *  Description:  Create the inside directories 
- * =====================================================================================
- */
-void Initfacade::Create_Inside_Directoies()
-{
-	if ( access(PBM_PATH,0) != 0 )
-		mkdir(PBM_PATH,0755);
-	if ( access(HELP_PATH,0) != 0 )
-		mkdir(HELP_PATH,0755);
-	if ( access(DATA_PATH,0) != 0 )
-		mkdir(DATA_PATH,0755);
-	if ( access(PARA_PATH,0) != 0 )
-		mkdir(PARA_PATH,0755);
-	if ( access(PIC_PATH,0) != 0 )
-		mkdir(PIC_PATH,0755);
-	if ( access(LOG_PATH,0) != 0 )
-		mkdir(LOG_PATH,0755);
-	if ( access(DB_PATH,0) != 0 )
-		mkdir(DB_PATH,0755);
-}
diff --git a/src/EVA11/Initfacade.h b/src/EVA11/Initfacade.h
deleted file mode 100644
index 306733e..0000000
--- a/src/EVA11/Initfacade.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Initfacade.h
- *
- *    Description:  Manage Init process
- *
- *        Version:  1.0
- *        Created:  2012年07月23日 14时49分43秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  INITFACADE_INC
-#define  INITFACADE_INC
-
-class Resource;
-class Logic;
-class Global;
-class Language;
-class Algorithm;
-class DataRepo;
-class MixingManage;
-class FreeType;
-
-class Initfacade
-{
-	public:
-		Initfacade ();
-		~Initfacade ();
-
-		bool Standard_ET_System_Init();
-		void Standard_ET_System_Destroy();
-
-		bool Standard_TCP_System_Init();
-		void Standard_TCP_System_Destroy();
-	protected:
-
-	private:
-		void Create_Inside_Directoies();
-	private:
-		Resource*			res;
-		Logic*				lo;
-		Global*				gp;
-		Language*			pl;
-		Algorithm*			alg;
-		DataRepo*			dpo;
-		FreeType*			ft;
-		MixingManage*			mixm;
-};
-#endif
diff --git a/src/EVA11/JPGS/backscreen.png b/src/EVA11/JPGS/backscreen.png
deleted file mode 100644
index 3b59c08c5a15ee61e0f0ce38e1b29264916c0113..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 4742
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
I>A5}qKdu`HlmGw#

diff --git a/src/EVA11/JPGS/colorspot.jpg b/src/EVA11/JPGS/colorspot.jpg
deleted file mode 100644
index 18881797dff9796b0ebf58be3dc719ee79c96558..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 9817
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

diff --git a/src/EVA11/JPGS/czkscreen.jpg b/src/EVA11/JPGS/czkscreen.jpg
deleted file mode 100644
index 4ffb92c47d7e88e0b4a801b14ee4bc24af79514e..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 10830
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
MUjP<&*Ym=E0doDMhX4Qo

diff --git a/src/EVA11/JPGS/dzkscreen.jpg b/src/EVA11/JPGS/dzkscreen.jpg
deleted file mode 100644
index 7942be71900a338cdf833e58ac206690dd379389..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 12032
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

diff --git a/src/EVA11/JPGS/eddysunlogo.png b/src/EVA11/JPGS/eddysunlogo.png
deleted file mode 100644
index 10ba45dc48e6e92c4013c12197e414abcf256617..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 2930
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

diff --git a/src/EVA11/JPGS/ozkscreen.jpg b/src/EVA11/JPGS/ozkscreen.jpg
deleted file mode 100644
index 79cc3a546d82106254c0bec7f3615f6257b9ab47..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 11629
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

diff --git a/src/EVA11/JPGS/run.png b/src/EVA11/JPGS/run.png
deleted file mode 100644
index ea1f2565f526985b61af4fac6716f67416c31dcb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1821
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
LNkvXXu0mjfF8F4C

diff --git a/src/EVA11/JPGS/splash.gif b/src/EVA11/JPGS/splash.gif
deleted file mode 100644
index d8a79b09a6196800de359a9e035fff7f467d748b..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 159882
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
JAP~U%{{dF}FCzc|

diff --git a/src/EVA11/JPGS/startup.jpg b/src/EVA11/JPGS/startup.jpg
deleted file mode 100644
index 156492fb4b80505f55ddc6d0db14f1f2dc170e12..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 20820
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
Kh-PaB>;Kt20n&N^

diff --git a/src/EVA11/JPGS/stop.png b/src/EVA11/JPGS/stop.png
deleted file mode 100644
index 4127e8a1433c49722e31c96231dd05f5d67f5cb9..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1484
zcmV;-1vC1IP)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyz?
z1tKhBu1jP900m4*L_t(Y$BmY6Y*qCc$3M^cbN`+DkJ2?)ED$w?NC?GtCJhm$OQSJ1
z!kcN_$o9s>gc*1@ASKacWAd_bi_zc~Uu<Fw6Jki!K!DgNi!_z8I{(lPO6}l6+Y9aO
zz2}~D?|Js(*H)(1?Ma^GoRi=0`F@}0e1FgL6TW3ffM<X<;25-I!C@IwU>YhNaO*>0
z+xM)IJ710iI~JZVz@9ZdJuf(IZTW>*-vx*wY9D|6#b@Ww|N0R)`)}YhuyZ+pMf)eb
z*|vN4)6UMF7S6H>7?9ans=dAb`Hw#O&BO4A?_}^Y@EEWjcpp}-OQrt2wzv05dGt}G
zRufVEVF1fQQYj4&9+WSS9{ug7aPXH<I|XzD_Itn|fp?*!WA*B{R_)#UQ@gVh$>l`u
zz8i`~2m)v{pkDvRYc)tFk^AmLZ`=@j^Jel*O+RTK9&T%?*U$V4s{dFl(Ex03->~6u
zy0`a7;(4m;)*<WH3zh}5voJ7V0A!(}jRrI~Lsu6#4um0`JEz>bCDGNZOz+=6dahjF
zu^m2>v(UNufd>Y2d-tLuX5-eai0h)NhzL|FaOMom&l`Y30Umk?L{LCPi00>!4?ciK
zL#14n8!x^%GjjFn2FrKd&Rlyt1c6GmN;E!BZD4?Ut%iu8s*p;-wr${f(Ao-Hwt!_V
z1rKiCBs_T%Zr?^K6~S@TYiVgJLBWYsQ}{kqtD>sdfc4c^_)}Bp6HnlJo?)HIKzFw(
ziES@s=YRb*_Sv(zm5L$cILNE7iZwV$1Q{o?ETh9}6^SBKXWJ%GEaD$Oj@8qHoy!@v
z@%Vo!D43jt{(js>1C1h>nnK=q1Fl@b7Qt4{S~1lOK>*dNQAQ9TL4efjB(7hle(acG
z`z?7kN+tB@Q4*?Xv51^H1&0sA^fY)LmgC@xWE~q~M3D(@Szz0sirO|3ixKPY{$Bmt
z`8-Zn7kc0TGBpL|vf1l-5QZj$C`#GSiS(>ar@P2xAc~AP8b~?~J9Z#z))@98sP7||
z1tR8KYb#>gFg$EZyGU?B|6{e<hxRU!?W=Cyd{9S5kg+kibO~ZH*tHApxd&9u=D9gI
zbO^b889F+?ITM>U!CiO3(2yY~f-Vra;`@Jh)OBsrX~c0**F`pNguXtsP++M|gdzIU
zOUUFTIx%4c@%-~kGS$Z)NAA5B_Uu7RC3ALSF_@c6SXYAJ`X$RE@;sGflG^AfwV|OU
z=31%1zI{lk1T8H{p@0kzqp!STS_VK6FmvJr^)N&{k0_JT&wZcE<?^Kc2sBHj@>G~e
zNYkoSxXC1X`ZOAbh-D#teWn~MS3){%equ`tOit3cc#$xfr26{nq=$xZ@_8Dm6rYcd
z%D=|O7*p-DM`64TV%c(eOKE;yoA1A0+*}U1b`6Gyk!%+7dB|qXVN0jcWD;4i0;$*0
z!9n8nI=1H##^ZXSzn__j3HcNbz6^h{ry=Zzlba!ItyZ_*o}RXIn>OKOGRTS*Xf})F
zat0umgG>hTJV+#vSPVOrLR^<x6!FE8BQk&OT5t;XzW~3Rhq}F}>-S+`EquAAQrY5<
zjb-C)Z5nTHH!b^4FBD9PnwpjX=SD_!{I%C)x>%e%0nZ+SKP@-W<QMSZe%F0Fsk+w5
z=hYGsEXyck!F6GVsw$DHhBGrV8w3--ho8LzpWHcOWtl;>`a(YcxBT2(r$8i&2WufH
zCa?hjs{|K+Y{vQc4-S0*?dU*;h9Dkq{%cdy&mG%Nl1LzqV`S<3sPCKB;`@YQSlekX
mBSrq#tzsGbf7Yljv+zH4lRu;wRW!T+0000<MNUMnLSTYRzrMWy

diff --git a/src/EVA11/JPGS/video.jpg b/src/EVA11/JPGS/video.jpg
deleted file mode 100644
index c0df1e3e6bdd670403df0911de7f48867de8627c..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 8184
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
IQ+%BNUyxg6hyVZp

diff --git a/src/EVA11/JPGS/zkscreen.jpg b/src/EVA11/JPGS/zkscreen.jpg
deleted file mode 100644
index 2448cfc680a9f2f978295d0397c6c81d02c0c624..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 10580
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
YJ}mTQZ$JuURmTeHaW1tIY4$YtKTBxi4FCWD

diff --git a/src/EVA11/JpegOper.cpp b/src/EVA11/JpegOper.cpp
deleted file mode 100644
index 764a73f..0000000
--- a/src/EVA11/JpegOper.cpp
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  JpegOper.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年02月27日 15时06分24秒
- *       Revision:  none
- *       Compiler:  arm-g++
- *
- *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
- *   Organization:  
- *
- * =====================================================================================
- */
-#include	"JpegOper.h" 
-
-JpegOper::JpegOper()
-{
-	fb_ptr		= NULL;
-	Jpeg_buf	= NULL;
-	filePath	= NULL;
-	fb_bpp		= 0;
-	fb_width	= 0;
-	fb_height	= 0;
-}
-
-JpegOper::~JpegOper()
-{
-	if 	( filePath != NULL )
-	{
-		delete[] filePath;
-		filePath = NULL;
-	}
-	JpegDeleteJpegBuf();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegGetFrameBufferInfo
- *  Description:  Confiurature screen infomation for screen shot 
- * =====================================================================================
- */
-void JpegOper::JpegGetFrameBufferInfo(unsigned char *ptr,int bpp,int width,int height)
-{
-	fb_ptr	  = ptr;
-	fb_bpp    = bpp;
-	fb_width  = width;
-	fb_height = height;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegCreateJpeg
- *  Description:  Create the JPEG file from screen  
- * =====================================================================================
- */
-void JpegOper::JpegCreateJpeg(const char *filename,int quality)
-{
-	struct jpeg_compress_struct cinfo;
-	struct jpeg_error_mgr jerr;
-	FILE *outfile;
-	JSAMPROW row_pointer[1];
-	int row_stride;
-	uint16_t *ptr = (uint16_t *)fb_ptr;
-	uint8_t *imagebuf = new uint8_t [(fb_width<<1) + fb_width];
-
-	/* Step 1: allocate and initialize JPEG compression object */
-	cinfo.err = jpeg_std_error(&jerr);
-	jpeg_create_compress(&cinfo);
-
-	/* Step 2: specify data destination */
-	outfile = fopen(filename,"wb");
-	if( NULL == outfile )
-	{
-		fprintf(stderr,"can't open %s\n",filename);
-		exit(1);
-	}
-	jpeg_stdio_dest(&cinfo,outfile);
-
-	/* Step 3: set parameters for compression */
-	cinfo.image_width = fb_width;
-	cinfo.image_height = fb_height;
-	cinfo.input_components = 3;
-	cinfo.in_color_space = JCS_RGB;
-	jpeg_set_defaults(&cinfo);
-	jpeg_set_quality(&cinfo,quality,TRUE);
-
-	/* Step 4: Start compressor */
-	jpeg_start_compress(&cinfo,true);
-
-	/* Step 5: while() */
-	row_stride = fb_width * 3;
-	while(cinfo.next_scanline < cinfo.image_height)
-	{
-		ptr = (uint16_t *)&fb_ptr[cinfo.next_scanline*fb_width<<1];
-		for(int i=0;i<fb_width;i++)
-		{
-			imagebuf[3*i]	= (uint8_t)((ptr[i] & 0xF800)>>8);	//(value>>11)<<3
-			imagebuf[3*i+1]	= (uint8_t)((ptr[i] & 0x07E0)>>3);	//(value>>5)<<2
-			imagebuf[3*i+2]	= (uint8_t)((ptr[i] & 0x001F)<<3);	//value<<3
-		}
-		row_pointer[0] = imagebuf;
-		(void)jpeg_write_scanlines(&cinfo,row_pointer,1);
-	}
-
-	/* Step 6: Finish compression */
-	jpeg_finish_compress(&cinfo);
-	fclose(outfile);
-	delete []imagebuf;
-
-	/* Step 7: Release JPEG	compression object */
-	jpeg_destroy_compress(&cinfo);
-	sync();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegSetJpegPara
- *  Description:  As the title showing 
- * =====================================================================================
- */
-void JpegOper::JpegSetJpegPara(const char *filename,int zoom,int narrow,J_COLOR_SPACE color_space)
-{
-	if(filePath != NULL)
-	{
-		delete[] filePath;
-		filePath = NULL;
-	}
-
-	filePath = new char[strlen(filename)+1];
-	strcpy(filePath,filename);
-
-	scale_num     = zoom;
-	scale_denom   = narrow;
-	j_color_space = color_space;
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegReadJpegFile2
- *  Description:  Version2 of read jpeg file  
- * =====================================================================================
- */
-void JpegOper::JpegReadJpegFile2(unsigned long long offset)
-{
-	struct jpeg_decompress_struct cinfo;
-	struct my_error_mgr jerr;
-	/* More stuff */
-	FILE * infile;		/* source file */
-	JSAMPARRAY buffer;	/* Output row buffer */
-	int row_stride;		/* physical row width in output buffer */
-
-	if ((infile = fopen(filePath, "rb")) == NULL) {
-		printf("can't open %s\n", filePath);
-		exit(1);
-	}
-
-	fseek(infile,offset,SEEK_SET);
-
-	/* Step 1: allocate and initialize JPEG decompression object */
-	cinfo.err = jpeg_std_error(&jerr.pub);
-	jerr.pub.error_exit = my_error_exit;
-	if (setjmp(jerr.setjmp_buffer)) {
-		jpeg_destroy_decompress(&cinfo);
-		fclose(infile);
-		exit(1);
-	}
-	jpeg_create_decompress(&cinfo);
-
-	/* Step 2: specify data source (eg, a file) */
-	jpeg_stdio_src(&cinfo, infile);
-
-	/* Step 3: read file parameters with jpeg_read_header() */
-	(void) jpeg_read_header(&cinfo, TRUE);
-
-	/* Step 4: set parameters for decompression */
-	cinfo.scale_num = scale_num;
-	cinfo.scale_denom = scale_denom;
-	cinfo.out_color_space = j_color_space;
-
-
-	/* Step 5: Start decompressor */
-	(void) jpeg_start_decompress(&cinfo);
-	Jpeg_width = cinfo.output_width;
-	Jpeg_height = cinfo.output_height;
-	Jpeg_components = cinfo.output_components;
-	Jpeg_length = Jpeg_width * Jpeg_components;
-	
-	/* Make a one-row-high sample array that will go away when done with image */
-	buffer = (*cinfo.mem->alloc_sarray)
-		((j_common_ptr) &cinfo, JPOOL_IMAGE, Jpeg_length, 1);
-
-	JpegDeleteJpegBuf();
-	JpegNewJpegBuf();
-	
-	/* Step 6: while (scan lines remain to be read) */
-	while( cinfo.output_scanline < cinfo.output_height)
-	{
-		(void) jpeg_read_scanlines(&cinfo, buffer, 1);
-		/* Assume put_scanline_someplace wants a pointer and sample count. */
-		JpegCopyToJpegBuf(buffer[0],cinfo.output_scanline-1,Jpeg_length);
-	}
-	
-	/* Step 7: Finish decompression */
-	(void) jpeg_finish_decompress(&cinfo);
-
-	/* Step 8: Release JPEG decompression object */
-	jpeg_destroy_decompress(&cinfo);
-
-	fclose(infile);
-	return;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegReadJpeg
- *  Description:  Show JPEG file on screen 
- * =====================================================================================
- */
-void JpegOper::JpegReadJpegFile()
-{
-	struct jpeg_decompress_struct cinfo;
-	struct my_error_mgr jerr;
-	/* More stuff */
-	FILE * infile;		/* source file */
-	JSAMPARRAY buffer;	/* Output row buffer */
-	int row_stride;		/* physical row width in output buffer */
-
-	if ((infile = fopen(filePath, "rb")) == NULL) 
-	{
-		printf("can't open %s\n", filePath);
-		exit(1);
-	}
-	/* Step 1: allocate and initialize JPEG decompression object */
-	cinfo.err = jpeg_std_error(&jerr.pub);
-	jerr.pub.error_exit = my_error_exit;
-	if (setjmp(jerr.setjmp_buffer)) 
-	{
-		jpeg_destroy_decompress(&cinfo);
-		fclose(infile);
-		exit(1);
-	}
-	jpeg_create_decompress(&cinfo);
-
-	/* Step 2: specify data source (eg, a file) */
-	jpeg_stdio_src(&cinfo, infile);
-
-	/* Step 3: read file parameters with jpeg_read_header() */
-	(void) jpeg_read_header(&cinfo, TRUE);
-
-	/* Step 4: set parameters for decompression */
-	cinfo.scale_num = scale_num;
-	cinfo.scale_denom = scale_denom;
-	cinfo.out_color_space = j_color_space;
-
-	/* Step 5: Start decompressor */
-	(void) jpeg_start_decompress(&cinfo);
-	Jpeg_width = cinfo.output_width;
-	Jpeg_height = cinfo.output_height;
-	Jpeg_components = cinfo.output_components;
-	Jpeg_length = Jpeg_width * Jpeg_components;
-	
-	/* Make a one-row-high sample array that will go away when done with image */
-	buffer = (*cinfo.mem->alloc_sarray)
-		((j_common_ptr) &cinfo, JPOOL_IMAGE, Jpeg_length, 1);
-
-	JpegDeleteJpegBuf();
-	JpegNewJpegBuf();
-	
-	/* Step 6: while (scan lines remain to be read) */
-	while( cinfo.output_scanline < cinfo.output_height)
-	{
-		(void) jpeg_read_scanlines(&cinfo, buffer, 1);
-		/* Assume put_scanline_someplace wants a pointer and sample count. */
-		JpegCopyToJpegBuf(buffer[0],cinfo.output_scanline-1,Jpeg_length);
-	}
-	
-	/* Step 7: Finish decompression */
-	(void) jpeg_finish_decompress(&cinfo);
-
-	/* Step 8: Release JPEG decompression object */
-	jpeg_destroy_decompress(&cinfo);
-
-	fclose(infile);
-	return;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegDeleteJpegBuf
- *  Description:  
- * =====================================================================================
- */
-void JpegOper::JpegDeleteJpegBuf()
-{
-	if( Jpeg_buf != NULL )
-	{
-		for(int i=0;i<Jpeg_height;i++)
-		{
-			if(Jpeg_buf[i] != NULL)
-			{
-				delete []Jpeg_buf[i];
-			}
-		}
-		delete []Jpeg_buf;
-		Jpeg_buf = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegNewJpegBuf
- *  Description:  
- * =====================================================================================
- */
-void JpegOper::JpegNewJpegBuf()
-{
-	Jpeg_buf = new unsigned char *[Jpeg_height];
-	for(int i=0;i<Jpeg_height;i++)
-	{
-		Jpeg_buf[i] = new unsigned char [Jpeg_length];
-		memset(Jpeg_buf[i],0,Jpeg_length);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegCopyToJpegBuf
- *  Description:  
- * =====================================================================================
- */
-void JpegOper::JpegCopyToJpegBuf(unsigned char *Src, int line, int length)
-{
-	if( Jpeg_buf[line] )
-		memcpy(Jpeg_buf[line],Src,length);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  JpegPlayJpeg
- *  Description:  
- * =====================================================================================
- */
-void JpegOper::JpegPlayJpeg(int Jpeg_x,int Jpeg_y,int fb_x,int fb_y,int Play_width,int Play_height)
-{
-	int i,j;
-	uint16_t pixel;
-	uint16_t *ptr;
-	if(Jpeg_x>Jpeg_width || Jpeg_y>Jpeg_height || fb_x>fb_width || fb_y>fb_height)
-		return;
-
-	switch( Jpeg_components )
-	{
-		case 1:
-			for(i=Jpeg_y; (i<Jpeg_height)&&((i-Jpeg_y)<Play_height)&&(fb_y<fb_height); fb_y++,i++)
-			{
-				ptr = (uint16_t *)(fb_ptr + (fb_x + fb_y*fb_width)*2);
-				
-				for(j=Jpeg_x; (j<Jpeg_width)&&((j-Jpeg_x)<Play_width)&&((fb_x+j-Jpeg_x)<fb_width); j++)
-				{
-					pixel = ( ((Jpeg_buf[i][j]>>3)<<11) | 
-							((Jpeg_buf[i][j+1]>>2)<<5) |
-							((Jpeg_buf[i][j+2]>>3)) );
-
-					*ptr = pixel;
-					ptr ++;
-				}
-			}
-			break;
-		case 3:
-			for(i=Jpeg_y; (i<Jpeg_height)&&((i-Jpeg_y)<Play_height)&&(fb_y<fb_height); fb_y++,i++)
-			{
-				ptr = (uint16_t *)(fb_ptr + (fb_x + fb_y*fb_width)*2);
-				
-				for(j=Jpeg_x; (j<Jpeg_width)&&((j-Jpeg_x)<Play_width)&&((fb_x+j-Jpeg_x)<fb_width); j++)
-				{
-					pixel = ( ((Jpeg_buf[i][j*3]>>3)<<11) | 
-							((Jpeg_buf[i][j*3+1]>>2)<<5) |
-							((Jpeg_buf[i][j*3+2]>>3)) );
-
-					*ptr = pixel;
-					ptr ++;
-				}
-			}
-
-			break;
-		default:
-			break;
-	}
-}
diff --git a/src/EVA11/JpegOper.h b/src/EVA11/JpegOper.h
deleted file mode 100644
index 9c9d0ef..0000000
--- a/src/EVA11/JpegOper.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  JpegOper.h
- *
- *    Description:  This class operator Jpeg class
- *
- *        Version:  1.0
- *        Created:  2012年02月27日 14时56分24秒
- *       Revision:  none
- *       Compiler:  arm-g++
- *
- *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef  _JPEGOPER_INC
-#define  _JPEGOPER_INC
-
-#include 	<cstdio>
-#include 	<cstdlib>
-#include 	<unistd.h>
-#include 	<stdint.h>
-#include	<cstring>
-#include 	<setjmp.h>
-
-#include	<jpeglib.h>
-
-/*
- * =====================================================================================
- *        Class:  JpegOper
- *  Description:  Manage jpeg operation 
- * =====================================================================================
- */
-/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/
-struct my_error_mgr {
-	struct jpeg_error_mgr pub;	/* "public" fields */
-	jmp_buf setjmp_buffer;		/* for return to caller */
-};
-typedef struct my_error_mgr * my_error_ptr;
-
-/* Here's the routine that will replace the standard error_exit method */
-METHODDEF(void) my_error_exit (j_common_ptr cinfo)
-{
-	my_error_ptr myerr = (my_error_ptr) cinfo->err;
-	(*cinfo->err->output_message) (cinfo);
-	longjmp(myerr->setjmp_buffer, 1);
-}
-
-class JpegOper
-{
-	public:
-		/* ====================  LIFECYCLE     ======================================= */
-		JpegOper ();                             	/* constructor */
-		~JpegOper ();                            	/* destructor */
-		void JpegCreateJpeg(const char *filename,int quality);
-		void JpegGetFrameBufferInfo(unsigned char *ptr,int bpp,int width,int height);
-		void JpegSetJpegPara(const char *filename,int zoom,int narrow,J_COLOR_SPACE color_space);
-		void JpegReadJpegFile();
-		void JpegReadJpegFile2(unsigned long long offset);
-		void JpegDeleteJpegBuf();
-		void JpegNewJpegBuf();
-		void JpegCopyToJpegBuf(unsigned char *Src, int line, int length);
-		void JpegPlayJpeg(int Jpeg_x,int Jpeg_y,int fb_x,int fb_y,int Play_width,int Play_height);
-	protected:
-
-	private:
-		/* framebuffer information */
-		unsigned char* 		fb_ptr;
-		int 			fb_bpp;
-		int 			fb_width;
-		int 			fb_height;
-
-		/* Set Para into Jpeg */
-		char*			filePath;
-		int 			scale_num;
-		int 			scale_denom;
-		J_COLOR_SPACE 		j_color_space;
-
-		/* Play information */
-		unsigned char **	Jpeg_buf;
-
-		/* JPEG file information */
-		int 			Jpeg_width;
-		int 			Jpeg_height;
-		int 			Jpeg_components;
-		int 			Jpeg_length;
-}; /* -----  end of class JpegOper  ----- */
-#endif   /* ----- #ifndef _JPEGOPER_INC  ----- */
diff --git a/src/EVA11/KFInterface.cpp b/src/EVA11/KFInterface.cpp
deleted file mode 100644
index a23f5f3..0000000
--- a/src/EVA11/KFInterface.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  KFInterface.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年12月12日 10时24分18秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"KFInterface.h"
-
-BaseKFInterface::BaseKFInterface()
-{
-}
-BaseKFInterface::~BaseKFInterface()
-{
-}
-
-int BaseKFInterface::Key_Enter_Fun(Graphic& g){;}
-int BaseKFInterface::Key_ESC_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F1_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F2_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F3_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F4_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F5_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F6_Fun(Graphic& g){;}
-int BaseKFInterface::Key_F7_Fun(Graphic& g){;}
-                                           
-DetectKFInterface::DetectKFInterface()
-{
-}
-DetectKFInterface::~DetectKFInterface()
-{
-}
-
-int DetectKFInterface::Key_NL1_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR1_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NL2_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR2_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NL3_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR3_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NL4_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR4_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NL5_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR5_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NL6_Fun(Graphic& g,int sub){;}
-int DetectKFInterface::Key_NR6_Fun(Graphic& g,int sub){;}
-
-AlarmKFInterface::AlarmKFInterface()
-{
-}
-AlarmKFInterface::~AlarmKFInterface()
-{
-}
-
-int AlarmKFInterface::Alarm_NL1_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR1_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NL2_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR2_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NL3_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR3_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NL4_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR4_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NL5_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR5_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NL6_Fun(Graphic& g,int sub){;}
-int AlarmKFInterface::Alarm_NR6_Fun(Graphic& g,int sub){;}
-
-ParaKFInterface::ParaKFInterface()
-{
-}
-ParaKFInterface::~ParaKFInterface()
-{
-}
-
-int ParaKFInterface::Para_NL1_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR1_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NL2_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR2_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NL3_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR3_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NL4_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR4_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NL5_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR5_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NL6_Fun(Graphic& g,int sub){;}
-int ParaKFInterface::Para_NR6_Fun(Graphic& g,int sub){;}
diff --git a/src/EVA11/KFInterface.h b/src/EVA11/KFInterface.h
deleted file mode 100644
index 5ee6c55..0000000
--- a/src/EVA11/KFInterface.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  KFInterface.h
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年12月12日 10时22分48秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _KFINTERFACE_INC
-#define  _KFINTERFACE_INC
-
-class Graphic;
-class BaseKFInterface
-{
-	public:
-		BaseKFInterface ();
-		virtual ~BaseKFInterface ();
-
-		virtual int Key_Enter_Fun(Graphic& g);
-		virtual int Key_ESC_Fun(Graphic& g);
-		virtual int Key_F1_Fun(Graphic& g);
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F5_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-		virtual int Key_F7_Fun(Graphic& g);
-};
-
-class DetectKFInterface
-{
-	public:
-		DetectKFInterface ();
-		virtual ~DetectKFInterface ();
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-};
-
-class AlarmKFInterface
-{
-	public:
-		AlarmKFInterface ();
-		virtual ~AlarmKFInterface ();
-
-		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
-};
-
-class ParaKFInterface
-{
-	public:
-		ParaKFInterface ();
-		virtual ~ParaKFInterface ();
-
-		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR6_Fun(Graphic& g,int sub=1);
-};
-
-#endif
diff --git a/src/EVA11/Label.cpp b/src/EVA11/Label.cpp
deleted file mode 100644
index fef040d..0000000
--- a/src/EVA11/Label.cpp
+++ /dev/null
@@ -1,464 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Label.cpp
- *
- *    Description:  Implementation of Label class 
- *
- *        Version:  1.0
- *        Created:  2012年11月20日 08时51分34秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"ColorObj.h"
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"Language.h"
-#include 	"FreeType.h"
-#include 	"Gradual.h"
-
-struct Label::PImpl
-{
-	static const int	SHADOW  = 2;
-	static const int	RSHADOW = 1;
-	short 			m_BGFO_Color;
-	short 			m_FGFO_Color;
-	short 			m_BGNO_Color;
-	short 			m_FGNO_Color;
-
-	ColorObj::ColorV*	m_BGF_PColor;
-	ColorObj::ColorV*       m_FGF_PColor;
-	ColorObj::ColorV*       m_BGN_PColor;
-	ColorObj::ColorV*       m_FGN_PColor;
-	ColorObj::ColorV*	m_HI_PColor;
-	ColorObj::ColorV*       m_LO_PColor;
-
-	int			m_Font_Size;
-
-	bool			m_Focus;
-	LABELTYPE       	m_Type;
-	LADISPTYPE		m_Display_Type;
-	std::string		m_strText;
-	std::string		m_strContent1;
-	std::string		m_strContent2;
-
-	FreeType*		m_ft;
-	int			m_radius;
-};
-
-Label::Label (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh) , m_Imple(new struct PImpl)
-{
-	Language *lan      	= Language::Instance();
-	m_Imple->m_strText 	= lan->GetText(NONE);
-	m_Imple->m_Type    	= Label::LA_NONE;
-	m_Imple->m_Focus   	= false;
-	m_Imple->m_ft 	   	= FreeType::Instance();
-	m_Imple->m_Font_Size 	= 16;
-	m_Imple->m_radius       = 12;
-	m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
-	m_Imple->m_Display_Type = Label::LA_DT_CENTER;
-	m_Imple->m_strContent1  = lan->GetText(NONE);
-	m_Imple->m_strContent2  = lan->GetText(NONE);
-}
-
-Label::~Label ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the screen object on screen 
- * =====================================================================================
- */
-void Label::Drawme(Graphic &g,bool bufdraw)
-{
-	if ( bufdraw == true )
-		g.Switch_Screen();
-
-	short bgcolor,fgcolor;
-	short hicolor,locolor;
-	if 	( m_Imple->m_Focus == true )
-	{
-		bgcolor = m_Imple->m_BGFO_Color;
-		fgcolor = m_Imple->m_FGFO_Color;
-		hicolor = g_LIGHT_CO;
-		locolor = g_SHADOW_CO;
-	}
-	else
-	{
-		bgcolor = m_Imple->m_BGNO_Color;
-		fgcolor = m_Imple->m_FGNO_Color;
-		hicolor = g_SHADOW_CO;
-		locolor = g_LIGHT_CO;
-	}
-
-	ColorObj::ColorV* pbgcolor;
-	ColorObj::ColorV* pfgcolor;
-	ColorObj::ColorV* phicolor;
-	ColorObj::ColorV* plocolor;
-	if 	( m_Imple->m_Focus == true )
-	{
-		pbgcolor = m_Imple->m_BGF_PColor;
-		pfgcolor = m_Imple->m_FGF_PColor;
-		phicolor = m_Imple->m_HI_PColor;
-		plocolor = m_Imple->m_LO_PColor;
-	}
-	else
-	{
-		pbgcolor = m_Imple->m_BGN_PColor;
-		pfgcolor = m_Imple->m_FGN_PColor;
-		phicolor = m_Imple->m_LO_PColor;
-		plocolor = m_Imple->m_HI_PColor;
-	}
-
-	if 	( m_Imple->m_Type == Label::LA_NONE || m_Imple->m_Type == Label::LA_THIN )
-	{
-		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,bgcolor);
-
-		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
-		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
-		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
-		m_Imple->m_ft->Set_Transparce(true);
-
-		int xoffset; 
-		int yoffset;
-		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_LEFT )
-		{
-			xoffset =  m_X+(m_Width>>4);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_RIGHT )
-		{
-			xoffset =  m_X+m_Width-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(2))*m_Imple->m_Font_Size)-3;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_SPEC )
-		{
-			xoffset =  m_X+7;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_DOUBLE )
-		{
-			xoffset =  m_X+m_Width-(m_Imple->m_strContent1.size()>>1)*m_Imple->m_Font_Size-(m_Width>>4)-10;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
-			xoffset =  m_X+(m_Width>>4);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)-8;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
-			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
-		}
-		if 	( m_Imple->m_Type == Label::LA_THIN )
-		{
-			g.DrawRect(m_X,m_Y,m_Width,m_Heigh,fgcolor);
-		}
-	}
-	else if ( m_Imple->m_Type == Label::LA_ROUND || m_Imple->m_Type == Label::LA_HALFROUND || m_Imple->m_Type == Label::LA_QUAT )
-	{
-		if 	( m_Imple->m_Type == Label::LA_ROUND )
-		{
-			g.FillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
-			g.FillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
-			g.FillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
-		}
-		else if ( m_Imple->m_Type == Label::LA_HALFROUND )
-		{
-			g.HalfFillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
-			g.HalfFillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
-			g.HalfFillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
-		}
-		else if ( m_Imple->m_Type == Label::LA_QUAT )
-		{
-			g.QuatFillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
-			g.QuatFillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
-			g.QuatFillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
-		}
-
-		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
-		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
-		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
-		m_Imple->m_ft->Set_Transparce(true);
-
-		int xoffset;
-		int yoffset;
-		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size)+1;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)-8;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
-			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_SM )
-		{
-			m_Imple->m_ft->Set_Font_Size(15);
-			m_Imple->m_ft->Set_Transparce(true);
-
-			xoffset =  m_X+4;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset-8,m_Imple->m_strText.c_str());
-			m_Imple->m_ft->Set_Font_Size(17);
-			m_Imple->m_ft->Text(xoffset+9,yoffset+4,m_Imple->m_strContent1.c_str());
-		}
-	}
-	else if ( m_Imple->m_Type == Label::LA_3D )
-	{
-		g.DrawFillRect(m_X,m_Y,m_Width+m_Imple->SHADOW,m_Heigh+m_Imple->SHADOW,hicolor);
-		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
-		g.DrawFillRect(m_X+m_Imple->SHADOW,m_Y+m_Imple->SHADOW,m_Width-m_Imple->SHADOW,m_Heigh-m_Imple->SHADOW,bgcolor);
-
-		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
-		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
-		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
-		m_Imple->m_ft->Set_Transparce(true);
-
-		int xoffset;
-		int yoffset;
-		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_LEFT )
-		{
-			xoffset =  m_X+(m_Width>>4);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_RIGHT )
-		{
-			xoffset =  m_X+m_Width-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(2))*m_Imple->m_Font_Size)-3;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_SPEC )
-		{
-			xoffset =  m_X+7;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_DOUBLE )
-		{
-			xoffset =  m_X+m_Width-(m_Imple->m_strContent1.size()>>1)*m_Imple->m_Font_Size-(m_Width>>4)-10;
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
-			xoffset =  m_X+(m_Width>>4);
-			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-		}
-		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
-		{
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)-8;
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
-
-			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
-			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
-			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
-			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
-		}
-	}
-	else if ( m_Imple->m_Type == Label::LA_SM )
-	{
-		g.DrawFillRect(m_X,m_Y,m_Width+m_Imple->SHADOW,m_Heigh+m_Imple->SHADOW,hicolor);
-		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
-		g.DrawFillRect(m_X+m_Imple->SHADOW,m_Y+m_Imple->SHADOW,m_Width-m_Imple->SHADOW,m_Heigh-m_Imple->SHADOW,bgcolor);
-
-		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
-		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
-		m_Imple->m_ft->Set_Font_Size(15);
-		m_Imple->m_ft->Set_Transparce(true);
-
-		int xoffset; 
-		int yoffset;
-		xoffset =  m_X+4;
-		yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
-		m_Imple->m_ft->Text(xoffset,yoffset-8,m_Imple->m_strText.c_str());
-		m_Imple->m_ft->Set_Font_Size(17);
-		m_Imple->m_ft->Text(xoffset+9,yoffset+4,m_Imple->m_strContent1.c_str());
-	}
-
-	if 	( bufdraw == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-2,m_Y+m_Heigh-2,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Text
- *  Description:  Set the Text of object 
- * =====================================================================================
- */
-void Label::Set_Text(const char* str,int index)
-{
-	if 	( index == 0 )
-	{
-		m_Imple->m_strText.clear();
-		m_Imple->m_strText.assign(str);
-	}
-	else if ( index == 1 )
-	{
-		m_Imple->m_strContent1.clear();
-		m_Imple->m_strContent1.assign(str);
-	}
-	else if ( index == 2 )
-	{
-		m_Imple->m_strContent2.clear();
-		m_Imple->m_strContent2.assign(str);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Content
- *  Description:  Set the text of label 
- * =====================================================================================
- */
-void Label::Set_Content(const char *str)
-{
-	Set_Text(str,1);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Focus
- *  Description:  Set the Focus of label 
- * =====================================================================================
- */
-void Label::Set_Focus(bool value)
-{
-	m_Imple->m_Focus = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Label_Color
- *  Description:  Set the Label color include bkcolor and fgcolor
- * =====================================================================================
- */
-void Label::Set_Label_Color(LABCOLOR type,short color)
-{
-	switch ( type ) 
-	{
-        	case LA_BGFO_COLOR:	
-			m_Imple->m_BGFO_Color = color;
-			break;
-		case LA_FGNO_COLOR:	
-			m_Imple->m_FGNO_Color = color;
-			break;
-		case LA_BGNO_COLOR:	
-			m_Imple->m_BGNO_Color = color;
-			break;
-		case LA_FGFO_COLOR:	
-			m_Imple->m_FGFO_Color = color;
-			break;
-	}
-}
-void Label::Set_Label_Color(LABCOLOR type,ColorObj::ColorV* pcolor)
-{
-	switch ( type ) 
-	{
-        	case LA_BGFO_COLOR:	
-			m_Imple->m_BGF_PColor = pcolor;
-			break;
-		case LA_FGNO_COLOR:    
-			m_Imple->m_FGN_PColor = pcolor;
-			break;
-		case LA_BGNO_COLOR:    
-			m_Imple->m_BGN_PColor = pcolor;
-			break;
-		case LA_FGFO_COLOR:    
-			m_Imple->m_FGF_PColor = pcolor;
-			break;
-		case LA_HI_COLOR:    
-			m_Imple->m_HI_PColor = pcolor;
-			break;
-		case LA_LO_COLOR:    
-			m_Imple->m_LO_PColor = pcolor;
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Font_Size
- *  Description:  Set the size of Font
- * =====================================================================================
- */
-void Label::Set_Font_Size(int size)
-{
-	m_Imple->m_Font_Size = size;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Display_Type
- *  Description:  Set the display type 
- * =====================================================================================
- */
-void Label::Set_Display_Type(LADISPTYPE type)
-{
-	m_Imple->m_Display_Type = type;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Label_Type
- *  Description:  Set the label type 
- * =====================================================================================
- */
-void Label::Set_Label_Type(LABELTYPE type)
-{
-	m_Imple->m_Type = type;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Radius
- *  Description:  Set the radius of label 
- * =====================================================================================
- */
-void Label::Set_Radius(int radius)
-{
-	m_Imple->m_radius = radius;
-}
diff --git a/src/EVA11/Label.h b/src/EVA11/Label.h
deleted file mode 100644
index 98ba609..0000000
--- a/src/EVA11/Label.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Label.h
- *
- *    Description:  New label class which take place old lable lcass
- *
- *        Version:  1.0
- *        Created:  2012年11月20日 08时48分47秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  LABEL_INC
-#define  LABEL_INC
-
-#include 	<string>
-#include 	<memory>	
-
-#include 	"ColorObj.h"
-class Graphic;
-class Label : public Object
-{
-	public:
-		typedef enum 
-		{
-			LA_3D,
-			LA_NONE,
-			LA_SM,
-			LA_THIN,
-			LA_ROUND,
-			LA_HALFROUND,
-			LA_QUAT,
-		} LABELTYPE;
-		typedef enum 
-		{
-			LA_BGFO_COLOR,
-			LA_BGNO_COLOR,
-			LA_FGFO_COLOR,
-			LA_FGNO_COLOR,
-			LA_HI_COLOR,
-			LA_LO_COLOR,
-		} LABCOLOR;
-		typedef enum 
-		{
-			LA_DT_CENTER,
-			LA_DT_LEFT,
-			LA_DT_RIGHT,
-			LA_DT_DOUBLE,
-			LA_DT_DLINE,
-			LA_DT_SPEC,
-			LA_DT_SM,
-		}LADISPTYPE;
-
-		Label (int x,int y,int width,int heigh);
-		~Label ();
-
-		void Drawme(Graphic &g,bool bufdraw=false);
-		void Set_Text(const char*,int index=0);
-		void Set_Content(const char *);
-		void Set_Focus(bool value);
-		void Set_Label_Color(LABCOLOR,short color);
-		void Set_Label_Color(LABCOLOR,ColorObj::ColorV* pcolor);
-		void Set_Font_Size(int);
-		void Set_Display_Type(LADISPTYPE);
-		void Set_Label_Type(LABELTYPE);
-		void Set_Radius(int);
-	protected:
-
-	private:
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif   /* ----- #ifndef LABEL_INC  ----- */
diff --git a/src/EVA11/Language.cpp b/src/EVA11/Language.cpp
deleted file mode 100644
index 8d54594..0000000
--- a/src/EVA11/Language.cpp
+++ /dev/null
@@ -1,846 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Language.cpp
- *
- *    Description:  Implementation of Language class
- *
- *        Version:  1.0
- *        Created:  2011年02月10日 13时39分58秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#include 	<cstdio>
-
-#include 	"Language.h"
-
-std::auto_ptr<Language> Language::m_Instance;
-
-Language::Language ()
-{
-	m_Langue = 0;                           /* 0: Chinese  1:English */
-}
-
-Language::~Language ()
-{
-}
-
-char const *Language::GetText(int index)
-{
-	if      ( m_Langue == 0 ) return Get_CN_Text(index);
-	else if ( m_Langue == 1 ) return Get_EN_Text(index);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only used the function to init language class 
- * =====================================================================================
- */
-Language* Language::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Language() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_EN_Text
- *  Description:  Get English Text 
- * =====================================================================================
- */
-char const *Language::Get_EN_Text(int index)
-{
-	switch ( index ) 
-	{
-		case MAINTITLE:
-			return MAINTITLE_EN;
-		case DETECT:
-			return DETECT_EN;
-		case PARAM:
-			return PARAM_EN;
-		case DEBUG:
-			return DEBUG_EN;
-		case ALARM:
-			return ALARM_EN;
-		case ANALYZE:
-			return ANALYZE_EN;
-		case LAYOUT:
-			return LAYOUT_EN;
-		case OTHERS:
-			return OTHERS_EN;
-		case PREVIOUSE:
-			return PREVIOUSE_EN;
-		case NEXT:
-			return NEXT_EN;
-		case LEFTC:
-			return LEFTC_EN;
-		case RIGHTC:
-			return RIGHTC_EN;
-		case COMFIRM:
-			return COMFIRM_EN;
-		case BACKOUT:
-			return BACKOUT_EN;
-		case MAINBUTTON:
-			return MAINBUTTON_EN;
-		case RESERVE:
-			return RESERVE_EN;
-		case SUBTITLE:
-			return SUBTITLE_EN;
-		case CANCEL:
-			return CANCEL_EN;
-		case COMFIRMEXIT:
-			return COMFIRMEXIT_EN;
-		case INFORMESG08:
-			return INFORMESG08_EN;
-		case INFORMESG09:
-			return INFORMESG09_EN;
-		case SCREEN:
-			return SCREEN_EN;
-		case CHANNEL:
-			return CHANNEL_EN;
-		case HDGAIN:
-			return HDGAIN_EN;
-		case FREQUENCEVALUE:
-			return FREQUENCEVALUE_EN;
-		case DRIVER:
-			return DRIVER_EN;
-		case OFFSET:
-			return OFFSET_EN;
-		case PROBE:
-			return PROBE_EN;
-		case FREQUENCE:               
-			return FREQUENCE_EN;
-		case DIFILTER:
-			return DIFILTER_EN;
-		case GAIN:                 
-			return GAIN_EN;
-		case PHASE:
-     			return PHASE_EN;
-		case HIFILTER:           
-			return HIFILTER_EN;
-		case LOFILTER:          
-			return LOFILTER_EN;
-		case CRAFTPARA:
-			return CRAFTPARA_EN;
-		case SAVEPARAM:
-			return SAVEPARAM_EN;
-		case LOADPARAM:
-			return LOADPARAM_EN;
-		case DELPARAM:
-			return DELPARAM_EN;
-		case SUB_TITLE2:
-			return SUB_TITLE2_EN;
-		case EXCUTE:
-			return EXCUTE_EN;
-		case LOADEMPTYDOC:
-			return LOADEMPTYDOC_EN;
-		case DELEMPTYDOC:
-			return DELEMPTYDOC_EN;
-		case OVERWRITECHECK:
-			return OVERWRITECHECK_EN;
-		case INFO_PASSWORD:
-			return INFO_PASSWORD_EN;
-		case INFO_PD_INVAIL:
-			return INFO_PD_INVAIL_EN;
-		case CLOSED:
-			return CLOSED_EN;
-		case HELPTITLE1:
-			return HELPTITLE1_EN;
-		case HELPTITLE2: 
-			return HELPTITLE2_EN;
-		case HELPB1F1:   
-			return HELPB1F1_EN;
-		case HELPB1F2:   
-			return HELPB1F2_EN;
-		case HELPB1F3:  
-			return HELPB1F3_EN;
-		case HELPB1F3_O:  
-			return HELPB1F3_O_EN;
-		case HELPB1F5:  
-			return HELPB1F5_EN;
-		case HELPB1F4:   
-			return HELPB1F4_EN;
-		case HELPB1F6:  
-			return HELPB1F6_EN;
-		case HELPB1F7:  
-			return HELPB1F7_EN;
-		case HELPB1ESC:  
-			return HELPB1ESC_EN;
-		case HELPB1ENTER:
-			return HELPB1ENTER_EN;
-		case GRAPHICFILE:
-			return GRAPHICFILE_EN;
-		case GRAPHICSAVE:
-			return GRAPHICSAVE_EN;
-		case INFORMESG10:
-			return INFORMESG10_EN;
-		case VIDEODISPLAY:
-			return VIDEODISPLAY_EN;
-		case COLORDISPLAY:
-			return COLORDISPLAY_EN;
-		case SIGZKDISPLAY:
-			return SIGZKDISPLAY_EN;
-		case INFORMESG22:
-			return INFORMESG22_EN;
-		case LOADDATA:
-			return LOADDATA_EN;
-		case SAVEDATA:
-			return SAVEDATA_EN;
-		case DELEDATA:
-			return DELEDATA_EN;
-		case SUB_TITLE3:
-			return SUB_TITLE3_EN;
-		case UPDATEPRO:
-		       return UPDATEPRO_EN;	
-		case UPDATECOMFIRM:
-		       return UPDATECOMFIRM_EN;
-		case TRANINFO1:
-		       return TRANINFO1_EN;
-		case ALLGAIN:
-		       return ALLGAIN_EN;
-		case VIDEOOPEN:
-		       return VIDEOOPEN_EN;
-		case VIDEOCLOSE:
-		       return VIDEOCLOSE_EN;
-		case ADJRES:
-		       return ADJRES_EN;
-		case AUTODI:
-		       return AUTODI_EN;
-		case PAGE5:
-		       return PAGE5_EN;
-		case CHCOL:
-		       return CHCOL_EN;
-		case PGUP:
-		       return PGUP_EN;
-		case PGDN:
-		       return PGDN_EN;
-		case DATAFILE:
-		       return DATAFILE_EN;
-		case LOADDATA1:
-		       return LOADDATA1_EN;
-		case SAVEDATA1:
-		       return SAVEDATA1_EN;
-		case LANGUAGE:
-		       return LANGUAGE_EN;
-		case LAN_VALUE:
-			return LAN_VALUE_EN;
-		case DZKDISPLAY:
-			return DZKDISPLAY_EN;
-		case DATE:
-			return DATE_EN;
-		case TIME:
-			return TIME_EN;
-		case VERSION:
-			return VERSION_EN;
-		case ABOUTMSG1: 
-			return ABOUTMSG1_EN;
-		case ABOUTMSG2:
-			return ABOUTMSG2_EN;
-		case ABOUTMSG21:
-			return ABOUTMSG21_EN;
-		case ABOUTMSG22:
-			return ABOUTMSG22_EN;
-		case ABOUTMSG3:
-			return ABOUTMSG3_EN;
-		case ABOUTMSG4: 
-			return ABOUTMSG4_EN;
-		case ABOUTMSG5: 
-			return ABOUTMSG5_EN;
-		case ABOUTMSG7: 		
-			return ABOUTMSG7_EN;
-		case ABOUTMSG6: 
-			return ABOUTMSG6_EN;
-		case ABOUTMSG8: 
-			return ABOUTMSG8_EN;
-		case SAMPLETYPE:
-			return SAMPLETYPE_EN;
-		case INSIDESAMP:
-			return INSIDESAMP_EN;
-		case OUTSIDESAMP:
-			return OUTSIDESAMP_EN;
-		case STIMEINTER:
-			return STIMEINTER_EN;
-		case SAMPPLUS:
-			return SAMPPLUS_EN;
-		case COLORSPOTDM:
-			return COLORSPOTDM_EN;
-		case DISPMOD_3D:
-			return DISPMOD_3D_EN;
-		case DISPMOD_2D:
-			return DISPMOD_2D_EN;
-		case SCANSPEED:
-			return SCANSPEED_EN;
-		case EDDYNETWORK:
-			return EDDYNETWORK_EN;
-		case IPMESG:
-			return IPMESG_EN;
-		case ERRORMSG1:
-			return ERRORMSG1_EN;
-		case INFORMESG07:
-			return INFORMESG07_EN;
-		case INFORMESG06:
-			return INFORMESG06_EN;
-		case SYSTEMDATE:
-			return SYSTEMDATE_EN;
-		case SYSTEMTIME:
-			return SYSTEMTIME_EN;
-		case INFORMESG21:
-			return INFORMESG21_EN;
-		case DELETE:
-			return DELETE_EN;
-		case DELETEHELP:
-			return DELETEHELP_EN;
-		case PICMANAGE:
-			return PICMANAGE_EN;
-		case PREVIEW:
-			return PREVIEW_EN;
-		case PREPIC:
-			return PREPIC_EN;
-		case PICFILE:
-			return PICFILE_EN;
-		case PREVIEWPIC:
-			return PREVIEWPIC_EN;
-		case DELPICFILE:
-			return DELPICFILE_EN;
-		case ALARMTYPE:
-			return ALARMTYPE_EN;
-		case ALARMACOUNT:           
-			return ALARMACOUNT_EN;
-		case ALARMBEEP:               
-			return ALARMBEEP_EN;
-		case ALARMOUT:
-			return ALARMOUT_EN;
-		case ALARMDISP:       
-			return ALARMDISP_EN;
-		case ALARMWINS:
-			return ALARMWINS_EN;
-		case LEFTLIMIT:
-			return LEFTLIMIT_EN;
-		case RIGHTLIMIT:
-			return RIGHTLIMIT_EN;
-		case UPLIMIT:
-			return UPLIMIT_EN;
-		case DOWNLIMIT:
-			return DOWNLIMIT_EN;
-		case DEGREE1:
-			return DEGREE1_EN;
-		case DEGREE2:
-			return DEGREE2_EN;
-		case XHALF:
-			return XHALF_EN;
-		case YHALF:
-			return YHALF_EN;
-		case RECTALARM:
-			return RECTALARM_EN;
-		case AMPALARM:
-			return AMPALARM_EN;
-		case HAMPALARM:
-			return HAMPALARM_EN;
-		case ALARMWINMENU:
-			return ALARMWINMENU_EN;
-		case OPEN:
-			return OPEN_EN;
-		case DEFAULT:
-			return DEFAULT_EN;
-		case RESTORE:
-			return RESTORE_EN;
-		case RESTOREDEFAULT:
-			return RESTOREDEFAULT_EN;
-		case REBOOTMSG:
-			return REBOOTMSG_EN;
-		case CLEANBUF:
-			return CLEANBUF_EN;
-		case RUNTIME:
-			return RUNTIME_EN;
-		case KEYBEEP:
-			return KEYBEEP_EN;
-		case SHUTDOWNMSG1:
-			return SHUTDOWNMSG1_EN;
-		case SHUTDOWNMSG2:
-			return SHUTDOWNMSG2_EN;
-		case TIMESCALE:
-			return TIMESCALE_EN;
-		case TIMESCALESPEED:
-			return TIMESCALESPEED_EN;
-		case MIXINGINFO1:
-			return MIXINGINFO1_EN;
-		case PRIFREQ:
-			return PRIFREQ_EN;
-		case SECFREQ:
-			return SECFREQ_EN;
-		case MIXFACTOR:
-			return MIXFACTOR_EN;
-		case MIXFACTORCOMFIRM:
-			return MIXFACTORCOMFIRM_EN;
-		case SAVEMIXCOMFIRM:
-			return SAVEMIXCOMFIRM_EN;
-		case X1POINT:
-			return X1POINT_EN;
-		case Y1POINT:
-			return Y1POINT_EN;
-		case X2POINT:
-			return X2POINT_EN;
-		case Y2POINT:
-			return Y2POINT_EN;
-		case GAINRATIO:
-			return GAINRATIO_EN;
-		case CLEANPHOTO:
-			return CLEANPHOTO_EN;
-		case OZKDISPLAY:
-			return OZKDISPLAY_EN;
-		case XNPOINT:
-			return XNPOINT_EN;
-		case YNPOINT:
-			return YNPOINT_EN;
-		case SCOPE:
-			return SCOPE_EN;
-		case WHOLE:
-			return WHOLE_EN;
-		case CROSSCHAN:
-			return CROSSCHAN_EN;
-		case ALARMLIMIT:
-			return ALARMLIMIT_EN;
-		case COMBINING:
-			return COMBINING_EN;
-		case ASCANCHAN:
-			return ASCANCHAN_EN;
-		case EMSGAIN:
-			return EMSGAIN_EN;
-		case ASCANSPEED:
-			return ASCANSPEED_EN;
-		case PARASYNC:
-			return PARASYNC_EN;
-		case PARASYNCCOMFIRM:
-			return PARASYNCCOMFIRM_EN;
-		case RESBALACE:
-			return RESBALACE_EN;
-		case ADRIVE: 		
-			return ADRIVE_EN;
-		case BDRIVE: 		
-			return BDRIVE_EN;
-		case APICK: 		
-			return APICK_EN;
-		case BPICK: 		
-			return BPICK_EN;
-		case RFFILTER:
-			return RFFILTER_EN;
-		case PRECISION:
-			return PRECISION_EN;
-		case PREHIGH:
-			return PREHIGH_EN;
-		case PREMED:
-			return PREMED_EN;
-		case PRELOW:
-			return PRELOW_EN;
-		case OPERATION:
-			return OPERATION_EN;
-		default:
-			return NONE_EN;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_CN_Text
- *  Description:  Get Chinese Text 
- * =====================================================================================
- */
-char const *Language::Get_CN_Text(int index)
-{
-	switch ( index ) {
-		case MAINTITLE:
-			return MAINTITLE_CN;
-		case DETECT:
-			return DETECT_CN;
-		case PARAM:
-			return PARAM_CN;
-		case DEBUG:
-			return DEBUG_CN;
-		case ALARM:
-			return ALARM_CN;
-		case ANALYZE:
-			return ANALYZE_CN;
-		case LAYOUT:
-			return LAYOUT_CN;
-		case OTHERS:
-			return OTHERS_CN;
-		case PREVIOUSE:
-			return PREVIOUSE_CN;
-		case NEXT:
-			return NEXT_CN;
-		case LEFTC:
-			return LEFTC_CN;
-		case RIGHTC:
-			return RIGHTC_CN;
-		case COMFIRM:
-			return COMFIRM_CN;
-		case BACKOUT:
-			return BACKOUT_CN;
-		case MAINBUTTON:
-			return MAINBUTTON_CN;
-		case RESERVE:
-			return RESERVE_CN;
-		case SUBTITLE:
-			return SUBTITLE_CN;
-		case CANCEL:
-			return CANCEL_CN;
-		case COMFIRMEXIT:
-			return COMFIRMEXIT_CN;
-		case INFORMESG08:
-			return INFORMESG08_CN;
-		case INFORMESG09:
-			return INFORMESG09_CN;
-		case SCREEN:
-			return SCREEN_CN;
-		case CHANNEL:
-			return CHANNEL_CN;
-		case HDGAIN:
-			return HDGAIN_CN;
-		case FREQUENCEVALUE:
-			return FREQUENCEVALUE_CN;
-		case DRIVER:
-			return DRIVER_CN;
-		case OFFSET:
-			return OFFSET_CN;
-		case PROBE:
-			return PROBE_CN;
-		case FREQUENCE:               
-			return FREQUENCE_CN;
-		case DIFILTER:
-			return DIFILTER_CN;
-		case GAIN:                 
-			return GAIN_CN;
-		case PHASE:
-     			return PHASE_CN;
-		case HIFILTER:           
-			return HIFILTER_CN;
-		case LOFILTER:          
-			return LOFILTER_CN;
-		case CRAFTPARA:
-			return CRAFTPARA_CN;
-		case SAVEPARAM:
-			return SAVEPARAM_CN;
-		case LOADPARAM:
-			return LOADPARAM_CN;
-		case DELPARAM:
-			return DELPARAM_CN;
-		case SUB_TITLE2:
-			return SUB_TITLE2_CN;
-		case EXCUTE:
-			return EXCUTE_CN;
-		case LOADEMPTYDOC:
-			return LOADEMPTYDOC_CN;
-		case DELEMPTYDOC:
-			return DELEMPTYDOC_CN;
-		case OVERWRITECHECK:
-			return OVERWRITECHECK_CN;
-		case INFO_PASSWORD:
-			return INFO_PASSWORD_CN;
-		case INFO_PD_INVAIL:
-			return INFO_PD_INVAIL_CN;
-		case CLOSED:
-			return CLOSED_CN;
-		case HELPTITLE1:
-			return HELPTITLE1_CN;
-		case HELPTITLE2: 
-			return HELPTITLE2_CN;
-		case HELPB1F1:   
-			return HELPB1F1_CN;
-		case HELPB1F2:   
-			return HELPB1F2_CN;
-		case HELPB1F3:  
-			return HELPB1F3_CN;
-		case HELPB1F3_O:  
-			return HELPB1F3_O_CN;
-		case HELPB1F5:  
-			return HELPB1F5_CN;
-		case HELPB1F4:   
-			return HELPB1F4_CN;
-		case HELPB1F6:  
-			return HELPB1F6_CN;
-		case HELPB1F7:  
-			return HELPB1F7_CN;
-		case HELPB1ESC:  
-			return HELPB1ESC_CN;
-		case HELPB1ENTER:
-			return HELPB1ENTER_CN;
-		case GRAPHICFILE:
-			return GRAPHICFILE_CN;
-		case GRAPHICSAVE:
-			return GRAPHICSAVE_CN;
-		case INFORMESG10:
-			return INFORMESG10_CN;
-		case VIDEODISPLAY:
-			return VIDEODISPLAY_CN;
-		case COLORDISPLAY:
-			return COLORDISPLAY_CN;
-		case SIGZKDISPLAY:
-			return SIGZKDISPLAY_CN;
-		case INFORMESG22:
-			return INFORMESG22_CN;
-		case LOADDATA:
-			return LOADDATA_CN;
-		case SAVEDATA:
-			return SAVEDATA_CN;
-		case DELEDATA:
-			return DELEDATA_CN;
-		case SUB_TITLE3:
-			return SUB_TITLE3_CN;
-		case UPDATEPRO:
-		       return UPDATEPRO_CN;
-		case UPDATECOMFIRM:
-		       return UPDATECOMFIRM_CN;
-		case TRANINFO1:
-		       return TRANINFO1_CN;
-		case ALLGAIN:
-		       return ALLGAIN_CN;
-		case VIDEOOPEN:
-		       return VIDEOOPEN_CN;
-		case VIDEOCLOSE:
-		       return VIDEOCLOSE_CN;
-		case ADJRES:
-		       return ADJRES_CN;
-		case AUTODI:
-		       return AUTODI_CN;
-		case PAGE5:
-		       return PAGE5_CN;
-		case CHCOL:
-		       return CHCOL_CN;
-		case PGUP:
-		       return PGUP_CN;
-		case PGDN:
-		       return PGDN_CN;
-		case DATAFILE:
-		       return DATAFILE_CN;
-		case LOADDATA1:
-		       return LOADDATA1_CN;
-		case SAVEDATA1:
-		       return SAVEDATA1_CN;
-		case LANGUAGE:
-		       return LANGUAGE_CN;
-		case LAN_VALUE:
-			return LAN_VALUE_CN;
-		case DZKDISPLAY:
-			return DZKDISPLAY_CN;
-		case DATE:
-			return DATE_CN;
-		case TIME:
-			return TIME_CN;
-		case VERSION:
-			return VERSION_CN;
-		case ABOUTMSG1: 
-			return ABOUTMSG1_CN;
-		case ABOUTMSG2:
-			return ABOUTMSG2_CN;
-		case ABOUTMSG21:
-			return ABOUTMSG21_CN;
-		case ABOUTMSG22:
-			return ABOUTMSG22_CN;
-		case ABOUTMSG3:
-			return ABOUTMSG3_CN;
-		case ABOUTMSG4: 
-			return ABOUTMSG4_CN;
-		case ABOUTMSG5: 
-			return ABOUTMSG5_CN;
-		case ABOUTMSG7: 	       
-			return ABOUTMSG7_CN;
-		case ABOUTMSG6: 
-			return ABOUTMSG6_CN;
-		case ABOUTMSG8: 
-			return ABOUTMSG8_CN;
-		case SAMPLETYPE:
-			return SAMPLETYPE_CN;
-		case INSIDESAMP:
-			return INSIDESAMP_CN;
-		case OUTSIDESAMP:
-			return OUTSIDESAMP_CN;
-		case STIMEINTER:
-			return STIMEINTER_CN;
-		case SAMPPLUS:
-			return SAMPPLUS_CN;
-		case COLORSPOTDM:
-			return COLORSPOTDM_CN;
-		case DISPMOD_3D:
-			return DISPMOD_3D_CN;
-		case DISPMOD_2D:
-			return DISPMOD_2D_CN;
-		case SCANSPEED:
-			return SCANSPEED_CN;
-		case EDDYNETWORK:
-			return EDDYNETWORK_CN;
-		case IPMESG:
-			return IPMESG_CN;
-		case ERRORMSG1:
-			return ERRORMSG1_CN;
-		case INFORMESG07:
-			return INFORMESG07_CN;
-		case INFORMESG06:
-			return INFORMESG06_CN;
-		case SYSTEMDATE:
-			return SYSTEMDATE_CN;
-		case SYSTEMTIME:
-			return SYSTEMTIME_CN;
-		case INFORMESG21:
-			return INFORMESG21_CN;
-		case DELETE:
-			return DELETE_CN;
-		case DELETEHELP:
-			return DELETEHELP_CN;
-		case PICMANAGE:
-			return PICMANAGE_CN;
-		case PREVIEW:
-			return PREVIEW_CN;
-		case PREPIC:
-			return PREPIC_CN;
-		case PICFILE:
-			return PICFILE_CN;
-		case PREVIEWPIC:
-			return PREVIEWPIC_CN;
-		case DELPICFILE:
-			return DELPICFILE_CN;
-		case ALARMTYPE:
-			return ALARMTYPE_CN;
-		case ALARMACOUNT:           
-			return ALARMACOUNT_CN;
-		case ALARMBEEP:               
-			return ALARMBEEP_CN;
-		case ALARMOUT:
-			return ALARMOUT_CN;
-		case ALARMDISP:       
-			return ALARMDISP_CN;
-		case ALARMWINS:
-			return ALARMWINS_CN;
-		case LEFTLIMIT:
-			return LEFTLIMIT_CN;
-		case RIGHTLIMIT:
-			return RIGHTLIMIT_CN;
-		case UPLIMIT:
-			return UPLIMIT_CN;
-		case DOWNLIMIT:
-			return DOWNLIMIT_CN;
-		case DEGREE1:
-			return DEGREE1_CN;
-		case DEGREE2:
-			return DEGREE2_CN;
-		case XHALF:
-			return XHALF_CN;
-		case YHALF:
-			return YHALF_CN;
-		case RECTALARM:
-			return RECTALARM_CN;
-		case AMPALARM:
-			return AMPALARM_CN;
-		case HAMPALARM:
-			return HAMPALARM_CN;
-		case ALARMWINMENU:
-			return ALARMWINMENU_CN;
-		case OPEN:
-			return OPEN_CN;
-		case DEFAULT:
-			return DEFAULT_CN;
-		case RESTORE:
-			return RESTORE_CN;
-		case RESTOREDEFAULT:
-			return RESTOREDEFAULT_CN;
-		case REBOOTMSG:
-			return REBOOTMSG_CN;
-		case CLEANBUF:
-			return CLEANBUF_CN;
-		case RUNTIME:
-			return RUNTIME_CN;
-		case KEYBEEP:
-			return KEYBEEP_CN;
-		case SHUTDOWNMSG1:
-			return SHUTDOWNMSG1_CN;
-		case SHUTDOWNMSG2:
-			return SHUTDOWNMSG2_CN;
-		case TIMESCALE:
-			return TIMESCALE_CN;
-		case TIMESCALESPEED:
-			return TIMESCALESPEED_CN;
-		case MIXINGINFO1:
-			return MIXINGINFO1_CN;
-		case PRIFREQ:
-			return PRIFREQ_CN;
-		case SECFREQ:
-			return SECFREQ_CN;
-		case MIXFACTOR:
-			return MIXFACTOR_CN;
-		case MIXFACTORCOMFIRM:
-			return MIXFACTORCOMFIRM_CN;
-		case SAVEMIXCOMFIRM:
-			return SAVEMIXCOMFIRM_CN;
-		case X1POINT:
-			return X1POINT_CN;
-		case Y1POINT:
-			return Y1POINT_CN;
-		case X2POINT:
-			return X2POINT_CN;
-		case Y2POINT:
-			return Y2POINT_CN;
-		case GAINRATIO:
-			return GAINRATIO_CN;
-		case CLEANPHOTO:
-			return CLEANPHOTO_CN;
-		case OZKDISPLAY:
-			return OZKDISPLAY_CN;
-		case XNPOINT:
-			return XNPOINT_CN;
-		case YNPOINT:
-			return YNPOINT_CN;
-		case SCOPE:
-			return SCOPE_CN;
-		case WHOLE:
-			return WHOLE_CN;
-		case CROSSCHAN:
-			return CROSSCHAN_CN;
-		case ALARMLIMIT:
-			return ALARMLIMIT_CN;
-		case COMBINING:
-			return COMBINING_CN;
-		case ASCANCHAN:
-			return ASCANCHAN_CN;
-		case EMSGAIN:
-			return EMSGAIN_CN;
-		case ASCANSPEED:
-			return ASCANSPEED_CN;
-		case PARASYNC:
-			return PARASYNC_CN;
-		case PARASYNCCOMFIRM:
-			return PARASYNCCOMFIRM_CN;
-		case RESBALACE:
-			return RESBALACE_CN;
-		case ADRIVE: 		
-			return ADRIVE_CN;
-		case BDRIVE: 		
-			return BDRIVE_CN;
-		case APICK: 		
-			return APICK_CN;
-		case BPICK: 		
-			return BPICK_CN;
-		case RFFILTER:
-			return RFFILTER_CN;
-		case PRECISION:
-			return PRECISION_CN;
-		case PREHIGH:
-			return PREHIGH_CN;
-		case PREMED:
-			return PREMED_CN;
-		case PRELOW:
-			return PRELOW_CN;
-		case OPERATION:
-			return OPERATION_CN;
-		default:
-			return NONE_CN;
-	}
-}
diff --git a/src/EVA11/Language.h b/src/EVA11/Language.h
deleted file mode 100644
index 978c54f..0000000
--- a/src/EVA11/Language.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Language.h
- *
- *    Description:  Manage the Language string
- *
- *        Version:  1.0
- *        Created:  2011年02月10日 13时35分52秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  _LANGUAGE_INC
-#define  _LANGUAGE_INC
-
-#include 	<memory>
-#include 	"ProjectGBText.h"
-
-class Language
-{
-	public:
-		static Language* Instance();             /* only used this function to visit variables   */
-
-		char const *GetText(int index);
-		inline int GetLang(){ return m_Langue;}
-		inline void SetLang(int value) { m_Langue = value;}
-	protected:
-	private:
-		Language ();
-		~Language ();
-		Language (const Language&);
-		Language& operator = (const Language&);
-	private:
-		char const *Get_EN_Text(int index);
-		char const *Get_CN_Text(int index);
-	private:
-		friend class std::auto_ptr<Language>;
-		static std::auto_ptr<Language>		m_Instance;
-		int              			m_Langue;
-}; /* -----  end of class Language  ----- */
-
-#endif   /* ----- #ifndef language_INC  ----- */
diff --git a/src/EVA11/LimitManage.cpp b/src/EVA11/LimitManage.cpp
deleted file mode 100644
index afafb83..0000000
--- a/src/EVA11/LimitManage.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  LimitManage.cpp
- *
- *    Description:  implementation of LimitManage class 
- *
- *        Version:  1.0
- *        Created:  2013年04月07日 10时18分47秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Global.h"
-#include 	"LimitManage.h"
-#include 	"Basescreen.h"
-#include 	"AlarmRegion.h"
-
-LimitManage::LimitManage (int x,int y,int width,int heigh)
-	: Object(x,y,width,heigh)
-{
-}
-
-LimitManage::~LimitManage ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Alarm_Sets
- *  Description:  Init the Alarm parameters 
- * =====================================================================================
- */
-void LimitManage::Init_Alarm_Sets(Graphic&)
-{
-	m_Alarm = new(std::nothrow) SLimitAlarm(m_X,m_Y,m_Width,m_Heigh);
-	m_Alarm->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_Alarm_Sets
- *  Description:  Destroy the Alarm Sets 
- * =====================================================================================
- */
-void LimitManage::Destroy_Alarm_Sets()
-{
-	delete m_Alarm;
-	m_Alarm = NULL;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm window parameters into Object 
- * =====================================================================================
- */
-void LimitManage::Load_Alarm_Para(int gpalarm)
-{
-	m_Alarm->Set_4Para(gpalarm,
-				       0,
-				       0,
-				       0);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Alarm_Para
- *  Description:  Save Alarm window parameters into Object 
- * =====================================================================================
- */
-void LimitManage::Save_Alarm_Para(int& gpalarm)
-{
-	Global *gp = Global::Instance();
-	gpalarm = m_Alarm->Get_P1();
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Alarm_Sets
- *  Description:  Draw all class manage alarm on screen 
- * =====================================================================================
- */
-void LimitManage::Draw_Alarm_Sets(Graphic& g,bool bufflag)
-{
-	Global *gp = Global::Instance();
-//	if 	( m_AlarmType == 3 ) return;
-
-	if ( bufflag == true )
-		g.Switch_Screen();
-
-	m_Alarm->Drawme(g,false);
-
-	if ( bufflag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Adj_P1
- *  Description:  Adjust the 1 parameters of device 
- * =====================================================================================
- */
-void LimitManage::Adj_P1(int v,int& gpalarm)
-{
-	Global *gp = Global::Instance();
-
-	m_Alarm->Adj_P1(v);
-
-	Save_Alarm_Para(gpalarm);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Is_In_Alarm
- *  Description:  Judge the signal whether in Alarm 
- * =====================================================================================
- */
-int LimitManage::Is_In_Alarm(const int& x,const int& y)
-{
-	Global *gp = Global::Instance();
-
-	if ( m_Alarm->Is_In_Region(x,y) )
-		return 0;
-	else
-		return 0xff;
-}
diff --git a/src/EVA11/LimitManage.h b/src/EVA11/LimitManage.h
deleted file mode 100644
index 06c6ff7..0000000
--- a/src/EVA11/LimitManage.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  LimitManage.h
- *
- *    Description:  Something like the AlarmManage class 
- *
- *        Version:  1.0
- *        Created:  2013年04月07日 10时14分13秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  LIMITMANAGE_INC
-#define  LIMITMANAGE_INC
-
-class Object;
-class IAlarm;
-class LimitManage : public Object
-{
-	public:
-		LimitManage (int x,int y,int width,int heigh);
-		virtual ~LimitManage();
-
-		void Init_Alarm_Sets(Graphic&);
-		void Destroy_Alarm_Sets();
-
-		void Load_Alarm_Para(int gpalarm);
-		void Save_Alarm_Para(int& gpalarm);
-
-		void Draw_Alarm_Sets(Graphic& g,bool bufflag=false);
-
-		void Adj_P1(int,int& gpalarm); 
-
-		int Is_In_Alarm(const int& x,const int& y); 
-	protected:
-
-	private:
-		IAlarm*			m_Alarm;
-};
-
-#endif   /* ----- #ifndef LIMITMANAGE_INC  ----- */
diff --git a/src/EVA11/Loadwin.cpp b/src/EVA11/Loadwin.cpp
deleted file mode 100644
index db04d6b..0000000
--- a/src/EVA11/Loadwin.cpp
+++ /dev/null
@@ -1,605 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Loadwin.cpp
- *
- *    Description:  Implementation of Loadwin class
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 14时39分24秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<typeinfo>
-#include 	<fstream>
-
-#include 	<boost/format.hpp>
-
-#include 	"Basewin.h"
-#include	"Loadwin.h"
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Logic.h"
-#include	"Label.h"
-#include	"Language.h"
-#include	"Global.h"
-#include	"Msgbox.h"
-#include	"Battery.h"
-#include 	"Parawin.h"
-#include 	"Algorithm.h"
-
-#include 	"FreeType.h"
-#include 	"Png.h"
-
-#include 	"Resource.h"
-
-Loadwin::Loadwin (Graphic&g,LOADTYPE type)
-{
-	m_Type = type;
-}
-
-Loadwin::~Loadwin ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object of screen 
- * =====================================================================================
- */
-void Loadwin::Init_GUI(Graphic& g)
-{
-        m_Title = new Label(90,12,460,30);
-	m_Title->Set_Label_Type(Label::LA_NONE);
-	m_Title->Set_Text(m_pl->GetText(MAINTITLE));
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-
-	Sub_Init_GUI(g);
-
-	m_NorLable[26] = new Label(3+424,53+39*9,210,38);
-	m_NorLable[26]->Set_Label_Type(Label::LA_3D);
-	m_NorLable[26]->Set_Text(m_pl->GetText(MAINBUTTON));
-	m_NorLable[26]->Set_Font_Size(18);
-	m_NorLable[26]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_NorLable[26]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	m_NorLable[26]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	m_NorLable[26]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-	m_BottomFocus = 1;
-	m_NormalFocus = 27;
-	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-	m_BomButton[m_BottomFocus-1]->Set_Focus(true);
-
-	for ( int i=0;i<3;i++ )	
-	{
-		m_BlankLable[i] = new Label(3+424,53+39*(i+6),210,38);
-		m_BlankLable[i]->Set_Text(m_pl->GetText(RESERVE));
-		m_BlankLable[i]->Set_Label_Type(Label::LA_3D);
-		m_BlankLable[i]->Set_Font_Size(18);
-		m_BlankLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_BlankLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_BlankLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_BlankLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	}
-
-	std::string s = str(boost::format("Ver:%s")%PROVERSION);
-	m_Version = new Label(8+40,15,70,22);
-	m_Version->Set_Font_Size(16);
-	m_Version->Set_Text(s.c_str());
-	m_Version->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Version->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_Version->Set_Label_Type(Label::LA_NONE);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void Loadwin::Destroy_GUI()
-{
-	if ( m_Title != NULL )
-	{
-		delete m_Title;
-		m_Title = NULL;
-	}
-	if ( m_SubTitle != NULL )
-	{
-		delete m_SubTitle;
-		m_SubTitle = NULL;
-	}
-	if ( m_Version != NULL )
-	{
-		delete m_Version;
-		m_Version = NULL;
-	}
-	for ( int i=0;i<27;i++ )
-	{
-		if ( m_NorLable[i] != NULL ) 
-		{
-			delete m_NorLable[i];
-			m_NorLable[i] = NULL;
-		}
-	}
-	for ( int i=0;i<3;i++ )	
-	{
-		if ( m_BlankLable[i] != NULL ) 
-		{
-			delete m_BlankLable[i];
-			m_BlankLable[i] = NULL;
-		}
-	}
-	Basewin::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bom_Index
- *  Description:  Return the Bom button text 
- *        index: from 0 to 6
- * =====================================================================================
- */
-const char*Loadwin::Get_Bom_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0: 
-			return m_pl->GetText(PREVIOUSE);
-			break;
-		case 1: 
-			return m_pl->GetText(NEXT);
-			break;
-		case 2: 
-			return m_pl->GetText(LEFTC);
-			break;
-		case 3: 
-			return m_pl->GetText(RIGHTC);
-			break;
-		case 4: 
-			return m_pl->GetText(NONE);
-			break;
-		case 5: 
-			return m_pl->GetText(COMFIRM);
-			break;
-		case 6: 
-			return m_pl->GetText(BACKOUT);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_Title
- *  Description:  Init the normal button title 
- * =====================================================================================
- */
-void Loadwin::Init_Normal_Title()
-{
-	char oc;
-	int num;
-
-	for ( int i = 0; i < TITLECOUNT ; i += 1 )
-	{
-		m_Text[i]	=	" ";
-	}
-
-	std::string strfilename = str(boost::format("%s%s")%RUN_PATH%"PAR.NAM");
-	std::fstream filestream;                /* used by save data */
-	filestream.open(strfilename.c_str(),std::ios::in|std::ios::out);
-
-	if (!filestream)
-		perror("Not Found The PAR.NAM File,Continue....\n");
-	else
-	{
-		int i=0;
-		int index=0;
-		while(!filestream.eof())        /* go through the whold file do preparation of the menu text*/
-		{
-			filestream.get(oc);
-			if (oc >= 'A' && oc <= 'Z' )
-			{
-				index = oc - 0x41;
-				filestream.get(oc);
-				if (oc == ' ')
-				{
-					if ( i != index ) i = index;
-					m_Text[i] = ""; /* reset the value of string */
-					filestream.get(oc);
-					do
-					{
-						m_Text[i] = m_Text[i] + oc;	
-						filestream.get(oc);
-					}while( oc!=0x0d && !filestream.eof() );
-					i = i + 1;
-				}
-			}
-		}
-		filestream.close();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- * =====================================================================================
- */
-void Loadwin::Drawme (Graphic& g)
-{
-	Basewin::Drawme(g);
-	m_Title->Drawme(g);
-	m_SubTitle->Drawme(g);
-	m_Version->Drawme(g);
-
-	Resource *res = Resource::Instance();
-	res->Show_Resource_Png(g,7,5,5);
-
-	for ( int i=0;i<27;i++ )
-	{
-		m_NorLable[i]->Drawme(g);
-	}
-	for ( int i=0;i<3;i++ )
-	{
-		m_BlankLable[i]->Drawme(g);
-	}
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function 
- *       return:  0: Exit program
- *                1: goto Mainwin
- * =====================================================================================
- */
-int Loadwin::Loopwindow (Graphic &g)
-{
-	return SubLoopwindow(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Loadwin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-	return CO_NONE;
-}
-int Loadwin::Key_Bom2_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,2);
-	return CO_NONE;
-}
-int Loadwin::Key_Bom3_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,3);
-	return CO_NONE;
-}
-int Loadwin::Key_Bom4_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,4);
-	return CO_NONE;
-}
-int Loadwin::Key_Bom6_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,6);
-	return CO_OK;
-}
-int Loadwin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Loadwin::Key_Esc_Fun(Graphic& g)
-{
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(COMFIRMEXIT),Msgbox::MSG_OKCANCEL);	
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == true )
-	{
-		delete ms;
-		ms = NULL;
-		return CO_EXIT;
-	}
-	delete ms;
-	ms = NULL;
-	return CO_NONE;
-}
-int  Loadwin::Key_Enter_Fun(Graphic& g)
-{
-	return Key_Bom6_Fun(g);
-}
-
-int Loadwin::Key_F5_Fun(Graphic& g)
-{
-	Logic* lo = Logic::Instance();
-	lo->Screen_Shoot(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  As the input parameter index to set the bottoms button status  
- * =====================================================================================
- */
-void Loadwin::DrawBottomFocus(Graphic& g,int index)
-{
-	Basewin::DrawBottomFocus(g,index);
-	switch ( index ) 
-	{
-		case 1:                         /* previouse */
-			{
-				if ( m_NormalFocus == 1 )
-				{
-				        m_NormalFocus = 27;
-					m_NorLable[0]->Set_Focus(false);
-					m_NorLable[0]->Drawme(g);
-					m_NorLable[26]->Set_Focus(true);
-					m_NorLable[26]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus--;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-
-			}
-			break;
-		case 2:                         /* next */
-			{
-				if ( m_NormalFocus == 27 )
-				{
-				        m_NormalFocus = 1;
-					m_NorLable[26]->Set_Focus(false);
-					m_NorLable[26]->Drawme(g);
-					m_NorLable[0]->Set_Focus(true);
-					m_NorLable[0]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus++;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 3:                         /* left  */
-			{
-				if ( m_NormalFocus < 7 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 20;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus >= 7 && m_NormalFocus <= 9 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus == 10 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus = 27;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus == 27 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus = 20;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 4:                         /* right */
-			{
-				if ( m_NormalFocus > 20 && m_NormalFocus != 27 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 20;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus <= 19 && m_NormalFocus > 16 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus == 20 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus = 27;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus == 27 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus = 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SubLoopwindow
- *  Description:  SubLoopwindow function for Loopwindow 
- * =====================================================================================
- */
-int Loadwin::SubLoopwindow(Graphic &g)
-{
-	int result = 0;
-	Init_Normal_Title();
-	Init_GUI(g);
-	Drawme(g);
-
-	while( 1 )
-	{
-		result = Command_Process(g);
-		if 	( result == CO_EXIT )
-			goto Exit;
-		else if ( result == CO_OK )
-		{
-			if  	( m_NormalFocus == 27 )
-			{
-				m_alg->MDelay(100);
-				goto Exit;
-			}
-			else
-			{
-				Parawin *paraw;
-				if 	( m_Type == LT_LOAD )
-					paraw = new Parawin(Parawin::PT_LOAD,'a'+m_NormalFocus-1);
-				else if ( m_Type == LT_SAVE )
-					paraw = new Parawin(Parawin::PT_SAVE,'a'+m_NormalFocus-1);
-				else if ( m_Type == LT_DELE )
-					paraw = new Parawin(Parawin::PT_DELE,'a'+m_NormalFocus-1);
-
-				else if ( m_Type == DA_LOAD )
-					paraw = new Parawin(Parawin::DA_LOAD,'a'+m_NormalFocus-1);
-				else if ( m_Type == DA_SAVE )
-					paraw = new Parawin(Parawin::DA_SAVE,'a'+m_NormalFocus-1);
-				else if ( m_Type == DA_DELE )
-					paraw = new Parawin(Parawin::DA_DELE,'a'+m_NormalFocus-1);
-
-				result = paraw->Loopwindow(g);
-				delete paraw;
-				paraw = NULL;
-				if 	( result == CO_LOADEXIT )
-					goto Exit;
-			}
-		}
-	}
-
-Exit:
-	Destroy_GUI();
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sub_Init_GUI
- *  Description:  Subversion to init GUI 
- * =====================================================================================
- */
-void Loadwin::Sub_Init_GUI(Graphic &g)
-{
-	Basewin::Init_GUI(g);
-	/*-----------------------------------------------------------------------------
-	 *  Init the buttom line buttons
-	 *-----------------------------------------------------------------------------*/
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-	}	
-
-	m_BomSmall->Set_Text("X");
-
-	m_SubTitle = new Label(550,25,80,22);
-	m_SubTitle->Set_Label_Type(Label::LA_NONE);
-	m_SubTitle->Set_Text(m_pl->GetText(SUBTITLE));
-	m_SubTitle->Set_Font_Size(16);
-	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-
-	if 	( m_gp->Language == 1 )
-		m_Title->Set_Font_Size(16);
-	else if ( m_gp->Language == 0 )
-		m_Title->Set_Font_Size(26);
-
-	for ( int i=0;i<10;i++ )
-	{
-		m_NorLable[i] = new Label(3,53+39*i,210,38);
-		m_NorLable[i]->Set_Label_Type(Label::LA_3D);
-		m_NorLable[i]->Set_Text((char *)m_Text[i].c_str());
-		m_NorLable[i]->Set_Font_Size(18);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	}
-	for ( int i=0;i<10;i++ )
-	{
-		m_NorLable[10+i] = new Label(3+212,53+39*i,210,38);
-		m_NorLable[10+i]->Set_Label_Type(Label::LA_3D);
-		m_NorLable[10+i]->Set_Text((char *)m_Text[i+10].c_str());
-		m_NorLable[10+i]->Set_Font_Size(18);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	}
-	for ( int i=0;i<6;i++ )
-	{
-		m_NorLable[20+i] = new Label(3+424,53+39*i,210,38);
-		m_NorLable[20+i]->Set_Label_Type(Label::LA_3D);
-		m_NorLable[20+i]->Set_Text((char *)m_Text[i+10].c_str());
-		m_NorLable[20+i]->Set_Font_Size(18);
-		m_NorLable[20+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[20+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[20+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[20+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	}
-}
diff --git a/src/EVA11/Loadwin.h b/src/EVA11/Loadwin.h
deleted file mode 100644
index a9e5adf..0000000
--- a/src/EVA11/Loadwin.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Loadwin.h
- *
- *    Description:  Manage the Parameters loading 
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 14时37分32秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _LOADWIN_INC
-#define  _LOADWIN_INC
-
-#include 	<string>
-class Loadwin : public Basewin
-{
-	public:
-		enum LOADTYPE 
-		{
-			LT_LOAD,
-			LT_SAVE,
-			LT_DELE,
-
-			DA_LOAD,	
-			DA_SAVE,
-			DA_DELE
-		};						                 /* ----------  end of enum LOADTYPE  ---------- */
-		typedef enum LOADTYPE LOADTYPE;
-
-		Loadwin (Graphic&g,LOADTYPE type);   		                 /* constructor */
-		virtual ~Loadwin ();                           	                 /* destructor */
-
-		void Drawme (Graphic& g);       		                 /* Any window coming from window class draw itself on screen */
-		int Loopwindow (Graphic &);        		                 /* deal with the command getting from key board  */
-
-	protected:
-		virtual int Key_Bom1_Fun(Graphic& g);
-		virtual int Key_Bom2_Fun(Graphic& g);
-		virtual int Key_Bom3_Fun(Graphic& g);
-		virtual int Key_Bom4_Fun(Graphic& g);
-		virtual int Key_Bom6_Fun(Graphic& g);
-		virtual int Key_Bom7_Fun(Graphic& g);
-
-		virtual int Key_Esc_Fun(Graphic& g);
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual int Key_F5_Fun(Graphic& g); 
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		void Init_Normal_Title();
-		const char*Get_Bom_Text(int);
-		void DrawBottomFocus(Graphic &g,int index);     		 /* change the bottom buttons status as the parameter index */
-
-		int SubLoopwindow(Graphic &);
-		void Sub_Init_GUI(Graphic &);
-
-	protected:
-		static const int		     TITLECOUNT = 26;
-
-		int                                  m_NormalFocus;
-		std::string 			     m_Text[TITLECOUNT];
-		LOADTYPE                             m_Type;
-		Label                               *m_Title;
-		Label                               *m_SubTitle;
-		Label                               *m_Version;
-		Label                               *m_NorLable[27];             /* Normal Lines A~Z and Normal detect */
-		Label                               *m_BlankLable[3];            /* Nothing function                   */
-}; /* -----  end of class Loadwin  ----- */
-#endif   /* ----- #ifndef _LOADWIN_INC  ----- */
diff --git a/src/EVA11/Log.cpp b/src/EVA11/Log.cpp
deleted file mode 100644
index 928a0a0..0000000
--- a/src/EVA11/Log.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Log.cpp
- *
- *    Description:  Implementation of Log class
- *
- *        Version:  1.0
- *        Created:  2013年06月05日 15时05分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<unistd.h>
-#include 	<sys/types.h>
-#include 	<dirent.h>
-#include	<cstdio>
-
-#include 	<log4cplus/logger.h>
-#include 	<log4cplus/loggingmacros.h>
-#include 	<log4cplus/configurator.h>
-#include 	<log4cplus/fileappender.h>
-
-#include	"main.h"
-#include	"Log.h"
-
-std::auto_ptr<Log> Log::m_Instance;
-
-struct Log::PImpl
-{
-	log4cplus::Logger 		    m_log;
-	int				    m_Files_Amount;
-	char*				    m_Msg;
-};
-
-Log::Log() : m_Imple(new struct PImpl)
-{
-	log4cplus::BasicConfigurator config;
-	config.configure();
-
-	m_Imple->m_log = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT("EVA11"));
-	m_Imple->m_log.setLogLevel(log4cplus::INFO_LOG_LEVEL);
-
-	Create_Log_Directory_File();
-
-	m_Imple->m_Msg = new char[200];
-}
-
-Log::~Log()
-{
-	delete[] m_Imple->m_Msg;
-	m_Imple->m_Msg = NULL;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Log* Log::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Log() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_Log
- *  Description:  Write the Log into media
- * =====================================================================================
- */
-void Log::Write_Log(const char* log)
-{
-	struct tm *timenow;
-	time_t now;
-	time(&now);
-	timenow = localtime(&now);
-
-	sprintf(m_Imple->m_Msg,"%04d-%02d-%02d %02d:%02d:%02d V%s %s",
-			timenow->tm_year+1900,timenow->tm_mon+1,timenow->tm_mday,
-			timenow->tm_hour,timenow->tm_min,timenow->tm_sec,PROVERSION,log);
-
-	LOG4CPLUS_INFO(m_Imple->m_log,LOG4CPLUS_TEXT(m_Imple->m_Msg));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Create_Log_Directory
- *  Description:  Create the Log directory and file 
- * =====================================================================================
- */
-void Log::Create_Log_Directory_File()
-{
-	char *file = new char[100];
-	if ( access(LOGDIRECTORY,0) != 0 )
-	{
-		sprintf(file,"mkdir -p %s",LOGDIRECTORY);
-		int re = system(static_cast<const char*>(file));
-		m_Imple->m_Files_Amount = 0;
-	}
-	struct tm *timenow;
-	time_t now;
-	time(&now);
-	timenow = localtime(&now);
-	sprintf(file,"%s/EVA11-P%03d-%04d-%02d-%02d-%02d-%02d-%02d.log",LOGDIRECTORY,m_Imple->m_Files_Amount+1,timenow->tm_year+1900,timenow->tm_mon+1,timenow->tm_mday,timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-	log4cplus::SharedAppenderPtr append(new log4cplus::FileAppender(file));
-	append->setName("EVA11 log File");
-	m_Imple->m_log.addAppender(append);
-	delete[] file;
-	file = NULL;
-	sync();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Scan_Files_Amount
- *  Description:  Scan the Files of log directory amount 
- * =====================================================================================
- */
-void Log::Scan_Files_Amount()
-{
-	DIR *dp;
-	struct dirent *dirp;
-	m_Imple->m_Files_Amount = 0;
-
-	if ( ( dp = opendir(LOGDIRECTORY) ) == NULL )
-		printf ( "not open directory \n" );
-	else
-	{
-		while( ( dirp = readdir(dp) ) != NULL )
-		{
-			m_Imple->m_Files_Amount ++;
-		}
-
-		m_Imple->m_Files_Amount -= 2;		//directory:  .   ..
-		closedir(dp);
-	}
-}
diff --git a/src/EVA11/Log.h b/src/EVA11/Log.h
deleted file mode 100644
index 9a58289..0000000
--- a/src/EVA11/Log.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Log.h
- *
- *    Description:  manage the Log class,write Log messgae into file or 
- *                  show them on screen
- *
- *        Version:  1.0
- *        Created:  2013年06月05日 15时05分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  LOG_INC
-#define  LOG_INC
-
-#include 	<memory>	
-class Log
-{
-	public:
-		static Log* Instance();
-		void Write_Log(const char*);
-
-	private:
-		Log ();                             /* constructor */
-		~Log ();                            /* destructor  */
-		Log( const Log& );
-		Log& operator = (const Log&);
-
-		void Create_Log_Directory_File();
-		void Scan_Files_Amount();
-	private:
-		friend class std::auto_ptr<Log>;
-		static std::auto_ptr<Log>    	    m_Instance;
-
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	    m_Imple;
-};
-
-#endif
diff --git a/src/EVA11/Logic.cpp b/src/EVA11/Logic.cpp
deleted file mode 100644
index a3d4626..0000000
--- a/src/EVA11/Logic.cpp
+++ /dev/null
@@ -1,997 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Logic.cpp
- *
- *    Description:  Implementation of Logic class
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 15时36分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdio>
-#include	<iostream>
-#include	<fstream>
-#include	<sys/vfs.h>
-#include 	<boost/bind.hpp>
-
-#include 	"Graphic.h"
-#include 	"Logic.h"
-#include	"Msgbox.h"
-#include 	"Device.h"
-#include 	"Language.h"
-#include 	"Algorithm.h"
-#include	"Global.h"
-#include 	"JpegOper.h"
-#include 	"DataRepo.h"
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"ManageMD5.h"
-#include 	"Gradual.h"
-#include 	"MixingManage.h"
-#include 	"FreeType.h"
-
-std::auto_ptr<Logic> Logic::m_Instance;
-
-Logic::Logic ()
-{
-	m_pl     	= Language::Instance();
-	m_alg    	= Algorithm::Instance();
-	m_device 	= Device::Instance();
-	m_gp     	= Global::Instance();
-	m_repo		= DataRepo::Instance();
-
-	m_SuffixJpeg    = ".jpeg"; 
-
-#ifdef X86
-#else
-	m_ADC_fd = open("/dev/ADC", O_RDWR);
-	if ( m_ADC_fd < 0 ) { perror("Unable to open the ADC file!"); }
-#endif
-}  /* -----  end of method Logic::Logic  (constructor)  ----- */
-
-Logic::~Logic ()
-{
-#ifdef X86
-#else
-	if ( m_ADC_fd != -1 )
-	{
-		close(m_ADC_fd);
-	}
-#endif
-}  /* -----  end of method Logic::~Logic  (destructor)  ----- */
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-Logic* Logic::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Logic() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Hardware
- *  Description:  Init the FPGA work mode 
- * =====================================================================================
- */
-void Logic::Init_Hardware(Graphic& g)
-{
-	if 	( m_device->Init_ET_Board() == false )
-	{
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG09),Msgbox::MSG_OK);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g);
-		delete ms;
-		ms = NULL;
-		while(1);                                                /* Waiting shutdown 		  */
-	}
-	else
-	{
-		m_g = &g;
-		for ( int i = 0; i < 10; i += 1 ) 			/* Just clean unstable key status */
-			Get_Key();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ShutDownMsg
- *  Description:  
- * =====================================================================================
- */
-void Logic::ShutDownMsg(const boost::system::error_code & e)
-{
-	printf ( "Shutdown Device!\n" );
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_Hardware
- *  Description:  Release the Hardware source
- * =====================================================================================
- */
-void Logic::Release_Hardware()
-{
-	m_device->UnInit_ET_Board();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Global_Variables_Into_PCB
- *  Description:  Set device all partial_sumrameters into FPGA  
- *                call it, when set to default value or start the device 
- * =====================================================================================
- */
-void Logic::Set_Global_Variables_Into_PCB()
-{
-	m_device->Write_Para_Func(Device::NORMAL);
-	for ( int ch=0;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		m_device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		m_device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		m_device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-
-		m_device->Write_Para_DriverBal(ch,m_gp->DriverBal[ch]);
-		m_device->Write_Para_DriveA_ID(ch,m_gp->DriverA_ID[ch]);
-		m_device->Write_Para_DriveB_ID(ch,m_gp->DriverB_ID[ch]);
-		m_device->Write_Para_PickA_ID(ch,m_gp->PickA_ID[ch]);
-		m_device->Write_Para_PickB_ID(ch,m_gp->PickB_ID[ch]);
-	}
-
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		m_device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	m_device->Write_Para_Driver(m_gp->Driver);
-	m_device->Write_Para_Offset(m_gp->Offset);
-	m_device->Write_Para_SignalWave(0);
-
-	m_device->Transfer_ECT_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Global_Variables_Into_System
- *  Description:  We need one function to calculate system variables into system 
- * =====================================================================================
- */
-void Logic::Set_Global_Variables_Into_System()
-{
-	m_gp->Calculate_Gain();
-	m_pl->SetLang(m_gp->Language);
-	Reset_Data_Repo();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_Data_Repo
- *  Description:  Reset the Data of Repo 
- *                when chang the display panel need call it to chang the each loop 
- *                word cout
- * =====================================================================================
- */
-void Logic::Reset_Data_Repo()
-{
-	if 	( m_gp->PanelType == 2 )             // Single ZKScreen
-		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),1<<2);
-	else if ( m_gp->PanelType == 3 )             // Double ZKScreen
-		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),2<<2);
-	else if ( m_gp->PanelType == 4 )             // Oct ZKScreen
-		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),16<<2);
-	else if ( m_gp->PanelType == 5 )             // Composite ZKScreen
-		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),2<<2);
-	else 
-		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),Global::CHANCOUNT<<2);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Key
- *  Description:  Get the Key Value from device or keyboard 
- * =====================================================================================
- */
-int Logic::Get_Key()
-{
-	if 	( KEYSOURCE == 0 )
-	{
-		return Get_Key_From_Keyboard();
-	}
-	else if ( KEYSOURCE == 1 )
-	{
-		return Get_Key_From_FPGA(); 
-	}
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Key_From_FPGA
- *  Description:  Get key value from FPGA 
- * =====================================================================================
- */
-int Logic::Get_Key_From_FPGA()
-{
-	if 	( !( m_device->Read_Port(0x0006) & 0x40) )
-	{
-		m_alg->MDelay(1500);
-		if	( !(m_device->Read_Port(0x0006) & 0x40) )
-		{
-			Shutdown();
-			while(1);
-		}
-	}
-
-	int key = m_device->Read_Port(0x002F);
-
-	if 	( key & 0x80 )
-	{
-		if ( m_gp->MultiKey < 30 ) m_gp->MultiKey ++;
-
-		if ( m_gp->KeyBeep == true )
-			Short_Beep();
-		return (key & 0x7f);
-	}
-	else if ( key == 0 )
-	{
-		m_gp->MultiKey = 0;
-		return key;
-	}
-	else
-	{
-		m_gp->MultiKey = 0;
-		if ( m_gp->KeyBeep == true )
-			Short_Beep();
-		return (key & 0x7f);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Key_From_Keyboard
- *  Description:  Get the key value form keyboard 
- * =====================================================================================
- */
-int Logic::Get_Key_From_Keyboard()
-{
-	int key;                                			/* because the getchar function return int type  */
-	key = getchar();
-
-	if ( key == 27 )
-	{
-		key = getchar();
-		if ( key == -1 ) return KEY_ESC;
-		else if ( key == 91 )           			/* function key value */
-		{
-			key = getchar();
-			if ( key == 49 ) 
-			{
-				key = getchar();
-				if ( key == 55 )
-				{
-					key = getchar();
-					if ( key == 126 )
-					{
-						return KEY_F6; 		/* F6 key value */
-					}
-				}
-			}
-			else if ( key == 91 )
-			{
-				key = getchar();
-				if ( key == 65 ) return KEY_F1;
-				if ( key == 66 ) return KEY_F2;
-				if ( key == 67 ) return KEY_F3;
-				if ( key == 68 ) return KEY_F4;
-			}
-		}
-	}
-	else
-	{
-		if 	( key == 0xffffffff )
-			return 0;
-		else
-			return key;                    			/* Normal key return immediately */
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Shutdown
- *  Description:  When user instruct, closed the power
- * =====================================================================================
- */
-void Logic::Shutdown()
-{
-	boost::asio::io_service io;
-	boost::asio::deadline_timer t(io,boost::posix_time::seconds(3));
-
-	t.async_wait(boost::bind(&Logic::ShutDownMsg,this,_1));
-
-	short m_BGColor = g_BUBGNO_CO;
-	short m_FGColor = g_BUTXNO_CO;
-
-	short x         = 180;
-	short y         = 160;
-	short basex     = x;
-	short basey     = y;
-	short width     = 310;
-	short heigh     = 68;
-	int   ft        = 16;
-	unsigned char *mem = new unsigned char[m_g->Get_Disp_Area_Bytes(x,y,x+width-1,y+heigh-1)];
-	m_g->Load_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
-	/*-----------------------------------------------------------------------------
-	 *  Draw the front color 
-	 *-----------------------------------------------------------------------------*/
-	m_g->DrawFillRect(x,y,width,heigh,m_BGColor);
-
-	m_g->Setcolor(m_FGColor);
-	m_g->DrawRect(x,y,width,heigh);
-	m_g->DrawRect(x+1,y+1,width-2,heigh-2);
-	m_g->Setcolor(m_g->RGB24_16(0x000000));
-	m_g->DrawRect(x+2,y+2,width-4,heigh-4);
-	m_g->DrawRect(x+3,y+3,width-6,heigh-6);
-	m_g->Setcolor(m_FGColor);
-	m_g->DrawRect(x+4,y+4,width-8,heigh-8);
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,m_FGColor);
-	font->Set_Color(FreeType::BGCOLOR,m_BGColor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(basex+90+21,basey+10+17,m_pl->GetText(SHUTDOWNMSG1));
-	font->Text(basex+14+21,basey+35+17,m_pl->GetText(SHUTDOWNMSG2));
-
-	Pre_Shutdown();
-
-	io.run();
-
-	sync();
-
-	m_g->Restore_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
-	delete[] mem;
-	mem = NULL;
-
-	m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)|0x80);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pre_Shutdown
- *  Description:  Before shutdown we need to do some job 
- * =====================================================================================
- */
-void Logic::Pre_Shutdown()
-{
-	/*-----------------------------------------------------------------------------
-	 * Save parameters into flash 
-	 *-----------------------------------------------------------------------------*/
-	Global *pgp = Global::Instance();
-	pgp->Save_Global_Variables(PAR_FILE_PATH);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Alarm_Beep
- *  Description:  Set the beep operation status
- *                status: true set the beep and led 
- * =====================================================================================
- */
-void Logic::Alarm_Beep(bool status)
-{
-	if 	( status == true )                             /* set the status of led on detect object  */
-		m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)|0x40);
-	else
-		m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)&0xBF);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Short_Beep
- *  Description:  Alarm a short beep 
- * =====================================================================================
- */
-void Logic::Short_Beep()
-{
-	Alarm_Beep(true);
-	m_alg->MDelay(40);
-	Alarm_Beep(false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Frequence_2_Char
- *  Description:  Convert frequence to char 
- * =====================================================================================
- */
-void Logic::Frequence_2_Char(int freqvalue,char* msg)
-{
-	if 	( freqvalue > 9999 && freqvalue <= 99999 )
-	{
-		sprintf(msg,"%.2fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
-	}
-	else if ( freqvalue > 99999 && freqvalue < 1000000 )
-	{
-		sprintf(msg,"%.1fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
-	}
-	else if ( freqvalue >= 1000000 )
-	{
-		sprintf(msg,"%.0fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
-	}
-	else
-		sprintf(msg,"%d Hz",freqvalue);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Probe_Fun_2_Char
- *  Description:  Convert Probe Fun 2 char
- * =====================================================================================
- */
-void Logic::Probe_Fun_2_Char(int chan,int probefun,int freq,char* msg)
-{
-	switch ( probefun ) 
-	{
-		case 1:	
-			sprintf(msg,"S%d(ET F%d)",chan,freq);
-			break;
-
-		case 2:	
-			sprintf(msg,"S%d(FET F%d)",chan,freq);
-			break;
-
-		case 3:	
-			sprintf(msg,"S%d(EMS F%d)",chan,freq);
-			break;
-
-		default:	
-			sprintf(msg,"S%d(-- F%d)",chan,freq);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Probe_Fun_2_Char_only
- *  Description:  
- * =====================================================================================
- */
-void Logic::Probe_Fun_2_Char_Only(int probefun,char* msg)
-{
-	switch ( probefun ) 
-	{
-		case 1:	
-			sprintf(msg,"ET");
-			break;
-
-		case 2:	
-			sprintf(msg,"FET");
-			break;
-
-		case 3:	
-			sprintf(msg,"EMS");
-			break;
-
-		default:	
-			sprintf(msg,"ET");
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Convert_Hi_Low_Filterpass_2_Char
- *  Description:  Convert Hight ot Low filterpass to char  
- *       HiFlag:  true     HiFilter
- *                false    LowFilter
- * =====================================================================================
- */
-void Logic::Convert_Hi_Low_Filterpass_2_Char(int value,bool HiFlag,char *msg)
-{
-	if 	( HiFlag == true )
-	{
-		if 	( value == 0 ) sprintf(msg,"%s",m_pl->GetText(CLOSED));
-		else if ( value == 100000 ) sprintf(msg,"%.dHz",10000);
-		else 
-			sprintf(msg,"%.1fHz",static_cast<float>(value)/static_cast<float>(10));
-	}
-	else
-	{
-		if 	( value == -1 ) sprintf(msg,"%s",m_pl->GetText(CLOSED));
-		else if ( value == 100000 ) sprintf(msg,"%.dHz",10000);
-		else sprintf(msg,"%.1fHz",static_cast<float>(value)/static_cast<float>(10));
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Check_Disk_Space
- *  Description:  Check whether the disk space have enough space
- *       return:  true:   There is enough space
- *                false:  There is not enough space
- *    needspace:  The space need to be save file
- *  remainspace:  If return is false, it will save the remain space
- *         Unit:  Bytes
- * =====================================================================================
- */
-bool Logic::Check_Disk_Space(const unsigned long long needspace,unsigned long long& remainspace)
-{
-	struct statfs diskinfo;
-	statfs(DATA_PATH,&diskinfo);
-	unsigned long long size = diskinfo.f_bsize*diskinfo.f_bfree;
-	if ( needspace > size )
-	{
-		remainspace = size;
-		return false;
-	}
-	else
-	{
-		remainspace = needspace;
-		return true;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Screen_Shoot
- *  Description:  Save screen as JPEG formate 
- * =====================================================================================
- */
-void Logic::Screen_Shoot(Graphic& g)
-{
-	int index;
-	char *filename = new char[60];
-	JpegOper *jpeg = new JpegOper;
-	jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
-
-	/*-----------------------------------------------------------------------------
-	 *  Splash screen
-	 *-----------------------------------------------------------------------------*/
-	unsigned char* scr = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
-	g.Load_Disp_Area(0,0,639,479,scr);
-	g.DrawFillRect(0,0,640,480,0xffff);
-	m_alg->MDelay(20);
-	g.Restore_Disp_Area(0,0,639,479,scr);
-	delete[] scr;
-	scr = NULL;
-
-	if ( Check_Screen_Shoot_Available(index) == true )
-	{
-		char *data = new char[60];
-		sprintf(data,"%s%s%02d%s%s",m_pl->GetText(GRAPHICFILE),"pic",index,m_SuffixJpeg.c_str(),m_pl->GetText(GRAPHICSAVE));
-		Msgbox *ms = new Msgbox(180,170,300,100,data,Msgbox::MSG_OKCANCEL);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-
-		if ( ms->Showme(g) )
-		{
-			sprintf(filename,"%s%s%02d%s",PIC_PATH,"pic",index,m_SuffixJpeg.c_str());
-			jpeg->JpegCreateJpeg(filename,100);
-		}
-
-		delete ms;
-		ms = NULL;
-		delete[] data;
-		data = NULL;
-	}
-	else
-	{
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG10),Msgbox::MSG_OK);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g);
-		delete ms;
-		ms = NULL;
-	}
-
-	delete[] filename;
-	filename = NULL;
-	delete jpeg;
-	jpeg = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Check_Screen_Shoot_Available
- *  Description:  Check the screen shoot number available 
- * =====================================================================================
- */
-bool Logic::Check_Screen_Shoot_Available(int &index)
-{
-	using namespace std;
-	bool result = false;
-	char *databuf = new char[60];
-	char *filename = new char[60];
-
-	for ( int i=0;i<m_MAXJpegCount;i++ )
-	{
-		sprintf(filename,"%s%s%02d%s",PIC_PATH,"pic",i,m_SuffixJpeg.c_str());
-		if ( access(filename,0) != 0 )
-		{
-			result = true;
-			index = i;
-			goto Exit;
-		}
-	}	
-	result = false;
-Exit:
-	delete[] databuf;
-	databuf = NULL;
-	delete[] filename;
-	filename = NULL;
-	return result; 
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Update_Program
- *  Description:  Update Program for device 
- * =====================================================================================
- */
-void Logic::Update_Program(Graphic& g)
-{
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(UPDATECOMFIRM),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == true )
-	{
-		delete ms;
-		ms = NULL;
-		Do_Update_Event(g);
-	}
-	delete ms;
-	ms = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Do_Update_Event
- *  Description:  DO the Update Program Event 
- * =====================================================================================
- */
-void Logic::Do_Update_Event(Graphic& g)
-{
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
-	g.Load_Disp_Area(0,0,639,479,mem);
-	Label *lab = new Label(220,230,250,25);
-	lab->Set_Label_Type(Label::LA_THIN);
-	lab->Set_Text(m_pl->GetText(TRANINFO1));
-	lab->Set_Font_Size(16);
-	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	lab->Drawme(g);
-	delete lab;
-	lab = NULL;
-	Update_Command(g);
-	g.Restore_Disp_Area(0,0,639,479,mem);
-	delete[] mem;
-	mem = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Update_Command
- *  Description:  Do update command 
- * =====================================================================================
- */
-void Logic::Update_Command(Graphic& g)
-{
-	ManageMD5* md5 = ManageMD5::Instance();
-	char* command = new char[100];
-	sprintf(command,"cp -p %smain %smain",RUN_PATH_RU,APP_READY_PATH);
-	Excute_Command(command,true);
-
-	m_alg->MDelay(2000);
-
-	sprintf(command,"%smain",APP_READY_PATH);
-	if 	( md5->Calculate_MD5(command) == true )
-	{
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG07),Msgbox::MSG_OK);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g);
-		delete ms;
-		ms = NULL;
-		/*-----------------------------------------------------------------------------
-		 *  When Update Programe Sccessful, Clean .Par File
-		 *-----------------------------------------------------------------------------*/
-		sprintf(command,"rm %s",PAR_FILE_PATH);
-		Excute_Command(command);
-	}
-	else
-	{
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG06),Msgbox::MSG_OK);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g);
-		delete ms;
-		ms = NULL;
-
-		sprintf(command,"rm %smain",APP_READY_PATH);
-		Excute_Command(command,true);
-	}
-Exit:
-	delete[] command;
-	command = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Excute_Command
- *  Description:  Excute the command 
- *      caution:  It is the async mode
- * =====================================================================================
- */
-void Logic::Excute_Command(const char* command,bool syncflag)
-{
-	pid_t pid;
-	pid = vfork();
-	if ( pid == 0 )
-	{
-		if ( execl("/bin/sh", "sh", "-c", command, (char *)0) == -1 )
-			perror("Excute Command Error");
-		else
-		{
-			if ( syncflag == true )
-				sync();
-		}
-		_exit(0);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  About_Box
- *  Description:  Show the About Message on Screen 
- * =====================================================================================
- */
-void Logic::About_Box(Graphic& g,int x, int y)
-{
-	short m_BGColor = g_BUBGNO_CO;
-	short m_FGColor = g_BUTXNO_CO;
-
-	short basex     = x;
-	short basey     = y;
-	short width     = 312;
-	short heigh     = 250;
-	int   ft        = 16;
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(x,y,x+width-1,y+heigh-1)];
-	g.Load_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
-	/*-----------------------------------------------------------------------------
-	 *  Draw the front color 
-	 *-----------------------------------------------------------------------------*/
-	g.DrawFillRect(x,y,width,heigh,m_BGColor);
-
-	COLORTYPE co_sa;
-	co_sa = g.Getcolor();
-	g.Setcolor(m_FGColor);
-
-	Gradual *gd = new Gradual(x,y,width-2,20);
-	gd->Set_LColor(g.RGB24_16(0x789449));
-	gd->Set_RColor(g.RGB24_16(0x000000));
-	gd->Drawme(g);
-	delete gd;
-	gd = NULL;
-
-	g.DrawRect(x,y,width,heigh);
-	g.DrawRect(x+1,y+1,width-2,20);
-	g.DrawRect(x+1,y+20,width-2,heigh-21);
-	g.Setcolor(co_sa);
-
-	int cent_x      = x + ( width>>1 );
-	int cent_y      = y + ( heigh>>1 );
-
-	Label *button	= new Label(cent_x-2*ft-4,y+heigh-32,4*ft,ft+4+4);
-	button->Set_Font_Size(16);
-	button->Set_Text(m_pl->GetText(COMFIRM));
-	button->Set_Label_Type(Label::LA_3D);
-	button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-	char *databuf = new char[50];
-	float ver = (static_cast<float>(m_device->Get_Module_Version())/100);
-	INT32 fver = m_device->Get_FPGA_Version();
-	sprintf(databuf,"%s%s-%.2f-%x %s",m_pl->GetText(ABOUTMSG21),PROVERSION,ver,fver,m_pl->GetText(ABOUTMSG22));
-	
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,m_FGColor);
-	font->Set_Color(FreeType::BGCOLOR,m_BGColor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-	font->Text(basex+110,basey+45,m_pl->GetText(ABOUTMSG1));
-
-	if 	( m_gp->Language == 1 )
-		font->Text(basex+14,basey+35+20+15,m_pl->GetText(ABOUTMSG2));
-	else if ( m_gp->Language == 0 )
-		font->Text(basex+50,basey+35+20+15,m_pl->GetText(ABOUTMSG2));
-
-	font->Text(basex+14,basey+55+20+15,databuf);
-	font->Text(basex+14,basey+75+20+15,m_pl->GetText(ABOUTMSG3));
-	font->Text(basex+14,basey+95+20+15,m_pl->GetText(ABOUTMSG4));
-	font->Text(basex+14,basey+115+20+15,m_pl->GetText(ABOUTMSG5));
-	font->Text(basex+14,basey+135+20+15,m_pl->GetText(ABOUTMSG6));
-	font->Text(basex+14,basey+155+20+15,m_pl->GetText(ABOUTMSG7));
-	font->Text(basex+14,basey+175+20+15,m_pl->GetText(ABOUTMSG8));
-	delete[] databuf;
-	databuf = NULL;
-	button->Drawme(g);
-
-	int key = 0;
-	while(key!= KEY_ENTER && key!= KEY_ESC)
-	{
-		key = Get_Key();
-		if ( key == KEY_F5 )
-			Screen_Shoot(g);
-		m_alg->MDelay(100);
-	}
-
-	button->Set_Focus(true);
-	button->Drawme(g);
-
-	m_alg->MDelay(100);
-
-	delete button;
-	button = NULL;
-
-	g.Restore_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
-	delete[] mem;
-	mem = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restore_Default_Value
- *  Description:  Call this function to restore the default value 
- * =====================================================================================
- */
-void Logic::Restore_Default_Value(Graphic& g)
-{
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(RESTOREDEFAULT),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == true )
-	{
-		delete ms;
-		ms = NULL;
-
-		m_gp->Init_Global_Variables();
-		m_gp->Save_Global_Variables(PAR_FILE_PATH);
-
-		Msgbox *nms = new Msgbox(200,170,260,100,m_pl->GetText(REBOOTMSG),Msgbox::MSG_OK);
-		nms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		nms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		nms->Showme(g);
-		delete nms;
-		nms = NULL;
-	}
-	delete ms;
-	ms = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restore_Mix_Factor
- *  Description:  Restore Mixing Factor 
- * =====================================================================================
- */
-void Logic::Restore_Mix_Factor(Graphic& g)
-{
-	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(MIXFACTORCOMFIRM),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == true )
-	{
-		delete ms;
-		ms = NULL;
-
-		MixingManage *algm = MixingManage::Instance();
-		algm->Restore_Mix_Factor();
-		algm->Sync_Mixing_Para(true);
-	}
-	delete ms;
-	ms = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Data_Into_File
- *  Description:  For test the Mixing Algorithm 
- * =====================================================================================
- */
-bool Logic::Save_Data_Into_File(const char* path,short *buf,int length)
-{
-	bool result = false;
-	std::ofstream oo;
-	oo.open(path,std::ofstream::binary|std::ofstream::trunc);
-	if ( !oo )
-	{
-		perror("can't save para file");
-		result = false;
-	}
-	else
-	{
-		for ( int i=0;i<length;i++ )
-		{
-			oo<<buf[i]<<' ';
-		}
-		result = true;
-		oo.flush();
-		oo.close();
-		sync();
-	}
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Data_Into_File
- *  Description:  For test the Mixing Algorithm 
- * =====================================================================================
- */
-bool Logic::Load_Data_From_File(const char* path,short *buf,int length)
-{
-	bool result = false;
-	std::ifstream io;
-	io.open(path,std::ifstream::binary);
-	if ( !io.is_open() )
-	{
-		perror("can't load para file");
-		result = false;
-	}
-	else
-	{
-		for ( int i=0;i<length;i++ )
-		{
-			io>>buf[i];
-		}
-		result = true;
-		io.close();
-		sync();
-	}
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_ADC_Handle
- *  Description:  Get the handle of ADC driver  
- * =====================================================================================
- */
-int Logic::Get_ADC_Handle()
-{
-#ifdef X86 
-	return 0;
-#else
-	return m_ADC_fd;
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Mainwin_Point
- *  Description:  Set the Mainwin Point 
- * =====================================================================================
- */
-void Logic::Set_Mainwin_Point(Mainwin* p)
-{
-	m_pMainwin = p;
-}
diff --git a/src/EVA11/Logic.h b/src/EVA11/Logic.h
deleted file mode 100644
index 8d9e3ae..0000000
--- a/src/EVA11/Logic.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Logic.h
- *
- *    Description:  Declear Logic class
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 15时34分48秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _Logic_INC
-#define  _Logic_INC
-
-#include 	<string>
-#include 	<memory>
-#include 	<boost/asio.hpp>
-
-#include 	"main.h"
-
-class Graphic;
-class Language;
-class Algorithm;
-class Device;
-class Global;
-class DataRepo;
-class Mainwin;
-
-class Logic
-{
-	public:
-		static Logic* Instance();                /* only used this function to visit variables   */
-
-		int Get_Key();
-		void Init_Hardware(Graphic& g);
-		void Release_Hardware();
-		void Shutdown();
-		void Pre_Shutdown();
-		void Frequence_2_Char(int freqvalue,char* msg);
-		void Probe_Fun_2_Char(int chan,int probefun,int freq,char* msg);
-		void Probe_Fun_2_Char_Only(int probefun,char* msg);
-
-		void Set_Global_Variables_Into_PCB();
-		void Set_Global_Variables_Into_System();
-
-		void Convert_Hi_Low_Filterpass_2_Char(int value,bool HiFlag,char *msg);
-		bool Check_Disk_Space(const unsigned long long needspace,unsigned long long& remainspace);
-
-		void Screen_Shoot(Graphic& g);
-
-		void Update_Program(Graphic& g);
-
-		void About_Box(Graphic& g,int x,int y);
-		void Excute_Command(const char* command, bool syncflag=true);
-		void Restore_Default_Value(Graphic& g);
-
-		void Reset_Data_Repo();
-		void Restore_Mix_Factor(Graphic& g);
-
-		bool Save_Data_Into_File(const char*,short *,int);
-		bool Load_Data_From_File(const char*,short *,int);
-
-		int Get_ADC_Handle();
-		void Set_Mainwin_Point(Mainwin* p);
-	protected:
-	private:
-		Logic ();
-		~Logic ();
-		Logic (const Logic&);
-		Logic& operator = (const Logic&);
-
-		int Get_Key_From_Keyboard();
-		int Get_Key_From_FPGA();
-		void Alarm_Beep(bool status);
-		void Short_Beep();
-
-		bool Check_Screen_Shoot_Available(int &index);
-		void Do_Update_Event(Graphic& g);
-		void Update_Command(Graphic& g);
-
-		void ShutDownMsg(const boost::system::error_code & e);
-	private:
-		/*-----------------------------------------------------------------------------
-		 *  Battery Hand
-		 *-----------------------------------------------------------------------------*/
-		int m_ADC_fd;     	               /* ADC Handle */
-
-		friend class std::auto_ptr<Logic>;
-		static std::auto_ptr<Logic>		m_Instance;
-		static const int			m_MAXJpegCount = 100;
-		std::string				m_SuffixJpeg;
-		/*-----------------------------------------------------------------------------
-		* KEYSOURCE: 0 from keyboard
-		*            1 from device
-		*-----------------------------------------------------------------------------  */
-#ifdef		_KEY_PC_
-		static const int			KEYSOURCE      = 0;
-#endif
-#ifdef		_KEY_308_1_
-		static const int			KEYSOURCE      = 1;
-#endif
-#ifdef		_KEY_308_A_
-		static const int			KEYSOURCE      = 1;
-#endif
-
-		Language				*m_pl;
-		Algorithm                               *m_alg;
-		Device			                *m_device;
-		Global			                *m_gp;
-		DataRepo		                *m_repo;
-		Graphic					*m_g;
-		Mainwin					*m_pMainwin;
-}; /* -----  end of class Logic  ----- */
-#endif   /* ----- #ifndef _Logic_INC  ----- */
diff --git a/src/EVA11/MKlib.mk b/src/EVA11/MKlib.mk
deleted file mode 100644
index ec3aa03..0000000
--- a/src/EVA11/MKlib.mk
+++ /dev/null
@@ -1,186 +0,0 @@
-##########################################################
-#
-#                    The EVA11 project lib configrature 
-#
-# Author:    kevin.wang
-# Company:   Eddysun     xiamen
-# Date:      2012.12.13
-# Comment:   Try to re-structure the Project Makefile
-#            
-#
-###########################################################
-
-
-########################################################### 
-# Configrature the third library with follow selection
-########################################################### 
-LIBINC_SDL      = yes
-LIBINC_SDL2     = no
-LIBINC_ETIO     = yes
-LIBINC_GIF      = yes
-LIBINC_GSL      = yes
-LIBINC_LOG4CPP  = yes
-LIBINC_Z        = yes
-LIBINC_JPEG     = yes
-LIBINC_MD       = no
-LIBINC_USB      = yes
-LIBINC_PNG      = yes
-LIBINC_FREETYPE = yes
-LIBINC_ICONV    = yes
-LIBINC_SQLITE3  = yes
-LIBINC_SSL      = yes
-LIBINC_SDLGFX   = yes
-LIBINC_SDLIMAGE = yes
-LIBINC_SDLNET   = no
-LIBINC_SDLTTF   = no
-LIBINC_SOCKETS  = no
-LIBINC_BOOST    = yes
-LIBINC_ZTHREAD  = yes
-LIBINC_DIRECTFB = yes
-
-THIRDLIB =
-SEARCH_LIBPATH =
-SEARCH_INCPATH = -I$(MYLIBS_DIR)/sp++/include/
-
-ifeq ($(LIBINC_ETIO),yes)
-THIRDLIB+=etio
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libetio/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libetio/include/
-endif
-
-ifeq ($(LIBINC_GIF),yes)
-THIRDLIB+=gif
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libgif/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libgif/include/
-endif
-
-ifeq ($(LIBINC_GSL),yes)
-THIRDLIB+=gsl
-THIRDLIB+=gslcblas
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libgsl/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libgsl/include/
-endif
-
-ifeq ($(LIBINC_LOG4CPP),yes)
-THIRDLIB+=log4cplus
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/liblog4cplus/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/liblog4cplus/include/
-endif
-
-ifeq ($(LIBINC_Z),yes)
-THIRDLIB+=z
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libz/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libz/include/
-endif
-
-ifeq ($(LIBINC_JPEG),yes)
-THIRDLIB+=jpeg
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libjpeg/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libjpeg/include/
-endif
-
-ifeq ($(LIBINC_MD),yes)
-THIRDLIB+=md
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libmd5/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libmd5/include/
-endif
-
-ifeq ($(LIBINC_USB),yes)
-THIRDLIB+=usb-1.0
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libusb/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libusb/include/libusb-1.0/
-endif
-
-ifeq ($(LIBINC_PNG),yes)
-THIRDLIB+=png15
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libpng/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libpng/include/
-endif
-
-ifeq ($(LIBINC_FREETYPE),yes)
-THIRDLIB+=freetype
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libfreetype/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libfreetype/include/freetype2/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libfreetype/include/
-endif
-
-ifeq ($(LIBINC_ICONV),yes)
-THIRDLIB+=iconv
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libiconv/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libiconv/include/
-endif
-
-ifeq ($(LIBINC_SQLITE3),yes)
-THIRDLIB+=sqlite3
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsqlite/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsqlite/include/
-endif
-
-ifeq ($(LIBINC_SSL),yes)
-THIRDLIB+=ssl crypto
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libopenssl/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libopenssl/include/
-endif
-
-ifeq ($(LIBINC_SDLGFX),yes)
-THIRDLIB+=SDL_gfx
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-gfx/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-gfx/include/
-endif
-
-ifeq ($(LIBINC_SDLIMAGE),yes)
-THIRDLIB+=SDL_image
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-image/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-image/include/
-endif
-
-ifeq ($(LIBINC_SDLNET),yes)
-THIRDLIB+=SDL_net
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-net/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-net/include/
-endif
-
-ifeq ($(LIBINC_SDLTTF),yes)
-THIRDLIB+=SDL_ttf
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-ttf/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-ttf/include/
-endif
-
-ifeq ($(LIBINC_SDL),yes)
-THIRDLIB+=SDL
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl/include/SDL/
-endif
-
-ifeq ($(LIBINC_SDL2),yes)
-THIRDLIB+=SDL2
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl2.0/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl2.0/include/
-endif
-
-ifeq ($(LIBINC_SOCKETS),yes)
-THIRDLIB+=Sockets
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsocket/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsocket/include/
-endif
-
-ifeq ($(LIBINC_BOOST),yes)
-THIRDLIB+=boost_system boost_filesystem
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libboost/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libboost/include/
-endif
-
-ifeq ($(LIBINC_ZTHREAD),yes)
-THIRDLIB+=ZThread
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libzthread/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libzthread/include/
-endif
-
-ifeq ($(LIBINC_DIRECTFB),yes)
-THIRDLIB+=directfb
-THIRDLIB+=direct
-THIRDLIB+=fusion
-THIRDLIB+=++dfb
-SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libdirectfb/lib/
-SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libdirectfb/include/
-endif
diff --git a/src/EVA11/Mainwin.cpp b/src/EVA11/Mainwin.cpp
deleted file mode 100644
index 5ab7fe4..0000000
--- a/src/EVA11/Mainwin.cpp
+++ /dev/null
@@ -1,3532 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Mainwin.cpp
- *
- *    Description:  Implemntation of Mainwin class
- *
- *        Version:  1.0
- *        Created:  2012年06月13日 15时19分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<unistd.h>
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Basewin.h"
-#include 	"Mainwin.h"
-#include 	"Graphic.h"
-#include	"Language.h"
-#include	"Global.h"
-#include	"Msgbox.h"
-#include	"Battery.h"
-#include	"Process.h"
-#include 	"Logic.h"
-
-#include 	"Basescreen.h"
-
-#include	"Label.h"
-
-#include 	"IView.h"
-#include 	"DetectView.h"
-#include 	"ParaView.h"
-#include	"DebugView.h"
-#include	"OtherView.h"
-#include	"PanelView.h"
-#include 	"AlarmView.h"
-#include 	"AnalyzeView.h"
-
-Mainwin::Mainwin ()
-{
-}
-
-Mainwin::~Mainwin ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void Mainwin::Drawme(Graphic &g)
-{
-	Basewin::Drawme(g);
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-		m_NorButton[i]->Drawme(g);
-
-	m_View[m_BottomFocus-1]->Switch_View();
-	m_View[m_BottomFocus-1]->Drawme(g);
-	Refresh_Small_Label(g);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Main loop in Mainwin class 
- * =====================================================================================
- */
-int Mainwin::Loopwindow(Graphic &g)
-{
-	int result = 0;
-	Init_Variables();
-	Init_GUI(g);
-	Init_View_Sets(g);
-	Drawme(g);
-	Init_Process_Sets();
-#ifdef CALSAMPLE
-	unsigned long long len = 0;
-	struct tm *timenow;
-	time_t now,old;
-	time(&old);
-#endif
-	while( 1 )
-	{
-		if 	( m_PauseFlag == false )
-			m_View[m_BottomFocus-1]->Loop_View(g);
-
-		result = Command_Process(g);
-
-		if 	( result == CO_EXIT )
-			goto Exit;
-
-		if	( m_BottomFocus == 7 && m_SubMenuNo[m_BottomFocus-1] == 4 )
-			DisplayTimeDate(g);
-
-#ifdef CALSAMPLE
-		len ++;
-		if ( len == 100000 )
-		{
-			time(&now);
-			now = now - old;
-			time(&old);
-			timenow = localtime(&now);
-			printf ( "100K sample cost %d second \n",timenow->tm_sec );
-			len = 0;
-		}
-#endif
-	}
-
-Exit:
-	Release_Process_Sets();
-	Release_View_Sets();
-	Destroy_GUI();
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Mainwin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-}
-int Mainwin::Key_Bom2_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,2);
-}
-int Mainwin::Key_Bom3_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,3);
-}
-int Mainwin::Key_Bom4_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,4);
-}
-int Mainwin::Key_Bom5_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,5);
-}
-int Mainwin::Key_Bom6_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,6);
-}
-int Mainwin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-}
-int Mainwin::Key_Esc_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false && m_BottomFocus == 1 )
-	{
-		m_PauseFlag = true;
-		m_View[m_BottomFocus-1]->Lock_View(g);
-		return CO_NONE;
-	}
-	else
-	{
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(COMFIRMEXIT),Msgbox::MSG_OKCANCEL);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		if ( ms->Showme(g) == true )
-		{
-			delete ms;
-			ms = NULL;
-			return CO_EXIT;
-		}
-		delete ms;
-		ms = NULL;
-		return CO_NONE;
-	}
-}
-int Mainwin::Key_Enter_Fun(Graphic& g)
-{
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],m_NormalFocus,IProcess::ENTER);
-
-	m_View[m_BottomFocus-1]->Key_Enter_Fun(g);
-
-	if ( m_PauseFlag == true && m_BottomFocus == 1 )
-	{
-		m_PauseFlag = false;
-		m_View[m_BottomFocus-1]->UnLock_View(g);
-		return CO_NONE;
-	}
-}
-int Mainwin::Key_NL1_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,1);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],1,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL1_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR1_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,1);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],1,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR1_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NL2_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,2);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],2,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL2_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR2_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,2);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],2,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR2_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NL3_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,3);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],3,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL3_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR3_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,3);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],3,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR3_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NL4_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,4);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],4,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL4_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR4_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,4);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],4,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR4_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NL5_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,5);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],5,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL5_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR5_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,5);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],5,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR5_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NL6_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,6);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],6,IProcess::LKEY);
-	m_View[m_BottomFocus-1]->Key_NL6_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_NR6_Fun(Graphic& g)
-{
-	DrawNormalFocus(g,6);
-	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],6,IProcess::RKEY);
-	m_View[m_BottomFocus-1]->Key_NR6_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-	return CO_NONE;
-}
-int Mainwin::Key_F1_Fun(Graphic& g)
-{
-	m_View[m_BottomFocus-1]->Key_F1_Fun(g);
-}
-int Mainwin::Key_F2_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false )
-		m_View[m_BottomFocus-1]->Key_F2_Fun(g);
-}
-int Mainwin::Key_F3_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false )
-		m_View[m_BottomFocus-1]->Key_F3_Fun(g);
-}
-int Mainwin::Key_F4_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false )
-		m_View[m_BottomFocus-1]->Key_F4_Fun(g);
-}
-int Mainwin::Key_F5_Fun(Graphic& g)
-{
-	m_View[m_BottomFocus-1]->Key_F5_Fun(g);
-	m_lo->Screen_Shoot(g);
-}
-int Mainwin::Key_F6_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false )
-		m_View[m_BottomFocus-1]->Key_F6_Fun(g);
-}
-int Mainwin::Key_F7_Fun(Graphic& g)
-{
-	if ( m_PauseFlag == false )
-		m_View[m_BottomFocus-1]->Key_F7_Fun(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Variables
- *  Description:  Init the variables of device 
- * =====================================================================================
- */
-void Mainwin::Init_Variables()
-{
-	m_BottomFocus  	  = 1;
-	m_NormalFocus 	  = 1;
-
-	for (int i=0;i<MAXBOMCOUNT;i++)
-	{
-		m_SubMenuNo[i] 
-			  = 1;
-	}
-
-	m_SubMenuMaxNo[0] = 1;
-	m_SubMenuMaxNo[1] = 3;
-	m_SubMenuMaxNo[2] = 2;
-	m_SubMenuMaxNo[3] = 2;
-	m_SubMenuMaxNo[4] = 1;
-	m_SubMenuMaxNo[5] = 1;
-	m_SubMenuMaxNo[6] = 4;
-
-	m_PauseFlag       = false;
-
-	Logic* lo = Logic::Instance();
-	lo->Set_Mainwin_Point(this);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void Mainwin::Init_GUI(Graphic& g)
-{
-	Basewin::Init_GUI(g);
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-	}
-
-	ColorObj* colorobj = ColorObj::Instance();
-
-	m_BomButton[0]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_BomButton[1]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_BomButton[3]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_BomButton[4]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-
-	m_BomButton[0]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
-	m_BomButton[1]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
-	m_BomButton[3]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
-	m_BomButton[4]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
-
-	m_BomButton[0]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_BomButton[1]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_BomButton[3]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_BomButton[4]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-
-	m_BomButton[0]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
-	m_BomButton[1]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
-	m_BomButton[3]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
-	m_BomButton[4]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
-
-	for ( int i=0;i<MAXNORCOUNT;i++)
-	{
-		if ( i == MAXNORCOUNT-1 )
-			m_NorButton[i] = new Label(533,4+73*(MAXNORCOUNT-1),104,72);
-		else
-			m_NorButton[i] = new Label(533,4+73*i,104,71);
-
-		m_NorButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-		m_NorButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
-		m_NorButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
-		m_NorButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
-		m_NorButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
-		m_NorButton[i]->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
-		m_NorButton[i]->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
-
-		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,1));
-		m_NorButton[i]->Set_Label_Type(Label::LA_ROUND);
-		m_NorButton[i]->Set_Display_Type(Label::LA_DT_DLINE);
-		m_NorButton[i]->Set_Font_Size(18);
-		m_NorButton[i]->Set_Radius(15);
-		if 	( i == m_NormalFocus - 1 )
-			m_NorButton[i]->Set_Focus(true);
-		else
-			m_NorButton[i]->Set_Focus(false); 
-	}
-	m_BomSmall->Set_Display_Type(Label::LA_DT_SM);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void Mainwin::Destroy_GUI()
-{
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		if	( m_NorButton[i] != NULL )
-		{
-			delete m_NorButton[i];
-			m_NorButton[i] = NULL;
-		}
-	}
-	Basewin::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View_Sets
- *  Description:  Init the sets of view 
- * =====================================================================================
- */
-void Mainwin::Init_View_Sets(Graphic& g)
-{
-	m_View[0] = new DetectView(2,2,530,442);
-	m_View[0]->Init_View(g);
-
-	m_View[1] = new ParaView(2,2,530,442);
-	m_View[1]->Init_View(g);
-	m_View[1]->Load_View_Object(m_View[0]);
-
-	m_View[2] = new DebugView(2,2,530,442);
-	m_View[2]->Init_View(g);
-
-	m_View[3] = new AlarmView(2,2,530,442);
-	m_View[3]->Init_View(g);
-	m_View[3]->Load_View_Object(m_View[0]);
-
-	m_View[4] = new AnalyzeView(2,2,530,442);
-	m_View[4]->Init_View(g);
-	m_View[4]->Load_View_Object(m_View[0]);
-
-	m_View[5] = new PanelView(2,2,530,442);
-	m_View[5]->Init_View(g);
-
-	m_View[6] = new OtherView(2,2,530,442);
-	m_View[6]->Init_View(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View_Sets
- *  Description:  Release the view sets 
- * =====================================================================================
- */
-void Mainwin::Release_View_Sets()
-{
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_View[i]->Release_View();
-		delete m_View[i];
-		m_View[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  As the input parameter index to set the bottoms button status
- *        index: From 1 to 7
- * =====================================================================================
- */
-void Mainwin::DrawBottomFocus(Graphic& g,int index)
-{
-	int savebomindex = m_BottomFocus;
-	Basewin::DrawBottomFocus(g,index);
-
-	int kt[7] = {256,1,1,1,1,1,1};
-	Basewin::Set_MAX_Get_Key_Interval(kt[index-1]);
-
-	if 	( index == 1 && savebomindex != 1 )
-	{
-		m_PauseFlag = false;
-	}
-
-	if 	( index != 1 )
-		m_PauseFlag = false;
-
- 	if 	( index == savebomindex )
-	{
-		if 	( (m_SubMenuNo[index-1] == m_SubMenuMaxNo[index-1]) )
-			m_SubMenuNo[index-1] = 1;
-		else
-			m_SubMenuNo[index-1] += 1;
-	}
-	else
-	{
-		m_View[m_BottomFocus-1]->Switch_View();
-		m_View[m_BottomFocus-1]->Drawme(g);
-	}
-
-	Refresh_Small_Label(g);
-	Refresh_Normal_Label_Content(g);
-	Refresh_Normal_Label_Text(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawNormalFocus
- *  Description:  
- * =====================================================================================
- */
-void Mainwin::DrawNormalFocus(Graphic& g,int index)
-{
-	if 	( index != m_NormalFocus )
-	{
-		m_NorButton[m_NormalFocus-1]->Set_Focus(false);
-		m_NorButton[index-1]->Set_Focus(true);
-		m_NormalFocus = index;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Small_Label
- *  Description:  Refresh the small label of page 
- * =====================================================================================
- */
-void Mainwin::Refresh_Small_Label(Graphic& g)
-{
-	sprintf(m_Msg,"%d",m_SubMenuNo[m_BottomFocus-1]);
-	m_BomSmall->Set_Text(m_Msg,0);
-	sprintf(m_Msg,"%d",m_SubMenuMaxNo[m_BottomFocus-1]);
-	m_BomSmall->Set_Text(m_Msg,1);
-	m_BomSmall->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Bom_Label
- *  Description:  Refresh the Bomttom Label 
- * =====================================================================================
- */
-void Mainwin::Refresh_Normal_Label_Text(Graphic& g)
-{
-	g.Switch_Screen();
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
-		m_NorButton[i]->Drawme(g,false);
-	}
-	g.Switch_Screen();
-	g.Screen_Copy(533,4,533+105-1,4+73*MAXNORCOUNT-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Normal_Label_Content
- *  Description:  Display the Normal label content 
- * =====================================================================================
- */
-void Mainwin::Refresh_Normal_Label_Content(Graphic& g)
-{
-	int bom = m_BottomFocus;
-	int sub = m_SubMenuNo[m_BottomFocus-1];
-
-	switch ( bom )
-	{
-		case 1: 
-			Refresh_Normal_Label_Content_1(g,sub);
-			break;
-		case 2:	
-			Refresh_Normal_Label_Content_2(g,sub);
-			break;
-		case 3: 
-			Refresh_Normal_Label_Content_3(g,sub);
-			break;
-		case 4: 
-			Refresh_Normal_Label_Content_4(g,sub);
-			break;
-		case 5:	
-			Refresh_Normal_Label_Content_5(g,sub);
-			break;
-		case 6: 
-			Refresh_Normal_Label_Content_6(g,sub);
-			break;
-		case 7: 
-			Refresh_Normal_Label_Content_7(g,sub);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0:
-			Refresh_Normal_Label_Content_1_ColorPanel(g,sub);
-			break;
-
-		case 1:
-			Refresh_Normal_Label_Content_1_VideoPanel(g,sub);
-			break;
-
-		case 2:
-			Refresh_Normal_Label_Content_1_ZKPanel(g,sub);
-			break;
-
-		case 3:
-			Refresh_Normal_Label_Content_1_DZKPanel(g,sub);
-			break;
-
-		case 4:
-			Refresh_Normal_Label_Content_1_OZKPanel(g,sub);
-			break;
-
-		case 5:
-			Refresh_Normal_Label_Content_1_CZKPanel(g,sub);
-			break;
-	}
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1_ZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->SingleFocusSignal]/static_cast<float>(10));
-							break;
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->SingleFocusSignal]);
-							break;
-						case 3:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]],m_Msg);
-							break;
-						case 4:
-							if 	( m_gp->TimeScaleDisp == 1 )
-								sprintf(m_Msg,"S.Y");
-							else if ( m_gp->TimeScaleDisp == 0 )
-								sprintf(m_Msg,"S.X");
-							else
-								sprintf(m_Msg,"OFF");
-							break;
-						case 5:
-							sprintf(m_Msg,"%d",m_gp->TimeScaleSpeed);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1_DZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
-							break;
-						case 1:
-							{
-								if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								{
-									if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
-										sprintf(m_Msg,"S%d OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]+1);
-									else
-										m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[m_gp->ScrSigFocus]+1,m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]],m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]+1,m_Msg);
-								}
-								else
-								{
-									if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
-										  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
-									{
-										sprintf(m_Msg,"M%d:OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
-									}
-									else
-										sprintf(m_Msg,"M%d:S%d-S%d",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1);
-								}
-							}
-							break;
-						case 2:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]]/static_cast<float>(10));
-							else
-								sprintf(m_Msg,"%.1f dB",m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]/static_cast<float>(10));
-							break;
-						case 3:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]]);
-							else
-								sprintf(m_Msg,"%d DEG",m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]);
-							break;
-						case 4:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-							{
-								if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
-									sprintf(m_Msg,"OFF");
-								else
-									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]],m_Msg);
-							}
-							else
-							{
-								if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
-									  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
-										sprintf(m_Msg,"OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
-								else
-									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]],m_Msg);
-							}
-							break;
-						case 5:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-							{
-								sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							}
-							else
-							{
-								if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
-									  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
-										sprintf(m_Msg,"OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
-								else
-									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]],m_Msg);
-							}
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-		
-void Mainwin::Refresh_Normal_Label_Content_1_OZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d %s",m_gp->ScopeChan+1,m_pl->GetText(CHANNEL));
-							break;
-
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->CrossGain[m_gp->ScopeChan]/static_cast<float>(10));
-							break;
-
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->CrossDegree[m_gp->ScopeChan]);
-							break;
-
-						case 3:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1_CZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
-							break;
-						case 1:
-							{
-								if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								{
-									if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
-										sprintf(m_Msg,"S%d OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]+1);
-									else
-										m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[m_gp->ScrSigFocus]+1,m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]],m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]+1,m_Msg);
-								}
-								else
-								{
-									if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
-										  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
-									{
-										sprintf(m_Msg,"%s","M%d:SX OFF");
-									}
-									else
-										sprintf(m_Msg,"M%d:S%d-S%d",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1);
-								}
-							}
-							break;
-						case 2:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]]/static_cast<float>(10));
-							else
-								sprintf(m_Msg,"%.1f dB",m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]/static_cast<float>(10));
-							break;
-						case 3:
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]]);
-							else
-								sprintf(m_Msg,"%d DEG",m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]);
-							break;
-						case 4:
-								sprintf(m_Msg,"S3-S4");
-							break;
-						case 5:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->AScanMapChan[0]]/static_cast<float>(10));  // always m_gp->AScanMapChan[0]
-																            //	   =  m_gp->AScanMapChan[1]
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1_VideoPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-						case 1:
-						case 2:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_1_ColorPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%.1f dB",m_gp->ColorGain/static_cast<float>(10));
-							break;
-						case 1:	
-							sprintf(m_Msg,"F%d",m_gp->ColorSpotFreqIndex+1);
-							break;
-						case 2:	
-							m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->ColorSpotFreqIndex],m_Msg);
-							break;
-						case 5:
-							sprintf (m_Msg,"%d",m_gp->ColorSpotScanSpeed);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0:
-			Refresh_Normal_Label_Content_2_ColorPanel(g,sub);
-			break;
-		case 1:
-			Refresh_Normal_Label_Content_2_VideoPanel(g,sub);
-			break;
-		case 2:
-			Refresh_Normal_Label_Content_2_ZKPanel(g,sub);
-			break;
-		case 3:
-			Refresh_Normal_Label_Content_2_DZKPanel(g,sub);
-			break;
-		case 4:
-			Refresh_Normal_Label_Content_2_OZKPanel(g,sub);
-			break;
-		case 5:
-			Refresh_Normal_Label_Content_2_CZKPanel(g,sub);
-			break;
-		default:
-			Refresh_Normal_Label_Content_2_ZKPanel(g,sub);
-			break;
-	}
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2_ColorPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ColorSpotSampleType == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(INSIDESAMP));
-							else if ( m_gp->ColorSpotSampleType == 1 )
-								sprintf(m_Msg,"%s",m_pl->GetText(OUTSIDESAMP));
-							break;
-						case 1:
-							if 	( m_gp->ColorSpotSampleType == 0 )
-								sprintf(m_Msg,"%d",m_gp->ColorSpotSampIntervalClock);
-							else if ( m_gp->ColorSpotSampleType == 1 )
-								sprintf(m_Msg,"%d",m_gp->ColorSPotSampOutPuls);
-							break;
-						case 5:
-							if 	( m_gp->ColorSpotDispMode == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(DISPMOD_2D));
-							else if ( m_gp->ColorSpotDispMode == 1 )
-								sprintf(m_Msg,"%s",m_pl->GetText(DISPMOD_3D));
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-			
-void Mainwin::Refresh_Normal_Label_Content_2_VideoPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-		case 2:
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-
-
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2_ZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
-							break;
-						case 1:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->SingleFocusSignal],m_Msg);
-							break;
-						case 2:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
-							break;
-						case 3:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]],m_Msg);
-							break;
-						case 4:
-							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->SingleFocusSignal]));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->SingleFocusSignal]/static_cast<float>(10));
-							break;
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->SingleFocusSignal]);
-							break;
-						case 3:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->SingleFocusSignal],true,m_Msg);
-							break;
-						case 4:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->SingleFocusSignal],false,m_Msg);
-							break;
-						case 5:
-							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->SingleCentX);
-							break;
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->SingleCentY);
-							break;
-						case 2:
-							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2_DZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->DParaChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->DParaChan+1,m_gp->ProbeFun[m_gp->DParaChan],m_gp->FreqIndex[m_gp->DParaChan]+1,m_Msg);
-							break;
-						case 1:
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->DParaChan],m_Msg);
-							break;
-						case 2:
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->DParaChan]+1);
-							break;
-						case 3:
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]],m_Msg);
-							break;
-						case 4:
-							if 	( m_gp->DFilter[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->DParaChan]));
-							break;
-						case 5:
-							sprintf(m_Msg,"%s",m_pl->GetText(RESTORE));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->DParaChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->DParaChan+1,m_gp->ProbeFun[m_gp->DParaChan],m_gp->FreqIndex[m_gp->DParaChan]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->DParaChan]/static_cast<float>(10));
-							break;
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->DParaChan]);
-							break;
-						case 3:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->DParaChan],true,m_Msg);
-							break;
-						case 4:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->DParaChan],false,m_Msg);
-							break;
-						case 5:
-							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->DoubleCentX1);
-							break;
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->DoubleCentY1);
-							break;
-						case 2:
-							sprintf(m_Msg,"%d",m_gp->DoubleCentX2);
-							break;
-						case 3:
-							sprintf(m_Msg,"%d",m_gp->DoubleCentY2);
-							break;
-						case 4:
-							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2_CZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->CompositeChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->CompositeChan+1,m_gp->ProbeFun[m_gp->CompositeChan],m_gp->FreqIndex[m_gp->CompositeChan]+1,m_Msg);
-							break;
-						case 1:
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->CompositeChan],m_Msg);
-							break;
-						case 2:
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->CompositeChan]+1);
-							break;
-						case 3:
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]],m_Msg);
-							break;
-						case 4:
-							if 	( m_gp->DFilter[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->CompositeChan]));
-							break;
-						case 5:
-							sprintf(m_Msg,"%d",20 - m_gp->AScanSpeed);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->CompositeChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->CompositeChan+1,m_gp->ProbeFun[m_gp->CompositeChan],m_gp->FreqIndex[m_gp->CompositeChan]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->CompositeChan]/static_cast<float>(10));
-							break;
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->CompositeChan]);
-							break;
-						case 3:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->CompositeChan],true,m_Msg);
-							break;
-						case 4:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->CompositeChan],false,m_Msg);
-							break;
-						case 5:
-							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->CompositeCentX1);
-							break;
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->CompositeCentY1);
-							break;
-						case 2:
-							sprintf(m_Msg,"%d",m_gp->CompositeCentX2);
-							break;
-						case 3:
-							sprintf(m_Msg,"%d",m_gp->CompositeCentY2);
-							break;
-						case 4:
-							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_2_OZKPanel(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->QuadChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->QuadChan+1,m_gp->ProbeFun[m_gp->QuadChan],m_gp->FreqIndex[m_gp->QuadChan]+1,m_Msg);
-							break;
-						case 1:
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->QuadChan],m_Msg);
-							break;
-						case 2:
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->QuadChan]+1);
-							break;
-						case 3:
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"OFF");
-							else
-								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]],m_Msg);
-							break;
-						case 4:
-							if 	( m_gp->DFilter[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->QuadChan]));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->QuadChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->QuadChan+1,m_gp->ProbeFun[m_gp->QuadChan],m_gp->FreqIndex[m_gp->QuadChan]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->QuadChan]/static_cast<float>(10));
-							break;
-						case 2:
-							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->QuadChan]);
-							break;
-						case 3:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->QuadChan],true,m_Msg);
-							break;
-						case 4:
-							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->QuadChan],false,m_Msg);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->OCTCentX[0]);
-							break;
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->OCTCentY[0]);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-
-void Mainwin::Refresh_Normal_Label_Content_3(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->ProbeFun[m_gp->DebugChan] == 0 )
-								sprintf(m_Msg,"S%d OFF",m_gp->DebugChan+1);
-							else
-								m_lo->Probe_Fun_2_Char(m_gp->DebugChan+1,m_gp->ProbeFun[m_gp->DebugChan],m_gp->FreqIndex[m_gp->DebugChan]+1,m_Msg);
-							break;
-						case 1:
-							sprintf(m_Msg,"%d dB",m_gp->HDGain[m_gp->DebugChan]*5);
-							break;
-						case 2:
-							m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]],m_Msg);
-							break;
-						case 3:
-							if 	( m_gp->Driver == 4 )
-								sprintf(m_Msg,"%d V(*)",5);
-							else
-								sprintf(m_Msg,"%d V",m_gp->Driver+1);
-							break;
-						case 4:
-							sprintf(m_Msg,"%d",m_gp->Offset);
-							break;
-						case 5:
-							if 	( m_gp->bRFFilterEnable == true )
-								sprintf(m_Msg,"%s","On");
-							else
-								sprintf(m_Msg,"%s","Off");
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							{
-								if 	( m_gp->Precision == 16 )
-									sprintf(m_Msg,"%s",m_pl->GetText(PRELOW));
-								else if ( m_gp->Precision == 8 )
-									sprintf(m_Msg,"%s",m_pl->GetText(PREMED));
-								else if ( m_gp->Precision == 0 )
-									sprintf(m_Msg,"%s",m_pl->GetText(PREHIGH));
-							}
-							break;
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->DriverBal[m_gp->DebugChan]-8);
-							break;
-						case 2:
-							if ( m_gp->DriverA_ID[m_gp->DebugChan] >= 0 && m_gp->DriverA_ID[m_gp->DebugChan] <= 247 )
-								sprintf(m_Msg,"C%d",m_gp->DriverA_ID[m_gp->DebugChan]+1);
-							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 254 )
-								sprintf(m_Msg,"%s","GND");
-							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 255 )
-								sprintf(m_Msg,"%s","NULL");
-							break;
-						case 3:
-							if ( m_gp->DriverB_ID[m_gp->DebugChan] >= 0 && m_gp->DriverB_ID[m_gp->DebugChan] <= 247 )
-								sprintf(m_Msg,"C%d",m_gp->DriverB_ID[m_gp->DebugChan]+1);
-							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 254 )
-								sprintf(m_Msg,"%s","GND");
-							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 255 )
-								sprintf(m_Msg,"%s","NULL");
-							break;
-						case 4:
-							if ( m_gp->PickA_ID[m_gp->DebugChan] >= 0 && m_gp->PickA_ID[m_gp->DebugChan] <= 247 )
-								sprintf(m_Msg,"C%d",m_gp->PickA_ID[m_gp->DebugChan]+1);
-							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 254 )
-								sprintf(m_Msg,"%s","GND");
-							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 255 )
-								sprintf(m_Msg,"%s","NULL");
-							break;
-						case 5:
-							if ( m_gp->PickB_ID[m_gp->DebugChan] >= 0 && m_gp->PickB_ID[m_gp->DebugChan] <= 247 )
-								sprintf(m_Msg,"C%d",m_gp->PickB_ID[m_gp->DebugChan]+1);
-							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 254 )
-								sprintf(m_Msg,"%s","GND");
-							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 255 )
-								sprintf(m_Msg,"%s","NULL");
-							break;
-						default:
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_4(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 2:
-			Refresh_Normal_Label_Content_4_ZKPanel(g,sub);
-			break;
-		case 3:
-			Refresh_Normal_Label_Content_4_DZKPanel(g,sub);
-			break;
-		case 4:
-			Refresh_Normal_Label_Content_4_OZKPanel(g,sub);
-			break;
-		case 5:
-			Refresh_Normal_Label_Content_4_CZKPanel(g,sub);
-			break;
-		default:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}
-}
-
-void Mainwin::Refresh_Normal_Label_Content_4_ZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if 	( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else if ( m_gp->SAlarmType == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
-							else if ( m_gp->SAlarmType == 1 )
-								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
-							else if ( m_gp->SAlarmType == 2 )
-								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
-							break;
-						case 1:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",m_gp->SAlarmCount[m_gp->SAlarmType]+1);
-							break;
-						case 2:
-							if ( m_gp->AlarmBeep == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 3:
-							if ( m_gp->AlarmOutput == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 4:
-							if ( m_gp->AlarmDisplay == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%c",'A'+m_gp->SAlarmIndex[m_gp->SAlarmType]);
-							break;
-						case 1:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][0]);
-							break;
-						case 2:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][1]);
-							break;
-						case 3:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][2]);
-							break;
-						case 4:
-							if ( m_gp->SAlarmType == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][3]);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_4_DZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
-							break;
-
-						case 1:
-							if 	( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
-							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 1 )
-								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
-							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
-								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
-							break;
-						case 2:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",m_gp->DAlarmCount[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]+1);
-							break;
-						case 3:
-							if ( m_gp->AlarmBeep == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 4:
-							if ( m_gp->AlarmOutput == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 5:
-							if ( m_gp->AlarmDisplay == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%c",'A'+m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]);
-							break;
-						case 1:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][0]);
-							break;
-						case 2:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][1]);
-							break;
-						case 3:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][2]);
-							break;
-						case 4:
-							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][3]);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_4_CZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
-							break;
-
-						case 1:
-							if 	( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 0 )
-								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
-							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 1 )
-								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
-							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
-								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
-							break;
-						case 2:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-								sprintf(m_Msg,"%d",m_gp->CAlarmCount[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]+1);
-							break;
-						case 3:
-							if ( m_gp->AlarmBeep == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 4:
-							if ( m_gp->AlarmOutput == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 5:
-							if ( m_gp->AlarmDisplay == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%c",'A'+m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]);
-							break;
-						case 1:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][0]);
-							break;
-						case 2:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][1]);
-							break;
-						case 3:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][2]);
-							break;
-						case 4:
-							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							else
-							       	sprintf(m_Msg,"%d",
-								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][3]);
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-
-}
-			
-void Mainwin::Refresh_Normal_Label_Content_4_OZKPanel(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 1:
-							sprintf(m_Msg,"%d",m_gp->OAlarmPara[0]);
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		default:
-			for ( int i=0;i<MAXNORCOUNT;i++ )
-			{
-					switch ( i )
-					{
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-			}
-			break;
-	}
-}
-
-void Mainwin::Refresh_Normal_Label_Content_5(Graphic& g,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_6(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-						case 1:
-						case 2:
-						case 3:
-						case 4:
-						case 5:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						default:
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-void Mainwin::Refresh_Normal_Label_Content_7(Graphic& g,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-						case 1:
-						case 2:
-						case 3:
-						case 4:
-						case 5:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 2:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						case 1:
-							sprintf(m_Msg,"%s",m_pl->GetText(RESTORE));
-							break;
-						case 2:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						case 3:
-							if 	( m_gp->KeyBeep == true )
-								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
-							else
-								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
-							break;
-						case 4:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						case 5:
-							sprintf(m_Msg,"%s",m_pl->GetText(LAN_VALUE));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 3:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-			}
-			break;
-		case 4:
-			{
-				for ( int i=0;i<MAXNORCOUNT;i++ )
-				{
-					switch ( i )
-					{
-						case 0:
-							{
-								struct tm *timenow;
-								time_t now;
-								time(&now);
-								timenow = localtime(&now);
-
-								timenow->tm_mon += 1;
-								timenow->tm_year -=100;
-								sprintf(m_Msg,"%02d/%02d/%02d",timenow->tm_year,timenow->tm_mon,timenow->tm_mday);
-							}
-							break;
-						case 1:
-							{
-								struct tm *timenow;
-								time_t now;
-								time(&now);
-								timenow = localtime(&now);
-
-								sprintf(m_Msg,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-							}
-							break;
-						case 2:
-							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
-							break;
-						default:	
-							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
-							break;
-					}				/* -----  end switch  ----- */
-					m_NorButton[i]->Set_Content(m_Msg);
-				}
-
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bom_Text
- *  Description:  Get the Bom button text  
- * =====================================================================================
- */
-const char*Mainwin::Get_Bom_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0:
-			m_pl->GetText(DETECT);
-			break;
-		case 1:
-			m_pl->GetText(PARAM);
-			break;
-		case 2:
-			m_pl->GetText(DEBUG);
-			break;
-		case 3:
-			m_pl->GetText(ALARM);
-			break;
-		case 4:
-			m_pl->GetText(ANALYZE);
-			break;
-		case 5:
-			m_pl->GetText(LAYOUT);
-			break;
-		case 6:
-			m_pl->GetText(OTHERS);
-			break;
-		default:	
-			m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Normal_Text
- *  Description:  Get the Normal button text 
- *
- *                bom:    1-7
- *                normal: 1-6
- *                sub:    start from 1
- * =====================================================================================
- */
-const char*Mainwin::Get_Normal_Text(int bom,int normal,int sub)
-{
-	switch ( bom ) 
-	{
-		case 1:	
-			return Get_Normal_Text_1(normal,sub);
-			break;
-		case 2:	
-			return Get_Normal_Text_2(normal,sub);
-			break;
-		case 3:	
-			return Get_Normal_Text_3(normal,sub);
-			break;
-		case 4:	
-			return Get_Normal_Text_4(normal,sub);
-			break;
-		case 5:	
-			return Get_Normal_Text_5(normal,sub);
-			break;
-		case 6:	
-			return Get_Normal_Text_6(normal,sub);
-			break;
-		case 7:	
-			return Get_Normal_Text_7(normal,sub);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Normal_Text_1 2 3 4 5 6 7
- *  Description:  Get the difference of Submenu text 
- * =====================================================================================
- */
-const char*Mainwin::Get_Normal_Text_1(int normal,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0: 
-			return Get_Normal_Text_1_ColorPanel(normal,sub);
-			break;
-
-		case 1: 
-			return Get_Normal_Text_1_VideoPanel(normal,sub);
-			break;
-
-		case 2:
-			return Get_Normal_Text_1_ZKPanel(normal,sub);
-			break;
-
-		case 3:
-			return Get_Normal_Text_1_DZKPanel(normal,sub);
-			break;
-
-		case 4:
-			return Get_Normal_Text_1_OZKPanel(normal,sub);
-			break;
-
-		case 5:
-			return Get_Normal_Text_1_CZKPanel(normal,sub);
-			break;
-
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_1_ColorPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0:
-						return m_pl->GetText(ALLGAIN);
-						break;
-					case 1:
-						return m_pl->GetText(FREQUENCE);
-						break;
-					case 2:
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 5:
-						return m_pl->GetText(SCANSPEED);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_1_VideoPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal )
-				{
-					case 0: 
-						return m_pl->GetText(VIDEOOPEN);
-						break;
-					case 1:	
-						return m_pl->GetText(VIDEOCLOSE);
-						break;
-					case 2:	
-						return m_pl->GetText(ADJRES);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_1_ZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 3:
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 4:
-						return m_pl->GetText(TIMESCALE);
-						break;
-					case 5:
-						return m_pl->GetText(TIMESCALESPEED);
-						break;
-					default:
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_1_DZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal )
-				{
-					case 0:
-						return m_pl->GetText(SCREEN);
-						break;
-					case 1: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 2:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 3:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 4:
-						if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-							return m_pl->GetText(FREQUENCEVALUE);
-						else
-						{
-							return m_pl->GetText(PRIFREQ);
-						}
-						break;
-					case 5:
-						if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-							return m_pl->GetText(NONE);
-						else
-						{
-							return m_pl->GetText(SECFREQ);
-						}
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-
-const char*Mainwin::Get_Normal_Text_1_OZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal )
-				{
-					case 0:
-						return m_pl->GetText(CROSSCHAN);
-						break;
-					case 1:
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:
-						return m_pl->GetText(PHASE);
-						break;
-					case 3:
-						return m_pl->GetText(PARASYNC);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-
-const char*Mainwin::Get_Normal_Text_1_CZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal )
-				{
-					case 0:
-						return m_pl->GetText(SCREEN);
-						break;
-					case 1: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 2:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 3:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 4:
-						return m_pl->GetText(ASCANCHAN);
-						break;
-					case 5:
-						return m_pl->GetText(EMSGAIN);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-
-const char*Mainwin::Get_Normal_Text_2(int normal,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0: 
-			return Get_Normal_Text_2_ColorPanel(normal,sub);
-			break;
-		case 1: 
-			return Get_Normal_Text_2_VideoPanel(normal,sub);
-			break;
-		case 2:
-			return Get_Normal_Text_2_ZKPanel(normal,sub);
-			break;
-		case 3:
-			return Get_Normal_Text_2_DZKPanel(normal,sub);
-			break;
-		case 4:
-			return Get_Normal_Text_2_OZKPanel(normal,sub);
-			break;
-		case 5:
-			return Get_Normal_Text_2_CZKPanel(normal,sub);
-			break;
-
-		default:
-			return Get_Normal_Text_2_ZKPanel(normal,sub);
-			break;
-	}
-}
-
-const char*Mainwin::Get_Normal_Text_2_VideoPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-		case 2:
-		case 3:
-			{
-				switch ( normal ) 
-				{
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_2_ColorPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(SAMPLETYPE);
-						break;
-					case 1:	
-						if 	( m_gp->ColorSpotSampleType == 0 )
-							return m_pl->GetText(STIMEINTER);
-						else if ( m_gp->ColorSpotSampleType == 1 )
-							return m_pl->GetText(SAMPPLUS);
-						break;
-					case 5:
-						return m_pl->GetText(COLORSPOTDM);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_2_ZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(PROBE);
-						break;
-					case 2:	
-						return m_pl->GetText(FREQUENCE);
-						break;
-					case 3: 
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 4:	
-						return m_pl->GetText(DIFILTER);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 3: 
-						return m_pl->GetText(HIFILTER);
-						break;
-					case 4:	
-						return m_pl->GetText(LOFILTER);
-						break;
-					case 5:
-						return m_pl->GetText(AUTODI);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 3:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(X1POINT);
-						break;
-					case 1:	
-						return m_pl->GetText(Y1POINT);
-						break;
-					case 2:
-						return m_pl->GetText(GAINRATIO);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_2_DZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(PROBE);
-						break;
-					case 2:	
-						return m_pl->GetText(FREQUENCE);
-						break;
-					case 3: 
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 4:	
-						return m_pl->GetText(DIFILTER);
-						break;
-					case 5:
-						return m_pl->GetText(MIXFACTOR);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 3: 
-						return m_pl->GetText(HIFILTER);
-						break;
-					case 4:	
-						return m_pl->GetText(LOFILTER);
-						break;
-					case 5:
-						return m_pl->GetText(AUTODI);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 3:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(X1POINT);
-						break;
-					case 1:	
-						return m_pl->GetText(Y1POINT);
-						break;
-					case 2:	
-						return m_pl->GetText(X2POINT);
-						break;
-					case 3:	
-						return m_pl->GetText(Y2POINT);
-						break;
-					case 4:
-						return m_pl->GetText(GAINRATIO);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_2_OZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(PROBE);
-						break;
-					case 2:	
-						return m_pl->GetText(FREQUENCE);
-						break;
-					case 3: 
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 4:	
-						return m_pl->GetText(DIFILTER);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 3: 
-						return m_pl->GetText(HIFILTER);
-						break;
-					case 4:	
-						return m_pl->GetText(LOFILTER);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-
-		case 3:
-			{
-				switch ( normal ) 
-				{
-					case 0:
-						return m_pl->GetText(XNPOINT);
-						break;
-					case 1:
-						return m_pl->GetText(YNPOINT);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_2_CZKPanel(int normal,int sub)
-{
-	switch ( sub )
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(PROBE);
-						break;
-					case 2:	
-						return m_pl->GetText(FREQUENCE);
-						break;
-					case 3: 
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 4:	
-						return m_pl->GetText(DIFILTER);
-						break;
-					case 5:
-						return m_pl->GetText(ASCANSPEED);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(GAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(PHASE);
-						break;
-					case 3: 
-						return m_pl->GetText(HIFILTER);
-						break;
-					case 4:	
-						return m_pl->GetText(LOFILTER);
-						break;
-					case 5:
-						return m_pl->GetText(AUTODI);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 3:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(X1POINT);
-						break;
-					case 1:	
-						return m_pl->GetText(Y1POINT);
-						break;
-					case 2:	
-						return m_pl->GetText(X2POINT);
-						break;
-					case 3:	
-						return m_pl->GetText(Y2POINT);
-						break;
-					case 4:
-						return m_pl->GetText(GAINRATIO);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-const char*Mainwin::Get_Normal_Text_3(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(CHANNEL);
-						break;
-					case 1:	
-						return m_pl->GetText(HDGAIN);
-						break;
-					case 2:	
-						return m_pl->GetText(FREQUENCEVALUE);
-						break;
-					case 3: 
-						return m_pl->GetText(DRIVER);
-						break;
-					case 4:	
-						return m_pl->GetText(OFFSET);
-						break;
-					case 5:
-						return m_pl->GetText(RFFILTER);
-						break;
-
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(PRECISION);
-						break;
-					case 1:	
-						return m_pl->GetText(RESBALACE);
-						break;
-					case 2:	
-						return m_pl->GetText(ADRIVE);
-						break;
-					case 3: 
-						return m_pl->GetText(BDRIVE);
-						break;
-					case 4:	
-						return m_pl->GetText(APICK);
-						break;
-					case 5:	
-						return m_pl->GetText(BPICK);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-const char*Mainwin::Get_Normal_Text_4(int normal,int sub)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 2: 
-			return Get_Normal_Text_4_ZKPanel(normal,sub);
-			break;
-		case 3: 
-			return Get_Normal_Text_4_DZKPanel(normal,sub);
-			break;
-		case 4:
-			return Get_Normal_Text_4_OZKPanel(normal,sub);
-			break;
-		case 5:
-			return Get_Normal_Text_4_CZKPanel(normal,sub);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_4_ZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(ALARMTYPE);
-						break;
-					case 1:	
-						return m_pl->GetText(ALARMACOUNT);
-						break;
-					case 2:	
-						return m_pl->GetText(ALARMBEEP);
-						break;
-					case 3: 
-						return m_pl->GetText(ALARMOUT);
-						break;
-					case 4:	
-						return m_pl->GetText(ALARMDISP);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(ALARMWINS);
-						break;
-					case 1:	
-						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
-							return m_pl->GetText(LEFTLIMIT);
-						else
-							return m_pl->GetText(DEGREE1);
-						break;
-					case 2:	
-						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
-							return m_pl->GetText(UPLIMIT);
-						else
-							return m_pl->GetText(DEGREE2);
-						break;
-					case 3: 
-						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
-							return m_pl->GetText(RIGHTLIMIT);
-						else
-							return m_pl->GetText(XHALF);
-						break;
-					case 4:	
-						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
-							return m_pl->GetText(DOWNLIMIT);
-						else
-							return m_pl->GetText(YHALF);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-const char*Mainwin::Get_Normal_Text_4_DZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0:
-						return m_pl->GetText(SCREEN);
-						break;
-					case 1: 
-						return m_pl->GetText(ALARMTYPE);
-						break;
-					case 2:	
-						return m_pl->GetText(ALARMACOUNT);
-						break;
-					case 3:	
-						return m_pl->GetText(ALARMBEEP);
-						break;
-					case 4: 
-						return m_pl->GetText(ALARMOUT);
-						break;
-					case 5:	
-						return m_pl->GetText(ALARMDISP);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(ALARMWINS);
-						break;
-					case 1:	
-						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(LEFTLIMIT);
-						else
-							return m_pl->GetText(DEGREE1);
-						break;
-					case 2:	
-						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(UPLIMIT);
-						else
-							return m_pl->GetText(DEGREE2);
-						break;
-					case 3: 
-						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(RIGHTLIMIT);
-						else
-							return m_pl->GetText(XHALF);
-						break;
-					case 4:	
-						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(DOWNLIMIT);
-						else
-							return m_pl->GetText(YHALF);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-const char*Mainwin::Get_Normal_Text_4_CZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 0:
-						return m_pl->GetText(SCREEN);
-						break;
-					case 1: 
-						return m_pl->GetText(ALARMTYPE);
-						break;
-					case 2:	
-						return m_pl->GetText(ALARMACOUNT);
-						break;
-					case 3:	
-						return m_pl->GetText(ALARMBEEP);
-						break;
-					case 4: 
-						return m_pl->GetText(ALARMOUT);
-						break;
-					case 5:	
-						return m_pl->GetText(ALARMDISP);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		case 2:
-			{
-				switch ( normal ) 
-				{
-					case 0: 
-						return m_pl->GetText(ALARMWINS);
-						break;
-					case 1:	
-						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(LEFTLIMIT);
-						else
-							return m_pl->GetText(DEGREE1);
-						break;
-					case 2:	
-						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(UPLIMIT);
-						else
-							return m_pl->GetText(DEGREE2);
-						break;
-					case 3: 
-						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(RIGHTLIMIT);
-						else
-							return m_pl->GetText(XHALF);
-						break;
-					case 4:	
-						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
-							return m_pl->GetText(DOWNLIMIT);
-						else
-							return m_pl->GetText(YHALF);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-const char*Mainwin::Get_Normal_Text_4_OZKPanel(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			{
-				switch ( normal ) 
-				{
-					case 1: 
-						return m_pl->GetText(ALARMLIMIT);
-						break;
-					default:	
-						return m_pl->GetText(NONE);
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}
-}
-const char*Mainwin::Get_Normal_Text_5(int normal,int sub)
-{
-	return m_pl->GetText(NONE);
-}
-const char*Mainwin::Get_Normal_Text_6(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( normal ) 
-			{
-				case 0:
-					return m_pl->GetText(COMBINING);
-					break;
-				case 1:
-					return m_pl->GetText(OZKDISPLAY);
-					break;
-				case 2:
-					return m_pl->GetText(DZKDISPLAY);
-					break;
-
-				case 3: 
-					return m_pl->GetText(SIGZKDISPLAY);
-					break;
-
-				case 4: 
-					return m_pl->GetText(COLORDISPLAY);
-					break;
-
-				case 5: 
-					return m_pl->GetText(VIDEODISPLAY);
-					break;
-
-				default:	
-					return m_pl->GetText(NONE);
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-	return m_pl->GetText(NONE);
-}
-const char*Mainwin::Get_Normal_Text_7(int normal,int sub)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( normal ) 
-			{
-				case 0: 
-					return m_pl->GetText(SAVEPARAM);
-					break;
-
-				case 1: 
-					return m_pl->GetText(LOADPARAM);
-					break;
-
-				case 2: 
-					return m_pl->GetText(DELPARAM);
-					break;
-
-				case 3: 
-					return m_pl->GetText(SAVEDATA);
-					break;
-
-				case 4: 
-					return m_pl->GetText(LOADDATA);
-					break;
-
-				case 5: 
-					return m_pl->GetText(DELEDATA);
-					break;
-
-				default:	
-					return m_pl->GetText(NONE);
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-
-		case 2:
-			switch ( normal ) 
-			{
-				case 0: 
-					return m_pl->GetText(UPDATEPRO);
-					break;
-
-				case 1:
-					return m_pl->GetText(DEFAULT);
-					break;
-
-				case 2:
-					return m_pl->GetText(PICMANAGE);
-					break;
-
-				case 3:
-					return m_pl->GetText(KEYBEEP);
-					break;
-
-				case 4:
-					return m_pl->GetText(OPERATION);
-					break;
-
-				case 5:
-					return m_pl->GetText(LANGUAGE);
-					break;
-
-				default:	
-					return m_pl->GetText(NONE);
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-		case 4:
-			switch ( normal ) 
-			{
-				case 0:
-					return m_pl->GetText(SYSTEMDATE);
-					break;
-				case 1:
-					return m_pl->GetText(SYSTEMTIME);
-					break;
-				case 2:
-					return m_pl->GetText(VERSION);
-					break;
-				default:	
-					return m_pl->GetText(NONE);
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-	return m_pl->GetText(NONE);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Process_Sets
- *  Description:  Init process sets 
- * =====================================================================================
- */
-void Mainwin::Init_Process_Sets()
-{
-	m_Process[0]	 = 	new DetectProcess(this);
-	m_Process[1]	 = 	new ParameterProcess(this);
-	m_Process[2]	 = 	new DebugProcess(this);
-	m_Process[3]	 = 	new AlarmProcess(this);
-	m_Process[4]	 = 	new AnalyzeProcess(this);
-	m_Process[5]	 = 	new DisplayProcess(this);
-	m_Process[6]	 = 	new OthersProcess(this);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_Process_Sets
- *  Description:  Release Process Sets 
- * =====================================================================================
- */
-void Mainwin::Release_Process_Sets()
-{
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		delete m_Process[i];
-		m_Process[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Language
- *  Description:  When switch language call it
- * =====================================================================================
- */
-void Mainwin::Switch_Language(Graphic& g)
-{
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-		if 	( m_gp->Language == 0 )
-			m_BomButton[i]->Set_Font_Size(24);
-		else
-			m_BomButton[i]->Set_Font_Size(16);
-	}
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
-	}
-	Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DisplayTimeDate
- *  Description:  Display time and date on screen
- * =====================================================================================
- */
-void Mainwin::DisplayTimeDate(Graphic& g)
-{
-	struct tm *timenow;
-	time_t now;
-	time(&now);
-	timenow = localtime(&now);
-
-	if ( m_ssecond == timenow->tm_sec )
-		return;
-
-	m_ssecond = timenow->tm_sec;
-
-	sprintf(m_Msg,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-	m_NorButton[1]->Set_Content(m_Msg);
-	m_NorButton[1]->Drawme(g,true);
-
-	timenow->tm_mon += 1;
-	timenow->tm_year -=100;
-	sprintf(m_Msg,"%02d/%02d/%02d",timenow->tm_year,timenow->tm_mon,timenow->tm_mday);
-	m_NorButton[0]->Set_Content(m_Msg);
-	m_NorButton[0]->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Update_Time
- *  Description:  Update time on button 
- * =====================================================================================
- */
-void Mainwin::Update_Time(Graphic& g,const char* timebuf)
-{
-	m_NorButton[1]->Set_Content(timebuf);
-	m_NorButton[1]->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Update_Date
- *  Description:  Update date on button 
- * =====================================================================================
- */
-void Mainwin::Update_Date(Graphic& g,const char* timebuf)
-{
-	m_NorButton[0]->Set_Content(timebuf);
-	m_NorButton[0]->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sync_Cross_Chan_Parameters
- *  Description: Sync the Cross Channel Parameters to other parameters  
- * =====================================================================================
- */
-void Mainwin::Sync_Cross_Chan_Parameters(Graphic& g)
-{
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
-		m_NorButton[i]->Drawme(g,false);
-	}
-
-	Msgbox *ms = new Msgbox(120,170,420,100,m_pl->GetText(PARASYNCCOMFIRM),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == true )
-	{
-		for ( int i=0;i<8;i++ )
-		{
-			m_gp->CrossDegree[i] = m_gp->CrossDegree[m_gp->ScopeChan];
-			m_gp->CrossGain[i] = m_gp->CrossGain[m_gp->ScopeChan];
-		}
-		m_gp->Calculate_Gain();
-	}
-
-	delete ms;
-	ms = NULL;
-}
diff --git a/src/EVA11/Mainwin.h b/src/EVA11/Mainwin.h
deleted file mode 100644
index d1ad86e..0000000
--- a/src/EVA11/Mainwin.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Mainwin.h
- *
- *    Description:  Important class, in the Ruby project 
- *
- *        Version:  1.0
- *        Created:  2012年06月13日 15时15分28秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _MAINWIN_INC
-#define  _MAINWIN_INC
-
-class Basewin;
-class IView;
-class IProcess;
-class OthersProcess;
-class Graphic;
-
-#include 	<time.h>
-#include 	<sys/time.h>
-
-class Mainwin : public Basewin
-{
-	public:
-		Mainwin ();
-		virtual ~Mainwin ();
-		void Drawme (Graphic&);
-		int Loopwindow(Graphic &);
-
-	protected:
-		void Init_GUI(Graphic& g);
-		void Init_Variables();
-		void Destroy_GUI();
-
-		void Init_Process_Sets();
-		void Release_Process_Sets();
-
-		void Init_View_Sets(Graphic& g);
-		void Release_View_Sets();
-
-		virtual int Key_Bom1_Fun(Graphic& g);
-		virtual int Key_Bom2_Fun(Graphic& g);
-		virtual int Key_Bom3_Fun(Graphic& g);
-		virtual int Key_Bom4_Fun(Graphic& g);
-		virtual int Key_Bom5_Fun(Graphic& g);
-		virtual int Key_Bom6_Fun(Graphic& g);
-		virtual int Key_Bom7_Fun(Graphic& g);
-
-		virtual int Key_Esc_Fun(Graphic& g);
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual int Key_NL1_Fun(Graphic& g);
-		virtual int Key_NR1_Fun(Graphic& g);
-		virtual int Key_NL2_Fun(Graphic& g);
-		virtual int Key_NR2_Fun(Graphic& g);
-		virtual int Key_NL3_Fun(Graphic& g);
-		virtual int Key_NR3_Fun(Graphic& g);
-		virtual int Key_NL4_Fun(Graphic& g);
-		virtual int Key_NR4_Fun(Graphic& g);
-		virtual int Key_NL5_Fun(Graphic& g);
-		virtual int Key_NR5_Fun(Graphic& g);
-		virtual int Key_NL6_Fun(Graphic& g);
-		virtual int Key_NR6_Fun(Graphic& g);
-
-		virtual int Key_F1_Fun(Graphic& g);
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F5_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-		virtual int Key_F7_Fun(Graphic& g);
-	private:
-		const char*Get_Bom_Text(int index);
-		const char*Get_Normal_Text(int bom,int normal,int sub);
-
-		const char*Get_Normal_Text_1(int normal,int sub);
-		const char*Get_Normal_Text_2(int normal,int sub);
-		const char*Get_Normal_Text_3(int normal,int sub);
-		const char*Get_Normal_Text_4(int normal,int sub);
-		const char*Get_Normal_Text_5(int normal,int sub);
-		const char*Get_Normal_Text_6(int normal,int sub);
-		const char*Get_Normal_Text_7(int normal,int sub);
-
-		const char*Get_Normal_Text_1_ColorPanel(int normal,int sub);
-		const char*Get_Normal_Text_1_VideoPanel(int normal,int sub);
-		const char*Get_Normal_Text_1_ZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_1_DZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_1_OZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_1_CZKPanel(int normal,int sub);
-
-		const char*Get_Normal_Text_2_VideoPanel(int normal,int sub);
-		const char*Get_Normal_Text_2_ColorPanel(int normal,int sub);
-		const char*Get_Normal_Text_2_ZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_2_DZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_2_OZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_2_CZKPanel(int normal,int sub);
-
-		const char*Get_Normal_Text_4_ZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_4_DZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_4_OZKPanel(int normal,int sub);
-		const char*Get_Normal_Text_4_CZKPanel(int normal,int sub);
-
-		void DrawBottomFocus(Graphic& g,int index);
-		void DrawNormalFocus(Graphic& g,int index);
-
-		void Refresh_Small_Label(Graphic& g);
-
-		void Refresh_Normal_Label_Text(Graphic& g);
-		void Refresh_Normal_Label_Content(Graphic& g);
-
-		void Refresh_Normal_Label_Content_1(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_3(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_4(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_5(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_6(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_7(Graphic& g,int sub);
-
-		void Refresh_Normal_Label_Content_1_VideoPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_1_ColorPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_1_ZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_1_DZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_1_OZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_1_CZKPanel(Graphic& g,int sub);
-
-		void Refresh_Normal_Label_Content_2_VideoPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2_ColorPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2_ZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2_DZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2_OZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_2_CZKPanel(Graphic& g,int sub);
-
-		void Refresh_Normal_Label_Content_4_ZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_4_DZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_4_OZKPanel(Graphic& g,int sub);
-		void Refresh_Normal_Label_Content_4_CZKPanel(Graphic& g,int sub);
-
-		void Switch_Language(Graphic& g);
-
-		void DisplayTimeDate(Graphic& g);
-		void Update_Time(Graphic& g,const char *);
-		void Update_Date(Graphic& g,const char *);
-		void Sync_Cross_Chan_Parameters(Graphic& g);
-	private:
-		friend class 			     OthersProcess;
-		friend class 			     ParameterProcess;
-		friend class 			     DetectProcess;
-
-		static const int  		     MAXNORCOUNT = 6;
-
-		/*-----------------------------------------------------------------------------
-		 * Bottom buttons
-		 *---------------------------------------------------------------------------- */
-		int               		     m_NormalFocus;
-		int 				     m_SubMenuNo[MAXBOMCOUNT];    
-		int 				     m_SubMenuMaxNo[MAXBOMCOUNT]; 
-
-		Label				     *m_NorButton[MAXNORCOUNT];
-		IProcess			     *m_Process[MAXBOMCOUNT];
-		IView				     *m_View[MAXBOMCOUNT];
-
-		bool				     m_PauseFlag;
-		int				     m_ssecond;
-		
-}; /* -----  end of class Mainwin  ----- */
-#endif   /* ----- #ifndef _MAINWIN_INC  ----- */
diff --git a/src/EVA11/Makefile b/src/EVA11/Makefile
index 311190e..6c11a00 100644
--- a/src/EVA11/Makefile
+++ b/src/EVA11/Makefile
@@ -1,118 +1,29 @@
 ##########################################################
 #
-#                    The EVA11 project Makefile
+#                    The Main project Makefile
 #
 # Author:    kevin.wang
 # Company:   Eddysun     xiamen
-# Date:      2012.12.13
-# Comment:   Try to re-structure the Project Makefile
+# Date:      2010.04.06
+# Comment:   Acoording to the PROJ parameters to design 
+#            which project to be constructed
 #            
-#
 ###########################################################
-include MKlib.mk 
-
-ifeq ($(CMOD),dynamic)
-DYNAMICLIBS=$(THIRDLIB) $(LIBS)
-else
-DYNAMICLIBS:=$(LIBS) 
-STATICLIBS=$(THIRDLIB)
-endif
-
-TXTOBJS:=OBJS
-TXTDEPS:=DEPS
-TXTJPGS:=JPGS
-TXTASMS:=ASMS
-OBJS_DIR:=./$(TXTOBJS)/
-DEPS_DIR:=./$(TXTDEPS)/
-
-ifeq ($(COMPILE),arm9)
-SRCS:=$(wildcard *.cpp *.c $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif $(TXTASMS)/*.s)
-else
-SRCS:=$(wildcard *.cpp *.c $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif)
-endif
-
-OBJS:=$(SRCS:=.o)
-DEPS:=$(SRCS:=.dep)
-
-OBJS:=$(addprefix $(OBJS_DIR),$(OBJS))
-DEPS:=$(addprefix $(DEPS_DIR),$(DEPS))
-
-ifeq ($(DEBUG),yes)
-COMPILE_FLAG = -g2
-else
-
-ifeq ($(COMPILE),arm9)
-COMPILE_FLAG = -O2 -march=armv4t
-else 
-COMPILE_FLAG = -O2
-endif
-
-endif
-
-
-all: $(DEPS) $(EXEC)
-
-$(DEPS_DIR)%.cpp.dep: %.cpp
-	@set -e; \
-	$(RM) -rf $@.tmp; \
-	gcc -E -MM $^ > $@.tmp; \
-	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.cpp.o:,g' < $@.tmp > $@; \
-	$(RM) $@.tmp
-
-$(DEPS_DIR)%.c.dep: %.c
+SUBDIRS := $(shell find * -maxdepth 0 -type d)
+.PHONY : all
+all:
+	@echo Building $(PROJ) Project...                                     
+	@for dir in $(SUBDIRS); \
+		do $(MAKE) $(MAKECMDGOALS) -C $$dir || exit 1; \
+	done
+.PHONY : clean 
+clean:
 	@set -e; \
-	$(RM) -rf $@.tmp; \
-	gcc -E -MM $^ > $@.tmp; \
-	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.c.o:,g' < $@.tmp > $@; \
-	$(RM) $@.tmp
-
-$(DEPS_DIR)$(TXTASMS)/%.s.dep: $(TXTASMS)/%.s
-	@set -e;
-
-$(DEPS_DIR)$(TXTJPGS)/%.jpg.dep: $(TXTJPGS)/%.jpg
-	@set -e;
-
-$(DEPS_DIR)$(TXTJPGS)/%.png.dep: $(TXTJPGS)/%.png
-	@set -e;
-
-$(DEPS_DIR)$(TXTJPGS)/%.gif.dep: $(TXTJPGS)/%.gif
-	@set -e;
-
--include $(DEPS)
-
-$(EXEC): $(OBJS)
-	$(CPP) $(FLAG) -o $@ $^ -Wl,-Bdynamic $(addprefix -l,$(DYNAMICLIBS)) -Wl,-Bstatic $(addprefix -l,$(STATICLIBS)) $(SEARCH_LIBPATH) -Wl,-Bdynamic
 
-$(addprefix $(OBJS_DIR),%.s.o): %.s
-	$(AS) $< -o $@
+	@for dir in $(SUBDIRS); \
+		do $(MAKE) $(MAKECMDGOALS) -C $$dir ||  exit 1; \
+	done
 
-$(addprefix $(OBJS_DIR),%.c.o): %.c
-	$(CC) $(C_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
-
-$(addprefix $(OBJS_DIR),%.cpp.o): %.cpp
-	$(CPP) $(CPP_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
-
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.jpg.o): $(TXTJPGS)/%.jpg
-ifeq ($(COMPILE),arm9)
-	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
-else
-	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
-endif
-
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.png.o): $(TXTJPGS)/%.png
-ifeq ($(COMPILE),arm9)
-	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
-else
-	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
-endif
-
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.gif.o): $(TXTJPGS)/%.gif
-ifeq ($(COMPILE),arm9)
-	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
-else
-	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
-endif
-
-.PHONY: clean
-clean:
-	$(RM) -rf $(addprefix $(OBJS_DIR),*.o) $(addprefix $(OBJS_DIR),$(TXTJPGS)/*.o) $(addprefix $(DEPS_DIR),*.dep) $(EXEC) 
+#for dir in $(SUBDIRS); \
+	do $(MAKE) clean -C $$dir all || exit 1; \
+done
diff --git a/src/EVA11/ManageMD5.cpp b/src/EVA11/ManageMD5.cpp
deleted file mode 100644
index ff5a7b5..0000000
--- a/src/EVA11/ManageMD5.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ManageMD5.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年09月12日 16时44分40秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<new>
-#include 	<cstring>
-#include        <cstdio>
-#include 	<unistd.h>
-#include 	<fstream>
-#include 	<ostream>
-
-#include 	<openssl/md5.h>
-
-#include 	"ManageMD5.h"
-std::auto_ptr<ManageMD5> ManageMD5::m_Instance;
-
-static unsigned char shash[MD5_DIGEST_LENGTH] = {0};
-
-ManageMD5::ManageMD5 ()
-{
-}
-
-ManageMD5::~ManageMD5 ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-ManageMD5* ManageMD5::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new ManageMD5() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_MD5
- *  Description:  Calculate the MD5 value 
- *         path:  Complete path of file which need to calculate MD5
- * =====================================================================================
- */
-bool ManageMD5::Calculate_MD5(const char* path)
-{
-	using namespace std;
-	bool result = false;
-	if 	( access(path,0) == -1 )
-	{
-		perror("access file");
-		return false;
-	}
-	std::fstream filestream;
-	filestream.open(path,ios::binary|ios::in);
-	if 	( !filestream )
-	{
-		perror("can't open the input data file\n");
-		return false;
-	}
-	filestream.seekp(0,ios::end);
-	unsigned int length = filestream.tellp();
-
-	if ( length <= 16 )
-	{
-		printf ( "length less 16 bytes\n" );
-		return false;
-	}
-
-	unsigned char *buf  = new(std::nothrow) unsigned char[length];
-
-	if ( buf == NULL )
-	{
-		perror("Can't Allocate Memory for Programe");
-		return false;
-	}
-
-	filestream.seekp(0,ios::beg);
-	filestream.read((char*)buf,length);
-	filestream.close();
-
-	MD5_CTX ctx;
-	memset(&ctx,0,sizeof(MD5_CTX));
-	MD5_Init(&ctx);
-	MD5_Update(&ctx,buf,length-16);
-	MD5_Final(shash,&ctx);
-
-	for ( int i=0;i<16;i++ )
-	{
-		if ( buf[length-16+i] != shash[i] )
-		{
-			result = false;
-			goto Exit;
-		}
-	}
-
- 	result = true;
-Exit:
-	delete[] buf;
-	buf = NULL;
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Hash_Value
- *  Description:  Get the Hash table value 
- *      caution:  Get the Hash value after Calculate_MD5
- * =====================================================================================
- */
-unsigned char* ManageMD5::Get_Hash_Value()
-{
-	return shash;
-}
diff --git a/src/EVA11/ManageMD5.h b/src/EVA11/ManageMD5.h
deleted file mode 100644
index c45428a..0000000
--- a/src/EVA11/ManageMD5.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ManageMD5.h
- *
- *    Description:  Deal with md5 function
- *
- *        Version:  1.0
- *        Created:  2012年09月12日 16时39分52秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  ManageMD5_INC
-#define  ManageMD5_INC
-
-#include 	<memory>
-class ManageMD5
-{
-	public:
-		static ManageMD5* Instance();
-		bool Calculate_MD5(const char* path);
-		unsigned char* Get_Hash_Value();
-	protected:
-
-	private:
-		ManageMD5();
-		~ManageMD5();
-		ManageMD5( const ManageMD5& );
-		ManageMD5& operator = (const ManageMD5&);
-	private:
-		friend class std::auto_ptr<ManageMD5>;
-		static std::auto_ptr<ManageMD5>		m_Instance;
-};
-
-#endif   /* ----- #ifndef ManageMD5_INC  ----- */
diff --git a/src/EVA11/MixingManage.cpp b/src/EVA11/MixingManage.cpp
deleted file mode 100644
index c270130..0000000
--- a/src/EVA11/MixingManage.cpp
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  MixingManage.cpp
- *
- *    Description:  Implementation of MixingManage class
- *
- *        Version:  1.0
- *        Created:  2012年11月28日 11时25分57秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	"MixingManage.h"
-#include 	"AlgMixing.h"
-#include 	"Global.h"
-
-std::auto_ptr<MixingManage> MixingManage::m_Instance;
-
-struct MixingManage::PImpl
-{
-	const static int	UnitCount = Global::MIXCOUNT;
-	AlgMixing*		AlgMixUnit[UnitCount];
-};
-
-MixingManage::MixingManage ()
-	: m_Imple(new struct PImpl)
-{
-}
-
-MixingManage::~MixingManage ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  Only use this function to init logic class 
- * =====================================================================================
- */
-MixingManage* MixingManage::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new MixingManage() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Object
- *  Description:  Init the Object of MixingManage class 
- * =====================================================================================
- */
-bool MixingManage::Init_Object()
-{
-	for ( int i=0;i<m_Imple->UnitCount;i++ )
-	{
-		m_Imple->AlgMixUnit[i] = new AlgMixing;
-		m_Imple->AlgMixUnit[i]->Init_Object();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy
- *  Description:  Destroy the object of class 
- * =====================================================================================
- */
-void MixingManage::Destroy_Object()
-{
-	for ( int i=0;i<m_Imple->UnitCount;i++ )
-	{
-		delete m_Imple->AlgMixUnit[i];
-		m_Imple->AlgMixUnit[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Data_Into_Buffer
- *  Description:  Load Data into Buffer of object 
- * =====================================================================================
- */
-void MixingManage::Load_Data_Into_Buffer(int index,ETDATA *data)
-{
-	m_Imple->AlgMixUnit[index]->Load_Data_Into_Buffer(data);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_Data_From_Buffer
- *  Description:  Clean Data from Buffer 
- * =====================================================================================
- */
-void MixingManage::Clean_Data_From_Buffer(int index)
-{
-	m_Imple->AlgMixUnit[index]->Clean_Data_From_Buffer();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Mix_Para
- *  Description:  Calculate the mixing parameters
- * =====================================================================================
- */
-void MixingManage::Calculate_Mix_Para(int index)
-{
-	m_Imple->AlgMixUnit[index]->Calculate_Mix_Para();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mixing
- *  Description:  Mixing the Signal value 
- * =====================================================================================
- */
-void MixingManage::Mixing(int index,const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA & y)
-{
-	m_Imple->AlgMixUnit[index]->Mixing(xb,yb,x,y);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_MixUnit_Count
- *  Description:  Get the Mixing Unit Count 
- * =====================================================================================
- */
-int MixingManage::Get_MixUnit_Count()
-{
-	return m_Imple->UnitCount;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sync_Mixing_Para
- *  Description:  Sync Mixing para with Mixing Unit and Global 
- *
- *         flag:  true    	MixingUnit -> Global
- *                false 	Global->MixingUnit
- * =====================================================================================
- */
-void MixingManage::Sync_Mixing_Para(bool flag)
-{
-	Global *gp = Global::Instance();
-	if 	( flag == false )
-	{
-		for ( int i=0;i<Global::MIXCOUNT;i++ )
-		{
-			m_Imple->AlgMixUnit[i]->Set_Sx(gp->Sx[i]);
-			m_Imple->AlgMixUnit[i]->Set_Sy(gp->Sy[i]);
-			m_Imple->AlgMixUnit[i]->Set_Cos(gp->Cos[i]);
-			m_Imple->AlgMixUnit[i]->Set_Sin(gp->Sin[i]);
-
-			m_Imple->AlgMixUnit[i]->Set_a(gp->a[i]);
-			m_Imple->AlgMixUnit[i]->Set_b(gp->b[i]);
-			m_Imple->AlgMixUnit[i]->Set_c(gp->c[i]);
-			m_Imple->AlgMixUnit[i]->Set_d(gp->d[i]);
-
-			m_Imple->AlgMixUnit[i]->Set_AlgMix_Version(gp->MixAlgVersion[i]);
-		}
-	}
-	else
-	{
-		for ( int i=0;i<Global::MIXCOUNT;i++ )
-		{
-			gp->Sx[i]  = m_Imple->AlgMixUnit[i]->Get_Sx();
-			gp->Sy[i]  = m_Imple->AlgMixUnit[i]->Get_Sy();
-			gp->Cos[i] = m_Imple->AlgMixUnit[i]->Get_Cos();
-			gp->Sin[i] = m_Imple->AlgMixUnit[i]->Get_Sin();
-
-			gp->a[i] = m_Imple->AlgMixUnit[i]->Get_a();
-			gp->b[i] = m_Imple->AlgMixUnit[i]->Get_b();
-			gp->c[i] = m_Imple->AlgMixUnit[i]->Get_c();
-			gp->d[i] = m_Imple->AlgMixUnit[i]->Get_d();
-
-			gp->MixAlgVersion[i]
-				 = m_Imple->AlgMixUnit[i]->Get_AlgMix_Version();
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restore_Mix_Factor
- *  Description:  Restore Mult-Freq Factor 
- * =====================================================================================
- */
-void MixingManage::Restore_Mix_Factor()
-{
-	for ( int i=0;i<Global::MIXCOUNT;i++ )
-	{
-		m_Imple->AlgMixUnit[i]->Init_Object();
-	}
-}
diff --git a/src/EVA11/MixingManage.h b/src/EVA11/MixingManage.h
deleted file mode 100644
index 527eb2d..0000000
--- a/src/EVA11/MixingManage.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  MixingManage.h
- *
- *    Description:  Manage the Mixing unit
- *
- *        Version:  1.0
- *        Created:  2012年11月28日 11时23分45秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  MIXINGMANAGE_INC
-#define  MIXINGMANAGE_INC
-
-#include 	<memory>
-#include 	"main.h"
-
-class MixingManage
-{
-	public:
-		static MixingManage* Instance();
-
-		bool Init_Object();
-		void Destroy_Object();
-		void Load_Data_Into_Buffer(int index,ETDATA *data);
-		void Clean_Data_From_Buffer(int index);
-		void Calculate_Mix_Para(int index);
-		void Mixing(int index,const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA &y);
-		int Get_MixUnit_Count();
-
-		void Sync_Mixing_Para(bool);
-		void Restore_Mix_Factor();
-	protected:
-
-	private:
-		MixingManage ();
-		~MixingManage ();
-		MixingManage (const MixingManage&);
-		MixingManage& operator = (const MixingManage&);
-	private:
-		friend class std::auto_ptr<MixingManage>;
-		static std::auto_ptr<MixingManage>		m_Instance;
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif   /* ----- #ifndef MIXINGMANAGE_INC  ----- */
diff --git a/src/EVA11/Modifywin.cpp b/src/EVA11/Modifywin.cpp
deleted file mode 100644
index feea6ab..0000000
--- a/src/EVA11/Modifywin.cpp
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Modifywin.cpp
- *
- *    Description:  Implementation of Modifywin class 
- *
- *        Version:  1.0
- *        Created:  2012年07月04日 16时45分27秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Basewin.h"
-#include	"Loadwin.h"
-#include	"Modifywin.h" 
-#include 	"Graphic.h"
-#include 	"Logic.h"
-#include	"Label.h"
-#include	"Language.h"
-#include	"Global.h"
-#include	"Msgbox.h"
-#include	"Battery.h"
-#include 	"Parawin.h"
-
-Modifywin::Modifywin (Graphic&g,LOADTYPE type) :
-	Loadwin(g,type)
-{
-}
-
-Modifywin::~Modifywin ()
-{
-}
-
-void Modifywin::Drawme (Graphic& g)
-{
-	Basewin::Drawme(g);
-	m_Title->Drawme(g);
-
-	if ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE )
-		m_SubTitle->Drawme(g);
-
-	for ( int i=0;i<26;i++ )
-	{
-		m_NorLable[i]->Drawme(g);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object of screen 
- * =====================================================================================
- */
-void Modifywin::Init_GUI(Graphic& g)
-{
-	if 	( m_Type == LT_SAVE )
-	{
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(SAVEPARAM));
-	}
-	else if	( m_Type == LT_LOAD )
-	{
-	       	m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(LOADPARAM));
-	}
-	else if	( m_Type == LT_DELE )
-	{ 
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(DELPARAM));
-	}
-	else if	( m_Type == DA_SAVE )
-	{ 
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
-	}
-	else if	( m_Type == DA_LOAD )
-	{
-	       	m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(LOADDATA));
-	}
-	else if	( m_Type == DA_DELE ) 
-	{
-		m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(DELEDATA));
-	}
-	m_Title->Set_Label_Type(Label::LA_NONE);
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-
-	Sub_Init_GUI(g);
-
-	m_BottomFocus = 1;
-	m_NormalFocus = 1;
-	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-	m_BomButton[m_BottomFocus-1]->Set_Focus(true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void Modifywin::Destroy_GUI()
-{
-	if ( m_Title != NULL )
-	{
-		delete m_Title;
-		m_Title = NULL;
-	}
-	if ( m_SubTitle != NULL )
-	{
-		delete m_SubTitle;
-		m_SubTitle = NULL;
-	}
-	for ( int i=0;i<26;i++ )
-	{
-		if ( m_NorLable[i] != NULL )
-		{
-			delete m_NorLable[i];
-			m_NorLable[i] = NULL;
-		}
-	}
-	Basewin::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  Switch the bottom focus status 
- * =====================================================================================
- */
-void Modifywin::DrawBottomFocus(Graphic &g,int index)
-{
-	Basewin::DrawBottomFocus(g,index);
-	switch ( index ) 
-	{
-		case 1:                         /* previouse */
-			{
-				if ( m_NormalFocus == 1 )
-				{
-				        m_NormalFocus = 26;
-					m_NorLable[0]->Set_Focus(false);
-					m_NorLable[0]->Drawme(g);
-					m_NorLable[25]->Set_Focus(true);
-					m_NorLable[25]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus--;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-		case 2:                         /* next */
-			{
-				if ( m_NormalFocus == 26 )
-				{
-				        m_NormalFocus = 1;
-					m_NorLable[25]->Set_Focus(false);
-					m_NorLable[25]->Drawme(g);
-					m_NorLable[0]->Set_Focus(true);
-					m_NorLable[0]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus++;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 3:                         /* left  */
-			{
-				if ( m_NormalFocus < 7 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 20;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus >= 7 && m_NormalFocus <= 10 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 4:                         /* right */
-			{
-				if ( m_NormalFocus > 20 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 20;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else if ( m_NormalFocus <= 20 && m_NormalFocus > 16 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function 
- *       return:  0: Exit program
- *                1: goto Mainwin
- * =====================================================================================
- */
-int Modifywin::Loopwindow (Graphic &g)
-{
-	Save_Screen_Into_Memory(g);
-	int result = SubLoopwindow(g);
-	Restore_Screen_From_Memory(g);
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Modifywin::Key_Esc_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Modifywin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
diff --git a/src/EVA11/Modifywin.h b/src/EVA11/Modifywin.h
deleted file mode 100644
index 679239a..0000000
--- a/src/EVA11/Modifywin.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Modifywin.h
- *
- *    Description:  Load parameters level 1 class   
- *
- *        Version:  1.0
- *        Created:  2012年07月04日 16时43分31秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _MODIFYWIN_INC
-#define  _MODIFYWIN_INC
-
-class Loadwin;
-class Modifywin : public Loadwin
-{
-	public:
-		Modifywin (Graphic&g,LOADTYPE type);
-		virtual ~Modifywin ();
-
-		void Drawme (Graphic& g);       		                 /* Any window coming from window class draw itself on screen */
-		int Loopwindow (Graphic &);        		                 /* deal with the command getting from key board  */
-	protected:
-		virtual int Key_Esc_Fun(Graphic& g);
-		virtual int Key_Bom7_Fun(Graphic& g);
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-		void DrawBottomFocus(Graphic &g,int index);     		 /* change the bottom buttons status as the parameter index */
-	private:
-}; /* -----  end of class Modifywin  ----- */
-
-#endif   /* ----- #ifndef modifywin_INC  ----- */
diff --git a/src/EVA11/Msgbox.cpp b/src/EVA11/Msgbox.cpp
deleted file mode 100644
index cf70950..0000000
--- a/src/EVA11/Msgbox.cpp
+++ /dev/null
@@ -1,480 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Msgbox.cpp
- *
- *    Description:  implementation of Msgbox class
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 16时38分13秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include	<string.h>
-#include 	<stdio.h>
-#include 	<unistd.h>
-#include 	<sys/time.h>
-
-#include 	"Object.h"
-#include 	"Msgbox.h"
-#include	"Graphic.h"
-#include 	"Label.h"
-#include	"Language.h"
-#include 	"Algorithm.h"
-#include 	"Logic.h"
-
-Msgbox::Msgbox (int x,int y,int width,int heigh,const char *text,MSGBOXTYPE type)
-{
-	m_Type     = type;
-	m_X        = x;
-	m_Y        = y;
-	m_Width    = width;
-	m_Heigh    = heigh;
-	m_FontType = 16;
-
-	m_Text     = NULL;
-	m_Text     = new char[strlen(text)+1];
-	strcpy(m_Text,text);
-
-	m_Content  = NULL;
-	m_Content  = new char[strlen("--")+1];
-	strcpy(m_Content,"--");
-	
-	m_Transparece = 255;
-
-}  /* -----  end of method Msgbox::Msgbox  (constructor)  ----- */
-
-Msgbox::~Msgbox ()
-{
-	if ( m_Text == NULL )
-	{
-		delete[] m_Text;
-		m_Text = NULL;
-	}
-	if ( m_Content == NULL )
-	{
-		delete[] m_Content;
-		m_Content = NULL;
-	}
-}  /* -----  end of method Msgbox::Msgbox  (destructor)  ----- */
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Text
- *  Description:  Set the Msgbox showing text 
- * =====================================================================================
- */
-void Msgbox::Set_Text(const char *text)
-{
-	if ( strlen(text) == 0 ) return;
-	delete[] m_Text;
-	m_Text = new char[strlen(text)+1];
-	strcpy(m_Text,text);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Content
- *  Description:  Set the Content message 
- * =====================================================================================
- */
-void Msgbox::Set_Content(const char *text)
-{
-	if ( strlen(text) == 0 ) return;
-	delete[] m_Content;
-	m_Content = new char[strlen(text)+1];
-	strcpy(m_Content,text);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Color
- *  Description:  Set the Msgbox's color 
- * =====================================================================================
- */
-void Msgbox::Set_Color(MSG_COLORTYPE ct,short color)
-{
-	if 	( ct == MSG_COLORTYPE_FG )
-		m_FGColor = color;
-	else if ( ct == MSG_COLORTYPE_BG )
-		m_BGColor = color;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_FontType
- *  Description:  Set the font type 
- * =====================================================================================
- */
-void Msgbox::Set_FontType(int value)
-{
-	m_FontType = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Showme
- *  Description:  Very important function, draw msgbox and deal with the key event 
- * =====================================================================================
- */
-bool Msgbox::Showme(Graphic &g)
-{
-	bool revalue = false;
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1)];
-	g.Load_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,mem); 	   /* save the screen graphic buffer */
-
-	g.Switch_Screen();
-
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
-	COLORTYPE co_sa;
-	co_sa = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
-	g.Setcolor(g.RGB24_16(0x000000));
-	g.DrawRect(m_X+2,m_Y+2,m_Width-4,m_Heigh-4);
-	g.DrawRect(m_X+3,m_Y+3,m_Width-6,m_Heigh-6);
-	g.Setcolor(m_FGColor);
-	g.DrawRect(m_X+4,m_Y+4,m_Width-8,m_Heigh-8);
-	g.Setcolor(co_sa);
-
-	g.Switch_Screen();
-	int t = g.Get_Transparce();
-	g.Set_Transparce(m_Transparece);
-	g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	g.Set_Transparce(t);
-
-	revalue = Loopwindow(g);
-Exit:
-	g.Restore_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,mem); /* restore the graphic buffer */
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-	delete[] mem;                                                 /* release the buffer */
-	mem = NULL;
-	return revalue;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function, do anthing for this class 
- * =====================================================================================
- */
-bool Msgbox::Loopwindow(Graphic& g)
-{
-	bool revalue = false;
-	Language* pl = Language::Instance();
-	Algorithm* alg = Algorithm::Instance();
-	Logic* lo       = Logic::Instance();
-	int cent_x   = m_X + ( m_Width>>1 );
-	int cent_y   = m_Y + ( m_Heigh>>1 );
-	int ft       = m_FontType;
-	int key      = 0;
-
-	if 	( m_Type == MSG_OK )
-	{
-		Label *button	= new Label(cent_x-2*ft-4,cent_y+(ft>>1)-2,4*ft,ft+8);
-		button->Set_Text(pl->GetText(COMFIRM));
-		button->Set_Font_Size(16);
-		button->Set_Label_Type(Label::LA_3D);
-		button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
-		lab->Set_Label_Type(Label::LA_NONE);
-		lab->Set_Text(m_Text);
-		lab->Set_Font_Size(18);
-		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
-		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
-		lab->Drawme(g);
-		button->Drawme(g);
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		while(key!= KEY_ENTER && key!= KEY_ESC)                    /*there may be much start method */
-		{
-			key = lo->Get_Key();
-		}
-		button->Set_Focus(true);
-		button->Drawme(g);
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		alg->MDelay(100);
-
-		delete button;
-		button = NULL;
-		delete lab;
-		lab = NULL;
-		revalue = true;
-	}
-	else if ( m_Type == MSG_OKCANCEL )
-	{
-		g.Switch_Screen();
-
-		Label *button1	= new Label(cent_x-(ft<<2)-(ft<<1),cent_y+(ft>>1)-2,4*ft,ft+8);
-		Label *button2	= new Label(cent_x+(ft<<1),cent_y+(ft>>1)-2,4*ft,ft+8);
-		button1->Set_Label_Type(Label::LA_3D);
-		button2->Set_Label_Type(Label::LA_3D);
-		button1->Set_Font_Size(16);
-		button2->Set_Font_Size(16);
-		button2->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		button2->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		button2->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		button2->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		button1->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		button1->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		button1->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		button1->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-		button1->Set_Text(pl->GetText(COMFIRM));
-		button2->Set_Text(pl->GetText(CANCEL));
-
-		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
-		lab->Set_Label_Type(Label::LA_NONE);
-		lab->Set_Text(m_Text);
-		lab->Set_Font_Size(18);
-		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
-		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
-		lab->Drawme(g);
-		button1->Drawme(g);
-		button2->Drawme(g);
-	
-		g.Switch_Screen();
-		int t = g.Get_Transparce();
-		g.Set_Transparce(m_Transparece);
-		g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-		g.Set_Transparce(t);
-
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		while(key!= KEY_ENTER && key!= KEY_ESC)               	   /*there may be much start method */
-		{
-			key = lo->Get_Key();
-		}
-
-		g.Switch_Screen();
-
-		if ( key == KEY_ENTER )  { button1->Set_Focus(true); button1->Drawme(g); revalue = true;}
-		else if ( key == KEY_ESC ) { button2->Set_Focus(true); button2->Drawme(g); revalue = false;}
-
-		g.Switch_Screen();
-		t = g.Get_Transparce();
-		g.Set_Transparce(m_Transparece);
-		g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-		g.Set_Transparce(t);
-
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		alg->MDelay(100);
-
-		delete button1;
-		button1 = NULL;
-		delete button2;
-		button2 = NULL;
-		delete lab;
-		lab = NULL;
-	}
-	else if ( m_Type == MSG_AUTO )			 	           /* auto close the windows  */
-	{
-		int tick = 0;
-		Label *button	= new Label(cent_x-2*ft-4,cent_y+(ft>>1)-2,4*ft,ft+8);
-		button->Set_Text(pl->GetText(COMFIRM));
-		button->Set_Font_Size(16);
-		button->Set_Label_Type(Label::LA_3D);
-		button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
-		lab->Set_Label_Type(Label::LA_NONE);
-		lab->Set_Text(m_Text);
-		lab->Set_Font_Size(16);
-		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
-		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
-
-		lab->Drawme(g);
-		button->Drawme(g);
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		while( key!= KEY_ENTER && key!= KEY_ESC && tick<50 )   /*there may be much start method */
-		{
-			key = lo->Get_Key();
-			alg->MDelay(100);
-			tick ++;
-		}
-		button->Set_Focus(true);
-		button->Drawme(g);
-#ifdef X86
-		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-		alg->MDelay(100);
-		delete button;
-		button = NULL;
-		delete lab;
-		lab = NULL;
-		revalue = true;
-	}
-	return revalue;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Transparce
- *  Description:  
- * =====================================================================================
- */
-void Msgbox::Set_Transparce(int v)
-{
-	m_Transparece = v;
-}
-
-PasswdMsgbox::PasswdMsgbox (int x,int y,int width,int heigh,const char *text) :
-	Msgbox(x,y,width,heigh,text,MSG_OK) 
-{
-	m_Status = PWCANCEL;
-}
-
-PasswdMsgbox::~PasswdMsgbox()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Main loop function,very important function 
- * =====================================================================================
- */
-bool PasswdMsgbox::Loopwindow(Graphic &g)
-{
-	bool revalue    = false;
-	Language* pl    = Language::Instance();
-	Algorithm* alg  = Algorithm::Instance();
-	Logic* lo       = Logic::Instance();
-	int cent_x      = m_X + ( m_Width>>1 );
-	int cent_y      = m_Y + ( m_Heigh>>1 );
-	int ft          = m_FontType;
-	int key         = 0;
-
-	char pa[4];
-	int index       = 0;
-
-	Label *button1	= new Label(cent_x-(ft<<2)-(ft<<1),cent_y+(ft>>1)+10,4*ft,ft+8);
-	Label *button2	= new Label(cent_x+(ft<<1),cent_y+(ft>>1)+10,4*ft,ft+8);
-
-	button1->Set_Text(pl->GetText(COMFIRM));
-	button2->Set_Text(pl->GetText(CANCEL));
-
-	button1->Set_Label_Type(Label::LA_3D);
-	button2->Set_Label_Type(Label::LA_3D);
-	button1->Set_Font_Size(16);
-	button2->Set_Font_Size(16);
-
-	button2->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	button2->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	button2->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	button2->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	button1->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	button1->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	button1->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	button1->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-
-	Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-20,ft*(strlen(m_Text)>>1)+4,ft+4);
-	lab->Set_Text(m_Text);
-	lab->Set_Label_Type(Label::LA_NONE);
-
-	lab->Set_Font_Size(18);
-	lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
-	lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
-	lab->Drawme(g);
-	button1->Drawme(g);
-	button2->Drawme(g);
-
-#ifdef X86
-	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-	while( key!= KEY_ENTER && key!= KEY_ESC )
-	{
-		if ( index == 5 ) { revalue = false; m_Status = PWFAILTURE; goto Exit; }
-
-		if ( key != 0 && key!= KEY_ENTER && key!= KEY_ESC ) 
-		{
-			pa[index] = key;
-			index ++;
-			Show_Each_Password(g,index);
-		}
-
-		key = lo->Get_Key();
-		alg->MDelay(50);
-	}
-
-	if      ( key == KEY_ENTER )
-	{
-		button1->Set_Focus(true); 
-		button1->Drawme(g); 
-		if ( pa[0] == KEY_F2 && pa[1] == KEY_F5 && pa[2] == KEY_F4 && pa[3] == KEY_F3 )
-		{
-			m_Status = PWSUCCESS;
-			revalue = true;
-		}
-		else 
-		{
-			m_Status = PWFAILTURE;
-			revalue = false;
-		}
-	}
-	else if ( key == KEY_ESC   ) { button2->Set_Focus(true); button2->Drawme(g); m_Status = PWCANCEL; revalue = false;}
-
-#ifdef X86
-	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-Exit:		
-	alg->MDelay(100);
-	delete button1;
-	button1 = NULL;
-	delete button2;
-	button2 = NULL;
-	delete lab;
-	lab = NULL;
-	return revalue;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Each_Password
- *  Description:  Show Each passowrd key 
- *                MAX Count is 4
- * =====================================================================================
- */
-void PasswdMsgbox::Show_Each_Password(Graphic &g,int index)
-{
-	int cent_x = m_X + ( m_Width>>1 );
-	int cent_y = m_Y + ( m_Heigh>>1 );
-	Label *lab = new Label(cent_x-60+index*20,cent_y-8,20,18);
-
-	lab->Set_Text("*");
-	lab->Set_Label_Type(Label::LA_NONE);
-
-	lab->Set_Font_Size(16);
-	lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
-	lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
-	lab->Drawme(g);
-	delete lab;
-	lab = NULL;
-#ifdef X86
-	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
-#endif
-}
diff --git a/src/EVA11/Msgbox.h b/src/EVA11/Msgbox.h
deleted file mode 100644
index 72c7866..0000000
--- a/src/EVA11/Msgbox.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Msgbox.h
- *
- *    Description:  Declear of Msgbox class
- *
- *        Version:  1.0
- *        Created:  2012年06月06日 16时25分54秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _MSGBOX_INC
-#define  _MSGBOX_INC
-
-class Graphic;
-class Msgbox
-{
-	public:
-		enum MSGBOXTYPE 
-		{
-			MSG_OK,
-			MSG_OKCANCEL,
-			MSG_AUTO,
-		};
-		typedef enum MSGBOXTYPE MSGBOXTYPE;
-
-		enum MSG_COLORTYPE
-		{
-			MSG_COLORTYPE_FG,
-			MSG_COLORTYPE_BG,
-		};
-		typedef enum MSG_COLORTYPE MSG_COLORTYPE;
-
-		Msgbox (int x,int y,int width,int heigh,const char *text,MSGBOXTYPE type);
-		~Msgbox ();
-		
-		bool Showme(Graphic &);
-
-		void Set_Text(const char*);
-		void Set_Content(const char *text);
-		void Set_Color(MSG_COLORTYPE ct,short color);
-		void Set_FontType(int value);
-
-		void Set_Transparce(int);
-	protected:
-		virtual bool Loopwindow(Graphic &);
-	protected:
-		MSGBOXTYPE  			m_Type;
-		short       			m_X;
-		short       			m_Y;
-		short       			m_Width;
-		short       			m_Heigh;
-		int         			m_FontType;
-
-		char       		       *m_Text;
-		char       		       *m_Content;
-		short   			m_BGColor;
-		short				m_FGColor;
-		int				m_Transparece;
-	private:
-};
-
-class PasswdMsgbox : public Msgbox
-{
-	public:
-		enum STATUS 
-		{
-			PWSUCCESS ,
-			PWFAILTURE,
-			PWCANCEL  , 
-		};
-		typedef enum STATUS STATUS;
-
-		PasswdMsgbox (int x,int y,int width,int heigh,const char *text);
-		~PasswdMsgbox ();
-
-		inline STATUS Get_Status() { return m_Status; }
-	protected:
-		virtual bool Loopwindow(Graphic &);
-
-	private:
-		void Show_Each_Password(Graphic &,int index);
-		STATUS 			  	m_Status;
-};
-#endif
diff --git a/src/EVA11/Netclient.cpp b/src/EVA11/Netclient.cpp
deleted file mode 100644
index 11ef954..0000000
--- a/src/EVA11/Netclient.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Netclient.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2011年10月19日 15时17分13秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#include	"Netclient.h"
-
-Netclient::Netclient ()
-{
-	m_Port = 5300;
-	m_ServerIP = new CHAR[100];
-	m_ClientIP = new CHAR[100];
-
-	sprintf ( m_ServerIP,"%s","192.168.1.1" );
-	Getip(m_ClientIP);
-	printf ( "%s\n",m_ClientIP );
-
-	m_tv.tv_sec  = 0;
-	m_tv.tv_usec = 1;
-}
-
-Netclient::~Netclient ()
-{
-	delete[] m_ServerIP;
-	m_ServerIP = NULL;
-	delete[] m_ClientIP;
-	m_ClientIP = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Open_Client
- *  Description:  
- * =====================================================================================
- */
-BOOL Netclient::Open_Socket()
-{
-	m_Socketfd = socket(AF_INET,SOCK_STREAM,0);
-	if ( m_Socketfd == -1 ) { perror("Can't Init a socket!"); return false; }
-
-	bzero(&m_Locale,sizeof(m_Locale));
-	m_Locale.sin_family = AF_INET;           /* IPV4 version */
-	m_Locale.sin_port = htons(m_Port);
-	if ( inet_aton(m_ClientIP,(struct in_addr *)&m_Locale.sin_addr.s_addr) == 0 )
-	{
-		perror("Can't Init a local socket!"); 
-		close(m_Socketfd);	
-		return false;
-	}
-
-	bzero(&m_Remote,sizeof(m_Remote));
-	m_Remote.sin_family = AF_INET;
-	m_Remote.sin_port = htons(m_Port);       /* Remote port */
-	if ( inet_aton(m_ServerIP,(struct in_addr *)&m_Remote.sin_addr.s_addr) == 0 )
-	{
-		perror("Can't Init a remote socket!"); 
-		close(m_Socketfd);	
-		return false;
-	}
-
-	INT32 on = 1;                            /* Enable the Port can't be reused */
-	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on)) == -1 )
-	{
-		perror("Set Sockopt error");
-		close(m_Socketfd);
-		return false;
-	}
-
-	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_RCVTIMEO,(CHAR *)&m_tv,sizeof(struct timeval)) == -1 )
-	{
-		perror("Set Sockopt error 1");
-		close(m_Socketfd);
-		return false;
-	}
-
-	int rcvbuf = 1024*128;
-	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_RCVBUF,(const char *)&rcvbuf,sizeof(int) ) == -1 ) 
-	{
-		perror("Set Sockopt error 2");
-		close(m_Socketfd);
-		return false;
-	}
-
-	int sndbuf = 1024*128;
-	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_SNDBUF,(const char *)&sndbuf,sizeof(int) ) == -1 ) 
-	{
-		perror("Set Sockopt error 3");
-		close(m_Socketfd);
-		return false;
-	}
-
-	int flags;
-	flags = fcntl(m_Socketfd,F_GETFL,0);
-	fcntl(m_Socketfd,F_SETFL,flags|O_NONBLOCK);
-
-//	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_SNDTIMEO,(CHAR *)&m_tv,sizeof(struct timeval)) == -1 )
-//	{
-//		perror("Set Sockopt error 2");
-//		close(m_Socketfd);
-//		return false;
-//	}
-
-//	if ( bind(m_Socketfd,(struct sockaddr *)&m_Locale,sizeof(struct sockaddr) ) == -1 )
-//	{
-//		perror("Can't bind");
-//		close(m_Socketfd);
-//		return false;
-//	}
-
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Close_Socket
- *  Description:  
- * =====================================================================================
- */
-void Netclient::Close_Socket()
-{
-	close(m_Socketfd);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Connect_Server
- *  Description:   
- * =====================================================================================
- */
-BOOL Netclient::Connect_Server()
-{
-	BOOL flag = false;
-	if ( connect(m_Socketfd,(struct sockaddr*)&m_Remote,sizeof(m_Remote)) != 0 )
-	{
-		flag = false;
-	}
-	else
-	{
-		flag = true;
-	}
-	return flag;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Remote_IP
- *  Description:  
- * =====================================================================================
- */
-const CHAR* Netclient::Get_Remote_IP()
-{
-	return inet_ntoa(m_Remote.sin_addr);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Poll_Socket_Status
- *  Description:  
- * =====================================================================================
- */
-Netclient::NETSTA Netclient::Poll_Socket_Status()
-{
-	FD_ZERO(&m_RDfd);
-	FD_SET(m_Socketfd,&m_RDfd);
-
-	if ( select(m_Socketfd+1,&m_RDfd,NULL,NULL,&m_tv) <= 0 )
-		return Netclient::NETNONE;
-	else
-	{
-		if ( !FD_ISSET(m_Socketfd,&m_RDfd) )
-		{
-			return Netclient::NETNONE;
-		}
-		else
-		{
-			return Netclient::DATAIN;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  Get the Data from socket 
- * =====================================================================================
- */
-INT32 Netclient::Get_Data(CHAR* data,INT32 len)
-{
-	return recv(m_Socketfd,data,len,0);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Send_Data
- *  Description:  Send Data into Net port 
- * =====================================================================================
- */
-bool Netclient::Send_Data(CHAR* data,INT32 len)
-{
-	FD_ZERO(&m_WRfd);
-	FD_SET(m_Socketfd,&m_WRfd);
-
-	if ( select(m_Socketfd+1,NULL,&m_WRfd,NULL,&m_tv) <= 0 )
-		return false; 
-	else
-	{
-		if ( !FD_ISSET(m_Socketfd,&m_WRfd) )
-		{
-			printf ( "test\n" );
-			return false; 
-		}
-		else
-		{
-			if ( send(m_Socketfd,data,len,0) != len )
-			{
-				printf ( "send data length != wanted send data length\n" );
-				return false;
-			}
-			else
-				return true;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Getip
- *  Description:  
- * =====================================================================================
- */
-void Netclient::Getip(char *ip)
-{
-	int fd;
-	struct ifreq ifr;
-	struct sockaddr_in *sin;
-	fd = socket(AF_INET,SOCK_DGRAM,0);
-	memset(&ifr,0,sizeof(ifr));
-	strcpy(ifr.ifr_name,ETH_NAME);
-	ioctl(fd,SIOCGIFADDR,&ifr);
-	sin = (struct sockaddr_in*)&ifr.ifr_addr;
-	strcpy((char *)ip,(char *)inet_ntoa(sin->sin_addr));
-	close(fd);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Getmac
- *  Description:  
- * =====================================================================================
- */
-void Netclient::Getmac(char *mac)
-{
-	int i;
-	int fd;
-	unsigned char addr[6];
-	struct ifreq ifr;
-	struct sockaddr_in *sin;
-	
-	fd = socket(AF_INET,SOCK_DGRAM,0);
-	memset(&ifr,0,sizeof(ifr));
-	strcpy(ifr.ifr_name,ETH_NAME);
-	ioctl(fd,SIOCGIFHWADDR,&ifr);
-	sin = (struct sockaddr_in*)&ifr.ifr_addr;
-	memset(addr,0,6);
-	memcpy(addr,ifr.ifr_hwaddr.sa_data,6);
-	sprintf((char *)mac,"%02x:%02x:%02x:%02x:%02x:%02x",
-			addr[0],addr[1],addr[2],addr[3],addr[4],addr[5]);
-	close(fd);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Test_Ether_Connect
- *  Description:  Test the Ether Connect is OK
- * =====================================================================================
- */
-bool Netclient::Test_Ether_Connect()
-{
-	int fd = -1,err = 0;
-	struct ifreq ifr;
-	memset(&ifr, 0, sizeof(ifr));  
-	strcpy(ifr.ifr_name, ETH_NAME);  
-
-	fd = socket(AF_INET, SOCK_DGRAM, 0);  
-	if 	( fd < 0 )
-	{
-		perror("Cannot get control socket");  
-		return false;  
-	}
-
-	if 	( ioctl(fd, SIOCGIFFLAGS, &ifr) < 0 )
-	{
-		perror("Cannot get socket flags");  
-		return false;
-	}
-
-	if	( ifr.ifr_flags & IFF_RUNNING )
-		return true;
-	else 
-	{
-		perror("socket not running status");  
-		return false;
-	}
-}
diff --git a/src/EVA11/Netclient.h b/src/EVA11/Netclient.h
deleted file mode 100644
index 1e62da4..0000000
--- a/src/EVA11/Netclient.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Netclient.h
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2011年10月19日 15时14分10秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  _NETCLIENT_INC
-#define  _NETCLIENT_INC
-
-/*
- * =====================================================================================
- *        Class:  Netclient
- *  Description:  
- * =====================================================================================
- */
-/*-----------------------------------------------------------------------------
- *  Net program used head file
- *-----------------------------------------------------------------------------*/
-#include 	<sys/ioctl.h>
-#include 	<unistd.h>
-#include 	<fcntl.h>
-#include 	<sys/stat.h>
-#include 	<sys/mman.h>
-#include        <stdio.h>
-#include        <errno.h>
-#include        <strings.h>
-#include        <stdlib.h>
-#include	<cstdlib>
-#include	<cstdio>
-#include 	<sys/types.h>
-#include        <sys/socket.h>
-#include        <netinet/in.h>
-#include        <arpa/inet.h>
-#include        <signal.h>
-#include 	<string.h>
-#include 	<net/if.h>
-
-#include 	"main.h"
-
-#define 	ETH_NAME "eth0"
-class Netclient
-{
-	public:
-		enum NETSTA { NETNONE  = 0,
-			      DATAIN   = 1 };
-		Netclient ();                             /* constructor */
-		~Netclient ();                            /* destructor */
-		BOOL Open_Socket();
-		void Close_Socket();
-		BOOL Connect_Server();
-		const CHAR* Get_Remote_IP();
-		NETSTA Poll_Socket_Status();
-		INT32 Get_Data(CHAR* data,INT32 len);
-		bool Send_Data(CHAR* data,INT32 len);
-		void Getip(char *ip);
-		void Getmac(char *mac);
-
-		bool Test_Ether_Connect();
-	protected:
-
-	private:
-		INT32			m_Port;
-		CHAR*			m_ServerIP;
-		CHAR*			m_ClientIP;
-		INT32			m_Socketfd;
-		struct sockaddr_in	m_Remote;
-		struct sockaddr_in	m_Locale;
-		struct timeval          m_tv;
-		fd_set			m_WRfd;
-		fd_set			m_RDfd;
-}; /* -----  end of class Netclient  ----- */
-#endif   /* ----- #ifndef _NETCLIENT_INC  ----- */
diff --git a/src/EVA11/OBJS/ASMS/Asm_Fun_Sets.s.o b/src/EVA11/OBJS/ASMS/Asm_Fun_Sets.s.o
deleted file mode 100644
index 28bcebcef3f8de47c9d1bafc6ffe609b38c56a01..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1108
zcma)5&ubG=5T3W2w(F1L){BD0rcfbb^K5HC^cISSVpD=YKtZsZWTC+%E4#0tCwuVV
zQM`-&6Z``__$Tz}MMzTudJ{qLR=?SOv&Jgugvs~K%=hMPW+%^Ytlv~hk(i<q{fdYh
zSx~5?f)bq|kETED?$gKe7ezY*@&^YgZoT<@{_yg?)LtoP;1G02@`ZQnLvOD>^owst
z<iCdRj85*|8j6mukshL*rMXe)?;iZ2t*x$JFP2(ylq4pKy5)^pd0Ai8D;J9ueMPTO
z^$fZNVbJW5ng*Sy+@(p!Q>2q;Jrgv6CeCn6SR8h>37;C$?Z5=2n@K{t74>>yAGv;H
zLS5UqS58dOdQ7@{yRHLc;!bnhgb6?Vf7%>$JlaXC=lQ<0oS|U(Ip8tN85U6}*&Lr|
zod>@F=h%g_z0V;3&R!$YC1hCtFWnL}a)z65zj-Fsq;?Ila4vnabpffZA%Q!eNS<|P
zB>;+U23($v%irM-m{=1Xqa#V6heKb1$F1{Rd^pc;yx$K5%gBjIKZ*Z_ZvJ#x)%~p_
z_b(h#sPw%&%$upSzBv}>6vWN9Aj`TmF<wS}3ZKko0jJUJ6p%U3kYnC--XY!%j^}|q
z1NIsEcF6fnxYTJOpoKP7lis6hJHz^RH;o%n2djRk6*o+rCf52LgQMwPe4clM@xDd=
LoeutAFKql1i>iu(

diff --git a/src/EVA11/OBJS/ASMS/README b/src/EVA11/OBJS/ASMS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/OBJS/JPGS/README b/src/EVA11/OBJS/JPGS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/OBJS/README b/src/EVA11/OBJS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/OZKPanel.cpp b/src/EVA11/OZKPanel.cpp
deleted file mode 100644
index 9a15c8c..0000000
--- a/src/EVA11/OZKPanel.cpp
+++ /dev/null
@@ -1,603 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  OZKPanel.cpp
- *
- *    Description:  implementation of Octo-Panel
- *
- *        Version:  1.0
- *        Created:  2013年03月13日 15时15分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	"Object.h"
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Global.h"
-
-#include 	"DataRepo.h"
-#include 	"Bufferbar.h"
-#include 	"Device.h"
-
-#include 	"BasePanel.h"
-#include 	"OZKPanel.h"
-
-#include 	"Label.h"
-
-#include 	"Basescreen.h"
-#include 	"ZScreen.h"
-
-#include 	"FreeType.h"
-
-#include 	"LimitManage.h"
-
-OZKPanel::OZKPanel (int x,int y,int width,int heigh)
-	: BasePanel(x,y,width,heigh)
-{
-}
-
-OZKPanel::~OZKPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void OZKPanel::Init_GUI(Graphic& g)
-{
-	Global *gp = Global::Instance();
-	int width  = 132;
-	int height = 150 + 10 + 15 + 5 + 2;
-
-	m_Zscreen[0] = new Zscreen(2,43,width,height);
-	m_LimitManage[0] = new(std::nothrow) LimitManage(2,43,width,height);
-
-	m_Zscreen[1] = new Zscreen(2+width,43,width,height);
-	m_LimitManage[1] = new(std::nothrow) LimitManage(2+width,43,width,height);
-
-	m_Zscreen[2] = new Zscreen(2+2*width,43,width,height);
-	m_LimitManage[2] = new(std::nothrow) LimitManage(2+2*width,43,width,height);
-
-	m_Zscreen[3] = new Zscreen(2+3*width,43,width,height);
-	m_LimitManage[3] = new(std::nothrow) LimitManage(2+3*width,43,width,height);
-
-	m_Zscreen[4] = new Zscreen(2,44+217,width,height);
-	m_LimitManage[4] = new(std::nothrow) LimitManage(2,44+217,width,height);
-
-	m_Zscreen[5] = new Zscreen(2+width,44+217,width,height);
-	m_LimitManage[5] = new(std::nothrow) LimitManage(2+width,44+217,width,height);
-
-	m_Zscreen[6] = new Zscreen(2+2*width,44+217,width,height);
-	m_LimitManage[6] = new(std::nothrow) LimitManage(2+2*width,44+217,width,height);
-
-	m_Zscreen[7] = new Zscreen(2+3*width,44+217,width,height);
-	m_LimitManage[7] = new(std::nothrow) LimitManage(2+3*width,44+217,width,height);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_LimitManage[i]->Init_Alarm_Sets(g);
-
-	for (int i=0;i<8;i++ )
-		m_Zscreen[i]->Set_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-		m_Zscreen[i]->Set_ID(i+1);
-
-		if 	( gp->ODrawMode == 0 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
-		else if ( gp->ODrawMode == 1 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
-		else if ( gp->ODrawMode == 2 )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::SPEC);
-	}
-
-	m_labMsg[0] = new Label(1,8,width,18);
-	m_labMsg[1] = new Label(1+width,8,width,18);
-	m_labMsg[2] = new Label(1+2*width,8,width,18);
-	m_labMsg[3] = new Label(1+3*width,8,width,18);
-
-	m_labValue[0] = new Label(1,25,width,18);
-	m_labValue[1] = new Label(1+width,25,width,18);
-	m_labValue[2] = new Label(1+2*width,25,width,18);
-	m_labValue[3] = new Label(1+3*width,25,width,18);
-
-	int laby = 226;
-	m_labMsg[4] = new Label(1,laby,width,18);
-	m_labMsg[5] = new Label(1+width,laby,width,18);
-	m_labMsg[6] = new Label(1+2*width,laby,width,18);
-	m_labMsg[7] = new Label(1+3*width,laby,width,18);
-
-	m_labValue[4] = new Label(1,laby+17,width,18);
-	m_labValue[5] = new Label(1+width,laby+17,width,18);
-	m_labValue[6] = new Label(1+2*width,laby+17,width,18);
-	m_labValue[7] = new Label(1+3*width,laby+17,width,18);
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_labMsg[i]->Set_Label_Type(Label::LA_THIN);
-		m_labValue[i]->Set_Label_Type(Label::LA_THIN);
-		m_labMsg[i]->Set_Font_Size(14);
-		m_labValue[i]->Set_Font_Size(16);
-		m_labMsg[i]->Set_Text(" ");
-		m_labValue[i]->Set_Text(" ");
-
-		m_labMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_labMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-
-		m_labValue[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-		m_labValue[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-		m_labValue[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_labValue[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_labValue[i]->Set_Focus(true);
-	}
-
-	m_Bufbar = new Bufferbar(2,2,532,6);
-	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
-	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
-	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
-
-	m_DataProcess = new OZKDataProcess;
-
-	gp->bONeedResetAlarmArea = true;
-	Load_Alarm_Para();
-
-	m_gp->bQuadSrcPause = false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void OZKPanel::Destroy_GUI()
-{
-	if ( m_DataProcess != NULL )
-	{
-		delete m_DataProcess;
-		m_DataProcess = NULL;
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		if 	( m_Zscreen[i] != NULL )
-		{
-			delete m_Zscreen[i];
-			m_Zscreen[i] = NULL;
-		}
-
-		if 	( m_labMsg[i] != NULL )
-		{
-			delete m_labMsg[i];
-			m_labMsg[i] = NULL;
-		}
-
-		if 	( m_labValue[i] != NULL )
-		{
-			delete m_labValue[i];
-			m_labValue[i] = NULL;
-		}
-	}
-
-	if ( m_Bufbar != NULL )
-	{
-		delete m_Bufbar;
-		m_Bufbar = NULL;
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_LimitManage[i]->Destroy_Alarm_Sets();
-		if ( m_LimitManage[i] != NULL )
-		{
-			delete m_LimitManage[i];
-			m_LimitManage[i] = NULL;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void OZKPanel::Drawme(Graphic& g,bool flag)
-{
-	DataRepo *datarepo = DataRepo::Instance();
-
-	if 	( flag == true )
-		g.Switch_Screen();
-	Refresh_Gain_Rotation();
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Drawme(g,false);
-		m_labMsg[i]->Drawme(g,false);
-		m_labValue[i]->Drawme(g,false);
-		m_LimitManage[i]->Draw_Alarm_Sets(g,false);
-	}
-
-	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
-
-	if 	( flag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  important function, deal with data
- * =====================================================================================
- */
-int OZKPanel::Loop_Panel(Graphic& g)
-{
-	if 	( m_gp->bQuadSrcPause == true )
-		return 0;
-
-	m_DataProcess->Data_Process();
-	m_DataProcess->Get_Data(m_RawBuf);
-
-	int x,y;
-
-	if 	( m_gp->ODrawMode == 2 )
-	{
-		for ( int i=0;i<8;i++ )
-		{
-			x = m_RawBuf[i<<1];
-			y = m_RawBuf[(i<<1)+1];
-
-			m_Zscreen[i]->Map_XY_To_Scr(x,y);
-
-			if ( m_LimitManage[i]->Is_In_Alarm(x,y) != 0xff )
-				m_Zscreen[i]->Set_Alarm_Status(true);
-			else 
-				m_Zscreen[i]->Set_Alarm_Status(false);
-
-			m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[i<<1],m_RawBuf[(i<<1)+1]);
-		}
-	}
-	else
-	{
-		for ( int i=0;i<8;i++ )
-		{
-			m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[i<<1],m_RawBuf[(i<<1)+1]);
-			m_Zscreen[i]->Get_SX_SY(x,y);
-			
-			if ( i == 0 && m_LimitManage[i]->Is_In_Alarm(x,y) != 0xff ) 
-			{
-	//			printf ( "%d\n",i );
-			}
-		}
-	}
-
-
-	m_Bufbar->Save_Bytes_Number(g,8<<2);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void OZKPanel::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-	font->Text(x+30,y+110,pl->GetText(HELPB1F3_O));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Panel
- *  Description:  Switch panel call this function 
- * =====================================================================================
- */
-void OZKPanel::Switch_Panel()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-
-	for ( int ch=0;ch<16;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 1;			// ECT
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int ch=16;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 0;		       // CLOSE
-		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	device->Write_Para_Driver(m_gp->Driver);
-	device->Write_Para_Offset(m_gp->Offset);
-	device->Write_Para_SignalWave(0);
-
-	device->Transfer_ECT_Parameters();
-
-	m_DataProcess->Trigger_Balacne_Process();       // very Important
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_ZKScreen
- *  Description:  Clean the ZKScreen 
- * =====================================================================================
- */
-void OZKPanel::Clean_ZKScreen(Graphic& g)
-{
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Drawme(g,true);
-		m_LimitManage[i]->Draw_Alarm_Sets(g,true);
-		m_labMsg[i]->Drawme(g,true);
-		m_labValue[i]->Drawme(g,true);
-	}
-}
-
-int OZKPanel::Key_NL2_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
-}
-
-int OZKPanel::Key_NR2_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
-}
-
-int OZKPanel::Key_NL3_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
-}
-
-int OZKPanel::Key_NR3_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
-}
-int OZKPanel::Key_NL4_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_labMsg[i]->Drawme(g,true);
-}
-
-int OZKPanel::Key_NR4_Fun(Graphic& g,int sub)
-{
-	Refresh_Gain_Rotation();
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_labMsg[i]->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_FX_Fun
- *  Description:  Shot Functions 
- * =====================================================================================
- */
-int OZKPanel::Key_F2_Fun(Graphic& g)
-{
-	if 	( m_gp->bQuadSrcPause == false )
-		Clean_ZKScreen(g);
-}
-
-int OZKPanel::Key_F3_Fun(Graphic& g)
-{
-	if 	( m_gp->ODrawMode == 0 )
-	{
-		m_gp->ODrawMode = 1;
-
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
-	}
-	else if ( m_gp->ODrawMode == 1 )
-	{
-		m_gp->ODrawMode = 2;
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::SPEC);
-	}
-	else if ( m_gp->ODrawMode == 2 )
-	{
-		m_gp->ODrawMode = 0;
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
-	}
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-		m_Zscreen[i]->Reset_Trace();
-}
-
-int OZKPanel::Key_F4_Fun(Graphic& g)
-{
-	if 	( m_gp->bQuadSrcPause == false )
-		m_DataProcess->Trigger_Balacne_Process();
-}
-
-int OZKPanel::Key_Enter_Fun(Graphic& g)
-{
-	m_gp->bQuadSrcPause = false;
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		m_Zscreen[i]->Drawme(g,true);
-		m_LimitManage[i]->Draw_Alarm_Sets(g,true);
-	}
-}
-
-/* --------------------------------------------------------------------- */
-/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
-/* --------------------------------------------------------------------- */
-
-int OZKPanel::Para_NL1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::LEFT,3);
-			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
-		}
-	}
-}
-int OZKPanel::Para_NR1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
-		}
-	}
-}
-int OZKPanel::Para_NL2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::UP,3);
-			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
-		}
-	}
-}
-int OZKPanel::Para_NR2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-		{
-			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::DOWN,3);
-			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm Parameters from Global 
- *                When Load Para from device call this function
- * =====================================================================================
- */
-void OZKPanel::Load_Alarm_Para()
-{
-	Global* gp = Global::Instance();
-	if 	( gp->bONeedResetAlarmArea == true )
-	{
-		for ( int i=0;i<m_cMAXScreenCount;i++ )
-			m_LimitManage[i]->Load_Alarm_Para(gp->OAlarmPara[i]);
-		gp->bONeedResetAlarmArea = false;
-	}
-}
-
-/* --------------------------------------------------------------------- */
-/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
-/* --------------------------------------------------------------------- */
-
-int OZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		for (int i=0;i<m_cMAXScreenCount;i++ )
-			m_LimitManage[i]->Adj_P1(-(m_gp->MultiKey*2 + 5),gp->OAlarmPara[i]);
-
-		Drawme(g,true);
-		gp->bONeedResetAlarmArea = true;
-	}
-}
-int OZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		for (int i=0;i<m_cMAXScreenCount;i++ )
-			m_LimitManage[i]->Adj_P1((m_gp->MultiKey*2 + 5),gp->OAlarmPara[i]);
-
-		Drawme(g,true);
-		gp->bONeedResetAlarmArea = true;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Gain_Rotation
- *  Description:  Refresh the Gain and ROtation's value 
- * =====================================================================================
- */
-void OZKPanel::Refresh_Gain_Rotation()
-{
-	char *msg = new char[100];
-	Global *gp = Global::Instance();
-
-	for ( int i=0;i<m_cMAXScreenCount;i++ )
-	{
-		sprintf(msg,"C%d %.1f dB %d DEG",i+1,gp->CrossGain[i]/static_cast<float>(10),m_gp->CrossDegree[i]);
-		m_labMsg[i]->Set_Text(msg);
-	}
-
-	delete[] msg;
-	msg = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Calculate_Value
- *  Description:  display the Calculate on Msg Label 
- * =====================================================================================
- */
-void OZKPanel::Refresh_Calculate_Value(Graphic& g,int index,double value)
-{
-	char *msg = new char[100];
-	sprintf ( msg,"%f\n",value );
-	m_labValue[index]->Set_Text(msg);
-	m_labValue[index]->Drawme(g,true);
-	delete[] msg;
-	msg = NULL;
-}
diff --git a/src/EVA11/OZKPanel.h b/src/EVA11/OZKPanel.h
deleted file mode 100644
index 27152b9..0000000
--- a/src/EVA11/OZKPanel.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  OZKPanel.h
- *
- *    Description:  Manage Octo-ZK screen
- *
- *        Version:  1.0
- *        Created:  2013年03月13日 15时13分35秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _OZKPANEL_INC
-#define  _OZKPANEL_INC
-
-class BasePanel;
-class Zscreen;
-class Label;
-class OZKDataProcess;
-class LimitManage;
-
-class OZKPanel : public BasePanel
-{
-	public:
-		OZKPanel (int x,int y,int width,int heigh);
-		~OZKPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
-
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-		virtual void Switch_Panel();
-
-		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
-
-		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
-
-	protected:
-
-	private:
-		void Clean_ZKScreen(Graphic& g);
-		void Load_Alarm_Para();
-		void Refresh_Gain_Rotation();
-		void Refresh_Calculate_Value(Graphic& g,int index,double value);
-
-	private:
-		const static int			m_cMAXScreenCount = 8;
-		Zscreen*				m_Zscreen[m_cMAXScreenCount];
-
-		Label*					m_labMsg[m_cMAXScreenCount];
-		Label*					m_labValue[m_cMAXScreenCount];
-		Bufferbar*				m_Bufbar;
-
-		OZKDataProcess*				m_DataProcess;
-		LimitManage*				m_LimitManage[m_cMAXScreenCount];
-
-}; /* -----  end of class OZKPanel  ----- */
-
-#endif   /* ----- #ifndef _OZKPANEL_INC  ----- */
diff --git a/src/EVA11/Object.cpp b/src/EVA11/Object.cpp
deleted file mode 100644
index 2dcf9fd..0000000
--- a/src/EVA11/Object.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Object.cpp
- *
- *    Description:  Implemntation of Object class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 15时13分35秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-
-Object::Object (int x,int y,int width,int heigh)
-{
-	m_X          = x;
-	m_Y          = y;
-	m_Width      = width;
-	m_Heigh      = heigh;
-
-	m_Center_X   = x + ( m_Width >> 1 );
-	m_Center_Y   = y + ( m_Heigh >> 1 );
-
-	m_Left       = m_X;                                              /* On the frame */
-	m_Right      = m_X + m_Width-1 ;                                 /* On the frame */
-	m_Up         = m_Y;                                              /* On the frame */
-	m_Down       = m_Y + m_Heigh-1;                                  /* On the frame */
-}
-
-Object::~Object ()
-{
-}
diff --git a/src/EVA11/Object.h b/src/EVA11/Object.h
deleted file mode 100644
index cfa35fd..0000000
--- a/src/EVA11/Object.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Object.h
- *
- *    Description:  The most basic class of all screen class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 15时10分06秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  OBJECT_INC
-#define  OBJECT_INC
-
-class Object
-{
-	public:
-		Object (int x,int y,int width,int height);
-		virtual ~Object ();
-
-	private:
-
-	protected:
-		short 			m_X;
-		short 			m_Y;
-		short 			m_Width;
-		short 			m_Heigh;
-		short 			m_Center_X;
-		short 			m_Center_Y;
-
-		short 			m_Left;
-		short 			m_Right;
-		short 			m_Up;
-		short 			m_Down;
-};
-
-#endif
diff --git a/src/EVA11/Operationwin.cpp b/src/EVA11/Operationwin.cpp
deleted file mode 100644
index 86458ae..0000000
--- a/src/EVA11/Operationwin.cpp
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Operationwin.cpp
- *
- *    Description: Implemention of Operationwin class 
- *
- *        Version:  1.0
- *        Created:  2013年11月29日 15时17分32秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<sys/stat.h>
-#include	<fstream>
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"Basewin.h"
-#include 	"Operationwin.h"
-#include 	"Graphic.h"
-#include	"Label.h"
-#include	"Language.h"
-#include	"Global.h"
-#include 	"Log.h"
-
-#include 	"SQLLiteWrapper.h"
-
-#define DBNAME 	"OperationDB.db"
-
-Operationwin::Operationwin ()
-{
-	m_db = new SQLiteDB;
-}
-
-Operationwin::~Operationwin ()
-{
-	delete m_db;
-	m_db = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object
- * =====================================================================================
- */
-void Operationwin::Init_GUI(Graphic& g)
-{
-	Basewin::Init_GUI(g);
-
-	m_Title = new Label(250,12,140,30);
-		m_Title->Set_Text(m_pl->GetText(OPERATION));
-	m_Title->Set_Label_Type(Label::LA_NONE);
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	if 	( m_gp->Language == 1 )
-		m_Title->Set_Font_Size(16);
-	else if ( m_gp->Language == 0 )
-		m_Title->Set_Font_Size(26);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy thr GUI object
- * =====================================================================================
- */
-void Operationwin::Destroy_GUI()
-{
-	Basewin::Destroy_GUI();
-	if 	( m_Title    != NULL ) delete m_Title;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- * Description:  Evey Windows class ues this function to draw himself on screen
- * =====================================================================================
- */
-void Operationwin::Drawme(Graphic &g)
-{
-	Basewin::Drawme(g);
-
-	m_Title->Drawme(g);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function
- * =====================================================================================
- */
-int  Operationwin::Loopwindow(Graphic &g)
-{
-	Save_Screen_Into_Memory(g);
-	int result    = 0;
-
-	Init_GUI(g);
-	Drawme(g);
-	Init_DB();
-
-	while( 1 )
-	{
-		result = Command_Process(g);
-		if 	( result == CO_EXIT )
-			goto Exit;
-		else if ( result == CO_OK )
-		{
-			result = CO_OK;
-			goto Exit;
-		}
-	}
-
-Exit:
-	Close_DB();
-	Destroy_GUI();
-	Restore_Screen_From_Memory(g);
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Operationwin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom2_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,2);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom3_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,3);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom4_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,4);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom5_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,5);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom6_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,6);
-	return CO_NONE;
-}
-int Operationwin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Operationwin::Key_Enter_Fun(Graphic& g)
-{
-	return Key_Bom6_Fun(g);
-}
-int Operationwin::Key_Esc_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBottomFocus
- *  Description:  As the input parameter index to set the bottoms button status  
- * =====================================================================================
- */
-void Operationwin::DrawBottomFocus(Graphic& g,int index)
-{
-	Basewin::DrawBottomFocus(g,index);
-
-	switch ( index ) {
-		case 1:                         /* previouse */
-			{
-			}
-			break;
-		case 2:                         /* next */
-			{
-			}
-			break;
-
-		case 3:                         /* left  */
-			{
-			}
-
-			break;
-
-		case 4:                         /* right */
-			{
-			}
-			break;
-		case 5:
-			{
-			}
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_DB
- *  Description:  Init the Data Base 
- * =====================================================================================
- */
-bool Operationwin::Init_DB()
-{
-	Log *log = Log::Instance();
-	if	(!m_db->OpenConnection(DBNAME,DB_PATH))
-	{
-		std::cout<<"Connecting To DB Failed :"<<m_db->GetLastError().c_str();
-		Log *log = Log::Instance();
-		log->Write_Log("Connecting To DB Failed");
-		return false;
-	}
-	else 
-	{
-		log->Write_Log("Connecting To DB Successfully");
-		return true;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Close_DB
- *  Description:  Close the Data Base connection 
- * =====================================================================================
- */
-void Operationwin::Close_DB()
-{
-	Log *log = Log::Instance();
-	log->Write_Log("Closing DB Successfully");
-	m_db->CloseConnection();
-}
diff --git a/src/EVA11/Operationwin.h b/src/EVA11/Operationwin.h
deleted file mode 100644
index b66c51b..0000000
--- a/src/EVA11/Operationwin.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Operationwin.h
- *
- *    Description: Manage Device Operation 
- *
- *        Version:  1.0
- *        Created:  2013年11月29日 15时14分19秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  OPERATIONWIN_INC
-#define  OPERATIONWIN_INC
-
-#include 	<string>
-
-class SQLiteDB;
-class Operationwin : public Basewin
-{
-	public:
-		Operationwin ();                             /* constructor */
-		virtual ~Operationwin();
-
-		virtual int  Loopwindow(Graphic &g);
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-		void Drawme(Graphic &g);
-
-		bool Init_DB();
-		void Close_DB();
-
-		virtual int Key_Bom1_Fun(Graphic& g) ;
-		virtual int Key_Bom2_Fun(Graphic& g) ;
-		virtual int Key_Bom3_Fun(Graphic& g) ;
-		virtual int Key_Bom4_Fun(Graphic& g) ;
-		virtual int Key_Bom5_Fun(Graphic& g) ;
-		virtual int Key_Bom6_Fun(Graphic& g) ;
-		virtual int Key_Bom7_Fun(Graphic& g) ;
-
-		virtual int Key_Esc_Fun(Graphic& g)  ;
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual void DrawBottomFocus(Graphic& g,int index);
-	private:
-		Label  				    *m_Title;
-		int 				     m_BottomFocus;
-		SQLiteDB			    *m_db;
-
-}; /* -----  end of class Operationwin  ----- */
-#endif   /* ----- #ifndef OPERATIONwin_INC  ----- */
diff --git a/src/EVA11/OtherView.cpp b/src/EVA11/OtherView.cpp
deleted file mode 100644
index 1826647..0000000
--- a/src/EVA11/OtherView.cpp
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  OtherView.cpp
- *
- *    Description:  Implementation of OtherView class 
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 10时37分10秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Sinscreen.h"
-
-#include 	"IView.h"
-#include 	"OtherView.h"
-#include 	"Graphic.h"
-#include 	"Resource.h"
-#include 	"Language.h"
-#include 	"Device.h"
-
-#include 	"FreeType.h"
-
-OtherView::OtherView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-}
-
-OtherView::~OtherView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  
- * =====================================================================================
- */
-void OtherView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  
- * =====================================================================================
- */
-void OtherView::Release_View()
-{
-	Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  
- * =====================================================================================
- */
-int OtherView::Loop_View(Graphic& g)
-{
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  
- * =====================================================================================
- */
-void OtherView::Drawme(Graphic& g)
-{
-	g.Switch_Screen();
-	m_Zscreen->Drawme(g,false);
-	Show_BackGround_Pic(g);
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  
- * =====================================================================================
- */
-void OtherView::Init_GUI(Graphic& g)
-{
-	m_Zscreen = new Sinscreen(m_X,m_Y,m_Width,m_Heigh);
-	m_Zscreen->Set_Color(Sinscreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Zscreen->Set_Color(Sinscreen::LA_BG_COLOR,g_SCBG_CO);
-	m_Zscreen->Set_Color(Sinscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Zscreen->Set_Color(Sinscreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Zscreen->Set_Color(Sinscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-	m_Zscreen->Set_Back_Coordinate(Sinscreen::BKNONE);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void OtherView::Destroy_GUI()
-{
-	delete m_Zscreen;
-	m_Zscreen = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_BackGound_Pic
- *  Description:  Show the Backgound picture on screen 
- * =====================================================================================
- */
-void OtherView::Show_BackGround_Pic(Graphic& g)
-{
-	Resource *res = Resource::Instance();
-	res->Show_Resource_Png(g,1,132,109);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void OtherView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_View
- *  Description:  When Swtich view call this function
- *  		 Very important function
- * =====================================================================================
- */
-void OtherView::Switch_View()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-}
diff --git a/src/EVA11/OtherView.h b/src/EVA11/OtherView.h
deleted file mode 100644
index f44142b..0000000
--- a/src/EVA11/OtherView.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  OtherView.h
- *
- *    Description:  Display other functions
- *
- *        Version:  1.0
- *        Created:  2012年07月11日 10时30分33秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _OTHERVIEW_INC
-#define  _OTHERVIEW_INC
-
-class Sinscreen;
-class IView;
-class Graphic;
-class OtherView : public IView
-{
-	public:
-		OtherView (int x,int y,int width,int heigh);
-		~OtherView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-		virtual void Switch_View();
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		/* -----  Enter the DebugView call the sets function to init the view  ----- */
-
-		virtual void Drawme (Graphic&);
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		void Show_BackGround_Pic(Graphic& g);
-	private:
-		Sinscreen				     *m_Zscreen;
-};
-#endif
diff --git a/src/EVA11/PICwin.cpp b/src/EVA11/PICwin.cpp
deleted file mode 100644
index c4e4c63..0000000
--- a/src/EVA11/PICwin.cpp
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  PICwin.cpp
- *
- *    Description:  Manage of Pictrue of device
- *
- *        Version:  1.0
- *        Created:  2012年09月28日 09时47分50秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include	<fstream>
-
-#include 	"Object.h"
-#include 	"Basewin.h"
-#include 	"Datawin.h"
-#include 	"PICwin.h"
-#include	"JpegOper.h"
-#include 	"Logic.h"
-#include 	"Graphic.h"
-#include	"Language.h"
-#include 	"Label.h"
-#include 	"Msgbox.h"
-
-#include 	"main.h"
-
-PICwin::PICwin ()
-	: Datawin(Datawin::DA_LOAD,'A',0)
-{
-	m_Preview_Status = false;
-}
-
-PICwin::~PICwin ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object of screen 
- * =====================================================================================
- */
-void PICwin::Init_GUI(Graphic& g)
-{
-	Datawin::Init_GUI(g);
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-	}
-	m_Title->Set_Text(m_pl->GetText(PREPIC));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI object of screen 
- * =====================================================================================
- */
-void PICwin::Destroy_GUI()
-{
-	Datawin::Destroy_GUI();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- * =====================================================================================
- */
-void PICwin::Drawme(Graphic& g)
-{
-	Datawin::Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Loopwindow of class
- * =====================================================================================
- */
-int PICwin::Loopwindow(Graphic &g)
-{
-	return	Datawin::Loopwindow(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bom_Text
- *  Description:  Get the help screen buttons text
- * =====================================================================================
- */
-const char*  PICwin::Get_Bom_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0: 
-			return m_pl->GetText(PREVIOUSE);
-			break;
-		case 1: 
-			return m_pl->GetText(NEXT);
-			break;
-		case 2: 
-			return m_pl->GetText(DELETE);
-			break;
-		case 3: 
-			return m_pl->GetText(PGUP);
-			break;
-		case 4: 
-			return m_pl->GetText(PGDN);
-			break;
-		case 5: 
-			return m_pl->GetText(PREVIEW);
-			break;
-		case 6: 
-			return m_pl->GetText(BACKOUT);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_One_Line
- *  Description:  Init one Line value 
- * =====================================================================================
- */
-void PICwin::Init_Normal_One_Line(int i)
-{
-	std::fstream m_filestream;
-	char *databuf = new char[60];
-	char *filename = new char[60];
-
-	sprintf(filename,"%s%s%02d.jpeg",PIC_PATH,"pic",i+m_CurrentPage*m_cMAXItem);
-	m_filestream.open(filename,std::ios::binary|std::ios::in);
-	if 	( !m_filestream )
-	{
-		m_Itemtime[i].flag = false;
-		sprintf(databuf,"%s %s%02d.jpeg         %s",m_pl->GetText(PICFILE),"pic",i+m_CurrentPage*m_cMAXItem,m_pl->GetText(BLANK));
-		m_NorLable[i]->Set_Text(databuf);
-	}
-	else
-	{
-		struct stat info;
-		time_t seconds;
-		struct tm *p;
-		stat(filename,&info);
-		seconds             = info.st_mtime;
-		p                   = localtime(&seconds);
-		m_Itemtime[i].year  = p->tm_year + 1900;
-		m_Itemtime[i].month = p->tm_mon + 1;
-		m_Itemtime[i].day   = p->tm_mday;
-		m_Itemtime[i].flag  = true;
-		m_filestream.close();
-		sprintf(databuf,"%s %s%02d.jpeg    %d/%d/%d",m_pl->GetText(PICFILE),"pic",i+m_CurrentPage*m_cMAXItem,m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
-		m_NorLable[i]->Set_Text(databuf);
-	}
-
-	delete[] databuf;
-	databuf = NULL;
-	delete[] filename;
-	filename = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Preview_PIcture
- *  Description:  Preview screen shot file 
- * =====================================================================================
- */
-void PICwin::Preview_Picture(Graphic& g)
-{
-	sprintf(m_Msg,"%s%s%02d.jpeg",PIC_PATH,"pic",m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
-	if ( access(m_Msg,0) != 0 )
-	{
-		Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g); 
-		delete ms;
-		ms = NULL;
-	}
-	else
-	{
-		unsigned char *buf = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
-		g.Load_Disp_Area(0,0,639,479,buf);
-
-		JpegOper *m_Jpeg     = new JpegOper;
-		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
-
-		m_Jpeg->JpegSetJpegPara(m_Msg,5,5,JCS_RGB);
-		m_Jpeg->JpegReadJpegFile();
-		m_Jpeg->JpegPlayJpeg(0,0,0,0,640,480);
-
-		delete m_Jpeg;
-		m_Jpeg = NULL;
-
-		Label *lab = new Label(2,2,220,25);
-		lab->Set_Label_Type(Label::LA_THIN);
-		lab->Set_Text(m_pl->GetText(PREVIEWPIC));
-		lab->Set_Font_Size(18);
-		lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUBGNO_CO);
-		lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUTXNO_CO);
-		lab->Set_Display_Type(Label::LA_DT_LEFT);
-		lab->Drawme(g);
-		delete lab;
-		lab = NULL;
-
-		m_Preview_Status = true;
-
-		int result = 0;
-		while( result != CO_EXIT )
-		{
-			result = Command_Process(g);
-		}
-
-		m_Preview_Status = false;
-		g.Restore_Disp_Area(0,0,639,479,buf);
-		delete[] buf;
-		buf = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Delete_Picture
- *  Description:  Delete picture of screen-shot 
- * =====================================================================================
- */
-void PICwin::Delete_Picture(Graphic& g)
-{
-	sprintf(m_Msg,"%s%s%02d.jpeg",PIC_PATH,"pic",m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
-	if ( access(m_Msg,0) != 0 )
-	{
-		Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		ms->Showme(g); 
-		delete ms;
-		ms = NULL;
-	}
-	else
-	{
-		if ( Password_Confirm(g) == 1 )
-		{
-			if ( remove(m_Msg) == 0 )
-			{
-				Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELPICFILE),Msgbox::MSG_OK);	
-				ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-				ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-				ms->Showme(g); 
-				delete ms;
-				ms = NULL;
-				Init_Normal_Lines();
-				Drawme(g);
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int PICwin::Key_Bom1_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,1);
-	return CO_NONE;
-}
-int PICwin::Key_Bom2_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,2);
-	return CO_NONE;
-}
-int PICwin::Key_Bom3_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-	{
-		Basewin::DrawBottomFocus(g,3);
-		Delete_Picture(g);
-	}
-	return CO_NONE;
-}
-int PICwin::Key_Bom4_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,4);
-	return CO_NONE;
-}
-int PICwin::Key_Bom5_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,5);
-	return CO_NONE;
-}
-int PICwin::Key_Bom6_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-	{
-		DrawBottomFocus(g,6);
-		Preview_Picture(g);
-	}
-	return CO_NONE;
-}
-int PICwin::Key_Bom7_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int PICwin::Key_Enter_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-	{
-		DrawBottomFocus(g,6);
-		Preview_Picture(g);
-	}
-	return CO_NONE;
-}
-int PICwin::Key_Esc_Fun(Graphic& g)
-{
-	if ( m_Preview_Status == false )
-		DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
diff --git a/src/EVA11/PICwin.h b/src/EVA11/PICwin.h
deleted file mode 100644
index 8f8075a..0000000
--- a/src/EVA11/PICwin.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  PICwin.h
- *
- *    Description:  Manage the Picture file of device
- *
- *        Version:  1.0
- *        Created:  2012年09月28日 09时46分08秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _PICWIN_INC
-#define  _PICWIN_INC
-
-class PICwin : public Datawin
-{
-	public:
-		PICwin ();
-		virtual ~PICwin ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g);
-
-		virtual int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
-		virtual const char*  Get_Bom_Text(int);
-
-		virtual int Key_Bom1_Fun(Graphic& g) ;
-		virtual int Key_Bom2_Fun(Graphic& g) ;
-		virtual int Key_Bom3_Fun(Graphic& g) ;
-		virtual int Key_Bom4_Fun(Graphic& g) ;
-		virtual int Key_Bom5_Fun(Graphic& g) ;
-		virtual int Key_Bom6_Fun(Graphic& g) ;
-		virtual int Key_Bom7_Fun(Graphic& g) ;
-
-		virtual int Key_Esc_Fun(Graphic& g)  ;
-		virtual int Key_Enter_Fun(Graphic& g);
-	protected:
-		virtual void Init_Normal_One_Line(int i);
-	private:
-		void Preview_Picture(Graphic& g);
-		void Delete_Picture(Graphic& g);
-	private:
-		bool 		m_Preview_Status;
-
-};
-
-#endif
diff --git a/src/EVA11/PanelView.cpp b/src/EVA11/PanelView.cpp
deleted file mode 100644
index bf1ec41..0000000
--- a/src/EVA11/PanelView.cpp
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  PanelView.cpp
- *
- *    Description:  implementation of PanelView class
- *
- *        Version:  1.0
- *        Created:  2012年07月19日 17时37分19秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"Language.h"
-#include 	"Global.h"
-#include 	"Language.h"
-
-#include 	"Object.h"
-#include 	"Iconbutton.h"
-#include 	"IView.h"
-#include 	"PanelView.h"
-
-#include 	"FreeType.h"
-
-PanelView::PanelView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-}
-
-PanelView::~PanelView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view
- * =====================================================================================
- */
-void PanelView::Init_View(Graphic& g)
-{
-	for ( int i=0;i<3;i++ )
-	{
-		m_Iconbut[i] =  new Iconbutton(5+i*175,5,174,145);
-
-		m_Iconbut[i]->Set_IconColor(Iconbutton::BGFO_COLOR,g_BUTXFO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::BGNO_COLOR,g_BUBGNO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::FGFO_COLOR,g_BUBGFO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::FGNO_COLOR,g_BUTXNO_CO);
-
-		m_Iconbut[i]->Init_GUI();
-		m_Iconbut[i]->m_Focus = false;
-	}
-
-	for ( int i=3;i<m_cMAXIconCount;i++ )
-	{
-		m_Iconbut[i] =  new Iconbutton(5+(i-3)*175,5+145,174,145);
-
-		m_Iconbut[i]->Set_IconColor(Iconbutton::BGFO_COLOR,g_BUTXFO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::BGNO_COLOR,g_BUBGNO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::FGFO_COLOR,g_BUBGFO_CO);
-		m_Iconbut[i]->Set_IconColor(Iconbutton::FGNO_COLOR,g_BUTXNO_CO);
-
-		m_Iconbut[i]->Init_GUI();
-		m_Iconbut[i]->m_Focus = false;
-	}
-
-	Language	*pl = Language::Instance();
-	m_Iconbut[0]->Set_Text(pl->GetText(COLORDISPLAY));
-	m_Iconbut[0]->Set_Resource_Index(4);
-	m_Iconbut[1]->Set_Text(pl->GetText(VIDEODISPLAY));
-	m_Iconbut[1]->Set_Resource_Index(3);
-	m_Iconbut[2]->Set_Text(pl->GetText(SIGZKDISPLAY));
-	m_Iconbut[2]->Set_Resource_Index(5);
-	m_Iconbut[3]->Set_Text(pl->GetText(DZKDISPLAY));
-	m_Iconbut[3]->Set_Resource_Index(6);
-	m_Iconbut[4]->Set_Text(pl->GetText(OZKDISPLAY));
-	m_Iconbut[4]->Set_Resource_Index(10);
-	m_Iconbut[5]->Set_Text(pl->GetText(COMBINING));
-	m_Iconbut[5]->Set_Resource_Index(11);
-	Global *gp =  Global::Instance();
-	m_Iconbut[gp->PanelType]->m_Focus = true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  
- * =====================================================================================
- */
-void PanelView::Release_View()
-{
-	for ( int i=0;i<m_cMAXIconCount;i++ )
-	{
-		m_Iconbut[i]->Destroy_GUI();
-		delete m_Iconbut[i];
-		m_Iconbut[i] = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  
- * =====================================================================================
- */
-int PanelView::Loop_View(Graphic& g)
-{
-;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the Videw GUI object 
- * =====================================================================================
- */
-void PanelView::Drawme(Graphic& g)
-{
-	g.Switch_Screen();
-
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0x000000));
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
-	g.Setcolor(g.RGB24_16(0xFFFFFF));
-	g.Setcolor(co);
-
-	Language	*pl = Language::Instance();
-	m_Iconbut[0]->Set_Text(pl->GetText(COLORDISPLAY));
-	m_Iconbut[1]->Set_Text(pl->GetText(VIDEODISPLAY));
-	m_Iconbut[2]->Set_Text(pl->GetText(SIGZKDISPLAY));
-	m_Iconbut[3]->Set_Text(pl->GetText(DZKDISPLAY));
-	m_Iconbut[4]->Set_Text(pl->GetText(OZKDISPLAY));
-	m_Iconbut[5]->Set_Text(pl->GetText(COMBINING));
-
-	for ( int i=0;i<m_cMAXIconCount;i++ )
-	{
-		m_Iconbut[i]->Drawme(g);
-	}
-
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void PanelView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Chang_Panel_Focus
- *  Description:  Chang the panel focus 
- * =====================================================================================
- */
-void PanelView::Chang_Panel_Focus(Graphic& g)
-{
-	Global *gp = Global::Instance();
-	for ( int i=0;i<m_cMAXIconCount;i++ )
-	{
-		if 	( m_Iconbut[i]->m_Focus == true )
-		{
-			if ( i != gp->PanelType )
-			{
-				m_Iconbut[i]->m_Focus = false;
-				m_Iconbut[i]->Drawme(g);
-			}
-		}
-		else
-		{
-			if ( i == gp->PanelType )
-			{
-				m_Iconbut[i]->m_Focus = true;
-				m_Iconbut[i]->Drawme(g);
-			}
-		}
-	}
-}
-
-int PanelView::Key_NL1_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR1_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NL2_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR2_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NL3_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR3_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NL4_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR4_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NL5_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR5_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NL6_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
-int PanelView::Key_NR6_Fun(Graphic& g,int sub)
-{
-	Chang_Panel_Focus(g);
-}
diff --git a/src/EVA11/PanelView.h b/src/EVA11/PanelView.h
deleted file mode 100644
index 6e69b4f..0000000
--- a/src/EVA11/PanelView.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  PanelView.h
- *
- *    Description:  Select which Panel
- *
- *        Version:  1.0
- *        Created:  2012年07月19日 17时33分02秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _PANELVIEW_INC
-#define  _PANELVIEW_INC
-
-class IView;
-class Iconbutton;
-
-class PanelView : public IView
-{
-	public:
-		PanelView (int x,int y,int width,int heigh);
-		~PanelView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		/* -----  Enter the DebugView call the sets function to init the view  ----- */
-
-		virtual void Drawme (Graphic&);
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-	protected:
-		void Chang_Panel_Focus(Graphic& g);
-	private:
-		static const int	m_cMAXIconCount = 6;
-		Iconbutton 		*m_Iconbut[m_cMAXIconCount];
-};
-#endif
diff --git a/src/EVA11/ParaView.cpp b/src/EVA11/ParaView.cpp
deleted file mode 100644
index bfab372..0000000
--- a/src/EVA11/ParaView.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ParaView.cpp
- *
- *    Description:  Implementation of ParaView class 
- *
- *        Version:  1.0
- *        Created:  2012年12月12日 11时03分46秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdlib>
-#include 	<cstdio>
-
-#include 	"Graphic.h"
-#include	"Global.h"
-#include 	"Device.h"
-#include 	"Language.h"
-
-#include 	"Object.h"
-
-#include 	"BasePanel.h"
-#include 	"IView.h"
-#include	"DetectView.h"
-#include 	"ParaView.h"
-
-#include 	"FreeType.h"
-
-ParaView::ParaView (int x,int y,int width,int heigh)
-	: IView(x,y,width,heigh)
-{
-	m_DetectView = NULL;
-}
-
-ParaView::~ParaView ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_View
- *  Description:  Init the view sets 
- * =====================================================================================
- */
-void ParaView::Init_View(Graphic& g)
-{
-	Init_GUI(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_View
- *  Description:  
- * =====================================================================================
- */
-void ParaView::Release_View()
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_View
- *  Description:  Loop View
- * =====================================================================================
- */
-int ParaView::Loop_View(Graphic& g)
-{
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_DetectView_Object
- *  Description:  For Alarm view draw GUI on screen 
- * =====================================================================================
- */
-void ParaView::Load_View_Object(IView* obj)
-{
-	m_DetectView = dynamic_cast<DetectView *>(obj);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message system
- * =====================================================================================
- */
-void ParaView::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI Object 
- * =====================================================================================
- */
-void ParaView::Init_GUI(Graphic& g)
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void ParaView::Destroy_GUI()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- * =====================================================================================
- */
-void ParaView::Drawme(Graphic& g)
-{
-	if ( m_DetectView != NULL )
-		m_DetectView->Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Swtich_View
- *  Description:  when chang the view called it
- * =====================================================================================
- */
-void ParaView::Switch_View()
-{
-	if ( m_DetectView != NULL )
-		m_DetectView->Switch_View();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fn_Fun
- *  Description:  Key Function 
- * =====================================================================================
- */
-int ParaView::Key_NL1_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL1_Fun(g,sub);
-}
-int ParaView::Key_NR1_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR1_Fun(g,sub);
-}
-int ParaView::Key_NL2_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL2_Fun(g,sub);
-}
-int ParaView::Key_NR2_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR2_Fun(g,sub);
-}
-int ParaView::Key_NL3_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL3_Fun(g,sub);
-}
-int ParaView::Key_NR3_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR3_Fun(g,sub);
-}
-int ParaView::Key_NL4_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL4_Fun(g,sub);
-}
-int ParaView::Key_NR4_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR4_Fun(g,sub);
-}
-int ParaView::Key_NL5_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL5_Fun(g,sub);
-}
-int ParaView::Key_NR5_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR5_Fun(g,sub);
-}
-int ParaView::Key_NL6_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL6_Fun(g,sub);
-}
-int ParaView::Key_NR6_Fun(Graphic& g,int sub)
-{
-	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR6_Fun(g,sub);
-}
diff --git a/src/EVA11/ParaView.h b/src/EVA11/ParaView.h
deleted file mode 100644
index 845ab21..0000000
--- a/src/EVA11/ParaView.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ParaView.h
- *
- *    Description:  Parameters view Object
- *
- *        Version:  1.0
- *        Created:  2012年12月12日 10时59分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _PARAVIEW_INC
-#define  _PARAVIEW_INC
-
-class IView;
-class DetectView;
-class ParaView : public IView
-{
-	public:
-		ParaView (int x,int y,int width,int heigh);
-		~ParaView ();
-
-		virtual void Init_View(Graphic&);
-		virtual void Release_View();
-		virtual int  Loop_View(Graphic&);
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-		virtual void Drawme(Graphic&);
-
-		void Load_View_Object(IView* obj);
-		void Switch_View();
-
-		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
-	protected:
-
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		DetectView*		m_DetectView;
-	private:
-};
-
-#endif   /* ----- #ifndef _PARAVIEW_INC  ----- */
diff --git a/src/EVA11/Parawin.cpp b/src/EVA11/Parawin.cpp
deleted file mode 100644
index e5dee8a..0000000
--- a/src/EVA11/Parawin.cpp
+++ /dev/null
@@ -1,707 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Parawin.cpp
- *
- *    Description:  Body of Parawin class
- *
- *        Version:  1.0
- *        Created:  2012年06月29日 14时56分36秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<unistd.h>
-#include 	<fstream>
-
-#include 	"Object.h"
-#include 	"Basewin.h"
-#include 	"Parawin.h"
-#include 	"Graphic.h"
-#include 	"Logic.h"
-#include	"Label.h"
-#include	"Language.h"
-#include	"Global.h"
-#include	"Battery.h"
-#include 	"Datawin.h"
-#include	"Msgbox.h"
-#include 	"Helpwin.h"
-#include 	"Algorithm.h"
-#include 	"MixingManage.h"
-
-Parawin::Parawin (PARATYPE type,char flag)
-{
-	m_pl   = Language::Instance();
-	m_gp   = Global::Instance();
-	m_Type = type;
-	m_flag = flag;
-}  /* -----  end of method Parawin::Parawin  (constructor)  ----- */
-Parawin::~Parawin ()
-{
-}  /* -----  end of method Parawin::Parawin  (destructor)  ----- */
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI Object on screen 
- * =====================================================================================
- */
-void Parawin::Drawme(Graphic& g)
-{
-	Basewin::Drawme(g);
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		m_NorLable[i]->Drawme(g);
-	}
-	m_Title->Drawme(g);
-	m_SubTitle->Drawme(g);
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Very important function 
- *       return:  0: Exit program
- *                1: goto Mainwin
- * =====================================================================================
- */
-int Parawin::Loopwindow(Graphic& g)
-{
-	Save_Screen_Into_Memory(g);
-	int result    = 0;
-	m_BottomFocus = 1;
-	m_NormalFocus = 1;
-	Init_Normal_Title();
-	Init_Normal_Lines();
-	Init_GUI(g);
-	Drawme(g);
-
-	while( 1 )
-	{
-		result = Command_Process(g);
-		if 	( result == CO_EXIT )
-			goto Exit;
-		else if ( result == CO_OK )
-		{
-			result = CO_OK;
-			goto Exit;
-		}
-		else if ( result == CO_LOADEXIT )
-		{
-			result = CO_LOADEXIT;
-			goto Exit;
-		}
-	}
-
-Exit:
-	Destroy_GUI();
-	Restore_Screen_From_Memory(g);
-
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-	return result;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object of screen 
- * =====================================================================================
- */
-void Parawin::Init_GUI(Graphic& g)
-{
-	Basewin::Init_GUI(g);
-	/*-----------------------------------------------------------------------------
-	 *  Init the buttom line buttons
-	 *-----------------------------------------------------------------------------*/
-	for ( int i=0;i<MAXBOMCOUNT;i++ )
-	{
-		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
-	}	
-	m_BomButton[0]->Set_Focus(true);
-	m_BomSmall->Set_Text("X");
-
-	char *itembuf = new char[100];
-	for ( int i=0;i<10;i++ )
-	{
-		if 	( m_Itemtime[i].flag == true && ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE ) )
-		{
-			sprintf(itembuf,"%s",const_cast<char *>(m_Text[i].c_str()));
-			m_NorLable[i] = new Label(4,53+39*i,315,38);
-			m_NorLable[i]->Set_Text(itembuf);
-			sprintf(itembuf,"%d/%02d/%02d",m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
-			m_NorLable[i]->Set_Text(itembuf,1);
-			m_NorLable[i]->Set_Label_Type(Label::LA_3D);
-		}
-		else
-		{
-			m_NorLable[i] = new Label(4,53+39*i,315,38);
-			m_NorLable[i]->Set_Text(const_cast<char *>(m_Text[i].c_str()));
-			m_NorLable[i]->Set_Label_Type(Label::LA_3D);
-		}
-		m_NorLable[i]->Set_Font_Size(18);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_NorLable[i]->Set_Display_Type(Label::LA_DT_DOUBLE);
-	}
-	for ( int i=0;i<10;i++ )
-	{
-		if 	( m_Itemtime[i+10].flag == true && ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE ) )
-		{
-			sprintf(itembuf,"%s",const_cast<char *>(m_Text[i+10].c_str()));
-			m_NorLable[i+10] = new Label(7+315,53+39*i,315,38);
-			m_NorLable[i+10]->Set_Text(itembuf);
-			sprintf(itembuf,"%d/%02d/%02d",m_Itemtime[i+10].year,m_Itemtime[i+10].month,m_Itemtime[i+10].day);
-			m_NorLable[i+10]->Set_Text(itembuf,1);
-			m_NorLable[i+10]->Set_Label_Type(Label::LA_3D);
-		}
-		else
-		{
-			m_NorLable[i+10] = new Label(7+315,53+39*i,315,38);
-			m_NorLable[i+10]->Set_Text(const_cast<char *>(m_Text[i+10].c_str()));
-			m_NorLable[i+10]->Set_Label_Type(Label::LA_3D);
-		}
-		m_NorLable[10+i]->Set_Font_Size(18);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-		m_NorLable[10+i]->Set_Display_Type(Label::LA_DT_DOUBLE);
-	}
-
-	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-
-	delete[] itembuf;
-	itembuf = NULL;
-
-	m_Title = new Label(250,12,140,30);
-	if 	( m_Type == PT_SAVE ) 
-		m_Title->Set_Text(m_pl->GetText(SAVEPARAM));
-	else if	( m_Type == PT_LOAD )
-		m_Title->Set_Text(m_pl->GetText(LOADPARAM));
-	else if	( m_Type == PT_DELE )
-		m_Title->Set_Text(m_pl->GetText(DELPARAM));
-	else if	( m_Type == DA_SAVE )
-		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
-	else if	( m_Type == DA_LOAD )
-		m_Title->Set_Text(m_pl->GetText(LOADDATA));
-	else if	( m_Type == DA_DELE ) 
-		m_Title->Set_Text(m_pl->GetText(DELEDATA));
-	m_Title->Set_Label_Type(Label::LA_NONE);
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	if 	( m_gp->Language == 1 )
-		m_Title->Set_Font_Size(16);
-	else if ( m_gp->Language == 0 )
-		m_Title->Set_Font_Size(26);
-
-	m_SubTitle = new Label(550,25,80,22);
-	m_SubTitle->Set_Text(m_pl->GetText(SUB_TITLE2));
-	m_SubTitle->Set_Label_Type(Label::LA_NONE);
-	m_SubTitle->Set_Font_Size(16);
-	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object
- * =====================================================================================
- */
-void Parawin::Destroy_GUI()
-{
-	Basewin::Destroy_GUI();
-	if 	( m_Title    != NULL ) delete m_Title;
-	if 	( m_SubTitle != NULL ) delete m_SubTitle;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Bom_Text
- *  Description:  Return the Bom button text 
- *        index: from 0 to 6
- * =====================================================================================
- */
-const char*Parawin::Get_Bom_Text(int index)
-{
-	switch ( index ) 
-	{
-		case 0: 
-			return m_pl->GetText(PREVIOUSE);
-			break;
-		case 1: 
-			return m_pl->GetText(NEXT);
-			break;
-		case 2: 
-			return m_pl->GetText(LEFTC);
-			break;
-		case 3: 
-			return m_pl->GetText(RIGHTC);
-			break;
-		case 4: 
-			return m_pl->GetText(NONE);
-			break;
-		case 5: 
-			return m_pl->GetText(COMFIRM);
-			break;
-		case 6: 
-			return m_pl->GetText(BACKOUT);
-			break;
-		default:	
-			return m_pl->GetText(NONE);
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_Title
- *  Description:  Init the normal button title 
- * =====================================================================================
- */
-void Parawin::Init_Normal_Title()
-{
-	char oc;
-	int num;
-
-	for ( int i = 0; i < MAXNORCOUNT; i += 1 ) 
-	{
-		m_Text[i] = m_pl->GetText(CRAFTPARA);
-	}
-
-	sprintf(m_Msg,"%s%s",RUN_PATH,"PAR.NAM");
-
-	std::fstream filestream;
-	filestream.open(m_Msg,std::ios::in|std::ios::out);
-	if (!filestream)
-	{
-		perror("Can't open the par.nam file\n");
-	}
-	else
-	{
-		int i=0;
-		int index=0;
-		while(!filestream.eof())
-		{
-			filestream.get(oc);
-			if (oc == m_flag-0x20)
-			{
-				filestream.get(oc);
-				if ((oc == '0') || (oc == '1'))
-				{
-					if      ( oc == '0' ) index = 0;
-					else if ( oc == '1' ) index = 10;
-					filestream.get(oc);
-					if ((oc >= 0x30) && (oc < 0x30+10))
-					{
-						index = index + oc - 0x30;
-						if ( index >= 0 && index < 20 )
-						{
-							filestream.get(oc);
-							if ((oc == ' '))
-							{
-								if ( i != index ) i = index;
-								m_Text[i] = "";
-								filestream.get(oc);
-								do
-								{
-									m_Text[i] = m_Text[i] + oc;	
-									filestream.get(oc);
-								}while( oc!=0x0d && !filestream.eof() );
-								i = i + 1;
-							}
-						}
-					}
-				}
-			}
-		}
-		filestream.close();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Normal_Lines
- *  Description:  according the currentpage paramter initial the normal lines of screen 
- * =====================================================================================
- */
-void Parawin::Init_Normal_Lines()
-{
-	for ( int i=0;i<MAXNORCOUNT;i++ )
-	{
-		sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,i);
-		if ( access(m_Msg,0) != 0 )
-		{
-			m_Itemtime[i].flag = false;
-		}
-		else
-		{
-			struct stat info;
-			time_t seconds;
-			struct tm *p;
-			stat(m_Msg,&info);
-			seconds = info.st_mtime;
-			p = localtime(&seconds);
-			m_Itemtime[i].year = p->tm_year + 1900;
-			m_Itemtime[i].month = p->tm_mon + 1;
-			m_Itemtime[i].day = p->tm_mday;
-			m_Itemtime[i].flag = true;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBomttomFocus
- *  Description:  As the input parameter index to set the bottoms button status  
- * =====================================================================================
- */
-void Parawin::DrawBottomFocus(Graphic& g,int index)
-{
-	Basewin::DrawBottomFocus(g,index);
-
-	switch ( index ) {
-		case 1:                         /* previouse */
-			{
-				if 	( m_NormalFocus == 1 )
-				{
-				        m_NormalFocus = MAXNORCOUNT;
-					m_NorLable[0]->Set_Focus(false);
-					m_NorLable[0]->Drawme(g);
-					m_NorLable[19]->Set_Focus(true);
-					m_NorLable[19]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus--;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-
-			}
-			break;
-		case 2:                         /* next */
-			{
-				if ( m_NormalFocus == MAXNORCOUNT )
-				{
-				        m_NormalFocus = 1;
-					m_NorLable[19]->Set_Focus(false);
-					m_NorLable[19]->Drawme(g);
-					m_NorLable[0]->Set_Focus(true);
-					m_NorLable[0]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus++;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-
-		case 3:                         /* left  */
-			{
-				if ( m_NormalFocus < 11 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-
-			break;
-
-		case 4:                         /* right */
-			{
-				if ( m_NormalFocus > 10 )
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus -= 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-				else
-				{
-					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-					m_NormalFocus += 10;
-					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
-					m_NorLable[m_NormalFocus-1]->Drawme(g);
-				}
-			}
-			break;
-	}				/* -----  end switch  ----- */
-#ifdef X86
-	g.Update_Rect(0,0,640,480);
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Item_Refresh_Item
- *  Description:  Save the parameters into flash and refresh GUI item 
- * =====================================================================================
- */
-void Parawin::Save_Item_Refresh_Item(Graphic& g)
-{
-	int result = Password_Confirm(g);
-	if 	( result == 1 )
-	{
-		sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
-		m_gp->Save_Global_Variables(m_Msg);
-		if 	( access(m_Msg,0) == 0 )
-		{
-			struct stat info;
-			time_t seconds;
-			struct tm *p;
-			stat(m_Msg,&info);
-			seconds = info.st_mtime;
-			p = localtime(&seconds);
-			m_Itemtime[m_NormalFocus-1].year  = p->tm_year + 1900;
-			m_Itemtime[m_NormalFocus-1].month = p->tm_mon + 1;
-			m_Itemtime[m_NormalFocus-1].day   = p->tm_mday;
-			m_Itemtime[m_NormalFocus-1].flag  = true;
-
-			sprintf(m_Msg,"%s",const_cast<char *>(m_Text[m_NormalFocus-1].c_str()));
-			m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg);
-			sprintf(m_Msg,"%d/%02d/%02d",m_Itemtime[m_NormalFocus-1].year,m_Itemtime[m_NormalFocus-1].month,m_Itemtime[m_NormalFocus-1].day);
-			m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg,1);
-			m_NorLable[m_NormalFocus-1]->Drawme(g);
-		}
-	}
-	else if ( result == 0 )
-	{
-		Msgbox *mps = new Msgbox(150,170,350,100,m_pl->GetText(INFO_PD_INVAIL),Msgbox::MSG_OK);	
-		mps->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		mps->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		mps->Showme(g);
-		delete mps;
-		mps = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int Parawin::Key_Bom1_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,1);
-	return CO_NONE;
-}
-int Parawin::Key_Bom2_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,2);
-	return CO_NONE;
-}
-int Parawin::Key_Bom3_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,3);
-	return CO_NONE;
-}
-int Parawin::Key_Bom4_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,4);
-	return CO_NONE;
-}
-int Parawin::Key_Bom6_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,6);
-	switch ( m_Type )
-	{
-		case PT_LOAD:
-			{
-				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
-				{
-					sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
-					m_gp->Load_Global_Variables(m_Msg);
-
-					/*-----------------------------------------------------------------------------
-					 * When load parameters from nand flash we need let to device  
-					 *-----------------------------------------------------------------------------*/
-					m_gp->bSNeedResetAlarmArea = true;
-					m_gp->bDNeedResetAlarmArea = true;
-					m_gp->bONeedResetAlarmArea = true;
-
-					m_lo->Set_Global_Variables_Into_PCB();
-
-					for ( int i=0;i<Global::CHANCOUNT;i++ )
-						m_alg->Reset_MAX_Value(i,m_gp->DFilter[i]);
-
-					MixingManage *mixm = MixingManage::Instance();
-					mixm->Init_Object();
-					mixm->Sync_Mixing_Para(false);
-
-					m_lo->Set_Global_Variables_Into_System();
-
-					m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-
-					return CO_LOADEXIT;
-				}
-				else
-				{       Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					ms->Showme(g);
-					delete ms;
-					ms = NULL;
-				}
-			}
-			break;
-
-		case PT_SAVE:
-			{
-				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
-				{
-					Msgbox *ms = new Msgbox(200,170,280,100,m_pl->GetText(OVERWRITECHECK),Msgbox::MSG_OKCANCEL);	
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					if ( ms->Showme(g) == false )
-					{
-						delete ms;
-						ms = NULL;
-					}
-					else
-					{
-						delete ms;
-						ms = NULL;
-						Save_Item_Refresh_Item(g);
-					}
-				}
-				else
-				{
-					Save_Item_Refresh_Item(g);
-				}
-			}
-			break;
-
-		case PT_DELE:
-			{
-				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
-				{
-					if ( Password_Confirm(g) == 1 )
-					{
-						sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
-						if 	( remove(m_Msg) == 0 )
-						{
-							m_Itemtime[m_NormalFocus-1].flag = false;
-							sprintf(m_Msg,"%s",const_cast<char *>(m_Text[m_NormalFocus-1].c_str()));
-							m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg);
-							m_NorLable[m_NormalFocus-1]->Set_Text(" ",1);
-							m_NorLable[m_NormalFocus-1]->Drawme(g);
-						}
-					}
-					else
-					{
-						Msgbox *mps = new Msgbox(150,170,350,100,m_pl->GetText(INFO_PD_INVAIL),Msgbox::MSG_OK);	
-						mps->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-						mps->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-						mps->Showme(g);
-						delete mps;
-						mps = NULL;
-					}
-				}
-				else
-				{       Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-					ms->Showme(g);
-					delete ms;
-					ms = NULL;
-				}
-			}
-			break;
-		case DA_SAVE:
-			{
-				Datawin *dataw;
-				dataw = new Datawin(Datawin::DA_SAVE,m_flag,m_NormalFocus-1);
-				dataw->Loopwindow(g);
-				delete dataw;
-				dataw = NULL;
-			}
-			break;
-		case DA_LOAD:
-			{
-				Datawin *dataw;
-				dataw = new Datawin(Datawin::DA_LOAD,m_flag,m_NormalFocus-1);
-				dataw->Loopwindow(g);
-				delete dataw;
-				dataw = NULL;
-			}
-			break;
-		case DA_DELE:
-			{
-				Datawin *dataw;
-				dataw = new Datawin(Datawin::DA_DELE,m_flag,m_NormalFocus-1);
-				dataw->Loopwindow(g);
-				delete dataw;
-				dataw = NULL;
-			}
-			break;
-
-	}
-	return CO_NONE;
-}
-int Parawin::Key_Bom7_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Parawin::Key_Enter_Fun(Graphic& g)
-{
-	return Key_Bom6_Fun(g);
-}
-int Parawin::Key_Esc_Fun(Graphic& g)
-{
-	DrawBottomFocus(g,7);
-	return CO_EXIT;
-}
-int Parawin::Key_F1_Fun(Graphic& g)
-{
-	Show_Device_Help_Message(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Device_Help_Message
- *  Description:  When Enter the Device show this message to users 
- * =====================================================================================
- */
-void Parawin::Show_Device_Help_Message(Graphic& g)
-{
-	Helpwin* helpw = new Helpwin();
-	helpw->Set_Flag(m_flag);
-	helpw->Set_Index(m_NormalFocus-1);
-	helpw->Loopwindow(g);
-	delete helpw;
-	helpw = NULL;
-}
diff --git a/src/EVA11/Parawin.h b/src/EVA11/Parawin.h
deleted file mode 100644
index 61d4ad8..0000000
--- a/src/EVA11/Parawin.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Parawin.h
- *
- *    Description:  implementation of parameters managment
- *
- *        Version:  1.0
- *        Created:  2012年06月29日 14时52分55秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef  _PARAWIN_INC
-#define  _PARAWIN_INC
-
-#include 	<cstring>
-class Parawin : public Basewin
-{
-	public:
-		enum PARATYPE
-		{
-			PT_LOAD,
-			PT_SAVE,
-			PT_DELE,
-			DA_LOAD,
-			DA_SAVE,
-			DA_DELE
-		};				/* ----------  end of enum PARATYPE  ---------- */
-		typedef enum PARATYPE PARATYPE;
-
-		struct ITEMTIME 
-		{
-			bool flag;
-			short year;
-			short month;
-			short day;
-		};				/* ----------  end of struct ITEMTIME  ---------- */
-		typedef struct ITEMTIME ITEMTIME;
-
-		Parawin (PARATYPE type,char flag);      	/* constructor */
-		virtual ~Parawin ();              		/* destructor  */
-
-		void Drawme (Graphic& g);       		/* Any window coming from window class draw itself on screen */
-		int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
-
-	protected:
-		virtual int Key_Bom1_Fun(Graphic& g) ;
-		virtual int Key_Bom2_Fun(Graphic& g) ;
-		virtual int Key_Bom3_Fun(Graphic& g) ;
-		virtual int Key_Bom4_Fun(Graphic& g) ;
-		virtual int Key_Bom6_Fun(Graphic& g) ;
-		virtual int Key_Bom7_Fun(Graphic& g) ;
-
-		virtual int Key_Esc_Fun(Graphic& g)  ;
-		virtual int Key_Enter_Fun(Graphic& g);
-		virtual int Key_F1_Fun(Graphic& g);
-
-		virtual void DrawBottomFocus(Graphic& g,int index);
-
-	private:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-
-		void Init_Normal_Title();
-		void Init_Normal_Lines();
-		const char*Get_Bom_Text(int);
-
-		void Save_Item_Refresh_Item(Graphic& g);
-		void Show_Device_Help_Message(Graphic& g);
-	private:
-		static const int		     MAXNORCOUNT = 20;
-		int 				     m_NormalFocus;
-
-		Label  				    *m_Title;
-		Label  				    *m_SubTitle;
-
-		Language			    *m_pl;
-		Global				    *m_gp;
-		PARATYPE			     m_Type;
-		char				     m_flag;		
-
-		Label				    *m_NorLable[MAXNORCOUNT];
-		std::string 			     m_Text[MAXNORCOUNT];
-		ITEMTIME 			     m_Itemtime[MAXNORCOUNT];
-}; /* -----  end of class Parawin  ----- */
-#endif   /* ----- #ifndef _PARAWIN_INC  ----- */
diff --git a/src/EVA11/Png.cpp b/src/EVA11/Png.cpp
deleted file mode 100644
index cf8f7b8..0000000
--- a/src/EVA11/Png.cpp
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Png.cpp
- *
- *    Description:  Manage of Png class 
- *
- *        Version:  1.0
- *        Created:  2012年11月01日 10时18分15秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Png.h"
-#include 	"Graphic.h"
-
-Png::Png ()
-{
-}
-
-Png::~Png ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Read_PNG_File
- *  Description:  Read the png file and display it on screen  
- * =====================================================================================
- */
-void Png::Read_PNG_File(Graphic& g,const char* path,const int& x,const int& y)
-{
-	FILE *file = fopen(path,"rb");
-	if ( file == NULL )
-	{
-		perror("can't open the png file");
-		return;
-	}
-
-	png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);
-	png_infop info_ptr = png_create_info_struct(png_ptr);
-	png_init_io(png_ptr,file);
-	png_read_png(png_ptr,info_ptr,PNG_TRANSFORM_EXPAND,0);
-
-	int m_width = png_get_image_width(png_ptr,info_ptr);
-	int m_height = png_get_image_height(png_ptr,info_ptr);
-	int color_type = png_get_color_type(png_ptr,info_ptr);
-	int bit_depth = png_get_bit_depth(png_ptr,info_ptr);
-
-	switch ( color_type ) 
-	{
-		case PNG_COLOR_TYPE_RGB:
-			{
-				png_bytep* row_pointers = png_get_rows(png_ptr, info_ptr);
-
-				int color;
-				for( int i = 0; i < m_height; i++ )
-				{
-					for( int j = 0; j < m_width; j += 1 )
-					{
-						color = ( row_pointers[i][(j + (j << 1)) + 0]<< 16 ) + ( row_pointers[i][(j + (j << 1)) + 1] << 8 ) + \
-							( row_pointers[i][(j + (j << 1)) + 2] );
-						g.Setpixel(x+j,y+i,g.RGB24_16(color));
-					}
-				}
-			}
-			break;
-
-		case PNG_COLOR_TYPE_RGBA:
-			{
-				png_bytep* row_pointers = png_get_rows(png_ptr, info_ptr);
-
-				for( int i = 0; i < m_height; i++ )
-				{
-					for( int j = 0; j < m_width; j += 1 )
-					{
-						if 	( row_pointers[i][((j << 2))+3] != 0 )
-						{
-							g.Setpixel(x+j,y+i,g.RGB24_16(Alpha_Color((uint8_t *)&row_pointers[i][((j << 2))],g.Getpixel(x+j,y+i))));
-						}
-					}
-				}
-			}
-			break;
-
-		default:
-			printf ( "not support such png formate \n" );
-			break;
-	}
-
-	png_destroy_read_struct(&png_ptr, &info_ptr, 0);
-	fclose(file);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Write_PNG_File
- *  Description:  Write screen picture into png file 
- * =====================================================================================
- */
-void Png::Write_PNG_File(Graphic& g,const char* path,const int& width,const int& height)
-{
-	FILE *file = fopen(path,"wb");
-	if ( file == NULL )
-	{
-		perror("can't open the png file");
-		return;
-	}
-
-	unsigned short *src = (unsigned short *)g.Get_Screen_Ptr();
-	int	      srcw  = g.Get_Screen_Width();
-	int	      srch  = g.Get_Screen_Height();
-
-	png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,0,0,0);
-	png_infop info_ptr = png_create_info_struct(png_ptr);
-	png_init_io(png_ptr,file);
-
-	png_set_IHDR(png_ptr, info_ptr, width,height,  
-			8,PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
-			PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-	png_write_info(png_ptr, info_ptr);  
-
-	png_bytep *row_pointers = new png_bytep[height*sizeof(png_bytep)]; 
-
-	for ( int i=0;i<height;i++ )
-	{
-		row_pointers[i] =  new unsigned char[4*width];
-		for ( int j=0;j<width;j++ )
-		{
-			row_pointers[i][j*4+0] = ((src[i*srcw+j]>>11)&0x1f)<<3;
-			row_pointers[i][j*4+1] = ((src[i*srcw+j]>>5)&0x3f)<<2;
-			row_pointers[i][j*4+2] = ((src[i*srcw+j])&0x1f)<<3;
-			row_pointers[i][j*4+3] = 0xff;
-		}
-	}
-
-	png_write_image(png_ptr,row_pointers);
-	png_write_end(png_ptr,NULL);
-
-	for ( int i=0;i<height;i++ )
-	{
-		delete row_pointers[i];
-		row_pointers[i] = NULL;
-	}
-
-	delete[]  row_pointers;
-	row_pointers = NULL;
-
-	fclose(file);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Alpha_Color
- *  Description:  Alpha Color calculate,only called in Alpha parameters exist
- * =====================================================================================
- */
-int Png::Alpha_Color(uint8_t *row,short color)
-{
-	int nr    = row[0];
-	int ng    = row[1];
-	int nb    = row[2];
-	int alpha = row[3];
-
-	int oldr  = (( color >> 11 ) & 0x1f)<<3;
-	int oldg  = (( color >> 5 ) & 0x3f)<<2;
-	int oldb  = (( color ) & 0x1f)<<3;
-
-	nr    = (((nr - oldr)*alpha)>>8) + oldr;
-	ng    = (((ng - oldg)*alpha)>>8) + oldg;
-	nb    = (((nb - oldb)*alpha)>>8) + oldb;
-
-	return ( nr << 16 ) + ( ng << 8 ) + nb;
-}
diff --git a/src/EVA11/Png.h b/src/EVA11/Png.h
deleted file mode 100644
index 47e61d5..0000000
--- a/src/EVA11/Png.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Png.h
- *
- *    Description:  Manage Png picture process class
- *
- *        Version:  1.0
- *        Created:  2012年11月01日 10时16分57秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _PNG_INC
-#define  _PNG_INC
-
-#include	<png.h>
-#include 	<stdint.h>
-
-class Graphic;
-class Png
-{
-	public:
-		Png ();                             /* constructor */
-		~Png ();                            /* destructor */
-
-		void Read_PNG_File(Graphic& g,const char* path,const int& x,const int& y);
-		void Write_PNG_File(Graphic& g,const char* path,const int& width,const int& height);
-	protected:
-
-	private:
-		int Alpha_Color(uint8_t *row,short color);
-};
-
-#endif   /* ----- #ifndef _PNG_INC  ----- */
diff --git a/src/EVA11/Process.cpp b/src/EVA11/Process.cpp
deleted file mode 100644
index 732f299..0000000
--- a/src/EVA11/Process.cpp
+++ /dev/null
@@ -1,3445 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Process.cpp
- *
- *    Description:  Implementation of process sets
- *
- *        Version:  1.0
- *        Created:  2012年07月04日 14时47分20秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<unistd.h>
-#include 	<cstdio>
-
-#include 	"Language.h"
-#include	"Process.h" 
-#include	"Global.h"
-#include 	"Device.h"
-#include 	"Object.h"
-#include 	"Basewin.h"
-#include 	"Parawin.h"
-#include 	"Loadwin.h"
-#include	"Modifywin.h"
-#include 	"Logic.h"
-#include 	"Mainwin.h"
-#include 	"Algorithm.h"
-#include 	"Datawin.h"
-#include 	"PICwin.h"
-#include 	"Operationwin.h"
-
-IProcess::IProcess(Mainwin* mwin)
-{
-	m_gp     = Global::Instance();
-	m_device = Device::Instance();
-	m_mwin   = mwin;
-}
-
-IProcess::~IProcess() {}
-
-DetectProcess::DetectProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-
-void DetectProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0:
-			Do_Event_ColorPanel(g,sub,nor,key);
-			break;
-
-		case 1: 
-			Do_Event_VideoPanel(g,sub,nor,key);
-			break;
-
-		case 2:
-			Do_Event_ZKPanel(g,sub,nor,key);
-			break;
-
-		case 3:
-			Do_Event_DZKPanel(g,sub,nor,key);
-			break;
-
-		case 4:
-			Do_Event_OZKPanel(g,sub,nor,key);
-			break;
-
-		case 5:
-			Do_Event_CZKPanel(g,sub,nor,key);
-			break;
-	}
-}
-
-void DetectProcess::Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							int gain = m_gp->ColorGain;
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->ColorGain = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY ) 
-						{
-							int gain = m_gp->ColorGain;
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->ColorGain = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ColorSpotFreqIndex == 0 )
-								m_gp->ColorSpotFreqIndex = Global::FREQCOUNT-1;
-							else
-								m_gp->ColorSpotFreqIndex --;
-
-							for ( int i=0;i<Global::CHANCOUNT;i++ )
-							{
-								m_device->Write_Para_SignalID(i,
-											    i+1,
-											    m_gp->ColorSpotFreqIndex+1);
-							}
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ColorSpotFreqIndex == Global::FREQCOUNT-1 )
-								m_gp->ColorSpotFreqIndex = 0;
-							else
-								m_gp->ColorSpotFreqIndex ++;
-
-							for ( int i=0;i<Global::CHANCOUNT;i++ )
-							{
-								m_device->Write_Para_SignalID(i,
-											    i+1,
-											    m_gp->ColorSpotFreqIndex+1);
-							}
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->ColorSpotFreqIndex]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->ColorSpotFreqIndex] = newfreqvalue;
-							for ( int i=0;i<Global::CHANCOUNT;i++ )
-							{
-								m_device->Write_Para_Frequence_Value(i,newfreqvalue);
-							}
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->ColorSpotFreqIndex]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->ColorSpotFreqIndex] = newfreqvalue;
-							for ( int i=0;i<Global::CHANCOUNT;i++ )
-							{
-								m_device->Write_Para_Frequence_Value(i,newfreqvalue);
-							}
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 4:
-					{
-					}
-					break;
-				case 5: 
-					{
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ColorSpotScanSpeed == 1 )
-								m_gp->ColorSpotScanSpeed = 100;
-							else 
-								m_gp->ColorSpotScanSpeed --;
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ColorSpotScanSpeed == 100 )
-								m_gp->ColorSpotScanSpeed = 1;
-							else 
-								m_gp->ColorSpotScanSpeed ++; 
-						}
-					}
-					break;
-			}
-			break;
-	}
-}
-void DetectProcess::Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				switch ( nor )
-				{
-					case 1:
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->ScopeChan == 0 ) m_gp->ScopeChan = 7;
-								else m_gp->ScopeChan --;
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->ScopeChan == 7 ) m_gp->ScopeChan = 0;
-								else m_gp->ScopeChan ++;
-							}
-						}
-						break;
-					case 2:
-						{
-							if 	( key == LKEY )
-							{
-								int gain = m_gp->CrossGain[m_gp->ScopeChan];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( gain == 5 ) gain = 900;
-									else gain -= 5;
-								}
-								m_gp->CrossGain[m_gp->ScopeChan] = gain;
-								m_gp->Calculate_Gain();
-							}
-							else if ( key == RKEY )
-							{
-								int gain = m_gp->CrossGain[m_gp->ScopeChan];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( gain == 900 ) gain = 5;
-									else gain += 5;
-								}
-								m_gp->CrossGain[m_gp->ScopeChan] = gain;
-								m_gp->Calculate_Gain();
-							}
-						}
-						break;
-					case 3: 
-						{
-							if 	( key == LKEY )
-							{
-								int degree = m_gp->CrossDegree[m_gp->ScopeChan];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( degree == 0 ) degree = 359;
-									else degree -= 1;
-								}
-								m_gp->CrossDegree[m_gp->ScopeChan] = degree;
-							}
-							else if ( key == RKEY )
-							{
-								int degree = m_gp->CrossDegree[m_gp->ScopeChan];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( degree == 359 ) degree = 0;
-									else degree += 1;
-								}
-								m_gp->CrossDegree[m_gp->ScopeChan] = degree;
-							}
-						}
-						break;
-					case 4:
-						{
-							if 	( key == LKEY || key == RKEY )
-							{
-								m_mwin->Sync_Cross_Chan_Parameters(g);
-							}
-						}
-						break;
-					case 5: 
-						{
-						}
-						break;
-					case 6: 
-						{
-						}
-						break;
-				}
-			}
-			break;
-	}
-}
-void DetectProcess::Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			{
-				switch ( nor )
-				{
-					case 1:
-						{
-						}
-						break;
-					case 2:
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->bSingleSrcPause == false ) break;
-								int gain = m_gp->Gain[m_gp->SingleFocusSignal];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( gain == 5 ) gain = 900;
-									else gain -= 5;
-								}
-								m_gp->Gain[m_gp->SingleFocusSignal] = gain;
-								m_gp->Calculate_Gain();
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->bSingleSrcPause == false ) break;
-								int gain = m_gp->Gain[m_gp->SingleFocusSignal];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( gain == 900 ) gain = 5;
-									else gain += 5;
-								}
-								m_gp->Gain[m_gp->SingleFocusSignal] = gain;
-								m_gp->Calculate_Gain();
-							}
-						}
-						break;
-					case 3: 
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->bSingleSrcPause == false ) break;
-								int degree = m_gp->Degree[m_gp->SingleFocusSignal];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( degree == 0 ) degree = 359;
-									else degree -= 1;
-								}
-								m_gp->Degree[m_gp->SingleFocusSignal] = degree;
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->bSingleSrcPause == false ) break;
-								int degree = m_gp->Degree[m_gp->SingleFocusSignal];
-								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-								{
-									if ( degree == 359 ) degree = 0;
-									else degree += 1;
-								}
-								m_gp->Degree[m_gp->SingleFocusSignal] = degree;
-							}
-						}
-						break;
-					case 4:
-						{
-							if 	( key == LKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
-								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
-							}
-							else if ( key == RKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
-								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
-							}
-						}
-						break;
-					case 5: 
-						{
-							if 	( key == LKEY || key == RKEY )
-							{
-								if 	( m_gp->TimeScaleDisp == 0 )
-									m_gp->TimeScaleDisp = 1;
-								else if ( m_gp->TimeScaleDisp == 1 )
-									m_gp->TimeScaleDisp = 2;
-								else if ( m_gp->TimeScaleDisp == 2 )
-									m_gp->TimeScaleDisp = 0;
-							}
-						}
-						break;
-					case 6: 
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->TimeScaleSpeed == 1 )
-									m_gp->TimeScaleSpeed = 25;
-								else
-									m_gp->TimeScaleSpeed --; 
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->TimeScaleSpeed == 25 )
-									m_gp->TimeScaleSpeed = 1;
-								else
-									m_gp->TimeScaleSpeed ++; 
-							}
-						}
-						break;
-				}
-			}
-			break;
-	}
-}
-void DetectProcess::Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->ScrSigFocus == 0 )
-								m_gp->ScrSigFocus = 1;
-							else
-								m_gp->ScrSigFocus --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->ScrSigFocus == 1 )
-								m_gp->ScrSigFocus = 0;
-							else 
-								m_gp->ScrSigFocus ++;
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 0 )
-								m_gp->ScrSigM[m_gp->ScrSigFocus] = 2;
-							else
-								m_gp->ScrSigM[m_gp->ScrSigFocus] --;
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 2 )
-								m_gp->ScrSigM[m_gp->ScrSigFocus] = 0;
-							else
-								m_gp->ScrSigM[m_gp->ScrSigFocus] ++;
-						}
-					}
-					break;
-				case 3:
-					{
-
-
-
-						if 	( key == LKEY )
-						{
-							if ( m_gp->bDoubleSrcPause == false ) return;
-							int gain;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
-							else 
-								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
-
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->bDoubleSrcPause == false ) return;
-							int gain;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
-							else 
-								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
-
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 4: 
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->bDoubleSrcPause == false ) return;
-
-							int degree;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
-							else
-								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->bDoubleSrcPause == false ) return;
-
-							int degree;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
-							else
-								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
-						}
-					}
-					break;
-				case 5:
-					{
-						if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-						{
-							if 	( key == LKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]]);
-								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->ScrSigM[m_gp->ScrSigFocus],newfreqvalue);
-							}
-							else if ( key == RKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]]);
-								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->ScrSigM[m_gp->ScrSigFocus],newfreqvalue);
-							}
-						}
-						else
-						{
-							if 	( key == LKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
-								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
-							}
-							else if ( key == RKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
-								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
-							}
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-						{
-
-						}
-						else
-						{
-							if 	( key == LKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
-								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
-							}
-							else if ( key == RKEY )
-							{
-								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
-								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-								int newfreqvalue = m_device->Get_Frequence(freqindex);
-								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
-								m_device->Set_Para_Frequence_Value(m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
-							}
-						}
-
-					}
-					break;
-			}
-			break;
-	}
-}
-
-void DetectProcess::Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->ScrSigFocus == 0 )
-								m_gp->ScrSigFocus = 1;
-							else
-								m_gp->ScrSigFocus --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->ScrSigFocus == 1 )
-								m_gp->ScrSigFocus = 0;
-							else 
-								m_gp->ScrSigFocus ++;
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 0 )
-								m_gp->ScrSigM[m_gp->ScrSigFocus] = 2;
-							else
-								m_gp->ScrSigM[m_gp->ScrSigFocus] --;
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 2 )
-								m_gp->ScrSigM[m_gp->ScrSigFocus] = 0;
-							else
-								m_gp->ScrSigM[m_gp->ScrSigFocus] ++;
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->bCompositeSrcPause == false ) return;
-
-							int gain;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
-							else 
-								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
-
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->bCompositeSrcPause == false ) return;
-
-							int gain;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
-							else 
-								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
-
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 4: 
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->bCompositeSrcPause == false ) return;
-
-							int degree;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
-							else
-								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->bCompositeSrcPause == false ) return;
-
-							int degree;
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
-							else 
-								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
-								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
-							else
-								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
-						}
-					}
-					break;
-				case 5:
-					{
-
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							int gain = m_gp->Gain[m_gp->AScanMapChan[0]];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->Gain[m_gp->AScanMapChan[0]] = gain;
-							m_gp->Gain[m_gp->AScanMapChan[1]] = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							int gain = m_gp->Gain[m_gp->AScanMapChan[0]];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->Gain[m_gp->AScanMapChan[0]] = gain;
-							m_gp->Gain[m_gp->AScanMapChan[1]] = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-			}
-			break;
-	}
-}
-
-void DetectProcess::Do_Event_VideoPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-			}
-			break;
-	}
-}
-
-ParameterProcess::ParameterProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-
-void ParameterProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	Global *gp = Global::Instance();
-	switch ( gp->PanelType ) 
-	{
-		case 0:
-			Do_Event_ColorPanel(g,sub,nor,key);
-			break;
-		case 2:
-			Do_Event_ZKPanel(g,sub,nor,key);
-			break;
-		case 3:
-			Do_Event_DZKPanel(g,sub,nor,key);
-			break;
-		case 4:
-			Do_Event_OZKPanel(g,sub,nor,key);
-			break;
-		case 5:
-			Do_Event_CZKPanel(g,sub,nor,key);
-			break;
-		default:
-			Do_Event_ZKPanel(g,sub,nor,key);
-			break;
-	}
-}
-
-void ParameterProcess::Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY || key == RKEY )
-						{
-							if	( m_gp->ColorSpotSampleType == 0 )
-								m_gp->ColorSpotSampleType = 1;
-							else
-								m_gp->ColorSpotSampleType = 0;
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( m_gp->ColorSpotSampleType == 0 )
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->ColorSpotSampIntervalClock == 1000 )
-									m_gp->ColorSpotSampIntervalClock = 10000;
-								else
-									m_gp->ColorSpotSampIntervalClock --; 
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->ColorSpotSampIntervalClock == 10000 )
-									m_gp->ColorSpotSampIntervalClock = 1000;
-								else
-									m_gp->ColorSpotSampIntervalClock ++; 
-							}
-						}
-						else if ( m_gp->ColorSpotSampleType == 1 )
-						{
-							if 	( key == LKEY )
-							{
-								if ( m_gp->ColorSPotSampOutPuls == 1000 )
-									m_gp->ColorSPotSampOutPuls = 10000;
-								else
-									m_gp->ColorSPotSampOutPuls --; 
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->ColorSPotSampOutPuls == 10000 )
-									m_gp->ColorSPotSampOutPuls = 1000;
-								else
-									m_gp->ColorSPotSampOutPuls ++; 
-							}
-						}
-					}
-					break;
-				case 3: 
-					{
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ColorSpotDispMode == 0 )
-								m_gp->ColorSpotDispMode = 1;
-							else 
-								m_gp->ColorSpotDispMode --;
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ColorSpotDispMode == 1 )
-								m_gp->ColorSpotDispMode = 0;
-							else 
-								m_gp->ColorSpotDispMode ++;
-						}
-					}
-					break;
-			}
-			break;
-	}
-
-}
-
-void ParameterProcess::Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
-								m_gp->ProbeFun[m_gp->SingleFocusSignal] = 3;
-							else
-								m_gp->ProbeFun[m_gp->SingleFocusSignal] --;
-
-							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
-										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
-										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 3)
-								m_gp->ProbeFun[m_gp->SingleFocusSignal] = 0; 
-							else
-								m_gp->ProbeFun[m_gp->SingleFocusSignal] ++;
-
-							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
-										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
-										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->SingleFocusSignal] == 0 )
-								m_gp->FreqIndex[m_gp->SingleFocusSignal] = Global::FREQCOUNT-1;
-							else
-								m_gp->FreqIndex[m_gp->SingleFocusSignal] --;
-
-							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
-										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
-										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->SingleFocusSignal] == Global::FREQCOUNT-1 )
-								m_gp->FreqIndex[m_gp->SingleFocusSignal] = 0;
-							else
-								m_gp->FreqIndex[m_gp->SingleFocusSignal] ++;
-
-							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
-										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
-										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
-						}
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 0 )
-								m_gp->DFilter[m_gp->SingleFocusSignal] = 7;
-							else
-								m_gp->DFilter[m_gp->SingleFocusSignal] --;
-							
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->SingleFocusSignal,m_gp->DFilter[m_gp->SingleFocusSignal]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 7 )
-								m_gp->DFilter[m_gp->SingleFocusSignal] = 0;
-							else
-								m_gp->DFilter[m_gp->SingleFocusSignal] ++;
-
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->SingleFocusSignal,m_gp->DFilter[m_gp->SingleFocusSignal]);
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-			}
-			break;
-		case 2: 
-			switch ( nor )
-			{
-				case 1:
-					{
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							int gain = m_gp->Gain[m_gp->SingleFocusSignal];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->Gain[m_gp->SingleFocusSignal] = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							int gain = m_gp->Gain[m_gp->SingleFocusSignal];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->Gain[m_gp->SingleFocusSignal] = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							int degree = m_gp->Degree[m_gp->SingleFocusSignal];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-							m_gp->Degree[m_gp->SingleFocusSignal] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							int degree = m_gp->Degree[m_gp->SingleFocusSignal];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-							m_gp->Degree[m_gp->SingleFocusSignal] = degree;
-						}
-					}
-					break;
-				case 4:
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
-						lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                       /* the low filter closed */
-								{
-									hff --;		
-									if ( hff == -1 )
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 100000;
-										else hff = 0; 
-
-									}
-								}
-								else                                   /* normal lff value */
-								{
-									hff --;		
-									if ( hff == -1 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											hff = lff - 1;
-											if ( hff == -1 ) hff = 0;
-										}
-										else hff = 0;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->SingleFocusSignal] = hff;
-							m_device->Write_Para_HiFilter(m_gp->SingleFocusSignal,m_gp->HiFilter[m_gp->SingleFocusSignal]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                /* the low filter closed */
-								{
-									hff ++;		
-									if ( hff >= 100001 )
-									{
-										hff = 0;
-									}
-									else if ( hff == 1 )
-									{
-										if ( m_gp->MultiKey != 0 ) hff = 0;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									hff ++;		
-									if ( hff >= lff ) 
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 0;
-										else hff --;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->SingleFocusSignal] = hff;
-							m_device->Write_Para_HiFilter(m_gp->SingleFocusSignal,m_gp->HiFilter[m_gp->SingleFocusSignal]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 5: 
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
-						lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff --;		
-									if ( lff == -2 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = 100000;
-										}
-										else lff ++; 
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff --;
-									if ( lff <= hff && lff != -2 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == -2 ) 
-									{
-
-										if ( m_gp->MultiKey == 0 )
-										{
-											if ( hff == 100000 ) lff = -1;
-											else lff = 100000;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->SingleFocusSignal] = lff;
-							m_device->Write_Para_LowFilter(m_gp->SingleFocusSignal,m_gp->LoFilter[m_gp->SingleFocusSignal]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
-							lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff ++;		
-									if ( lff == 100000 ); 
-									{
-										if ( m_gp->MultiKey == 0 ) lff = -1;
-										else lff --;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff ++;
-									if ( lff > 100000 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == 0 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = hff + 1;
-											if ( lff > 100000 ) lff = -1;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->SingleFocusSignal] = lff;
-							m_device->Write_Para_LowFilter(m_gp->SingleFocusSignal,m_gp->LoFilter[m_gp->SingleFocusSignal]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->Auto_Disappear == 10 )
-								m_gp->Auto_Disappear = 128;
-							else
-								m_gp->Auto_Disappear --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->Auto_Disappear == 128 )
-								m_gp->Auto_Disappear = 10;
-							else
-								m_gp->Auto_Disappear ++;
-						}
-					}
-					break;
-			}
-			break;
-
-		case 3:
-			switch ( nor ) 
-			{
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							Algorithm* m_alg = Algorithm::Instance();
-							if ( m_gp->GainRatio == 1 )
-								m_gp->GainRatio = 100;
-							else
-								m_gp->GainRatio--;
-							m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-						}
-						else if ( key == RKEY )
-						{
-							Algorithm* m_alg = Algorithm::Instance();
-							if ( m_gp->GainRatio == 100 )
-								m_gp->GainRatio = 1;
-							else
-								m_gp->GainRatio ++;
-							m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-						}
-					}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-	}
-}
- 
-void ParameterProcess::Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->DParaChan == 0 ) m_gp->DParaChan = 1;
-							else m_gp->DParaChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->DParaChan == 1 ) m_gp->DParaChan = 0;
-							else m_gp->DParaChan ++;
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
-								m_gp->ProbeFun[m_gp->DParaChan] = 3;
-							else
-								m_gp->ProbeFun[m_gp->DParaChan] --;
-
-							m_device->Set_Para_SignalID(m_gp->DParaChan,
-										    m_gp->ProbeFun[m_gp->DParaChan],
-										    m_gp->FreqIndex[m_gp->DParaChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 3 )
-								m_gp->ProbeFun[m_gp->DParaChan] = 0; 
-							else
-								m_gp->ProbeFun[m_gp->DParaChan] ++;
-
-							m_device->Set_Para_SignalID(m_gp->DParaChan,
-										    m_gp->ProbeFun[m_gp->DParaChan],
-										    m_gp->FreqIndex[m_gp->DParaChan]+1);
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->DParaChan] == 0 )
-								m_gp->FreqIndex[m_gp->DParaChan] = Global::FREQCOUNT-1;
-							else
-								m_gp->FreqIndex[m_gp->DParaChan] --;
-
-							m_device->Set_Para_SignalID(m_gp->DParaChan,
-										    m_gp->ProbeFun[m_gp->DParaChan],
-										    m_gp->FreqIndex[m_gp->DParaChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->DParaChan] == Global::FREQCOUNT-1 )
-								m_gp->FreqIndex[m_gp->DParaChan] = 0;
-							else
-								m_gp->FreqIndex[m_gp->DParaChan] ++;
-
-							m_device->Set_Para_SignalID(m_gp->DParaChan,
-										    m_gp->ProbeFun[m_gp->DParaChan],
-										    m_gp->FreqIndex[m_gp->DParaChan]+1);
-						}
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->DParaChan,newfreqvalue);
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->DParaChan,newfreqvalue);
-						}
-					}
-					break;
-				case 5:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->DParaChan] == 0 )
-								m_gp->DFilter[m_gp->DParaChan] = 7;
-							else
-								m_gp->DFilter[m_gp->DParaChan] --;
-
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->DParaChan,m_gp->DFilter[m_gp->DParaChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->DParaChan] == 7 )
-								m_gp->DFilter[m_gp->DParaChan] = 0;
-							else
-								m_gp->DFilter[m_gp->DParaChan] ++;
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->DParaChan,m_gp->DFilter[m_gp->DParaChan]);
-						}
-					}
-					break;
-				case 6:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Logic *lo = Logic::Instance();
-						lo->Restore_Mix_Factor(g);
-					}
-					break;
-			}
-			break;
-		case 2: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->DParaChan == 0 ) m_gp->DParaChan = 1;
-							else m_gp->DParaChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->DParaChan == 1 ) m_gp->DParaChan = 0;
-							else m_gp->DParaChan ++;
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							int gain = m_gp->Gain[m_gp->DParaChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->Gain[m_gp->DParaChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							int gain = m_gp->Gain[m_gp->DParaChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->Gain[m_gp->DParaChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							int degree = m_gp->Degree[m_gp->DParaChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-							m_gp->Degree[m_gp->DParaChan] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							int degree = m_gp->Degree[m_gp->DParaChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-							m_gp->Degree[m_gp->DParaChan] = degree;
-						}
-					}
-					break;
-				case 4:
-					{
-						int hff = m_gp->HiFilter[m_gp->DParaChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if 	( hff == 0 )
-								{
-									if 	( m_gp->MultiKey == 0 )
-										hff = 1000;
-								}
-								else
-								{
-
-									hff --;
-								}
-							}
-							m_gp->HiFilter[m_gp->DParaChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->DParaChan,m_gp->HiFilter[m_gp->DParaChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if 	( hff == 1000 )
-									hff = 0;
-								else if ( hff == 0 )
-								{
-									if 	( m_gp->MultiKey == 0 )
-										hff = 1;
-								}
-								else
-									hff ++;
-							}
-							m_gp->HiFilter[m_gp->DParaChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->DParaChan,m_gp->HiFilter[m_gp->DParaChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 5:
-					{
-						int lff = m_gp->LoFilter[m_gp->DParaChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if 	( lff == 100 )
-									lff = -1;
-								else if ( lff == -1 )
-								{
-									if 	( m_gp->MultiKey == 0 )
-											lff = 20000;
-								}
-								else
-									lff --;
-							}
-							m_gp->LoFilter[m_gp->DParaChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->DParaChan,m_gp->LoFilter[m_gp->DParaChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if 	( lff == 20000 )
-									lff = -1;
-								else if ( lff == -1 )
-								{
-									if 	( m_gp->MultiKey == 0 )
-										lff = 100;
-								}
-								else
-									lff ++;
-							}
-							m_gp->LoFilter[m_gp->DParaChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->DParaChan,m_gp->LoFilter[m_gp->DParaChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->Auto_Disappear == 10 )
-								m_gp->Auto_Disappear = 128;
-							else
-								m_gp->Auto_Disappear --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->Auto_Disappear == 128 )
-								m_gp->Auto_Disappear = 10;
-							else
-								m_gp->Auto_Disappear ++;
-						}
-					}
-					break;
-			}
-			break;
-		case 3:
-			{
-				switch ( nor ) 
-				{
-					case 5: 
-						{
-							Algorithm* m_alg = Algorithm::Instance();
-							if 	( key == LKEY )
-							{
-								if ( m_gp->GainRatio == 1 )
-									m_gp->GainRatio = 100;
-								else
-									m_gp->GainRatio--;
-								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-							}
-							else if ( key == RKEY )
-							{
-								if ( m_gp->GainRatio == 100 )
-									m_gp->GainRatio = 1;
-								else
-									m_gp->GainRatio ++;
-								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-							}
-						}
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-
-void ParameterProcess::Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->CompositeChan == 0 ) m_gp->CompositeChan = 3;
-							else m_gp->CompositeChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->CompositeChan == 3 ) m_gp->CompositeChan = 0;
-							else m_gp->CompositeChan ++;
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
-								m_gp->ProbeFun[m_gp->CompositeChan] = 3;
-							else
-								m_gp->ProbeFun[m_gp->CompositeChan] --;
-							m_device->Set_Para_SignalID(m_gp->CompositeChan,
-										    m_gp->ProbeFun[m_gp->CompositeChan],
-										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 3 )
-								m_gp->ProbeFun[m_gp->CompositeChan] = 0; 
-							else
-								m_gp->ProbeFun[m_gp->CompositeChan] ++;
-							m_device->Set_Para_SignalID(m_gp->CompositeChan,
-										    m_gp->ProbeFun[m_gp->CompositeChan],
-										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->CompositeChan] == 0 )
-								m_gp->FreqIndex[m_gp->CompositeChan] = Global::FREQCOUNT-1;
-							else
-								m_gp->FreqIndex[m_gp->CompositeChan] --;
-
-							m_device->Set_Para_SignalID(m_gp->CompositeChan,
-										    m_gp->ProbeFun[m_gp->CompositeChan],
-										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->CompositeChan] == Global::FREQCOUNT-1 )
-								m_gp->FreqIndex[m_gp->CompositeChan] = 0;
-							else
-								m_gp->FreqIndex[m_gp->CompositeChan] ++;
-
-							m_device->Set_Para_SignalID(m_gp->CompositeChan,
-										    m_gp->ProbeFun[m_gp->CompositeChan],
-										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
-						}
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->CompositeChan,newfreqvalue);
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->CompositeChan,newfreqvalue);
-						}
-					}
-					break;
-				case 5:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->CompositeChan] == 0 )
-								m_gp->DFilter[m_gp->CompositeChan] = 7;
-							else
-								m_gp->DFilter[m_gp->CompositeChan] --;
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->CompositeChan,m_gp->DFilter[m_gp->CompositeChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->CompositeChan] == 7 )
-								m_gp->DFilter[m_gp->CompositeChan] = 0;
-							else
-								m_gp->DFilter[m_gp->CompositeChan] ++;
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->CompositeChan,m_gp->DFilter[m_gp->CompositeChan]);
-						}
-					}
-					break;
-				case 6:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->AScanSpeed == 1 )
-								m_gp->AScanSpeed = 19;
-							else 
-								m_gp->AScanSpeed --;
-				
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->AScanSpeed == 19 )
-								m_gp->AScanSpeed = 1;
-							else 
-								m_gp->AScanSpeed ++;
-
-						}
-					}
-					break;
-			}
-			break;
-		case 2: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->CompositeChan == 0 ) m_gp->CompositeChan = 1;
-							else m_gp->CompositeChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->CompositeChan == 1 ) m_gp->CompositeChan = 0;
-							else m_gp->CompositeChan ++;
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == LKEY )
-						{
-							int gain = m_gp->Gain[m_gp->CompositeChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->Gain[m_gp->CompositeChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							int gain = m_gp->Gain[m_gp->CompositeChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->Gain[m_gp->CompositeChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							int degree = m_gp->Degree[m_gp->CompositeChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-							m_gp->Degree[m_gp->CompositeChan] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							int degree = m_gp->Degree[m_gp->CompositeChan];
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-							m_gp->Degree[m_gp->CompositeChan] = degree;
-						}
-					}
-					break;
-				case 4:
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->CompositeChan];
-						lff = m_gp->LoFilter[m_gp->CompositeChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                       /* the low filter closed */
-								{
-									hff --;		
-									if ( hff == -1 )
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 100000;
-										else hff = 0; 
-
-									}
-								}
-								else                                   /* normal lff value */
-								{
-									hff --;		
-									if ( hff == -1 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											hff = lff - 1;
-											if ( hff == -1 ) hff = 0;
-										}
-										else hff = 0;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->CompositeChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->CompositeChan,m_gp->HiFilter[m_gp->CompositeChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                /* the low filter closed */
-								{
-									hff ++;		
-									if ( hff >= 100001 )
-									{
-										hff = 0;
-									}
-									else if ( hff == 1 )
-									{
-										if ( m_gp->MultiKey != 0 ) hff = 0;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									hff ++;		
-									if ( hff >= lff ) 
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 0;
-										else hff --;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->CompositeChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->CompositeChan,m_gp->HiFilter[m_gp->CompositeChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 5: 
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->CompositeChan];
-						lff = m_gp->LoFilter[m_gp->CompositeChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff --;		
-									if ( lff == -2 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = 100000;
-										}
-										else lff ++; 
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff --;
-									if ( lff <= hff && lff != -2 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == -2 ) 
-									{
-
-										if ( m_gp->MultiKey == 0 )
-										{
-											if ( hff == 100000 ) lff = -1;
-											else lff = 100000;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->CompositeChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->CompositeChan,m_gp->LoFilter[m_gp->CompositeChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							hff = m_gp->HiFilter[m_gp->CompositeChan];
-							lff = m_gp->LoFilter[m_gp->CompositeChan];
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff ++;		
-									if ( lff == 100000 ); 
-									{
-										if ( m_gp->MultiKey == 0 ) lff = -1;
-										else lff --;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff ++;
-									if ( lff > 100000 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == 0 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = hff + 1;
-											if ( lff > 100000 ) lff = -1;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->CompositeChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->CompositeChan,m_gp->LoFilter[m_gp->CompositeChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->Auto_Disappear == 10 )
-								m_gp->Auto_Disappear = 128;
-							else
-								m_gp->Auto_Disappear --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->Auto_Disappear == 128 )
-								m_gp->Auto_Disappear = 10;
-							else
-								m_gp->Auto_Disappear ++;
-						}
-					}
-					break;
-			}
-			break;
-		case 3:
-			{
-				switch ( nor ) 
-				{
-					case 5: 
-						{
-							if 	( key == LKEY )
-							{
-								Algorithm* m_alg = Algorithm::Instance();
-								if ( m_gp->GainRatio == 1 )
-									m_gp->GainRatio = 100;
-								else
-									m_gp->GainRatio--;
-								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-							}
-							else if ( key == RKEY )
-							{
-								Algorithm* m_alg = Algorithm::Instance();
-								if ( m_gp->GainRatio == 100 )
-									m_gp->GainRatio = 1;
-								else
-									m_gp->GainRatio ++;
-								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
-							}
-						}
-						break;
-				}				/* -----  end switch  ----- */
-			}
-			break;
-	}
-}
-		
-void ParameterProcess::Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->QuadChan == 0 ) m_gp->QuadChan = 15;
-							else m_gp->QuadChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->QuadChan == 15 ) m_gp->QuadChan = 0;
-							else m_gp->QuadChan ++;
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
-								m_gp->ProbeFun[m_gp->QuadChan] = 3;
-							else
-								m_gp->ProbeFun[m_gp->QuadChan] --;
-
-							m_device->Set_Para_SignalID(m_gp->QuadChan,
-										    m_gp->ProbeFun[m_gp->QuadChan],
-										    m_gp->FreqIndex[m_gp->QuadChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 3 )
-								m_gp->ProbeFun[m_gp->QuadChan] = 0; 
-							else
-								m_gp->ProbeFun[m_gp->QuadChan] ++;
-
-							m_device->Set_Para_SignalID(m_gp->QuadChan,
-										    m_gp->ProbeFun[m_gp->QuadChan],
-										    m_gp->FreqIndex[m_gp->QuadChan]+1);
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->QuadChan] == 0 )
-								m_gp->FreqIndex[m_gp->QuadChan] = Global::FREQCOUNT-1;
-							else
-								m_gp->FreqIndex[m_gp->QuadChan] --;
-
-							m_device->Set_Para_SignalID(m_gp->QuadChan,
-										    m_gp->ProbeFun[m_gp->QuadChan],
-										    m_gp->FreqIndex[m_gp->QuadChan]+1);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->FreqIndex[m_gp->QuadChan] == Global::FREQCOUNT-1 )
-								m_gp->FreqIndex[m_gp->QuadChan] = 0;
-							else
-								m_gp->FreqIndex[m_gp->QuadChan] ++;
-
-							m_device->Set_Para_SignalID(m_gp->QuadChan,
-										    m_gp->ProbeFun[m_gp->QuadChan],
-										    m_gp->FreqIndex[m_gp->QuadChan]+1);
-						}
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->QuadChan,newfreqvalue);
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->QuadChan,newfreqvalue);
-						}
-					}
-					break;
-				case 5:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->QuadChan] == 0 )
-								m_gp->DFilter[m_gp->QuadChan] = 7;
-							else
-								m_gp->DFilter[m_gp->QuadChan] --;
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->QuadChan,m_gp->DFilter[m_gp->QuadChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DFilter[m_gp->QuadChan] == 7 )
-								m_gp->DFilter[m_gp->QuadChan] = 0;
-							else
-								m_gp->DFilter[m_gp->QuadChan] ++;
-							Algorithm* alg = Algorithm::Instance();
-							alg->Reset_MAX_Value(m_gp->QuadChan,m_gp->DFilter[m_gp->QuadChan]);
-						}
-					}
-					break;
-				case 6:
-					{
-					}
-					break;
-			}
-			break;
-		case 2: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if ( m_gp->QuadChan == 0 ) m_gp->QuadChan = 7;
-							else m_gp->QuadChan --;
-						}
-						else if ( key == RKEY )
-						{
-							if ( m_gp->QuadChan == 7 ) m_gp->QuadChan = 0;
-							else m_gp->QuadChan ++;
-						}
-					}
-					break;
-				case 2:
-					{
-						int gain = m_gp->Gain[m_gp->QuadChan];
-						if 	( key == LKEY )
-						{
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 5 ) gain = 900;
-								else gain -= 5;
-							}
-							m_gp->Gain[m_gp->QuadChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( gain == 900 ) gain = 5;
-								else gain += 5;
-							}
-							m_gp->Gain[m_gp->QuadChan] = gain;
-							m_gp->Calculate_Gain();
-						}
-					}
-					break;
-				case 3: 
-					{
-						int degree = m_gp->Degree[m_gp->QuadChan];
-						if 	( key == LKEY )
-						{
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 0 ) degree = 359;
-								else degree -= 1;
-							}
-							m_gp->Degree[m_gp->QuadChan] = degree;
-						}
-						else if ( key == RKEY )
-						{
-							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
-							{
-								if ( degree == 359 ) degree = 0;
-								else degree += 1;
-							}
-							m_gp->Degree[m_gp->QuadChan] = degree;
-						}
-					}
-					break;
-				case 4:
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->QuadChan];
-						lff = m_gp->LoFilter[m_gp->QuadChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                       /* the low filter closed */
-								{
-									hff --;		
-									if ( hff == -1 )
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 100000;
-										else hff = 0; 
-
-									}
-								}
-								else                                   /* normal lff value */
-								{
-									hff --;		
-									if ( hff == -1 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											hff = lff - 1;
-											if ( hff == -1 ) hff = 0;
-										}
-										else hff = 0;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->QuadChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->QuadChan,m_gp->HiFilter[m_gp->QuadChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( lff == -1 )                /* the low filter closed */
-								{
-									hff ++;		
-									if ( hff >= 100001 )
-									{
-										hff = 0;
-									}
-									else if ( hff == 1 )
-									{
-										if ( m_gp->MultiKey != 0 ) hff = 0;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									hff ++;		
-									if ( hff >= lff ) 
-									{
-										if ( m_gp->MultiKey == 0 ) hff = 0;
-										else hff --;
-									}
-								}
-							}
-							m_gp->HiFilter[m_gp->QuadChan] = hff;
-							m_device->Write_Para_HiFilter(m_gp->QuadChan,m_gp->HiFilter[m_gp->QuadChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 5: 
-					{
-						int hff,lff;
-						hff = m_gp->HiFilter[m_gp->QuadChan];
-						lff = m_gp->LoFilter[m_gp->QuadChan];
-						if 	( key == LKEY )
-						{
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff --;		
-									if ( lff == -2 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = 100000;
-										}
-										else lff ++; 
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff --;
-									if ( lff <= hff && lff != -2 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == -2 ) 
-									{
-
-										if ( m_gp->MultiKey == 0 )
-										{
-											if ( hff == 100000 ) lff = -1;
-											else lff = 100000;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->QuadChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->QuadChan,m_gp->LoFilter[m_gp->QuadChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-						else if ( key == RKEY )
-						{
-							hff = m_gp->HiFilter[m_gp->QuadChan];
-							lff = m_gp->LoFilter[m_gp->QuadChan];
-							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
-							{
-								if ( hff == -1 )                /* the low filter closed */
-								{
-									lff ++;		
-									if ( lff == 100000 ); 
-									{
-										if ( m_gp->MultiKey == 0 ) lff = -1;
-										else lff --;
-									}
-								}
-								else                            /* normal lff value */
-								{
-									lff ++;
-									if ( lff > 100000 ) 
-									{
-										lff = -1;
-									}	
-									else if ( lff == 0 ) 
-									{
-										if ( m_gp->MultiKey == 0 )
-										{
-											lff = hff + 1;
-											if ( lff > 100000 ) lff = -1;
-										}
-										else lff = -1;
-									}
-								}
-							}
-							m_gp->LoFilter[m_gp->QuadChan] = lff;
-							m_device->Write_Para_LowFilter(m_gp->QuadChan,m_gp->LoFilter[m_gp->QuadChan]);
-							m_device->Transfer_ECT_Parameters();
-						}
-					}
-					break;
-				case 6: 
-					{
-					}
-					break;
-			}
-			break;
-	}
-}
-
-DebugProcess::DebugProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-void DebugProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DebugChan == 0 )
-								m_gp->DebugChan = Global::CHANCOUNT - 1;
-							else
-								m_gp->DebugChan --;
-
-							m_device->Set_Para_SignalWave(m_gp->DebugChan);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DebugChan == Global::CHANCOUNT - 1 )
-								m_gp->DebugChan = 0;
-							else
-								m_gp->DebugChan ++;
-
-							m_device->Set_Para_SignalWave(m_gp->DebugChan);
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->HDGain[m_gp->DebugChan] == 0 )
-								m_gp->HDGain[m_gp->DebugChan] = 7;
-							else
-								m_gp->HDGain[m_gp->DebugChan] --;
-							m_device->Set_Para_HDGain(m_gp->DebugChan,m_gp->HDGain[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->HDGain[m_gp->DebugChan] == 7 )
-								m_gp->HDGain[m_gp->DebugChan] = 0;
-							else 
-								m_gp->HDGain[m_gp->DebugChan] ++;
-							m_device->Set_Para_HDGain(m_gp->DebugChan,m_gp->HDGain[m_gp->DebugChan]);
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->FreqIndex[m_gp->DebugChan],newfreqvalue);
-						}
-						else if ( key == RKEY )
-						{
-							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]]);
-							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
-							int newfreqvalue = m_device->Get_Frequence(freqindex);
-							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]] = newfreqvalue;
-							m_device->Set_Para_Frequence_Value(m_gp->FreqIndex[m_gp->DebugChan],newfreqvalue);
-						}
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->Driver == 0 )
-								m_gp->Driver = 7;
-							else
-								m_gp->Driver --;
-							m_device->Set_Para_Driver(m_gp->Driver);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->Driver == 7 )
-								m_gp->Driver = 0;
-							else
-								m_gp->Driver ++;
-							m_device->Set_Para_Driver(m_gp->Driver);
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->Offset == -100 )
-								m_gp->Offset = 100;
-							else
-								m_gp->Offset --;
-							m_device->Set_Para_Offset(m_gp->Offset);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->Offset == 100 )
-								m_gp->Offset = -100;
-							else
-								m_gp->Offset ++;
-							m_device->Set_Para_Offset(m_gp->Offset);
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY || key == RKEY )
-						{
-							if 	( m_gp->bRFFilterEnable == true )
-							{
-								m_gp->bRFFilterEnable = false;
-								m_device->Set_Para_RF_Filter(m_gp->bRFFilterEnable);
-							}
-							else
-							{
-								m_gp->bRFFilterEnable = true;
-								m_device->Set_Para_RF_Filter(m_gp->bRFFilterEnable);
-							}
-						}
-					}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-		case 2:
-			switch ( nor ) 
-			{
-				case 1:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->Precision == 0 )
-								m_gp->Precision = 16;
-							else if ( m_gp->Precision == 16 )
-								m_gp->Precision = 8;
-							else if ( m_gp->Precision == 8 )
-								m_gp->Precision = 0;
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->Precision == 16 )
-								m_gp->Precision = 0;
-							else if ( m_gp->Precision == 0 )
-								m_gp->Precision = 8;
-							else if ( m_gp->Precision == 8 )
-								m_gp->Precision = 16;
-						}
-					break;
-
-				case 2:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DriverBal[m_gp->DebugChan] == 1 )
-								m_gp->DriverBal[m_gp->DebugChan] = 15;
-							else
-								m_gp->DriverBal[m_gp->DebugChan] --;
-							m_device->Set_Para_DriverBal(m_gp->DebugChan,m_gp->DriverBal[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DriverBal[m_gp->DebugChan] == 15 )
-								m_gp->DriverBal[m_gp->DebugChan] = 1;
-							else 
-								m_gp->DriverBal[m_gp->DebugChan] ++;
-							m_device->Set_Para_DriverBal(m_gp->DebugChan,m_gp->DriverBal[m_gp->DebugChan]);
-						}
-					break;
-
-				case 3:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DriverA_ID[m_gp->DebugChan] == 0 )
-								m_gp->DriverA_ID[m_gp->DebugChan] = 255;
-							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 254 )
-								m_gp->DriverA_ID[m_gp->DebugChan] = 247;
-							else
-								m_gp->DriverA_ID[m_gp->DebugChan] --;
-							m_device->Set_Para_DriveA_ID(m_gp->DebugChan,m_gp->DriverA_ID[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DriverA_ID[m_gp->DebugChan] == 255 )
-								m_gp->DriverA_ID[m_gp->DebugChan] = 0;
-							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 247 )
-								m_gp->DriverA_ID[m_gp->DebugChan] = 254;
-							else
-								m_gp->DriverA_ID[m_gp->DebugChan] ++;
-							m_device->Set_Para_DriveA_ID(m_gp->DebugChan,m_gp->DriverA_ID[m_gp->DebugChan]);
-						}
-					break;
-
-				case 4:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->DriverB_ID[m_gp->DebugChan] == 0 )
-								m_gp->DriverB_ID[m_gp->DebugChan] = 255;
-							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 254 )
-								m_gp->DriverB_ID[m_gp->DebugChan] = 247;
-							else
-								m_gp->DriverB_ID[m_gp->DebugChan] --;
-							m_device->Set_Para_DriveB_ID(m_gp->DebugChan,m_gp->DriverB_ID[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->DriverB_ID[m_gp->DebugChan] == 255 )
-								m_gp->DriverB_ID[m_gp->DebugChan] = 0;
-							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 247 )
-								m_gp->DriverB_ID[m_gp->DebugChan] = 254;
-							else
-								m_gp->DriverB_ID[m_gp->DebugChan] ++;
-							m_device->Set_Para_DriveB_ID(m_gp->DebugChan,m_gp->DriverB_ID[m_gp->DebugChan]);
-						}
-					break;
-
-				case 5:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->PickA_ID[m_gp->DebugChan] == 0 )
-								m_gp->PickA_ID[m_gp->DebugChan] = 255;
-							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 254 )
-								m_gp->PickA_ID[m_gp->DebugChan] = 247;
-							else
-								m_gp->PickA_ID[m_gp->DebugChan] --;
-							m_device->Set_Para_PickA_ID(m_gp->DebugChan,m_gp->PickA_ID[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->PickA_ID[m_gp->DebugChan] == 255 )
-								m_gp->PickA_ID[m_gp->DebugChan] = 0;
-							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 247 )
-								m_gp->PickA_ID[m_gp->DebugChan] = 254;
-							else
-								m_gp->PickA_ID[m_gp->DebugChan] ++;
-							m_device->Set_Para_PickA_ID(m_gp->DebugChan,m_gp->PickA_ID[m_gp->DebugChan]);
-						}
-					break;
-
-				case 6:
-						if 	( key == LKEY )
-						{
-							if 	( m_gp->PickB_ID[m_gp->DebugChan] == 0 )
-								m_gp->PickB_ID[m_gp->DebugChan] = 255;
-							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 254 )
-								m_gp->PickB_ID[m_gp->DebugChan] = 247;
-							else
-								m_gp->PickB_ID[m_gp->DebugChan] --;
-							m_device->Set_Para_PickB_ID(m_gp->DebugChan,m_gp->PickB_ID[m_gp->DebugChan]);
-						}
-						else if ( key == RKEY )
-						{
-							if 	( m_gp->PickB_ID[m_gp->DebugChan] == 255 )
-								m_gp->PickB_ID[m_gp->DebugChan] = 0;
-							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 247 )
-								m_gp->PickB_ID[m_gp->DebugChan] = 254;
-							else
-								m_gp->PickB_ID[m_gp->DebugChan] ++;
-							m_device->Set_Para_PickB_ID(m_gp->DebugChan,m_gp->PickB_ID[m_gp->DebugChan]);
-						}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-AlarmProcess::AlarmProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-void AlarmProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-AnalyzeProcess::AnalyzeProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-void AnalyzeProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub ) 
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 2: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 3: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-
-					}
-					break;
-				case 4:
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 5: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-				case 6: 
-					{
-						if 	( key == LKEY )
-						{
-
-						}
-						else if ( key == RKEY )
-						{
-
-						}
-					}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-DisplayProcess::DisplayProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-void DisplayProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						m_gp->PanelType = 5;
-					}
-					break;
-				case 2:
-					{
-						m_gp->PanelType = 4;
-					}
-					break;
-				case 3:
-					{
-						m_gp->PanelType = 3;
-					}
-					break;
-				case 4:
-					{
-						m_gp->PanelType = 2;
-					}
-					break;
-				case 5:
-					{
-						m_gp->PanelType = 0;
-					}
-					break;
-				case 6:
-					{
-						m_gp->PanelType = 1;
-					}
-					break;
-			}				/* -----  end switch  ----- */
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-OthersProcess::OthersProcess(Mainwin* mwin)
-	: IProcess(mwin)
-{
-}
-void OthersProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
-{
-	switch ( sub )
-	{
-		case 1: 
-			switch ( nor )
-			{
-				case 1:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::LT_SAVE);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-				case 2:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::LT_LOAD);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-				case 3:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::LT_DELE);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-				case 4:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::DA_SAVE);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-				case 5:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::DA_LOAD);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-				case 6:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Modifywin *mdw = new Modifywin(g,Loadwin::DA_DELE);
-						int result = mdw->Loopwindow(g);
-						delete mdw;
-						mdw = NULL;
-					}
-					break;
-			}
-			break;
-
-		case 2:
-			switch ( nor ) 
-			{
-				case 1:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Logic *lo = Logic::Instance();
-						lo->Update_Program(g);
-					}
-					break;
-
-				case 2:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						Logic *lo = Logic::Instance();
-						lo->Restore_Default_Value(g);
-					}
-					break;
-
-				case 3:
-					{
-						m_mwin->Refresh_Normal_Label_Text(g);
-						PICwin *picwin = new PICwin();
-						picwin->Loopwindow(g);
-						delete picwin;
-						picwin = NULL;
-					}
-					break;
-
-				case 4:
-					{
-						if ( m_gp->KeyBeep == true )
-							m_gp->KeyBeep =false;
-						else
-							m_gp->KeyBeep =true;
-					}
-					break;
-
-				case 5:
-					{
-						Operationwin *opwin = new Operationwin();
-						opwin->Loopwindow(g);
-						delete opwin;
-						opwin = NULL;
-					}
-					break;
-
-				case 6:
-					{
-						Language* m_lan = Language::Instance();
-						if ( m_gp->Language == 0 )
-							m_gp->Language = 1;
-						else 
-							m_gp->Language = 0;
-						m_lan->SetLang(m_gp->Language);
-						m_mwin->Switch_Language(g);
-					}
-					break;
-
-				default:
-					break;
-			}
-			break;
-		case 4:
-			switch ( nor )
-			{
-				case 1:
-					{
-						if 	( key == RKEY )
-						{
-						}
-						else if ( key == LKEY )
-						{
-						}
-						else if	( key == ENTER )
-						{
-							Set_Syetm_Date(g);
-						}
-					}
-					break;
-				case 2:
-					{
-						if 	( key == RKEY )
-						{
-						}
-						else if ( key == LKEY )
-						{
-						}
-						else if	( key == ENTER )
-						{
-							Set_Syetm_Time(g);
-						}
-					}
-					break;
-				case 3:
-					{
-						if 	( key == RKEY || key == LKEY )
-						{
-							m_mwin->Refresh_Normal_Label_Text(g);
-							Logic *lo = Logic::Instance();
-							lo->About_Box(g,180,100);
-						}
-					}
-					break;
-
-				default:
-					break;
-			}
-			break;
-	}
-}
-
-void OthersProcess::Set_Syetm_Date(Graphic &g)
-{
-	char key;
-	struct tm *timenow;
-	time_t now;
-	char timebuf[20];
-	bool flag    = false;
-	bool outflag = false;
-	int focus    = 0;
-	time(&now);
-	timenow = localtime(&now);
-
-	Algorithm *alg = Algorithm::Instance();
-
-	Logic *lo = Logic::Instance();
-	key       = lo->Get_Key();
-	m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
-	while ( outflag != true )
-	{
-		flag = !flag;
-		if 	( focus == 0 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
-			else
-				sprintf(timebuf,"**/%02d/%02d",timenow->tm_mon + 1,timenow->tm_mday);
-		}
-		else if ( focus == 1 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
-			else
-				sprintf(timebuf,"%02d/**/%02d",timenow->tm_year - 100,timenow->tm_mday);
-		}
-		else if ( focus == 2 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
-			else
-				sprintf(timebuf,"%02d/%02d/**",timenow->tm_year - 100,timenow->tm_mon + 1);
-		}
-
-		m_mwin->Update_Date(g,timebuf);
-
-		key = lo->Get_Key();
-		switch ( key ) {
-			case KEY_ENTER:         /* enable the new system time  */
-				{
-					now = mktime(timenow);
-					stime(&now);    /* set the system time */
-					lo->Excute_Command("/sbin/hwclock -w",false);
-					outflag = true;
-
-					boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
-					m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
-					m_gp->Time_start = m_gp->Time_now - time_elapse;
-					goto Exit;
-				}
-				break;
-			case KEY_ESC:        /* just go out the loop */
-				outflag = true;
-				break;
-			case KEY_FUN1L:         /* change year month day decrease */
-				if ( focus == 0 ) focus = 2;
-				else focus --;
-				break;
-			case KEY_FUN1R:         /* change year month day increase */
-				if ( focus == 2 ) focus = 0;
-				else focus ++;
-				break;
-			case KEY_F3:            /* decrease */
-				if ( focus == 0 ) /* year */
-				{
-					if ( timenow->tm_year == 100 ) timenow->tm_year = 199; /* 2000 - 2099 */
-					else timenow->tm_year --;
-				}
-				else if ( focus == 1 ) /* month */
-				{
-					if ( timenow->tm_mon == 0 ) timenow->tm_mon = 11;
-					else timenow->tm_mon --;
-				}
-				else if ( focus == 2 ) /* day */
-				{
-					if ( timenow->tm_mon + 1 == 4 || 
-					     timenow->tm_mon + 1 == 6 ||
-					     timenow->tm_mon + 1 == 9 ||
-					     timenow->tm_mon + 1 == 11 )
-					{
-						if ( timenow->tm_mday == 1 ) timenow->tm_mday = 30;
-						else timenow->tm_mday --;
-					}
-					else if ( timenow->tm_mon + 1 == 2 ) 
-					{
-						if ( (timenow->tm_year + 1900) % 4 == 0 && 
-						     ((timenow->tm_year + 1900 ) % 100) || 
-						     (timenow->tm_year + 1900) % 400 == 0)
-						{
-							if ( timenow->tm_mday == 1 ) timenow->tm_mday = 29;
-							else timenow->tm_mday --;
-						}
-						else
-						{
-							if ( timenow->tm_mday == 1 ) timenow->tm_mday = 28;
-							else timenow->tm_mday --;
-						}
-					}
-					else
-					{
-						if ( timenow->tm_mday == 1 ) timenow->tm_mday = 31;
-						else timenow->tm_mday --;
-					}
-				}
-				break;
-			case KEY_F4:            /* increase */
-				if ( focus == 0 ) /* year */
-				{
-					if ( timenow->tm_year == 199 ) timenow->tm_year = 100; /* 2000 - 2099 */
-					else timenow->tm_year ++;
-				}
-				else if ( focus == 1 ) /* month */
-				{
-					if ( timenow->tm_mon == 11 ) timenow->tm_mon = 0;
-					else timenow->tm_mon ++;
-				}
-				else if ( focus == 2 ) /* day */
-				{
-					if ( timenow->tm_mon + 1 == 4 || 
-					     timenow->tm_mon + 1 == 6 ||
-					     timenow->tm_mon + 1 == 9 ||
-					     timenow->tm_mon + 1 == 11 )
-					{
-						if ( timenow->tm_mday == 30 ) timenow->tm_mday = 1;
-						else timenow->tm_mday ++;
-					}
-					else if ( timenow->tm_mon + 1 == 2 ) 
-					{
-						if ( (timenow->tm_year + 1900) % 4 == 0 && 
-						     ((timenow->tm_year + 1900 ) % 100) || 
-						     (timenow->tm_year + 1900) % 400 == 0)
-						{
-							if ( timenow->tm_mday == 29 ) timenow->tm_mday = 1;
-							else timenow->tm_mday ++;
-						}
-						else
-						{
-							if ( timenow->tm_mday == 28 ) timenow->tm_mday = 1;
-							else timenow->tm_mday ++;
-						}
-					}
-					else
-					{
-						if ( timenow->tm_mday == 31 ) timenow->tm_mday = 1;
-						else timenow->tm_mday ++;
-					}
-				}
-				break;
-			default:	
-				break;
-		}				/* -----  end switch  ----- */
-		alg->MDelay(80);
-	}
-Exit:
-	;
-}
-void OthersProcess::Set_Syetm_Time(Graphic &g)
-{
-	char key;
-	struct tm *timenow;
-	char timebuf[20];
-	time_t now;
-	bool flag = false;
-	bool outflag = false;
-	int focus=0;                            /* Initiate the setting year */
-	Algorithm *alg = Algorithm::Instance();
-	time(&now);
-	timenow = localtime(&now);
-	Logic *lo = Logic::Instance();
-	key = lo->Get_Key();
-	m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
-	while ( outflag != true )
-	{
-		flag = !flag;
-
-		if ( focus == 0 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-			else
-				sprintf(timebuf,"**:%02d:%02d",timenow->tm_min,timenow->tm_sec);
-		}
-		else if ( focus == 1 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-			else
-				sprintf(timebuf,"%02d:**:%02d",timenow->tm_hour,timenow->tm_sec);
-		}
-		else if ( focus == 2 )
-		{
-			if ( flag == true )
-				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
-			else
-				sprintf(timebuf,"%02d:%02d:**",timenow->tm_hour,timenow->tm_min);
-		}
-
-		m_mwin->Update_Time(g,timebuf);
-
-		key = lo->Get_Key();
-		switch ( key ) {
-			case KEY_ENTER:         /* enable the new system time  */
-				{
-					now = mktime(timenow);
-					stime(&now);
-					lo->Excute_Command("/sbin/hwclock -w",false);
-					outflag = true;
-
-					boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
-					m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
-					m_gp->Time_start = m_gp->Time_now - time_elapse;
-					goto Exit;
-				}
-				break;
-			case KEY_ESC:        /* just go out the loop */
-				outflag = true;
-				break;
-			case KEY_FUN2L:         /* change year month day decrease */
-				if ( focus == 0 ) focus = 2;
-				else focus --;
-				break;
-			case KEY_FUN2R:         /* change year month day increase */
-				if ( focus == 2 ) focus = 0;
-				else focus ++;
-				break;
-			case KEY_F3:            /* decrease */
-				if ( focus == 0 ) /* hour */
-				{
-					if ( timenow->tm_hour == 0 ) timenow->tm_hour = 23; /* 2000 - 2099 */
-					else timenow->tm_hour --;
-				}
-				else if ( focus == 1 ) /* min */
-				{
-					if ( timenow->tm_min == 0 ) timenow->tm_min = 59;
-					else timenow->tm_min --;
-				}
-				else if ( focus == 2 ) /* second */
-				{
-					if ( timenow->tm_sec == 0 ) timenow->tm_sec = 59;
-					else timenow->tm_sec --;
-				}
-				break;
-			case KEY_F4:             /* increase */
-				if ( focus == 0 ) /* hour */
-				{
-					if ( timenow->tm_hour == 23 ) timenow->tm_hour = 0; /* 2000 - 2099 */
-					else timenow->tm_hour ++;
-				}
-				else if ( focus == 1 ) /* min */
-				{
-					if ( timenow->tm_min == 59 ) timenow->tm_min = 0;
-					else timenow->tm_min ++;
-				}
-				else if ( focus == 2 ) /* second */
-				{
-					if ( timenow->tm_sec == 59 ) timenow->tm_sec = 0;
-					else timenow->tm_sec ++;
-				}
-				break;
-			default:	
-				break;
-		}				/* -----  end switch  ----- */
-		alg->MDelay(80);
-	}
-Exit:
-	;
-}
diff --git a/src/EVA11/Process.h b/src/EVA11/Process.h
deleted file mode 100644
index 03f6e4a..0000000
--- a/src/EVA11/Process.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Process.h
- *
- *    Description:  Manage key process class sets
- *
- *        Version:  1.0
- *        Created:  2012年07月04日 14时37分08秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _PROCESS_INC
-#define  _PROCESS_INC
-
-class Global;
-class Device;
-class Graphic;
-class Mainwin;
-class Lgoic;
-class IProcess
-{
-	public:
-		enum RLKEY
-		{
-			RKEY  = 0,
-			LKEY  = 1,
-			ENTER = 2
-		};				/* ----------  end of enum RLFLAG  ---------- */
-		typedef enum RLKEY RLKEY;
-		IProcess(Mainwin* mwin);
-		virtual ~IProcess() = 0;
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key) = 0;
-
-	protected:
-		Global				     *m_gp;
-		Device				     *m_device;
-		Mainwin				     *m_mwin;
-
-	private:
-
-}; /* -----  end of class IProcess  ----- */
-
-class DetectProcess : public IProcess
-{
-	public:
-		DetectProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-	private:
-		void Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_VideoPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class ParameterProcess : public IProcess
-{
-	public:
-		ParameterProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-	private:
-		void Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-		void Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class DebugProcess : public IProcess
-{
-	public:
-		DebugProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class AlarmProcess : public IProcess
-{
-	public:
-		AlarmProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class AnalyzeProcess : public IProcess
-{
-	public:
-		AnalyzeProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class DisplayProcess : public IProcess
-{
-	public:
-		DisplayProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-};
-
-class OthersProcess : public IProcess
-{
-	public:
-		OthersProcess(Mainwin* mwin);
-		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
-	private:
-		void Set_Syetm_Date(Graphic &g);
-		void Set_Syetm_Time(Graphic &g);
-};
-
-#endif   /* ----- #ifndef _PROCESS_INC  ----- */
diff --git a/src/EVA11/ProjectFixHead.h b/src/EVA11/ProjectFixHead.h
deleted file mode 100644
index 6d3994f..0000000
--- a/src/EVA11/ProjectFixHead.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ProjectFixHead.h
- *
- *    Description:  Record something that not chang follow the project
- *
- *        Version:  1.0
- *        Created:  2010年05月17日 22时05分13秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  _PROJECTFIXHEAD_INC
-#define  _PROJECTFIXHEAD_INC
-/*-----------------------------------------------------------------------------
- *  DATA TYPE USED BY PROJECT
- *-----------------------------------------------------------------------------*/
-/*-----------------------------------------------------------------------------
- *      SYSTEM DATA TYPE
- *-----------------------------------------------------------------------------*/
-typedef unsigned char  		UCHAR;
-typedef char                    CHAR;
-typedef unsigned short          UINT16;
-typedef short                   INT16;
-typedef unsigned int            UINT32;
-typedef int                     INT32;
-typedef double                  DOUBLE;
-typedef long long               INT64;
-typedef unsigned long long      UINT64;
-typedef bool                    BOOL;
-/*-----------------------------------------------------------------------------
- *      APPLICATION DATA TYPE
- *-----------------------------------------------------------------------------*/
-typedef double         		DATATYPE;
-typedef int			ETDATA;                         /* the data type get from ET broad */
-typedef float	       		DVTYPE;                	        /* The data type of device */
-typedef int 	       		COLORTYPE;
-
-/*-----------------------------------------------------------------------------
- *  Debug Message MAROC  when release programal did not need define _DEBUG_ MAROC 
- *-----------------------------------------------------------------------------*/
-#define _DEBUG_
-#if defined(_DEBUG_)
-#define DMESSAGE(index,S)      printf("index %d:%s\n",index,S);
-#define DMS(S)                 printf("%s\n",S);
-#define DM1S(N,V)              printf("%s = %d\n",N,V);
-#else
-#define DMESSAGE(index,S) 
-#define DMS(S)
-#define DM1S(N,V)              
-#endif
-
-/*-----------------------------------------------------------------------------
- *  Define the color used by project
- *-----------------------------------------------------------------------------*/
-/*-----------------------------------------------------------------------------
- *  Description:  The color define with 16 bits mode under Linux environment
- *                         00000   000000   00000
- *                field     red     green    blue
- *  example:
- *                red     1111 1000 0000 0000   0xf800
- *                green   0000 0111 1110 0000   0x07e0
- *                blue    0000 0000 0001 1111   0x001f
- *-----------------------------------------------------------------------------*/
-
-/*-----------------------------------------------------------------------------
- *  16 bpp used
- *-----------------------------------------------------------------------------*/
-#define	RED_16     	0xf800			
-#define	TESTRED_16     	0xf800			
-#define	GREEN_16        0x07e0		
-#define BLUE_16         0x001F         
-#define	WHITE_16        0xffff	
-#define	BLACK_16        0x0000	
-#define YELLOW_16	0xffe0
-#define PINK_16		0xf81f
-#define ORANGE_16	0xfE00
-#define GRASS_16	0x87e0 
-#define LIGHTBLUE_16	0x4610
-/*-----------------------------------------------------------------------------
- *  8 BPP USED SYSTEM DEFINE  MY VALUE
- *-----------------------------------------------------------------------------*/
-/*-----------------------------------------------------------------------------
- *  USED BY 308 DEVICE DEFAULT VALUE
- *-----------------------------------------------------------------------------*/
-#define	BLACK_8         0xE0	
-#define	RED_8     	0xE1
-#define BLUE_8          0xE2
-#define	GREEN_8         0xE3
-#define YELLOW_8	0xE4
-#define ORANGE_8	0xE5
-#define PINK_8		0xE6
-#define LIGHTBLUE_8	0xE7
-#define LIGHTGREEN_8    0xE8
-#define HIGHGREEN_8     0xE9
-#define GOLD_8          0xF0
-#define GRASS_8		0xF1
-#define GRAY_8          0xF2
-#define	WHITE_8         0xFD
-/*-----------------------------------------------------------------------------
- *  1 BPP USED SYSTEM DEFINE
- *-----------------------------------------------------------------------------*/
-#define	WHITE_1         1	
-#define	BLACK_1         0	
-
-
-#ifdef _KEY_308_A_
-#define KEY_BOTTOM1  0x03                        /* first bottom button key value */
-#define KEY_BOTTOM2  0x05
-#define KEY_BOTTOM3  0x06
-#define KEY_BOTTOM4  0x09
-#define KEY_BOTTOM5  0x0a
-#define KEY_BOTTOM6  0x0C
-#define KEY_BOTTOM7  0x3F                        /*  */
-#define KEY_QUIT     0xfe 
-#define KEY_ESCAPE   0x18 
-#define KEY_FUN1L    0x7E
-#define KEY_FUN1R    0x41
-#define KEY_FUN2L    0x7D
-#define KEY_FUN2R    0x42
-#define KEY_FUN3L    0x7B
-#define KEY_FUN3R    0x44
-#define KEY_FUN4L    0x77
-#define KEY_FUN4R    0x48
-#define KEY_FUN5L    0x6F
-#define KEY_FUN5R    0x50
-#define KEY_FUN6L    0x5F
-#define KEY_FUN6R    0x60
-#define KEY_ENTER    0x30 
-#define KEY_ESC	     0x18                        /*  */
-#define KEY_F1       0x21                        /* re-define */
-#define KEY_F2       0x11                        /* re-define */
-#define KEY_F3       0x22                        /* re-define */
-#define KEY_F4       0x12                        /* re-define */
-#define KEY_F5       0x24                        /* re-define */
-#define KEY_F6       0x14                        /* re-define */
-#define KEY_F7       0x28                        /* re-define */
-
-#define KEY_UP       0x44
-#define KEY_DOWN     0x14
-#define KEY_LEFT     0x24
-#define KEY_RIGHT    0x28
-#endif
-
-
-#ifdef _KEY_308_1_
-#define KEY_BOTTOM1  0x3f                        /* first bottom button key value */
-#define KEY_BOTTOM2  0x5f
-#define KEY_BOTTOM3  0x60
-#define KEY_BOTTOM4  0x6f 
-#define KEY_BOTTOM5  0x50
-#define KEY_BOTTOM6  0x30
-#define KEY_BOTTOM7  0x03                        /*  */
-#define KEY_QUIT     0xfe 
-#define KEY_ESCAPE   0x18 
-#define KEY_FUN1L    0x7e
-#define KEY_FUN1R    0x7d
-#define KEY_FUN2L    0x41
-#define KEY_FUN2R    0x42
-#define KEY_FUN3L    0x21                        /*  */
-#define KEY_FUN3R    0x22
-#define KEY_FUN4L    0x11
-#define KEY_FUN4R    0x12
-#define KEY_FUN5L    0x09                        /*  */
-#define KEY_FUN5R    0x0a 
-#define KEY_FUN6L    0x05
-#define KEY_FUN6R    0x06
-#define KEY_ENTER    0x0c 
-#define KEY_ESC	     0x18                        /*  */
-#define KEY_F1       0x7b                        /* re-define */
-#define KEY_F2       0x77                        /* re-define */
-#define KEY_F3       0x44                        /* re-define */
-#define KEY_F4       0x48                        /* re-define */
-#define KEY_F5       0x24                        /* re-define */
-#define KEY_F6       0x28                        /* re-define */
-#define KEY_F7       0x14                        /* re-define */
-
-#define KEY_UP       0x44
-#define KEY_DOWN     0x14
-#define KEY_LEFT     0x24
-#define KEY_RIGHT    0x28
-#endif
-
-#ifdef _KEY_PC_
-#define KEY_BOTTOM1  '1'                       /* first bottom button key value */
-#define KEY_BOTTOM2  '2'
-#define KEY_BOTTOM3  '3'
-#define KEY_BOTTOM4  '4'
-#define KEY_BOTTOM5  '5'
-#define KEY_BOTTOM6  '6'
-#define KEY_BOTTOM7  '7'
-#define KEY_QUIT     'q'
-#define KEY_ESCAPE   '6'
-#define KEY_FUN1L    'y'
-#define KEY_FUN1R    'g'
-#define KEY_FUN2L    'u'
-#define KEY_FUN2R    'h'
-#define KEY_FUN3L    'i'
-#define KEY_FUN3R    'j'
-#define KEY_FUN4L    'o'
-#define KEY_FUN4R    'k'
-#define KEY_FUN5L    'p'
-#define KEY_FUN5R    'l'
-#define KEY_FUN6L    '['
-#define KEY_FUN6R    ';'
-#define KEY_ENTER    10
-#define KEY_ESC	     27
-#define KEY_F1       'z'                        /* re-define */
-#define KEY_F2       'x'                        /* re-define */
-#define KEY_F3       'c'                        /* re-define */
-#define KEY_F4       'v'                        /* re-define */
-#define KEY_F5       'b'                        /* re-define */
-#define KEY_F6       'n'                        /* re-define */
-#define KEY_F7       'm'                        /* re-define */
-#define KEY_F8       ','                        /* re-define */
-
-#define KEY_LEFT     'a'
-#define KEY_RIGHT    'd'
-#define KEY_UP       'w'
-#define KEY_DOWN     's'
-
-#define KEY_0        '0'
-#define KEY_1        '1' 
-#define KEY_2        '2' 
-#define KEY_3        '3'
-#define KEY_4        '4' 
-#define KEY_5        '5' 
-
-#define KEY_6        '6' 
-#define KEY_7        '7' 
-#define KEY_8        '8' 
-#define KEY_9        '9' 
-#define KEY_10       '-'                        /* # */
-#define KEY_11       '='                        /* * */
-#endif
-
-#endif   /* ----- #ifndef projectfixhead_INC  ----- */
diff --git a/src/EVA11/ProjectGBText.h b/src/EVA11/ProjectGBText.h
deleted file mode 100644
index ffeed38..0000000
--- a/src/EVA11/ProjectGBText.h
+++ /dev/null
@@ -1,770 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ProjectGBText.h
- *
- *    Description:  The file define the Texts used by Programme with GB2312 Code
- *
- *        Version:  1.0
- *        Created:  20120605 13ʱ4955
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun (XIAMEN)
- *
- * =====================================================================================
- */
-
-#ifndef  _PROGBTEXT_INC
-#define  _PROGBTEXT_INC
-
-#define MAINTITLE_CN                "EVA-11ɱ"
-
-#define DETECT_CN		    ""
-#define PARAM_CN                    ""
-#define DEBUG_CN  		    ""
-#define ALARM_CN   		    ""
-#define ANALYZE_CN 		    ""
-#define LAYOUT_CN                   "" 
-#define OTHERS_CN  		    ""
-
-#define PREVIOUSE_CN                ""
-#define NEXT_CN                     ""
-#define LEFTC_CN                    ""
-#define RIGHTC_CN                   ""
-
-#define COMFIRM_CN	 	    "ȷ"
-#define BACKOUT_CN		    "˳"
-
-#define SUBTITLE_CN                 "ѡ"
-#define MAINBUTTON_CN               "ͨ"
-#define RESERVE_CN                  "Ԥ"
-#define	CANCEL_CN		    "ȡ"	 
-#define COMFIRMEXIT_CN		    "ȷҪ˳" 
-#define INFORMESG09_CN              " : Ӳػ飡"
-#define INFORMESG08_CN              "ؼľ뾡챣ػ"
-
-#define SCREEN_CN		    "迹ͼ"
-#define CHANNEL_CN		    "ŵ"
-#define HDGAIN_CN   		    "ǰ"
-#define FREQUENCEVALUE_CN           "Ƶֵ"
-#define DRIVER_CN  		    ""
-#define OFFSET_CN  		    "ƫ"
-
-#define PROBE_CN                    "̽ͷ"
-#define FREQUENCE_CN                "Ƶ"
-#define DIFILTER_CN 		    "˲"
-
-#define GAIN_CN 		    ""
-#define PHASE_CN   		    "λ"
-#define HIFILTER_CN 		    "ͨ˲"
-#define LOFILTER_CN 		    "ͨ˲"
-#define CRAFTPARA_CN		    "ղ"
-
-#define	SAVEPARAM_CN		    ""
-#define	LOADPARAM_CN		    "ȡ"
-#define	DELPARAM_CN                 "ɾ"
-#define SUB_TITLE2_CN               "˵"
-#define SUB_TITLE3_CN               "˵"
-#define EXCUTE_CN   		    "ִ"
-
-#define LOADEMPTYDOC_CN             "λûĵ޷ȡ"
-#define DELEMPTYDOC_CN              "λûĵ޷ɾ"
-#define OVERWRITECHECK_CN           "ĵ! ȷ"
-#define INFO_PASSWORD_CN            ",[ȷ]"
-#define INFO_PD_INVAIL_CN           "Чûȡ"
-#define	CLOSED_CN		    ""
-
-#define HELPTITLE1_CN               "            EVA-11ɱ"
-#define HELPTITLE2_CN               "===================================="
-#define HELPB1F1_CN                 "  [  F1    ]      /˳ϵͳ"
-#define HELPB1F2_CN                 "  [  F2    ]       | Ƭ"
-#define HELPB1F3_CN                 "  [  F3    ]      ʾʽ ->->"
-#define HELPB1F3_O_CN               "  [  F3    ]      ʾʽ ->->"
-#define HELPB1F5_CN                 "  [  F5    ]      ȡĻ" 
-#define HELPB1F4_CN                 "  [  F4    ]      ƽ | Ƭ"
-#define HELPB1F6_CN                 "  [  F6    ]      " 
-#define HELPB1F7_CN                 "  [  F7    ]      ץȡ/Ƶ" 
-#define HELPB1ESC_CN                "  [  ESC   ]      ͣ⣬ص" 
-#define HELPB1ENTER_CN              "  [  ENTER ]      "
-
-#define GRAPHICFILE_CN              "ͼļ"
-#define GRAPHICSAVE_CN              "Ƿ񱣴?"
-#define INFORMESG10_CN              "޷ͼƬ"
-
-#define	VIDEODISPLAY_CN		    "Ƶʾ"
-#define COLORDISPLAY_CN		    "ɫʾ"
-#define SIGZKDISPLAY_CN		    "迹ʾ"
-#define INFORMESG22_CN              "޷ʼƵ̽ͷ"
-
-#define	SAVEDATA_CN		    ""
-#define LOADDATA_CN		    "ȡ"
-#define DELEDATA_CN		    "ɾ"
-
-#define	UPDATEPRO_CN		    ""
-#define	UPDATECOMFIRM_CN	    "Ƿг?"
-#define TRANINFO1_CN                "ڽԵ......" 
-#define	ALLGAIN_CN		    "ɫ"
-
-#define VIDEOOPEN_CN		    "Ƶ"
-#define VIDEOCLOSE_CN		    "رƵ"
-#define ADJRES_CN		    "ֱ"
-#define AUTODI_CN  		    "Զ"
-#define PAGE5_CN                    " 5 ҳ"
-
-#define CHCOL_CN	   	    ""
-#define PGUP_CN    		    "ҳ"
-#define PGDN_CN    		    "ҳ" 
-
-#define BLANK_CN                    ""
-#define	DATAFILE_CN                 "ļ"
-
-#define LOADDATA1_CN                "ڶȡԵ......"
-#define SAVEDATA1_CN                "ڱԵ......"
-
-#define LANGUAGE_CN                 ""
-#define LAN_VALUE_CN                ""
-
-#define DZKDISPLAY_CN		    "˫ʾ"
-
-#define DATE_CN			    "ǰ"
-#define TIME_CN			    "ǰʱ"
-#define VERSION_CN		    "汾˵"
-
-#define ABOUTMSG1_CN                "    ˵  "
-#define ABOUTMSG2_CN                "ӭʹSmartϵϵͳ"
-#define ABOUTMSG21_CN               "ϵͳ汾ΪV"
-#define ABOUTMSG22_CN               " ʹ"
-#define ABOUTMSG3_CN                "κҪеַϵ"
-#define ABOUTMSG4_CN                "ɭ()޹˾"
-#define ABOUTMSG5_CN                "ַź·57ŽԴ19A"
-#define ABOUTMSG6_CN                "绰0592-2211133  0592-2230833"
-#define ABOUTMSG7_CN                "棺0592-2237091"
-#define ABOUTMSG8_CN                "ַWWW.EDDYSUN.COM"
-
-#define SAMPLETYPE_CN		    "ģʽ" 
-#define INSIDESAMP_CN		    "ڲʱ" 
-#define	OUTSIDESAMP_CN		    "ⲿ"
-#define	STIMEINTER_CN		    ""
-#define	SAMPPLUS_CN		    ""
-
-#define	COLORSPOTDM_CN		    "ʾģʽ"
-#define	DISPMOD_3D_CN		    "3D ʾ"
-#define	DISPMOD_2D_CN		    "2D ʾ"
-
-#define SCANSPEED_CN		    "ɨٶ"
-
-#define EDDYNETWORK_CN		    "       "
-
-#define IPMESG_CN		    "IP  192.168.1.120  ˿ں 5200"
-#define	ERRORMSG1_CN		    "޷ʼ ˳"
-
-#define INFORMESG07_CN		    "³ɹ!"
-#define INFORMESG06_CN		    "ʧܣٴθ!"
-
-#define	SYSTEMDATE_CN		    "ϵͳ"
-#define	SYSTEMTIME_CN		    "ϵͳʱ"
-
-#define INFORMESG21_CN              "...... δְĵ"
-#define	DELETE_CN		    "ɾ"
-#define	DELETEHELP_CN		    "ɾĵɹ"
-#define	PICMANAGE_CN		    "ͼƬ"
-#define	PREVIEW_CN		    "Ԥ"
-#define PREPIC_CN		    "ԤͼƬ"
-#define	PICFILE_CN	            "ͼƬļ"
-#define	PREVIEWPIC_CN		    "ͼƬԤ....ESC˳"
-#define	DELPICFILE_CN		    "ɾͼƬļɹ"
-
-#define	ALARMTYPE_CN		    ""
-#define	ALARMACOUNT_CN		    "Ŀ"
-#define ALARMBEEP_CN                ""
-#define	ALARMOUT_CN		    ""
-#define	ALARMDISP_CN	            "ʾ"
-
-#define	ALARMWINS_CN		    "  "
-
-#define LEFTLIMIT_CN  		    "  "
-#define RIGHTLIMIT_CN 		    "  "
-#define UPLIMIT_CN    		    "  "
-#define DOWNLIMIT_CN  		    "  "
-
-#define DEGREE1_CN  		    "Ƕ 1"
-#define DEGREE2_CN  		    "Ƕ 2"
-#define XHALF_CN  		    "X 뾶"
-#define YHALF_CN  		    "Y 뾶"
-
-#define	RECTALARM_CN		    ""
-#define	AMPALARM_CN		    ""
-#define	HAMPALARM_CN		    ""
-#define ALARMWINMENU_CN  	    ""
-#define OPEN_CN			    ""
-#define	DEFAULT_CN		    "Ĭϲ"
-#define	RESTORE_CN		    "ָ"
-#define RESTOREDEFAULT_CN	    "Ƿָ?"
-#define REBOOTMSG_CN		    "ָɣ!"	
-#define	CLEANBUF_CN		    "Ƿݻ?"
-
-#define	RUNTIME_CN		    "ʱ"
-#define	KEYBEEP_CN		    ""
-
-#define SHUTDOWNMSG1_CN             "      "
-#define SHUTDOWNMSG2_CN             "          ,     !"
-
-#define TIMESCALE_CN		    "ʱʾ"
-#define TIMESCALESPEED_CN	    "ʱٶ"
-
-#define MIXINGINFO1_CN		    "ڽлƵ......" 
-
-#define PRIFREQ_CN		    "S1 Ƶֵ"
-#define SECFREQ_CN		    "S2 Ƶֵ"
-#define MIXFACTOR_CN		    "Ƶϵ"
-
-#define MIXFACTORCOMFIRM_CN	    "ǷָĬϵĻƵϵ?"
-#define SAVEMIXCOMFIRM_CN	    "Ƿ񱣴˴λƵ?"
-
-#define X1POINT_CN		    "ƫ X1"
-#define Y1POINT_CN		    "ƫ Y1"
-#define X2POINT_CN		    "ƫ X2"
-#define Y2POINT_CN		    "ƫ Y2"
-
-#define XNPOINT_CN		    "ƫ Xn"
-#define YNPOINT_CN		    "ƫ Yn"
-
-#define	GAINRATIO_CN		    ""
-#define CLEANPHOTO_CN		    "ǷƬͼ?"
-
-#define OZKDISPLAY_CN		    "ģʽ"
-#define SCOPE_CN		    "÷Χ"
-#define WHOLE_CN		    "ȫͨ"
-
-#define CROSSCHAN_CN		    "ŵ"
-#define ALARMLIMIT_CN		    ""
-
-#define COMBINING_CN		    "ģʽ"
-#define ASCANCHAN_CN		    "Aɨŵ"
-#define EMSGAIN_CN		    "ż"
-#define ASCANSPEED_CN		    "Aɨٶ"
-
-#define PARASYNC_CN		    "ͬ"
-#define PARASYNCCOMFIRM_CN	    "Ƿ񽫸ͨ桢λͬͨ?"
-
-#define RESBALACE_CN		    "ƽ"
-#define ADRIVE_CN 		    "·A"
-#define BDRIVE_CN 		    "·B"
-#define APICK_CN 		    "յ·A"
-#define BPICK_CN 		    "յ·B"
-
-#define RFFILTER_CN		    "RF˲"
-#define PRECISION_CN		    ""
-#define PREHIGH_CN		    ""
-#define PREMED_CN		    ""
-#define PRELOW_CN		    ""
-
-#define OPERATION_CN		    "־"
-
-#define	NONE_CN			    "  "
-/* ********************************************************************  */
-
-#define MAINTITLE_EN                "EVA-11 Variable Array Eddy Current Instrument"
-
-#define DETECT_EN		    "Detect"
-#define PARAM_EN                    "Parameter"
-#define DEBUG_EN   		    "Debug"
-#define ALARM_EN   		    "Alarm"
-#define ANALYZE_EN 		    "Analyze"
-#define LAYOUT_EN                   "Disp.Mode" 
-#define OTHERS_EN  		    "Others"
-
-#define PREVIOUSE_EN                "  Up  "
-#define NEXT_EN                     " Down "
-#define LEFTC_EN                    " Left "
-#define RIGHTC_EN                   " Right"
-
-#define COMFIRM_EN	 	    " O.K. "
-#define BACKOUT_EN		    " Exit "
-
-#define SUBTITLE_EN                 "Sel. Para."
-#define MAINBUTTON_EN               "Standard Testing"
-#define RESERVE_EN                  "Reserve"
-#define	CANCEL_EN		    "Cancel"	 
-#define COMFIRMEXIT_EN		    "Do you want to quit?"
-#define INFORMESG08_EN              "Discharge Off Soon, Pls. Save!"
-#define INFORMESG09_EN              "Hardware Error,Shutdown&Check!"
-#define SCREEN_EN		    "Screen No."
-#define CHANNEL_EN		    "Sig.Chan."
-#define HDGAIN_EN   		    "Prob.Gain"
-#define FREQUENCEVALUE_EN           "Freq.Value"
-#define DRIVER_EN  		    "Driver"
-#define OFFSET_EN  		    "Offset"
-
-#define PROBE_EN                    "Probe"
-#define FREQUENCE_EN                "Freq.Index"
-#define DIFILTER_EN 		    "Filter"
-
-#define GAIN_EN 		    "Gain"
-#define PHASE_EN   		    "Phase"
-#define HIFILTER_EN 		    "Hi.Pass"
-#define LOFILTER_EN 		    "Lo.Pass"
-#define CRAFTPARA_EN		    "Parameters"
-
-#define	SAVEPARAM_EN		    "Save Para."
-#define	LOADPARAM_EN		    "Load Para."
-#define	DELPARAM_EN                 "Del Para."
-#define SUB_TITLE2_EN               "Lv.2 Menu"
-#define SUB_TITLE3_EN               "Lv.3 Menu"
-#define EXCUTE_EN   		    "Excute"
-#define LOADEMPTYDOC_EN             "No File Found, Can't Load!"
-#define DELEMPTYDOC_EN              "No File Found, Can't Delete!"
-#define OVERWRITECHECK_EN           "File Exist! Overwrite?"
-#define INFO_PASSWORD_EN            "Enter Password, Push [Enter] Key to Confirm"
-#define INFO_PD_INVAIL_EN           "Password Invalidity or Cancelled by User"
-#define	CLOSED_EN		    "Closed"
-
-#define HELPTITLE1_EN               "EVA-11 Variable Array Eddy Current Instrument"
-#define HELPTITLE2_EN               "==============================================="
-#define HELPB1F1_EN                 "  [  F1    ]      Enter/Quit Help System"
-#define HELPB1F2_EN                 "  [  F2    ]      Clean Screen | Make Plate"
-#define HELPB1F3_EN                 "  [  F3    ]      Mode: Point->Lin.->Aut."
-#define HELPB1F3_O_EN               "  [  F3    ]      Mode: Point->Lin.->Spe."
-#define HELPB1F5_EN                 "  [  F5    ]      Save Screen" 
-#define HELPB1F4_EN                 "  [  F4    ]      Balance | Clean Plate"
-#define HELPB1F6_EN                 "  [  F6    ]      Clean Buffer" 
-#define HELPB1F7_EN                 "  [  F7    ]      Mixing Signal" 
-#define HELPB1ESC_EN                "  [  ESC   ]      Pause DetectReturn" 
-#define HELPB1ENTER_EN              "  [  ENTER ]      Resume to Detect"
-#define GRAPHICFILE_EN              "PIC file"
-#define GRAPHICSAVE_EN              "be Saved?" 
-#define INFORMESG10_EN              "Buffer full,Can't save file!"
-
-#define	VIDEODISPLAY_EN		    "Video"
-#define COLORDISPLAY_EN		    "Color.Belt"
-#define SIGZKDISPLAY_EN		    "Impedance"
-#define INFORMESG22_EN              "Unable to init Video Probe "
-
-#define	SAVEDATA_EN		    "Save Data"
-#define LOADDATA_EN		    "Load Data"
-#define DELEDATA_EN		    "Del  Data"
-
-#define	UPDATEPRO_EN		    "Update Pro."
-#define	UPDATECOMFIRM_EN	    "Update Application or Not?"
-#define TRANINFO1_EN                "Transmit.... Wait Please"
-#define	ALLGAIN_EN		    "CD. Gain"
-
-#define VIDEOOPEN_EN		    "Open Video"
-#define VIDEOCLOSE_EN		    "Close Video"
-#define ADJRES_EN		    "Resolution"
-#define AUTODI_EN  		    "Disp.Delay"
-#define PAGE5_EN                    "Total 5 Pages"
-
-#define CHCOL_EN	   	    "  Row "
-#define PGUP_EN    		    " PgUp "
-#define PGDN_EN    		    " PgDn "
-
-#define BLANK_EN                    "Blank"
-#define DATAFILE_EN                 "Data File"
-
-#define LOADDATA1_EN                "Data Load... Wait Please"
-#define SAVEDATA1_EN                "Data Save... Wait Please"
-
-#define LANGUAGE_EN                 "Language"
-#define LAN_VALUE_EN                "English"
-
-#define DZKDISPLAY_EN		    "Double Imp."
-
-#define DATE_EN			    "Date"
-#define TIME_EN			    "Time"
-#define VERSION_EN		    "Version"
-
-#define ABOUTMSG1_EN                "Version Information"
-#define ABOUTMSG2_EN                "Welcome to use ECT of Smart series."
-#define ABOUTMSG21_EN               "VER.: V"
-                                 
-#define ABOUTMSG22_EN               "When you have" 
-#define ABOUTMSG3_EN                "any question, please contact"
-#define ABOUTMSG4_EN                "Eddysun(Xiamen)Electronics Co.,Ltd"
-#define ABOUTMSG5_EN                "Addr.:Hubinnan Road No.57 Jinyuan"
-				        
-#define ABOUTMSG7_EN                "Tel:0592-2211133  0592-2230833"
-#define ABOUTMSG6_EN                "19A Xiamen China. Fax:0592-2237091"
-#define ABOUTMSG8_EN                "Web:WWW.EDDYSUN.COM"
-
-#define SAMPLETYPE_EN		    "Samp. Type" 
-#define INSIDESAMP_EN		    "In. Clock" 
-#define	OUTSIDESAMP_EN		    "Out. Plus"
-#define	STIMEINTER_EN		    "Samp.Inter."
-#define	SAMPPLUS_EN		    "Samp.Plus"
-
-#define	COLORSPOTDM_EN		    "Disp.Mode"
-#define	DISPMOD_3D_EN		    "3D Mode"
-#define	DISPMOD_2D_EN		    "2D Mode"
-
-#define SCANSPEED_EN		    "Scan Speed"
-
-#define EDDYNETWORK_EN		    "Eddy Detect Network Interface"
-#define IPMESG_EN		    "Device IP  192.168.1.1  Port 5200"
-#define	ERRORMSG1_EN		    "Init Networking fail! Exit Programe!"
-
-#define INFORMESG07_EN		    "Update successfully! Reboot App!"
-#define INFORMESG06_EN		    "Update failPlease try again!"
-
-#define	SYSTEMDATE_EN		    "Sys.Date"
-#define	SYSTEMTIME_EN		    "Sys.Time"
-#define INFORMESG21_EN              "...... Not Help Document Found"
-#define	DELETE_EN		    "Delete"
-#define	DELETEHELP_EN		    "Delete Help Doc. Successfully"
-#define	PICMANAGE_EN		    "PIC.Manage"
-#define	PREVIEW_EN		    "Preview"
-#define PREPIC_EN		    "Preview Picture"
-#define	PICFILE_EN	            "Pic.File"
-
-#define	PREVIEWPIC_EN		    "Picture Preview....Push [ESC] Exit"
-#define	DELPICFILE_EN		    "Delete Pictrue Doc. Successfully"
-
-#define	ALARMTYPE_EN		    "Ala.Type"
-#define	ALARMACOUNT_EN		    "Ala.Count"
-#define ALARMBEEP_EN                "Ala.Beep"
-#define	ALARMOUT_EN		    "Ala.Output"
-#define	ALARMDISP_EN	            "Ala.Disp."
-
-#define	ALARMWINS_EN		    "Ala.Region"
-
-#define LEFTLIMIT_EN  		    "L.Border"
-#define RIGHTLIMIT_EN 		    "R.Border"
-#define UPLIMIT_EN    		    "U.Border"
-#define DOWNLIMIT_EN  		    "D.Border"
-
-#define DEGREE1_EN  		    "Angle 1"
-#define DEGREE2_EN  		    "Angle 2"
-#define XHALF_EN  		    "X Radius"
-#define YHALF_EN  		    "Y Radius"
-
-#define	RECTALARM_EN		    "Rectangle"
-#define	AMPALARM_EN		    "Amp-Pha"
-#define	HAMPALARM_EN		    "H-Amp-Pha"
-#define ALARMWINMENU_EN  	    "Region No."
-#define OPEN_EN			    "Open"
-#define	DEFAULT_EN		    "Def.Val."
-#define	RESTORE_EN		    "Restore"
-#define RESTOREDEFAULT_EN	    "Restore to Default Value?"
-#define REBOOTMSG_EN		    "Restore Parameters OK! Reboot App!"	
-#define	CLEANBUF_EN		    "Clean Up Data Buffer?"
-#define	RUNTIME_EN		    "Run Time"
-#define	KEYBEEP_EN		    "Key Beep"
-
-#define SHUTDOWNMSG1_EN            "Shutdown Waiting"
-#define SHUTDOWNMSG2_EN            "Please Waiting, Shutdown Device ...."
-
-#define TIMESCALE_EN		    "Chart Disp."
-#define TIMESCALESPEED_EN	    "Chart Speed"
-
-#define MIXINGINFO1_EN		    "Mixing Frequence Calculating......" 
-
-#define PRIFREQ_EN		    "Pri.Freq."
-#define SECFREQ_EN		    "Sec.Freq."
-#define MIXFACTOR_EN		    "Mix.Factor"
-
-#define MIXFACTORCOMFIRM_EN	    "Restore to default Mix. factor?"
-#define SAVEMIXCOMFIRM_EN	    "Save the Mixing result?"
-
-#define X1POINT_EN		    "Offset X1"
-#define Y1POINT_EN		    "Offset Y1"
-#define X2POINT_EN		    "Offset X2"
-#define Y2POINT_EN		    "Offset Y2"
-
-#define XNPOINT_EN		    "Offset Xn"
-#define YNPOINT_EN		    "Offset Yn"
-
-#define	GAINRATIO_EN		    "X/Y Ratio"
-#define CLEANPHOTO_EN		    "Clean Plate, OK?"
-
-#define OZKDISPLAY_EN		    "Quad.Patern"
-#define SCOPE_EN		    "Scope"
-#define WHOLE_EN		    "All Chan."
-
-#define CROSSCHAN_EN		    "Quad.Chan."
-#define ALARMLIMIT_EN		    "Alarm Limit"
-
-#define COMBINING_EN		    "Combining"
-#define ASCANCHAN_EN		    "AScan Chan."
-#define EMSGAIN_EN		    "EMS Gain"
-#define ASCANSPEED_EN		    "AScan Speed"
-
-#define PARASYNC_EN		    "Para.Sync."
-#define PARASYNCCOMFIRM_EN	    "Sync. Chan. Gain and Phase to other Chan.?"
-
-#define RESBALACE_EN		    "Res.Balance"
-#define ADRIVE_EN 		    "Driver A"
-#define BDRIVE_EN 		    "Driver B"
-#define APICK_EN 		    "Pick A"
-#define BPICK_EN 		    "Pick B"
-
-#define RFFILTER_EN		    "RF Filter"
-#define PRECISION_EN		    "Precision"
-#define PREHIGH_EN		    "High"
-#define PREMED_EN		    "Medial"
-#define PRELOW_EN		    "Low"
-
-#define OPERATION_EN		    "Oper.Log"
-
-#define	NONE_EN			    "  "
-/* ********************************************************************  */
-
-#define MAINTITLE		    0 
-
-#define DETECT			    1
-#define PARAM			    2
-#define DEBUG			    3
-#define ALARM			    4
-#define ANALYZE			    5
-#define LAYOUT			    6
-#define OTHERS		   	    7  
-                                    
-#define PREVIOUSE		    8
-#define NEXT			    9
-#define LEFTC			    10
-#define RIGHTC			    11  
-                                    
-#define COMFIRM			    12
-#define BACKOUT			    13
-#define SUBTITLE                    14 
-#define MAINBUTTON                  15 
-#define RESERVE			    16
-#define	CANCEL			    17
-#define COMFIRMEXIT		    18
-
-#define	INFORMESG08		    19
-#define	INFORMESG09		    20
-
-#define	SCREEN			    21
-#define CHANNEL			    22
-#define HDGAIN   		    23 
-#define FREQUENCEVALUE              24 
-#define DRIVER  		    25 
-#define OFFSET  		    26 
-
-#define PROBE			    27
-#define FREQUENCE                   28
-#define DIFILTER                    29 
-
-#define GAIN                        30
-#define PHASE                       31
-#define HIFILTER                    32
-#define LOFILTER                    33
-#define CRAFTPARA		    34
-
-#define SAVEPARAM		    35
-#define LOADPARAM                   36
-#define DELPARAM                    37
-#define SUB_TITLE2 		    38
-#define EXCUTE			    39
-
-#define LOADEMPTYDOC                40
-#define DELEMPTYDOC                 41
-#define OVERWRITECHECK              42
-#define INFO_PASSWORD               43
-#define INFO_PD_INVAIL              44
-#define	CLOSED			    45
-
-#define HELPTITLE1                  47
-#define HELPTITLE2                  48
-#define HELPB1F1                    49
-#define HELPB1F2                    50
-#define HELPB1F3                    51
-#define HELPB1F5                    52
-#define HELPB1F4                    53
-#define HELPB1F6                    54
-#define HELPB1F7                    55
-#define HELPB1ESC                   56
-#define HELPB1ENTER                 57
-#define GRAPHICFILE                 58
-#define GRAPHICSAVE                 59
-#define INFORMESG10                 60
-
-#define VIDEODISPLAY		    61
-#define COLORDISPLAY		    62
-#define SIGZKDISPLAY	            63
-#define INFORMESG22                 64
-
-#define	SAVEDATA		    65
-#define LOADDATA 		    66
-#define DELEDATA		    67
-
-#define SUB_TITLE3    	   	    68           
-#define	UPDATEPRO		    69
-#define	UPDATECOMFIRM	    	    70 
-#define TRANINFO1                   71
-#define	ALLGAIN		   	    72 
-
-#define VIDEOOPEN		    73
-#define VIDEOCLOSE		    74
-#define ADJRES			    75
-#define AUTODI			    76
-#define PAGE5                       77 
-
-#define CHCOL			    78
-#define PGUP			    79
-#define PGDN			    80
-
-#define BLANK			    81
-#define DATAFILE                    82
-
-#define LOADDATA1		    83
-#define SAVEDATA1		    84
-
-#define LANGUAGE                    85 
-#define LAN_VALUE                   86 
-
-#define DZKDISPLAY		    87
-
-#define DATE			    88	
-#define TIME			    89	
-#define VERSION		   	    90 
-
-#define ABOUTMSG1 		    91
-#define ABOUTMSG2                   92
-#define ABOUTMSG21                  93
-                  
-#define ABOUTMSG22                  94
-#define ABOUTMSG3                   95
-#define ABOUTMSG4		    96 
-#define ABOUTMSG5                   97
-		  
-#define ABOUTMSG7                   98 
-#define ABOUTMSG6                   99
-#define ABOUTMSG8                   100
-
-#define SAMPLETYPE		    101 
-#define INSIDESAMP		    102 
-#define	OUTSIDESAMP		    103 
-#define	STIMEINTER		    104 
-#define	SAMPPLUS		    105 
-
-#define	COLORSPOTDM		    106 
-
-#define	DISPMOD_3D		    107 
-#define	DISPMOD_2D		    108 
-
-#define SCANSPEED		    109 
-
-#define EDDYNETWORK		    110
-#define IPMESG		    	    111 
-#define	ERRORMSG1		    112
-
-#define INFORMESG07		    113
-#define INFORMESG06		    114
-
-#define	SYSTEMDATE		    115
-#define	SYSTEMTIME		    116
-
-#define INFORMESG21		    117
-#define	DELETE			    118
-#define	DELETEHELP		    119 
-#define	PICMANAGE 		    120
-#define	PREVIEW			    121
-#define PREPIC			    122
-#define	PICFILE			    123
-#define	PREVIEWPIC		    124
-#define	DELPICFILE		    125
-
-#define	ALARMTYPE		    126 
-#define	ALARMACOUNT                 127
-#define ALARMBEEP                   128 
-#define	ALARMOUT		    129 
-#define	ALARMDISP	            130 
-
-#define	ALARMWINS		    131 
-
-#define LEFTLIMIT  		    132 
-#define RIGHTLIMIT 		    133 
-#define UPLIMIT    		    134 
-#define DOWNLIMIT  		    135 
-
-#define DEGREE1  		    136 
-#define DEGREE2  		    137 
-#define XHALF  		    	    138 
-#define YHALF  		    	    139 
-
-#define	RECTALARM		    140 
-#define	AMPALARM		    141 
-#define	HAMPALARM		    142 
-#define ALARMWINMENU  	    	    143 
-
-#define OPEN			    144 
-#define	DEFAULT		     	    145 
-#define	RESTORE		   	    146 
-#define RESTOREDEFAULT              147
-#define REBOOTMSG		    148
-#define	CLEANBUF		    149 
-#define	RUNTIME			    150
-#define	KEYBEEP		   	    151
-
-#define SHUTDOWNMSG1		    152
-#define SHUTDOWNMSG2                153
-#define TIMESCALE		    154
-#define TIMESCALESPEED	    	    155	
-#define MIXINGINFO1                 156
-
-#define PRIFREQ			    157
-#define SECFREQ                     158
-#define MIXFACTOR	   	    159 
-#define MIXFACTORCOMFIRM            160
-#define SAVEMIXCOMFIRM		    161
-
-#define X1POINT			    162
-#define Y1POINT                     163
-#define X2POINT			    164
-#define Y2POINT			    165
-
-#define	GAINRATIO		    166
-#define CLEANPHOTO		    167
-
-#define OZKDISPLAY		    168 
-
-#define XNPOINT			    169
-#define YNPOINT			    170
-
-#define SCOPE			    171
-#define WHOLE			    172
-
-#define CROSSCHAN		    173
-#define ALARMLIMIT		    174
-
-#define COMBINING		    175
-
-#define ASCANCHAN		    176
-#define EMSGAIN			    177
-
-#define ASCANSPEED		    178
-#define HELPB1F3_O                  179 
-#define PARASYNC		    180
-#define PARASYNCCOMFIRM		    181
-
-#define RESBALACE		    182	
-#define ADRIVE 		    	    183
-#define BDRIVE 		            184 
-#define APICK 		  	    185 
-#define BPICK 		            186 
-#define RFFILTER		    187
-
-#define PRECISION		    188
-#define PREHIGH			    189
-#define PREMED 			    190
-#define PRELOW                      191
-#define OPERATION		    192 
-
-#define	NONE			    999
-
-#define CSTRING_A		    "A"
-#define CSTRING_B		    "B"
-#define CSTRING_C		    "C"
-#define CSTRING_D		    "D"
-#define CSTRING_E		    "E"
-#define CSTRING_F		    "F"
-#define CSTRING_G		    "G"
-#define CSTRING_H		    "H"
-
-#define	TEST			   "л񹲺͹GB2312"
-#define GGG			   ''
-#endif
-//#endif   /* ----- #ifndef _progbtext_INC  /
diff --git a/src/EVA11/Resource.cpp b/src/EVA11/Resource.cpp
deleted file mode 100644
index d18ee0f..0000000
--- a/src/EVA11/Resource.cpp
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Resource.cpp
- *
- *    Description:  Implementation of Resource class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 10时25分07秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<fstream>
-
-#include 	"Graphic.h"
-#include	"Global.h"
-#include 	"Resource.h"
-#include	"JpegOper.h"
-#include 	"Png.h"
-#include 	"Gif.h"
-
-#define		TEMPFILEPATH		"/var/"
-
-extern "C"
-{
-	extern char _binary_JPGS_backscreen_png_start;
-	extern int _binary_JPGS_backscreen_png_size;
-
-	extern char _binary_JPGS_startup_jpg_start;
-	extern int _binary_JPGS_startup_jpg_size;
-
-	/* i120 * 90 */
-	extern char _binary_JPGS_video_jpg_start;
-	extern int _binary_JPGS_video_jpg_size;
-
-	extern char _binary_JPGS_colorspot_jpg_start;
-	extern int _binary_JPGS_colorspot_jpg_size;
-
-	extern char _binary_JPGS_zkscreen_jpg_start;
-	extern int _binary_JPGS_zkscreen_jpg_size;
-
-	extern char _binary_JPGS_dzkscreen_jpg_start;
-	extern int _binary_JPGS_dzkscreen_jpg_size;
-
-	extern char _binary_JPGS_ozkscreen_jpg_start;
-	extern int _binary_JPGS_ozkscreen_jpg_size;
-
-	extern char _binary_JPGS_czkscreen_jpg_start;
-	extern int _binary_JPGS_czkscreen_jpg_size;
-
-	extern char _binary_JPGS_eddysunlogo_png_start;
-	extern int _binary_JPGS_eddysunlogo_png_size;
-
-	extern char _binary_JPGS_stop_png_start;
-	extern int _binary_JPGS_stop_png_size;
-
-	extern char _binary_JPGS_run_png_start;
-	extern int _binary_JPGS_run_png_size;
-
-	extern char _binary_JPGS_splash_gif_start;
-	extern int _binary_JPGS_splash_gif_size;
-}
-
-std::auto_ptr<Resource> Resource::m_Instance;
-
-Resource::Resource ()
-{
-	m_Initflag = false;
-	filename   = NULL;
-	filename   = new char[60];
-}
-
-Resource::~Resource ()
-{
-	if ( filename != NULL )
-	{
-		delete[] filename;
-		filename = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Resource* Resource::Instance()
-{
-	if ( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Resource() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance_Resource
- *  Description:  Instance the resource of jpeg 
- * =====================================================================================
- */
-bool Resource::Instance_Resource(const char* path, int index)
-{
-	int length;
-	char *addr;
-
-	switch ( index ) 
-	{
-		case 1:
-			length = (int)(&_binary_JPGS_backscreen_png_size);
-			addr   = &_binary_JPGS_backscreen_png_start;
-			break;
-		case 2: 
-			length = (int)(&_binary_JPGS_startup_jpg_size);
-			addr   = &_binary_JPGS_startup_jpg_start;
-			break;
-		case 3:
-			length = (int)(&_binary_JPGS_video_jpg_size);
-			addr   = &_binary_JPGS_video_jpg_start;
-			break;
-		case 4:
-			length = (int)(&_binary_JPGS_colorspot_jpg_size);
-			addr   = &_binary_JPGS_colorspot_jpg_start;
-			break;
-		case 5:
-			length = (int)(&_binary_JPGS_zkscreen_jpg_size);
-			addr   = &_binary_JPGS_zkscreen_jpg_start;
-			break;
-		case 6:
-			length = (int)(&_binary_JPGS_dzkscreen_jpg_size);
-			addr   = &_binary_JPGS_dzkscreen_jpg_start;
-			break;
-		case 7:
-			length = (int)(&_binary_JPGS_eddysunlogo_png_size);
-			addr   = &_binary_JPGS_eddysunlogo_png_start;
-			break;
-		case 8:
-			length = (int)(&_binary_JPGS_stop_png_size);
-			addr   = &_binary_JPGS_stop_png_start;
-			break;
-		case 9:
-			length = (int)(&_binary_JPGS_run_png_size);
-			addr   = &_binary_JPGS_run_png_start;
-			break;
-		case 10:
-			length = (int)(&_binary_JPGS_ozkscreen_jpg_size);
-			addr   = &_binary_JPGS_ozkscreen_jpg_start;
-			break;
-		case 11:
-			length = (int)(&_binary_JPGS_czkscreen_jpg_size);
-			addr   = &_binary_JPGS_czkscreen_jpg_start;
-			break;
-		case 12:
-			length = (int)(&_binary_JPGS_splash_gif_size);
-			addr   = &_binary_JPGS_splash_gif_start;
-			break;
-	}				/* -----  end switch  ----- */
-
-	std::ofstream oo;
-	oo.open(path,std::ofstream::binary|std::ofstream::trunc);
-	if ( !oo )
-	{
-		perror("can't open the /var/%s");
-		return false;
-	}
-	else
-	{
-		for ( int i=0;i<length;i++ )
-		{
-			oo<<*addr;
-			addr ++;
-		}
-		oo.flush();
-	}
-	oo.close();
-	sync();
-
-	return true;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Resource_Jpeg
- *  Description:  Very important function show JPEG file onto screen 
- * =====================================================================================
- */
-void Resource::Show_Resource_Jpeg(Graphic& g,int index,
-				       int Jpeg_x,int Jpeg_y,
-				       int fb_x,int fb_y,
-				       int Play_width,int Play_height)
-{
-	sprintf ( filename,"%s1.jpeg",TEMPFILEPATH );
-	Instance_Resource(filename,index);
-	if ( access(filename,0) == 0 )
-	{
-		m_Jpeg     = new JpegOper;
-		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
-		m_Initflag = true;
-
-		m_Jpeg->JpegSetJpegPara(filename,5,5,JCS_RGB);
-		m_Jpeg->JpegReadJpegFile();
-		m_Jpeg->JpegPlayJpeg(Jpeg_x,Jpeg_y,fb_x,fb_y,Play_width,Play_height);
-
-		delete m_Jpeg;
-		m_Jpeg = NULL;
-
-		remove(filename);
-		sync();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Resource_Png
- *  Description:  Very important function show PNG file onto screen 
- * =====================================================================================
- */
-void Resource::Show_Resource_Png(Graphic& g,const int& index,const int& x,const int& y)
-{
-	sprintf ( filename,"%s1.png",TEMPFILEPATH );
-	Instance_Resource(filename,index);
-
-	if ( access(filename,0) == 0 )
-	{
-		Png *png = new Png;
-		png->Read_PNG_File(g,filename,x,y);
-		delete png;
-		png = NULL;
-
-		remove(filename);
-		sync();
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Resource_Gif
- *  Description:  Very important function show GIF file onto screen 
- * =====================================================================================
- */
-void Resource::Show_Resource_Gif(const int& index,const int& mdelay,const int& loopcount,const int& x,const int& y)
-{
-	sprintf ( filename,"%s1.gif",TEMPFILEPATH );
-	Instance_Resource(filename,index);
-
-	if ( access(filename,0) == 0 )
-	{
-		Gif *gif = new Gif;
-		gif->Set_Delay_MSecond(mdelay);
-		for ( int i = 0; i < loopcount; i += 1 ) 
-			gif->Read_Gif_File(filename,x,y);
-		delete gif;
-		gif = NULL;
-
-		remove(filename);
-		sync();
-	}
-}
diff --git a/src/EVA11/Resource.h b/src/EVA11/Resource.h
deleted file mode 100644
index ae9cf0a..0000000
--- a/src/EVA11/Resource.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Resource.h
- *
- *    Description:  Manage Resource class
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 10时22分36秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _RESOURCE_INC
-#define  _RESOURCE_INC
-
-#include 	<memory>
-
-class Graphic;
-class JpegOper;
-
-class Resource
-{
-	public:
-		static Resource* Instance();
-		static void      Release();
-
-		void Show_Resource_Jpeg(Graphic& g,int index,
-				       int Jpeg_x,int Jpeg_y,
-				       int fb_x,int fb_y,
-				       int Play_width,int Play_height );
-
-		void Show_Resource_Png(Graphic& g,const int& index,const int& x,const int& Y);
-
-		void Show_Resource_Gif(const int& index,const int& mdelay,const int& loopcount,const int& x,const int& Y);
-	protected:
-
-	private:
-		Resource ();
-		~Resource ();
-		Resource (const Resource&);
-		Resource& operator = (const Resource&);
-
-		bool Instance_Resource(const char* path, int index);
-
-		friend class std::auto_ptr<Resource>;
-		static std::auto_ptr<Resource>		m_Instance;
-	private:
-		JpegOper			       *m_Jpeg;
-		bool 					m_Initflag;
-		char				       *filename;
-};
-#endif
diff --git a/src/EVA11/Rule.cpp b/src/EVA11/Rule.cpp
deleted file mode 100644
index 9696c0c..0000000
--- a/src/EVA11/Rule.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Rule.cpp
- *
- *    Description:  implementation of Rule class
- *
- *        Version:  1.0
- *        Created:  2012年07月12日 14时04分03秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<new>
-#include 	"Graphic.h"
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Rule.h"
-
-#include 	"FreeType.h"
-
-struct Rule::PImpl
-{
-	static const int	RULESPACE = 20;
-	int			m_Factor;
-	int			m_10Step;
-	int			m_Step;
-	short			m_RuleFGColor1; 
-	short			m_RuleBGColor1; 
-	short			m_RuleFGColor2; 
-	short			m_RuleBGColor2; 
-	FreeType*		m_ft;
-};
-
-Rule::Rule (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh) , m_Imple(new struct PImpl)
-{
-	m_Imple->m_Factor 	= 2;
-	m_Imple->m_10Step     	= ( m_Right - m_Left + 1 ) >> 3;
-	m_Imple->m_Step		= m_Imple->m_10Step / 10;
-
-	m_Imple->m_ft 	   	= FreeType::Instance();
-	m_Imple->m_ft->Set_Font_Size(12);
-}
-
-Rule::~Rule ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Rule_Color
- *  Description:  Init the color used by rule class 
- * =====================================================================================
- */
-void Rule::Init_Rule_Color(Graphic& g)
-{
-	m_Imple->m_RuleBGColor1  = g.RGB24_16(0xa5fd00);
-	m_Imple->m_RuleFGColor1  = g.RGB24_16(0x000000);
-	m_Imple->m_RuleBGColor2  = g.RGB24_16(0xa5fd00);
-	m_Imple->m_RuleFGColor2  = g.RGB24_16(0x000000);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Rule::Refreshme(Graphic& g)
-{
-	short co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_RuleBGColor2);
-	for ( int i=0;i<8;i++ )
-	{
-		DrawBigMark(g,m_Imple->RULESPACE-2,i,false);
-		for ( int j=0;j<10;j++ )
-		{
-			DrawSmallMark(g,4,i,j,false);
-		}
-	}
-
-	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
-	else g.Setcolor(m_Imple->m_RuleFGColor1);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
-	g.Setcolor(co);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawBigMark
- *  Description: Draw the Mark on Rule 
- *               type : false  Down Rule
- *                      true Left Rule
- *               pos  : 0~7
- * =====================================================================================
- */
-void Rule::DrawBigMark(Graphic &g,int value,int pos,bool type)
-{
-	if ( type == false )                              /* Down Rule Lable  */
-	{
-		if ( pos != 0 ) 
-		{
-			for ( int i=0;i<value;i++ )
-			{
-				g.Setpixel(m_Left + pos * m_Imple->m_10Step, m_Up + i, m_Imple->m_RuleFGColor1);
-			}
-		}
-		char *mes = new(std::nothrow) char[20];
-		if ( mes != NULL )
-		{
-			sprintf(mes,"%d",(-40+pos*10)*m_Imple->m_Factor);
-			m_Imple->m_ft->Set_Font_Size(12);
-			m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,m_Imple->m_RuleFGColor1);
-			m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,m_Imple->m_RuleBGColor1);
-			m_Imple->m_ft->Text(m_Left + pos * m_Imple->m_10Step + 2,m_Up + 4+12,mes);
-			delete[] mes;
-			mes = NULL;
-		}
-	}
-	else                                              /* Left Rule Lable  */
-	{
-		if ( pos != 0 ) 
-		{
-			for ( int i=0;i<value;i++ )
-			{
-				g.Setpixel(m_Right - i,m_Down - pos * m_Imple->m_10Step, m_Imple->m_RuleFGColor2);
-			}
-		}
-		char *mes = new(std::nothrow) char[20];
-		if ( mes != NULL )
-		{
-			sprintf(mes,"%d",(-40+pos*10)*m_Imple->m_Factor);
-//			g.Ascii90((480-m_Down) + pos * m_Imple->m_10Step + 10,m_Right - 18,mes,m_Imple->m_RuleFGColor2,m_Imple->m_RuleBGColor2);
-			delete[] mes;
-			mes = NULL;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawSmallMark
- *  Description: Draw the Mark on Rule 
- *               type : false  Down Rule
- *                      true Left Rule
- *               pos  : 0~7
- * =====================================================================================
- */
-void Rule::DrawSmallMark(Graphic &g,int value,int offset,int pos,bool type)
-{
-	if ( type == false )                              /* Down Rule Lable  */
-	{
-		if ( pos != 0 ) 
-		{
-			if ( pos == 5 ) value += 3;
-			for ( int i=0;i<value;i++ )
-			{
-				g.Setpixel(m_Left + offset * m_Imple->m_10Step + pos * m_Imple->m_Step, m_Up + i, m_Imple->m_RuleFGColor1);
-			}
-		}
-	}
-	else                                              /* Left Rule Lable  */
-	{
-		if ( pos != 0 ) 
-		{
-			if ( pos == 5 ) value += 3;
-			for ( int i=0;i<value;i++ )
-			{
-				g.Setpixel(m_Right - i,m_Down - offset * m_Imple->m_10Step - pos * m_Imple->m_Step,m_Imple->m_RuleFGColor1);
-			}
-		}
-	}
-}
diff --git a/src/EVA11/Rule.h b/src/EVA11/Rule.h
deleted file mode 100644
index d4ebdd1..0000000
--- a/src/EVA11/Rule.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Rule.h
- *
- *    Description:  Display Rule on screen
- *
- *        Version:  1.0
- *        Created:  2012年07月12日 14时01分50秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _RULE_INC
-#define  _RULE_INC
-
-#include 	<memory>	
-class Graphic;
-class Basescreen;
-class Rule : public Basescreen
-{
-	public:
-		Rule (int x,int y,int width,int heigh);
-		~Rule ();
-
-		void Init_Rule_Color(Graphic& g);
-	protected:
-		virtual void Refreshme(Graphic& g);
-
-	private:
-		void DrawBigMark(Graphic &g,int value,int pos,bool type);
-		void DrawSmallMark(Graphic &g,int value,int offset,int pos,bool type);
-	private:
-		struct PImpl;
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif
diff --git a/src/EVA11/SQLLiteWrapper.cpp b/src/EVA11/SQLLiteWrapper.cpp
deleted file mode 100644
index 84a23ae..0000000
--- a/src/EVA11/SQLLiteWrapper.cpp
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  SQLLiteWrapper.cpp
- *
- *    Description:  Implementation of SQLLiteWrapper class
- *
- *        Version:  1.0
- *        Created:  2013年07月30日 22时19分33秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-#include 	<cstdio>
-#include	<iostream>	
-#include 	"SQLLiteWrapper.h"
-
-SQLiteDB::SQLiteDB()
-{
-	m_bConnected=false;
-	pSQLiteConn = new SQLITECONNECTIONOBJECT();
-}
-
-SQLiteDB::~SQLiteDB()
-{
-	CloseConnection();
-	delete pSQLiteConn;
-}
-
-void SQLiteDB::CloseConnection()
-{
-	if	(pSQLiteConn->pCon)
-		sqlite3_close(pSQLiteConn->pCon);
-}
-
-std::string SQLiteDB::GetLastError()
-{
-	return m_strLastError;
-}
-
-bool   SQLiteDB::isConnected()
-{
-	return m_bConnected;
-}
-
-bool SQLiteDB::OpenConnection(std::string DatabaseName,std::string DatabaseDir)
-{
-	pSQLiteConn->SQLiteDatabaseName = DatabaseName;
-	pSQLiteConn->SQLiteDBPath	    = DatabaseDir;
-	
-	m_bConnected = true;
-
-	std::string db=pSQLiteConn->SQLiteDatabaseName;
-	std::string dir=pSQLiteConn->SQLiteDBPath;
-	std::string path=dir.append(db);
-
-	int rc = sqlite3_open(path.c_str(), &(pSQLiteConn->pCon));
-
-	m_strLastError =(std::string)sqlite3_errmsg(pSQLiteConn->pCon);
-	
-	if	(!rc)
-	{
-		if	(m_strLastError.find("not an error") == std::string::npos)
-			m_bConnected = false;
-	}
-
-	return m_bConnected;
-}
-
-void SQLiteDB::BeginTransaction()
-{
-	sqlite3_exec(pSQLiteConn->pCon, "BEGIN TRANSACTION", NULL, NULL,NULL);
-}
-
-void SQLiteDB::CommitTransection()
-{
-	sqlite3_exec(pSQLiteConn->pCon, "COMMIT TRANSACTION", NULL, NULL,NULL);
-}
-
-IResult*  SQLiteDB::ExcuteSelect(const char *Query)
-{
-	if	(!isConnected())
-		return NULL;
-
-	if	(sqlite3_prepare_v2(pSQLiteConn->pCon,Query,-1, &pSQLiteConn->pRes, NULL) != SQLITE_OK)
-	{
-		m_strLastError=sqlite3_errmsg(pSQLiteConn->pCon);		
-		sqlite3_finalize(pSQLiteConn->pRes);
-		return NULL;
-	}
-	else
-	{			
-		m_iColumnCount   =sqlite3_column_count(pSQLiteConn->pRes);
-		IResult *ires=this;
-		return ires;
-	}
-}
-
-unsigned int SQLiteDB::Excute(const char *Query)
-{
-	if	(!isConnected())
-		return 0;
-	m_strLastError="";
-	
-	char* err=0;
-	
-	if	(sqlite3_exec(pSQLiteConn->pCon, Query, NULL, 0, &err) != SQLITE_OK)
-	{
-		m_strLastError=sqlite3_errmsg(pSQLiteConn->pCon);
-		return 0;
-	}
-	return sqlite3_total_changes(pSQLiteConn->pCon);	
-}
-
-/*Result Set Definations*/
-int	SQLiteDB::GetColumnCount()
-{
-	return m_iColumnCount;
-}
-
-const char* SQLiteDB::NextColomnName(int iClmnCount)
-{
-	if	(iClmnCount > m_iColumnCount)
-		return "";
-	return sqlite3_column_name(pSQLiteConn->pRes,iClmnCount);
-}
-
-bool SQLiteDB:: Next()
-{
-	return (sqlite3_step(pSQLiteConn->pRes)==SQLITE_ROW) ? true : false;
-}
-
-const char*  SQLiteDB::ColomnData(int clmNum)
-{
-	if	(clmNum > m_iColumnCount)
-		return "";
-	return ((const char*)sqlite3_column_text(pSQLiteConn->pRes,clmNum));
-}
-
-void SQLiteDB::Release()
-{
-	sqlite3_finalize(pSQLiteConn->pRes);
-	m_iColumnCount=0;
-	m_strLastError="";
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Test
- *  Description:  Below code used to test SQLLiteWrapper 
- * =====================================================================================
- */
-static int callback(void *NotUsed, int argc, char **argv, char **azColName)
-{
-	int i;
-	for(i=0; i<argc;i++)
-	{
-		printf("%s = %s\n", azColName[i], argv [i]);
-
-	}
-	printf("\n");
-	return 0;
-}
-
-void SQLiteDB::Test()
-{
-	char *zErrMsg = 0;
-	sqlite3* db;
-	int rc;
-	rc = sqlite3_open("test.db",&db);
-	if 	( rc )
-	{
-		printf ( "cannot open database %s\n",sqlite3_errmsg(db) );
-
-		sqlite3_close(db);
-	}
-
-	rc = sqlite3_exec(db, "select * from fime", callback, 0, &zErrMsg);
-
-	if	( rc!=SQLITE_OK )
-	{
-		printf ( "SQL error: %s\n", zErrMsg );
-	} 
-
-	sqlite3_close(db);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Self_Test
- *  Description:  Self Test Code from Cplusplus website 
- * =====================================================================================
- */
-void SQLiteDB::Self_Test()
-{
-	SQLiteDB *pSQLite;
-	pSQLite=new SQLiteDB();
-
-	if	(!pSQLite->OpenConnection("SQLiteTest.db","/jffs2/"))
-	{
-		std::cout<<"\nConnecting To DB Failed :"<<pSQLite->GetLastError().c_str();
-		return;
-	}
-
-	//Create DB
-	int effected=pSQLite->Excute("create table test (seq int(2),name varchar(50));");
-
-	if	(effected>0)
-		std::cout<<"\nColoumn Effected :"<<effected;
-	else
-		std::cout<<"\nError in Query : "<<pSQLite->GetLastError().c_str();
-	effected=pSQLite->Excute("insert into test (seq,name) values (1,'SQLLiteDBtest');");
-	if	(effected>0)
-		std::cout<<"\nColoumn Effected :"<<effected;
-	else
-		std::cout<<"\nError in Query : "<<pSQLite->GetLastError().c_str();
-
-	//Get Data From DB
-	IResult *res=pSQLite->ExcuteSelect("Select * from test;");
-	if	(!res)
-		std::cout<<"\n Error:"<<pSQLite->GetLastError().c_str();
-	else
-	{
-		int i = res->GetColumnCount();
-
-		for(int k=0;k<i;k++)
-		{
-			printf("%s\t",res->NextColomnName(k));	
-		}
-		std::cout<<std::endl;
-
-		while(res->Next())
-		{
-			for(int k=0;k<i;k++)
-				printf("%s\t",res->ColomnData(k));		
-			std::cout<<std::endl;
-		}
-
-		//release Result Data
-		res->Release();
-	}
-
-	//Insert Heavey Data in DB
-	pSQLite->BeginTransaction();
-	for(int i=0;i<10000;i++)
-		pSQLite->Excute("insert into test (seq,name) values (1,'SQLLiteDBtest');");
-	pSQLite->CommitTransection();
-	delete pSQLite;
-}
diff --git a/src/EVA11/SQLLiteWrapper.h b/src/EVA11/SQLLiteWrapper.h
deleted file mode 100644
index 531b4b5..0000000
--- a/src/EVA11/SQLLiteWrapper.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/******************************************************************************************
-       Author : Saurabh Bhushan
-       Dated  : 22 Feb 2013
-  
-    This Class provide the simple wrapper for SQLite DB.			 
-******************************************************************************************/
-
-#ifndef  _SQLLITE_DB
-#define  _SQLLITE_DB
-
-#include 	<string>
-#include 	<sqlite3.h>
-
-//using namespace std;
-
-/*Interface class for Result data of query*/
-class IResult
-{
-public:
-	/*This function return of count of column 
-	  present in result set of last excueted query*/
-	virtual int	    GetColumnCount() = 0;
-
-	/*Get the next coloumn name*/
-	virtual const char* NextColomnName(int iClmnCount) = 0;
-	
-	/*This function returns TRUE if still rows are 
-	der in result set of last excueted query FALSE 
-	if no row present*/
-	virtual bool  Next() = 0;
-
-	/*Get the next coloumn data*/
-	virtual const char*  ColomnData(int clmNum) = 0;
-
-	/*RELEASE all result set as well as RESET all data*/
-	virtual void Release() = 0;
-};
-
-//SQLite Wrapper Class
-class SQLiteDB : public IResult
-{
-
-public:
-	SQLiteDB();
-	~SQLiteDB();
-	
-	/*Open Connection*/
-	bool OpenConnection(std::string DatabaseName,std::string DatabaseDir); 
-
-
-	/*Close Connection*/
-	void CloseConnection();
-
-	/*Query Wrapper*/
-	/*For large insert operation Memory Insert option for SQLLITE dbJournal*/
-	void BeginTransaction();
-	void CommitTransection();
-
-	/*This Method called when SELECT Query to be excuted. 
-	Return RESULTSET class pointer on success else NULL of failed*/
-	IResult*  ExcuteSelect(const char *Query);
-
-	/*This Method called when INSERT/DELETE/UPDATE Query to be excuted. 
-	Return UINT count of effected data on success*/
-	unsigned int Excute(const char *Query);
-
-	/*Get Last Error of excution*/
-	std::string GetLastError();
-
-	/*Return TRUE if databse is connected else FALSE*/
-	bool  isConnected() ;	
-
-
-	void Self_Test();
-	void Test();
-protected:
-	/*SQLite Connection Object*/
-	typedef struct SQLLITEConnection
-	{
-		std::string		 SQLiteDatabaseName;   //Database Name
-		std::string		 SQLiteDBPath;		   //Databse File Dir
-		sqlite3		 *pCon;				   //SQLite Connection Object
-		sqlite3_stmt *pRes;				   //SQLite statement object 
-	}SQLITECONNECTIONOBJECT;
-
-	//SQLite Connection Details
-	SQLITECONNECTIONOBJECT	 *pSQLiteConn;
-
-	bool	m_bConnected;      /*Is Connected To DB*/
-	bool    m_bConsole;	       /*If Console Application*/
-	std::string  m_strLastError;    /*Last Error String*/
-	int	    m_iColumnCount;    /*No.Of Column in Result*/
-
-
-private:
-	/*This function return of count of column 
-	  present in result set of last excueted query*/
-	int	    GetColumnCount();
-
-	/*Get the next coloumn name*/
-	const char* NextColomnName(int iClmnCount);
-	
-	/*This function returns TRUE if still rows are 
-	der in result set of last excueted query FALSE 
-	if no row present*/
-	bool  Next();
-
-	/*Get the next coloumn data*/
-	const char*  ColomnData(int clmNum);
-
-	/*RELEASE all result set as well as RESET all data*/
-	void Release(); 
-
-};
-#endif
diff --git a/src/EVA11/ShellCommand.cpp b/src/EVA11/ShellCommand.cpp
deleted file mode 100644
index 035976c..0000000
--- a/src/EVA11/ShellCommand.cpp
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ShellCommand.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年03月15日 10时25分31秒
- *       Revision:  none
- *       Compiler:  arm-g++
- *
- *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
- *   Organization:  
- *
- * =====================================================================================
- */
-#include	<getopt.h>
-#include 	<cstring>
-#include        <cstdio>
-
-#include	"main.h"
-#include	"ShellCommand.h"
-
-ShellCommand::ShellCommand ()
-{
-	m_Version = NULL;
-	m_Version = new char[10];
-	sprintf(m_Version,"%s","1.00");
-}
-
-ShellCommand::~ShellCommand ()
-{
-	if ( m_Version != NULL ) { delete[] m_Version; m_Version = NULL; }
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  ShellCommand
- *  Description:  Shell Command analyze function
- * =====================================================================================
- */
-ShellCommand::SHELLCOMMAND ShellCommand::Analyze( int argc, char* argv[] ) 
-{
-	if ( argc == 1 )
-		return SHELLCOMMAND_NORMAL;
-
-	int opt;
-	struct option longopts[] =  
-	{
-		{ "normal",0,NULL,'n' },
-		{ "tcp",0,NULL,'t' },
-		{ "sdl",0,NULL,'s' },
-		{ "version",0,NULL,'v' },
-		{ "help",0,NULL,'h' },
-	};
-
-	while( ( opt = getopt_long(argc,argv,"ntshv?",longopts,NULL) ) != -1 )
-	{
-		switch ( opt )
-		{
-			case 's':
-				return SHELLCOMMAND_SDL;
-				break;
-			case 'n':
-				return SHELLCOMMAND_NORMAL;
-				break;
-			case 't':
-				return SHELLCOMMAND_TCPNETWORK;
-				break;
-			case 'v':
-				printf ( "\n" );
-				printf("Version %s\n",m_Version);
-				printf ( "\n" );
-				return SHELLCOMMAND_INVALID;
-				break;
-			case 'h':
-				{
-					Help_Doc();
-					return SHELLCOMMAND_INVALID;
-				}
-				break;
-			case '?':
-				Help_Doc();
-				return SHELLCOMMAND_INVALID;
-				break;
-		}				/* -----  end switch  ----- */
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Help_Doc
- *  Description:  Help Document when type -h switch  
- * =====================================================================================
- */
-void ShellCommand::Help_Doc()
-{
-	printf ( "============================================================\n" );
-	printf ( "Compiler:   eabi-gcc %s\n",__VERSION__ );
-	printf ( "Build Time: %s %s\n",__DATE__,__TIME__ );
-	printf ( "Program:    EVA11 with 128 channels eddy current detect intrument\n");
-	printf ( "par file save in such path %s\n",PAR_FILE_PATH);
-	printf ( "log file save in such path %s\n",LOGDIRECTORY);
-	printf ( "\n" );
-	printf ( "Usage: main_EVA11 [Option]\n" );
-	printf ( "\n" );
-	printf ( "Option:\n" );
-	printf ( "none option :  Run Program in normal status.\n" );
-	printf ( "-n --normal :  Run Program in normal status.\n" );
-	printf ( "-t --tcp :     Run Program as TCP network mode\n" );
-	printf ( "-s --sdl :     Test SDL function\n" );
-	printf ( "-v --version:  Show the Version of Programe.\n" );
-	printf ( "-h --help:     Show this message.\n" );
-	printf ( "============================================================\n" );
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  SetVer
- *  Description:  Set the Version Value 
- * =====================================================================================
- */
-void ShellCommand::SetVer(const char *value)
-{
-	if ( strlen(value) == 0 ) return;
-	if ( m_Version != NULL ) delete[] m_Version;
-	m_Version = new char[strlen(value)+1];      /* be careful strlen function not including /0 charactor  */
-	strcpy(m_Version,value);
-}
diff --git a/src/EVA11/ShellCommand.h b/src/EVA11/ShellCommand.h
deleted file mode 100644
index 26f8b60..0000000
--- a/src/EVA11/ShellCommand.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ShellCommand.h
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年03月15日 10时25分21秒
-*       Revision:  none
- *       Compiler:  arm-g++
- *
- *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _SHELLCOMMAND_INC
-#define  _SHELLCOMMAND_INC
-
-class ShellCommand
-{
-	public:
-		typedef enum {
-			SHELLCOMMAND_INVALID    = 0,
-			SHELLCOMMAND_NORMAL     = 1,
-			SHELLCOMMAND_TCPNETWORK = 2,
-			SHELLCOMMAND_MD5	= 3,
-			SHELLCOMMAND_SDL	= 4,
-			SHELLCOMMAND_TEST       = 99,
-		} SHELLCOMMAND;
-
-		ShellCommand ();                                  /* constructor */
-		~ShellCommand ();                                 /* destructor  */
-		SHELLCOMMAND Analyze( int argc, char* argv[] ); 
-		void SetVer(const char *value);
-	protected:
-		void Help_Doc();
-	private:
-		char *m_Version;
-
-};
-
-#endif
diff --git a/src/EVA11/Sinscreen.cpp b/src/EVA11/Sinscreen.cpp
deleted file mode 100644
index 7e4758c..0000000
--- a/src/EVA11/Sinscreen.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Sinscreen.cpp
- *
- *    Description:  implementation of Sinscreen class
- *
- *        Version:  1.0
- *        Created:  2012年08月01日 13时39分12秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Graphic.h"
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Sinscreen.h"
-
-#include 	"Filte.h"
-
-Sinscreen::Sinscreen (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-	, m_BackCoordinate(GRID)
-{
-	m_Filter = new Filte;
-	m_Filter->Init_Algorithm1_Data_Structure();
-}
-
-Sinscreen::~Sinscreen ()
-{
-	delete m_Filter;
-	m_Filter = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Sinscreen::Refreshme(Graphic& g)
-{
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
-	if ( m_BackCoordinate == GRID )
-		DrawGrid(g);
-	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
-	g.Setcolor(co);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_SIN_Wave
- *  Description:  Draw the SIN wave on screen 
- * =====================================================================================
- */
-void Sinscreen::Draw_SIN_Wave(Graphic &g,int *databuf,int len)
-{
-	g.Switch_Screen();
-	Refreshme(g);
-
-	m_Filter->Calculate_Algorithm1(databuf,len);
-
-	for ( int i=0;i<len-1;i++ )
-	{
-		DrawPoint_SIN(g,i,databuf[i],databuf[i+1],len);
-	}
-
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawPoint_SIN
- *  Description:  Showing the SIN wave 
- * =====================================================================================
- */
-void Sinscreen::DrawPoint_SIN(Graphic &g,int x,int y,int y1,int samdataN)
-{
-	int cx,cy,cx1,cy1;
-	cx = static_cast<int>(m_Width * ((x+1) / static_cast<double>(samdataN)));
-	cy = static_cast<int>(m_Heigh * ( static_cast<double>(y) / 0x40dfffff));
-	cx1 = static_cast<int>(m_Width * ((x+2) / static_cast<double>(samdataN)));
-	cy1 = static_cast<int>(m_Heigh * ( static_cast<double>(y1) / 0x40dfffff));
-
-	Draw_Line_In_Arrange(g,m_Left+cx,m_Center_Y+cy,m_Left+cx1,m_Center_Y+cy1,m_PointColor);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Back_Coordinate
- *  Description:  
- * =====================================================================================
- */
-void Sinscreen::Set_Back_Coordinate(BACKCOOR back)
-{
-	m_BackCoordinate = back;
-}
diff --git a/src/EVA11/Sinscreen.h b/src/EVA11/Sinscreen.h
deleted file mode 100644
index 4b199c5..0000000
--- a/src/EVA11/Sinscreen.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Sinscreen.h
- *
- *    Description:  Just only draw sin wave on screen 
- *
- *        Version:  1.0
- *        Created:  2012年08月01日 13时36分41秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  SINSCREEN_INC
-#define  SINSCREEN_INC
-
-class Basescreen;
-class Graphic;
-class Filte;
-class Sinscreen : public Basescreen
-{
-	public:
-		enum BACKCOOR 
-		{
-			BKNONE = 0,
-			GRID   = 1,
-		};				/* ----------  end of enum BACKCOOR  ---------- */
-		typedef enum BACKCOOR BACKCOOR;
-		Sinscreen (int x,int y,int width,int heigh);
-		~Sinscreen();
-
-		void Draw_SIN_Wave(Graphic &g,int *databuf,int len);
-		void DrawPoint_SIN(Graphic &g,int x,int y,int y1,int samdataN);
-		void Set_Back_Coordinate(BACKCOOR);
-
-	protected:
-		virtual void Refreshme(Graphic& g);
-	private:
-		BACKCOOR		m_BackCoordinate;
-		Filte*			m_Filter;
-};
-
-#endif
diff --git a/src/EVA11/Splashscreen.cpp b/src/EVA11/Splashscreen.cpp
deleted file mode 100644
index a655736..0000000
--- a/src/EVA11/Splashscreen.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Splashscreen.cpp
- *
- *    Description:  Implemntation of splash screen
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 09时36分00秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"Splashscreen.h"
-#include 	"Resource.h"
-#include 	"Graphic.h"
-#include 	"FreeType.h"
-
-Splashscreen::Splashscreen (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-{
-}
-
-Splashscreen::~Splashscreen ()
-{
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Splashscreen::Refreshme(Graphic& g)
-{
-	Resource *res = Resource::Instance();
-	res->Show_Resource_Jpeg(g,2,0,0,m_X,m_Y,320,240);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Info
- *  Description:  Show the message into on screen 
- * =====================================================================================
- */
-void Splashscreen::Show_Info(Graphic& g,const char* info)
-{
-	Refreshme(g);
-	FreeType *ft = FreeType::Instance();
-	bool tr = ft->Get_Transparce();
-	ft->Set_Transparce(true);
-	ft->Set_Font_Size(16);
-	ft->Set_Color(FreeType::FGCOLOR,g.RGB24_16(0xffffff));
-	ft->Set_Color(FreeType::BGCOLOR,g.RGB24_16(0x000000));
-	ft->Text(m_X+2,m_Y+18+12,info);
-	ft->Set_Transparce(tr);
-#ifdef X86
-	g.Update_Rect(m_X,m_Y,320,240);
-#endif
-}
diff --git a/src/EVA11/Splashscreen.h b/src/EVA11/Splashscreen.h
deleted file mode 100644
index 71e90bd..0000000
--- a/src/EVA11/Splashscreen.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Splashscreen.h
- *
- *    Description:  Show start up information
- *
- *        Version:  1.0
- *        Created:  2012年07月18日 09时30分39秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  SPLASHSCREEN_INC
-#define  SPLASHSCREEN_INC
-
-class Graphic;
-class Basescreen;
-class Splashscreen : public Basescreen
-{
-	public:
-		Splashscreen (int x,int y,int width,int heigh);
-		~Splashscreen();
-
-		void Show_Info(Graphic& g,const char*);
-	protected:
-		virtual void Refreshme(Graphic& g);
-
-	private:
-
-}; /* -----  end of class Splashscreen  ----- */
-#endif   /* ----- #ifndef SPLASHSCREEN_INC  ----- */
diff --git a/src/EVA11/TCPMainwin.cpp b/src/EVA11/TCPMainwin.cpp
deleted file mode 100644
index ab11a87..0000000
--- a/src/EVA11/TCPMainwin.cpp
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  TCPMainwin.cpp
- *
- *    Description:  implementation of TCP Mainwin class
- *
- *        Version:  1.0
- *        Created:  2012年09月12日 08时57分17秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<string.h>
-
-#include 	"Object.h"
-#include 	"Graphic.h"
-#include 	"Basewin.h"
-#include 	"TCPMainwin.h"
-#include	"Language.h"
-#include 	"Label.h"
-#include 	"Netclient.h"
-#include 	"Logic.h"
-
-TCPMainwin::TCPMainwin ()
-{
-	m_pl   = Language::Instance();
-	m_lo   = Logic::Instance();
-	m_netc = new Netclient;
-}
-
-TCPMainwin::~TCPMainwin ()
-{
-	if 	( m_netc != NULL )
-	{
-		delete m_netc;
-		m_netc = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void TCPMainwin::Drawme(Graphic &g)
-{
-	g.Clearscreen();
-	g.DrawFillRect(0,0,640,480,g.RGB24_16(0x00000000));
-	g.Setcolor(g_MAINFG_CO);
-	m_Title->Drawme(g);
-	m_SubTitle->Drawme(g);
-	m_labTest->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loopwindow
- *  Description:  Main loop in Mainwin class 
- * =====================================================================================
- */
-int TCPMainwin::Loopwindow(Graphic &g)
-{
-	Init_GUI(g);
-	Drawme(g);
-
-	if ( m_netc->Open_Socket() == false )
-	{
-		m_MsgLab->Set_Text(m_pl->GetText(ERRORMSG1));
-		m_MsgLab->Drawme(g); 
-		goto ExitNetError;
-	}
-
-	if ( !Connect_Server(g,*m_MsgLab) ) goto Exit;
-Exit:
-	m_netc->Close_Socket();
-
-ExitNetError:
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void TCPMainwin::Init_GUI(Graphic &g)
-{
-	m_Title = new Label(2,60,636,20);
-	m_Title->Set_Font_Size(24);
-	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
-	m_Title->Set_Text(m_pl->GetText(EDDYNETWORK));
-
-	m_SubTitle = new Label(2,100,636,20);
-	m_SubTitle->Set_Font_Size(24);
-	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
-	m_SubTitle->Set_Text(m_pl->GetText(IPMESG));
-
-	m_MsgLab = new Label(240,140,336,20);
-	m_MsgLab->Set_Display_Type(Label::LA_DT_LEFT);
-	m_MsgLab->Set_Font_Size(24);
-	m_MsgLab->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
-	m_MsgLab->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
-
-	m_labTest = new Label(200,200,150,72);
-	Language *lan = Language::Instance();
-	m_labTest->Set_Text(lan->GetText(SCREEN));
-	m_labTest->Set_Content("25.5 dB");
-	m_labTest->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	m_labTest->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_labTest->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	m_labTest->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	m_labTest->Set_Font_Size(18);
-	m_labTest->Set_Focus(false);
-	m_labTest->Set_Label_Type(Label::LA_THIN);
-	m_labTest->Set_Display_Type(Label::LA_DT_CENTER);
-
-
-//	double dx = 0.65;
-//	int x = 88; 
-//	int z = 2;
-//	int y = x * dx - z;
-//	printf ( "%d\n",y );
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Detroy all GUI object 
- * =====================================================================================
- */
-void TCPMainwin::Destroy_GUI()
-{
-	if 	( m_Title != NULL ) 
-	{
-		delete m_Title;
-		m_Title = NULL;
-	}
-	if 	( m_SubTitle != NULL ) 
-	{
-		delete m_SubTitle;
-		m_SubTitle = NULL;
-	}
-	if 	( m_MsgLab != NULL ) 
-	{
-		delete m_MsgLab;
-		m_MsgLab = NULL;
-	}
-	if 	( m_labTest != NULL ) 
-	{
-		delete m_labTest;
-		m_labTest = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Connect_Server
- *  Description:  Connect the Server and show the message 
- * =====================================================================================
- */
-bool TCPMainwin::Connect_Server(Graphic& g,Label& msglab)
-{
-	int key     = 0;
-	int temp    = 0;
-	bool result = false;
-
-	std::string msg[5] = {"*","* *","* * *","* * * *","* * * * *"};
-	while ( !m_netc->Connect_Server() )
-	{
-		key = m_lo->Get_Key();
-		if 	( key == KEY_ESC )
-		{
-			result = false;
-			goto Exit;
-		}
-
-		msglab.Set_Text(msg[temp].c_str());
-		msglab.Drawme(g);
-
-		usleep(400000);
-		temp ++;
-		if ( temp == 5 ) temp = 0;
-	}
-	result = true;
-Exit:
-	return result;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_Fun
- *  Description:  Dealwith each key function 
- * =====================================================================================
- */
-int TCPMainwin::Key_Esc_Fun(Graphic& g)
-{
-
-}
-int TCPMainwin::Key_Enter_Fun(Graphic& g)
-{
-
-}
diff --git a/src/EVA11/TCPMainwin.h b/src/EVA11/TCPMainwin.h
deleted file mode 100644
index 0e4df5b..0000000
--- a/src/EVA11/TCPMainwin.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  TCPMainwin.h
- *
- *    Description:  Manage the TCP network Mainwin class 
- *
- *        Version:  1.0
- *        Created:  2012年09月12日 08时55分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  TCPMAINWIN_INC
-#define  TCPMAINWIN_INC
-
-class Basewin;
-class Graphic;
-class Netclient;
-class Label;
-class TCPMainwin : public Basewin
-{
-	public:
-		TCPMainwin ();
-		virtual ~TCPMainwin ();
-		void Drawme (Graphic&);
-		int Loopwindow(Graphic &);
-
-	protected:
-		void Init_GUI(Graphic& g);
-		void Destroy_GUI();
-		bool Connect_Server(Graphic& g,Label& msg);
-
-		virtual int Key_Esc_Fun(Graphic& g);
-		virtual int Key_Enter_Fun(Graphic& g);
-
-	private:
-		Label*				    m_Title;
-		Label*				    m_SubTitle;
-		Label*				    m_MsgLab;
-
-		Label*				    m_labTest;
-
-		Language			    *m_pl;
-		Netclient			    *m_netc;
-		Logic				    *m_lo;
-};
-
-#endif
diff --git a/src/EVA11/USB.cpp b/src/EVA11/USB.cpp
deleted file mode 100644
index dc85a0c..0000000
--- a/src/EVA11/USB.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  USB.cpp
- *
- *    Description:  Implementation of USB
- *
- *        Version:  1.0
- *        Created:  2012年11月03日 12时27分01秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cstdio>
-#include 	"USB.h"
-
-#define    USB_VENDOR_ID  		0x05ba
-#define    USB_PRODUCT_ID		0x000a 
-
-USB::USB ()
-{
-}
-
-USB::~USB ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_USB
- *  Description:  Init the USB libary used environment
- * =====================================================================================
- */
-bool USB::Init_USB()
-{
-	int rc = 1;
-	rc = libusb_init(NULL);
-	if 	( rc < 0 )
-	{
-		perror("fail to init usb lib");
-		return false;
-	}
-//	m_devh = NULL;
-//	m_devh = libusb_open_device_with_vid_pid(NULL, 0x05ba, 0x000a);
-//	if 	( m_devh == NULL )
-//	{
-//		perror("fail to open the usb device");
-//		libusb_exit(NULL);
-//		return false;
-//	}
-//	rc = libusb_claim_interface(m_devh, 0);
-//	if 	(rc < 0) 
-//	{
-//		perror("fail to claim interface");
-//		libusb_close(m_devh);
-//		libusb_exit(NULL);
-//		return false;
-//	}
-
-	return true;
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_USB
- *  Description:  Destroy the USB library environment
- * =====================================================================================
- */
-void USB::Destroy_USB()
-{
-//	libusb_release_interface(m_devh, 0);
-//	libusb_close(m_devh);
-	libusb_exit(NULL);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_USB_List
- *  Description:  List All USB device of system
- * =====================================================================================
- */
-void USB::Show_USB_List()
-{
-	libusb_device **devs;
-	ssize_t cnt;
-	cnt = libusb_get_device_list(NULL, &devs);
-	if (cnt < 0)
-	{
-		perror("can't get device list");
-		return;
-	}
-
-	libusb_device *dev;
-	int i = 0;
-
-	while ((dev = devs[i++]) != NULL) {
-		struct libusb_device_descriptor desc;
-		int r = libusb_get_device_descriptor(dev, &desc);
-		if (r < 0) 
-		{
-			fprintf(stderr, "failed to get device descriptor");
-			return;
-		}
-
-		printf("%04x:%04x (bus %d, device %d)\n",
-			desc.idVendor, desc.idProduct,
-			libusb_get_bus_number(dev), libusb_get_device_address(dev));
-	}
-
-	libusb_free_device_list(devs, 1);
-}
diff --git a/src/EVA11/USB.h b/src/EVA11/USB.h
deleted file mode 100644
index 9e99605..0000000
--- a/src/EVA11/USB.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  USB.h
- *
- *    Description:  Management of USB port
- *
- *        Version:  1.0
- *        Created:  2012年11月03日 12时24分48秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _USB_INC
-#define  _USB_INC
-
-#include 	<libusb.h>
-
-class USB
-{
-	public:
-		USB ();                             /* constructor */
-		~USB ();                            /* destructor */
-		bool Init_USB();
-		void Destroy_USB();
-
-
-		void Show_USB_List();
-	protected:
-
-	private:
-		struct libusb_device_handle 			*m_devh;
-
-};
-
-#endif   /* ----- #ifndef _USB_INC  ----- */
diff --git a/src/EVA11/Uart.cpp b/src/EVA11/Uart.cpp
deleted file mode 100644
index b758105..0000000
--- a/src/EVA11/Uart.cpp
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Uart.cpp
- *
- *    Description:  implementation of Uart class
- *
- *        Version:  1.0
- *        Created:  2012年11月07日 13时43分30秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<list>
-#include 	<cstdlib>
-#include 	<cstdio>
-
-#include 	"Uart.h"
-
-std::list<uint8_t>		m_Buf;
-
-static void callback(int id,
-	             uint8_t *buf,
-		     int length)
-{
-	for ( int i=0;i<length;i++ )
-	{
-		m_Buf.push_back(buf[i]);
-	}
-}
-
-Uart::Uart ()
-{
-}
-
-Uart::~Uart ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Uart
- *  Description:  Init the Uart class 
- * =====================================================================================
- */
-bool Uart::Init_Uart()
-{
-	cssl_start();
-	m_Serial = cssl_open("/dev/ttySAC0",callback,0,19200,8,0,1);
-	if ( !m_Serial )
-	{
-		printf("%s\n",cssl_geterrormsg());
-		cssl_stop();
-		return false;
-	}
-	else
-		printf ( "OK\n" );
-	m_Buf.clear();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_Uart
- *  Description:  Destroy the Uart class 
- * =====================================================================================
- */
-void Uart::Destory_Uart()
-{
-	cssl_close(m_Serial);
-	cssl_stop();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Send_Data
- *  Description:  Send the Data into 
- * =====================================================================================
- */
-void Uart::Send_Data(uint8_t *data,int length)
-{
-	cssl_putdata(m_Serial,data,length);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Data
- *  Description:  Get the Data from module 
- * =====================================================================================
- */
-void Uart::Get_Data(uint8_t *data,int length)
-{
-	for ( int i=0;i<length;i++ )
-	{
-		data[i] = m_Buf.front();
-		m_Buf.pop_front();
-	}
-}
diff --git a/src/EVA11/Uart.h b/src/EVA11/Uart.h
deleted file mode 100644
index 3a04afb..0000000
--- a/src/EVA11/Uart.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Uart.h
- *
- *    Description:  Manage the UART port class
- *
- *        Version:  1.0
- *        Created:  2012年11月07日 13时42分23秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _UART_INC
-#define  _UART_INC
-
-#include 	"cssl.h"
-class Uart
-{
-	public:
-		Uart ();                             /* constructor */
-		~Uart ();                            /* destructor */
-		bool Init_Uart();
-		void Destory_Uart();
-		void Send_Data(uint8_t *data,int length);
-		void Get_Data(uint8_t *data,int length);
-
-	protected:
-
-	private:
-		cssl_t 				*m_Serial;
-};
-
-#endif   /* ----- #ifndef _UART_INC  ----- */
diff --git a/src/EVA11/Video.cpp b/src/EVA11/Video.cpp
deleted file mode 100644
index ce95762..0000000
--- a/src/EVA11/Video.cpp
+++ /dev/null
@@ -1,1038 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Video.cpp
- *
- *    Description:  Implementation of Video class 
- *
- *        Version:  1.0
- *        Created:  2011年12月05日 20时20分43秒
- *       Revision:  none 
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  Eddysun Xiamen
- *
- * =====================================================================================
- */
-
-#include	<time.h>
-#include	"Video.h"
-
-#define CoefRv 1402
-#define CoefGu 344//714 // 344
-#define CoefGv 714//344 // 714
-#define CoefBu 1772
-
-#define  FOUR_TWO_TWO 2		//Y00 Cb Y01 Cr
-
-#define CLIP(color) (unsigned char)(((color)>0xFF)?0xff:(((color)<0)?0:(color)))
-
-Video::Video()
-{
-	m_AdjLight = 60;
-	m_Posx = 160;
-	m_Posy = 120;
-}
-Video::~Video()
-{
-
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Output_Pos
- *  Description:  
- * =====================================================================================
- */
-void Video::Set_Output_Pos(const int& x,const int& y)
-{
-	m_Posx = x;
-	m_Posy = y;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Video
- *  Description:  Init the Video resource 
- * =====================================================================================
- */
-bool Video::Init_Video(int width,int height)
-{
-    	videoIn = (struct vdIn *) calloc(1, sizeof(struct vdIn)); 		/* OK  */
-	if ( init_videoIn(videoIn, (char *)"/dev/video0", width, height, 10, V4L2_PIX_FMT_YUYV, 1, (char *)"video.avi") < 0 )
-	{
-		free(videoIn);
-		videoIn = NULL;
-		return false;
-	}
-	else
-	{
-		initLut();
-		m_Width  = width;
-		m_Height = height; 
-		return true;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Release_Video
- *  Description:  Release the video resource 
- * =====================================================================================
- */
-void Video::Release_Video()
-{
-    	close_v4l2(videoIn);
-	freeLut();
-	free(videoIn);
-	videoIn = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  init_videoIn
- *  Description:  Init the video resource 
- * =====================================================================================
- */
-int Video::init_videoIn(struct vdIn *vd, char *device, int width, int height, int fps,
-	     int format, int grabmethod, char *avifilename)
-{
-	if (vd == NULL || device == NULL)
-		return -1;
-	if (width == 0 || height == 0)
-		return -1;
-
-	if (grabmethod < 0 || grabmethod > 1)
-		grabmethod = 1;
-
-	vd->videodevice = NULL;
-	vd->status = NULL;
-	vd->pictName = NULL;
-	vd->videodevice = (char *) calloc(1, 16 * sizeof(char));
-	vd->status = (char *) calloc(1, 100 * sizeof(char));
-	vd->pictName = (char *) calloc(1, 80 * sizeof(char));
-	snprintf(vd->videodevice, 12, "%s", device);
-	vd->toggleAvi = 0;
-	vd->avifile = NULL;
-	vd->avifilename = avifilename;
-	vd->recordtime = 0;
-	vd->framecount = 0;
-	vd->recordstart = 0;
-	vd->signalquit = 1;
-	vd->width = width;
-	vd->height = height;
-	vd->fps = fps;
-	vd->formatIn = format;
-	vd->grabmethod = grabmethod;
-	vd->fileCounter = 0;
-	vd->rawFrameCapture = 0;
-	vd->rfsBytesWritten = 0;
-	vd->rfsFramesWritten = 0;
-	vd->captureFile = NULL;
-	vd->bytesWritten = 0;
-	vd->framesWritten = 0;
-
-	if (init_v4l2(vd) < 0) 
-	{
-		printf(" Init v4L2 failed !! exit fatal \n");
-		goto error;;
-	}
-
-	vd->framesizeIn = (vd->width * vd->height << 1);
-
-	vd->framebuffer = (unsigned char *) calloc(1, (size_t) vd->framesizeIn);
-
-	if (!vd->framebuffer)
-	{
-		goto error;
-	}
-	return 0;
-
-error:
-	free(vd->videodevice);
-	free(vd->status);
-	free(vd->pictName);
-	close(vd->fd);
-	return -1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  init_v4l2
- *  Description:  init_v4l2 
- * =====================================================================================
- */
-int Video::init_v4l2(struct vdIn *vd)
-{
-	int i;
-	int ret = 0;
-	if ((vd->fd = open(vd->videodevice, O_RDWR)) == -1) 
-	{
-		perror("ERROR opening V4L interface \n");
-		return -1;
-	}
-
-	memset(&vd->cap, 0, sizeof(struct v4l2_capability));
-	ret = ioctl(vd->fd, VIDIOC_QUERYCAP, &vd->cap);
-	if (ret < 0)
-	{
-		printf("Error opening device %s: unable to query device.\n",
-				vd->videodevice);
-		goto fatal;
-	}
-
-	if ((vd->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0) 
-	{
-		printf("Error opening device %s: video capture not supported.\n",
-				vd->videodevice);
-		goto fatal;;
-	}
-
-	if (!(vd->cap.capabilities & V4L2_CAP_STREAMING)) 
-	{
-		printf("%s does not support streaming i/o\n", vd->videodevice);
-		goto fatal;
-	}
-
-	/* set format in */
-	memset(&vd->fmt, 0, sizeof(struct v4l2_format));
-	vd->fmt.type 		    = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	vd->fmt.fmt.pix.width       = vd->width;
-	vd->fmt.fmt.pix.height      = vd->height;
-	vd->fmt.fmt.pix.pixelformat = vd->formatIn;
-	vd->fmt.fmt.pix.field       = V4L2_FIELD_ANY;
-	//vd->fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
-	ret = ioctl(vd->fd, VIDIOC_S_FMT, &vd->fmt);
-	if (ret < 0) 
-	{
-		perror("Unable to set format");
-		goto fatal;
-	}
-	else
-		printf ( "Format OK\n" );
-
-	if ((vd->fmt.fmt.pix.width != (unsigned int)vd->width) ||
-			(vd->fmt.fmt.pix.height != (unsigned int)vd->height)) 
-	{
-		printf(" format asked unavailable get width %d height %d \n",
-				vd->fmt.fmt.pix.width, vd->fmt.fmt.pix.height);
-		vd->width = vd->fmt.fmt.pix.width;
-		vd->height = vd->fmt.fmt.pix.height;
-	}
-
-	/* set framerate */
-	struct v4l2_streamparm* setfps;  
-	setfps= new struct v4l2_streamparm;
-	memset(setfps, 0, sizeof(struct v4l2_streamparm));
-	setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	setfps->parm.capture.timeperframe.numerator=1;
-	setfps->parm.capture.timeperframe.denominator=vd->fps;
-	if ( ioctl(vd->fd, VIDIOC_S_PARM, setfps) < 0 )
-	{
-		perror("unable to set param\n");
-		delete setfps;
-		setfps = NULL;
-		goto fatal;
-	}
-	delete setfps;
-	setfps = NULL;
-
-	/* request buffers */
-	memset(&vd->rb, 0, sizeof(struct v4l2_requestbuffers));
-	vd->rb.count = NB_BUFFER;
-	vd->rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	vd->rb.memory = V4L2_MEMORY_MMAP;
-
-	ret = ioctl(vd->fd, VIDIOC_REQBUFS, &vd->rb);
-	if (ret < 0) 
-	{
-		printf("Unable to allocate buffers: %d.\n", errno);
-		goto fatal;
-	}
-
-	/* map the buffers */
-	for (i = 0; i < NB_BUFFER; i++)
-	{
-		t_buf.index = i;
-  		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-  		t_buf.memory = V4L2_MEMORY_MMAP;
-
-		ret = ioctl(vd->fd, VIDIOC_QUERYBUF, &t_buf);
-		if (ret < 0) 
-		{
-			printf("Unable to query buffer (%d).\n", errno);
-			goto fatal;
-		}
-
-		vd->mapbuflength[i] = t_buf.length;
-		vd->mem[i] = mmap(0,
-				t_buf.length, PROT_READ, MAP_SHARED, vd->fd,
-				t_buf.m.offset);
-		if (vd->mem[i] == MAP_FAILED) 
-		{
-			printf("Unable to map buffer (%d)\n", errno);
-			goto fatal;
-		}
-	}
-	/* Queue the buffers. */
-
-	for ( i=0;i<NB_BUFFER;i++ )
-	{
-		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		t_buf.memory = V4L2_MEMORY_MMAP;
-		t_buf.index = i;
-
-		if (ioctl(vd->fd, VIDIOC_QBUF, &t_buf) < 0) 
-		{
-			printf("Unable to requeue buffer (%d).\n", errno);
-			goto fatal;
-		}
-	}
-
-	Show_Video_Info();
-
-	return 0;
-fatal:
-	return -1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  initLut
- *  Description:  Init Lut 
- * =====================================================================================
- */
-void Video::initLut(void)
-{
-	LutRv  = NULL;
-	LutGu  = NULL;
-	LutGv  = NULL;
-	LutBu  = NULL;
-
-	int i;
-	LutRv = (int *)malloc(256*sizeof(int));
-	LutGu = (int *)malloc(256*sizeof(int));
-	LutGv = (int *)malloc(256*sizeof(int));
-	LutBu = (int *)malloc(256*sizeof(int));
-
-	for (i= 0;i < 256;i++)
-	{
-		LutRv[i] = (i-128)*CoefRv/1000;
-		LutBu[i] = (i-128)*CoefBu/1000;
-		LutGu[i] = (128-i)*CoefGu/1000;
-		LutGv[i] = (128-i)*CoefGv/1000;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  freeLut
- *  Description:  FreeLut 
- * =====================================================================================
- */
-void Video::freeLut(void)
-{
-	free(LutRv);
-	free(LutGu);
-	free(LutGv);
-	free(LutBu);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  close_v4l2
- *  Description:  close_v4l2 
- * =====================================================================================
- */
-int Video::close_v4l2(struct vdIn *vd)
-{
-	if (vd->isstreaming)
-		video_disable(vd);
-	free(vd->framebuffer);
-	vd->framebuffer = NULL;
-	free(vd->videodevice);
-	free(vd->status);
-	free(vd->pictName);
-	vd->videodevice = NULL;
-	vd->status = NULL;
-	vd->pictName = NULL;
-	for (int i = 0; i < NB_BUFFER; i++) 
-	{
-		munmap(vd->mem[i],vd->mapbuflength[i]);
-	}
-	close(vd->fd);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  video_disable
- *  Description:  video_disable
- * =====================================================================================
- */
-int Video::video_disable(struct vdIn *vd)
-{
-	int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	int ret;
-	ret = ioctl(vd->fd, VIDIOC_STREAMOFF, &type);
-	if (ret < 0) 
-	{
-		perror("Unable to %s capture");
-		return ret;
-	}
-	vd->isstreaming = 0;
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  uvGrab
- *  Description:  uvcGrab Capture the video file 
- * =====================================================================================
- */
-int Video::uvcGrab(struct vdIn *vd)
-{
-	if (!vd->isstreaming)
-	{
-		if (video_enable(vd))
-			goto err;
-		else
-			printf ( "isstreaming=%d\n",vd->isstreaming );
-	}
-	q_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	q_buf.memory = V4L2_MEMORY_MMAP;
-
-	if (ioctl(vd->fd, VIDIOC_DQBUF, &q_buf) < 0) 
-	{
-		perror("Unable to dequeue buffer");
-		goto err;
-	}
-
-	if ( q_buf.bytesused> 0 )
-	{
-		vd->buf.index = q_buf.index;
-		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		t_buf.memory = V4L2_MEMORY_MMAP;
-		t_buf.index = vd->buf.index;
-
-		if (ioctl(vd->fd,VIDIOC_QBUF,&t_buf) < 0)
-		{
-			printf("Unable to requeue buffer (%d).\n", errno);
-			goto err;
-		}
-
-		return 0;
-	}
-	else
-		printf ( "File %s: Line %d\n",__FILE__,__LINE__ );
-
-err:
-	vd->signalquit = 0;
-	return -1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  video_enable
- *  Description:  video_enable function 
- * =====================================================================================
- */
-int Video::video_enable(struct vdIn *vd)
-{
-	int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	int ret;
-	ret = ioctl(vd->fd, VIDIOC_STREAMON, &type);
-	if (ret < 0) 
-	{
-		printf("Unable to %s capture: %d.\n", "start", errno);
-		return ret;
-	}
-	vd->isstreaming = 1;
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  get_pictureYV2
- *  Description:  get_pictureYV2
- * =====================================================================================
- */
-int Video::get_pictureYV2(unsigned char *buf,int width,int height)
-{
-	FILE *foutpict;
-	unsigned char *picture = NULL;
-	char *name = NULL;
-	name = (char *)calloc(80,1);
-	getPictureName (name, 0);
-	picture = (unsigned char *)malloc(width*height*3*sizeof(char));
-	if(picture)
-	{
-		Pyuv422torgb24(buf, picture, width, height);
-	}
-	else
-	{
-		printf(" no room to take a picture \n");
-		return 0;
-	}
-	if(name)
-	{
-		foutpict = fopen (name, "wb");
-		fprintf (foutpict, "P6\n%d %d\n255\n", width, height);
-		size_t result = fwrite (picture, sizeof (char), width * height * 3, foutpict);
-		fclose (foutpict);
-		free(name);
-	}
-	free(picture);
-	picture = NULL;
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  fill_bufYV2
- *  Description:  
- * =====================================================================================
- */
-int Video::fill_bufYV2(unsigned char *buf,unsigned char *pic,int width,int height)
-{
-	Pyuv422torgb24(buf, pic, width, height);
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  getPictureName
- *  Description:  getPictureName
- * =====================================================================================
- */
-void Video::getPictureName (char *Picture, int fmt)
-{
-	fmt = fmt;
-	char temp[80];
-/* 	time_t curdate;
- * 	struct tm *tdate;
- * 	memset (temp, '\0', sizeof (temp));
- * 	time (&curdate);
- * 	tdate = localtime (&curdate);
- */
-/* 	snprintf (temp, 26, "P_%02d_%02d_%02d.%s",
- * 			tdate->tm_hour, tdate->tm_min, tdate->tm_sec, "pnm");
- */
-	sprintf(temp,"%s","video.pnm");
-	memcpy (Picture, temp, strlen (temp));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torgb24
- *  Description:  
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torgb24(unsigned char * input_ptr, unsigned char * output_ptr, 
-		                   unsigned int image_width, unsigned int image_height)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_pt = output_ptr;
-	size = image_width * image_height >> 1;
-	for (i = size; i > 0; i--) 
-	{
-		/* bgr instead rgb ?? */
-		Y = buff[0] ;
-		U = buff[1] ;
-		Y1 = buff[2];
-		V = buff[3];
-		buff += 4;
-		*output_pt++ = R_FROMYV(Y,V);
-		*output_pt++ = G_FROMYUV(Y,U,V); //b
-		*output_pt++ = B_FROMYU(Y,U); //v
-			
-		*output_pt++ = R_FROMYV(Y1,V);
-		*output_pt++ = G_FROMYUV(Y1,U,V); //b
-		*output_pt++ = B_FROMYU(Y1,U); //v
-	}
-	return FOUR_TWO_TWO;
-} 
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torbut16_Low
- *  Description:  Display Data on screen directly 
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torbut16_Low(unsigned char * input_ptr, unsigned char * source_ptr, 
-		                   unsigned int image_width, unsigned int image_height,short scr_w,
-				   short scr_h)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_ptr = source_ptr;
-	size = image_width * image_height >> 1;
-	unsigned short color;
-	unsigned short *loc;
-	int w = 0;
-	int h = 0;
-	unsigned char temp1,temp2,temp3;
-
-	for ( i = size; i > 0; i-- ) 
-	{
-		Y = CLIP(buff[0]+m_AdjLight);
-		U = buff[1] ;
-		Y1 = CLIP(buff[2]+m_AdjLight);
-		V = buff[3];
-		buff += 4;
-
-//		color  = (B_FROMYU(Y,U)>>3);
-//		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
-//		color += ((R_FROMYV(Y,V)>>3)<<11);
-
-		temp1 = (unsigned char)(B_FROMYU(Y,U)*m_FactB+0.5);
-		temp2 = (unsigned char)(G_FROMYUV(Y,U,V)*m_FactG+0.5);
-		temp3 = (unsigned char)(R_FROMYV(Y,V)*m_FactR+0.5);
-		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
-
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + h * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + h * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + ( h + 1 ) * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + ( h + 1 ) * 2 ) );
-		*loc = color;
-		
-		w +=2;
-		if ( w == image_width * 2 )
-		{
-			w = 0;
-			h +=2;
-		}
-
-//		color  = ( B_FROMYU(Y1,U)>>3 );
-//		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
-//		color += ((R_FROMYV(Y1,V)>>3)<<11);
-
-		temp1 = (unsigned char)(B_FROMYU(Y1,U)*m_FactB+0.5);
-		temp2 = (unsigned char)(G_FROMYUV(Y1,U,V)*m_FactG+0.5);
-		temp3 = (unsigned char)(R_FROMYV(Y1,V)*m_FactR+0.5);
-		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
-
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + h * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + h * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + ( h + 1 ) * 2 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + ( h + 1 ) * 2 ) );
-		*loc = color;
-		
-		w +=2;
-		if ( w == image_width * 2 )
-		{
-			w = 0;
-			h +=2;
-		}
-	}
-	return FOUR_TWO_TWO;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torbut16_5097_Low
- *  Description:  Display Data on screen directly 
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torbut16_5097_Low(unsigned char * input_ptr, unsigned char * source_ptr, 
-		                   unsigned int image_width, unsigned int image_height,short scr_w,
-				   short scr_h)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_ptr = source_ptr + scr_w * m_Posy * 2 + m_Posx * 2;
-	size = image_width * image_height >> 1;
-	unsigned short color;
-	unsigned short *loc;
-	int w = 0;
-	int h = 0;
-	unsigned char temp1,temp2,temp3;
-
-	for ( i = size; i > 0; i-- ) 
-	{
-		Y = CLIP(buff[0]+m_AdjLight);
-		U = buff[1] ;
-		Y1 = CLIP(buff[2]+m_AdjLight);
-		V = buff[3];
-		buff += 4;
-
-		temp1 = (unsigned char)(B_FROMYU(Y,U)*m_FactB+0.5);
-		temp2 = (unsigned char)(G_FROMYUV(Y,U,V)*m_FactG+0.5);
-		temp3 = (unsigned char)(R_FROMYV(Y,V)*m_FactR+0.5);
-		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
-
-		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( ( w + 1 ) << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( ( w + 1 ) << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( w << 1 ) );
-		*loc = color;
-		
-		w +=2;
-		if ( w == image_width * 2 )
-		{
-			w = 0;
-			h +=2;
-		}
-
-
-		temp1 = (unsigned char)(B_FROMYU(Y1,U)*m_FactB+0.5);
-		temp2 = (unsigned char)(G_FROMYUV(Y1,U,V)*m_FactG+0.5);
-		temp3 = (unsigned char)(R_FROMYV(Y1,V)*m_FactR+0.5);
-		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
-
-		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( ( w + 1 ) << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( ( w + 1 ) << 1 ) );
-		*loc = color;
-		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( w << 1 ) );
-		*loc = color;
-		
-		w +=2;
-		if ( w == image_width * 2 )
-		{
-			w = 0;
-			h +=2;
-		}
-	}
-	return FOUR_TWO_TWO;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torbut16_High
- *  Description:  Display Data on screen directly 
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torbut16_High(unsigned char * input_ptr, unsigned char * source_ptr, 
-		                   unsigned int image_width, unsigned int image_height,short scr_w,
-				   short scr_h)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_ptr = source_ptr;
-	size = image_width * image_height >> 1;
-	unsigned short color,color1;
-	unsigned short *loc;
-	int w = 0;
-	int h = 0;
-
-	for ( i = size; i > 0; i-- ) 
-	{
-		Y = buff[0];
-		U = buff[1] ;
-		Y1 = buff[2];
-		V = buff[3];
-		buff += 4;
-
-		color  = (B_FROMYU(Y,U)>>3);
-		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + (  ( scr_w - 1 - w ) * ( scr_h << 1 )  + ( h << 1 ) ) ) = color;
-
-		w ++;
-
-		color  = ( B_FROMYU(Y1,U)>>3 );
-		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y1,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + (  ( scr_w - 1 - w ) * ( scr_h << 1 )  + ( h << 1 ) ) ) = color;
-
-		w ++;
-		if ( w == image_width )
-		{
-			w = 0;
-			h ++;
-		}
-	}
-
-	return FOUR_TWO_TWO;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torbut16_High
- *  Description:  Display Data on screen directly 
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torbut16_5097_High(unsigned char * input_ptr, unsigned char * source_ptr, 
-		                   unsigned int image_width, unsigned int image_height,short scr_w,
-				   short scr_h)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_ptr = source_ptr + scr_w * m_Posy * 2 + m_Posx * 2;
-	size = image_width * image_height >> 1;
-	unsigned short color,color1;
-	unsigned short *loc;
-	int w = 0;
-	int h = 0;
-
-	for ( i = size; i > 0; i-- ) 
-	{
-		Y = buff[0];
-		U = buff[1] ;
-		Y1 = buff[2];
-		V = buff[3];
-		buff += 4;
-
-		color  = (B_FROMYU(Y,U)>>3);
-		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
-
-		w ++;
-
-		color  = ( B_FROMYU(Y1,U)>>3 );
-		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y1,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
-
-		w ++;
-		if ( w == image_width )
-		{
-			w = 0;
-			h ++;
-		}
-	}
-
-	return FOUR_TWO_TWO;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Pyuv422torbut16_High
- *  Description:  Display Data on screen directly 
- * =====================================================================================
- */
-unsigned int Video::Pyuv422torbut16_5097_Super_High(unsigned char * input_ptr, unsigned char * source_ptr, 
-		                   unsigned int image_width, unsigned int image_height,short scr_w,
-				   short scr_h)
-{
-	unsigned int i, size;
-	unsigned char Y, Y1, U, V;
-	unsigned char *buff = input_ptr;
-	unsigned char *output_ptr = source_ptr;
-	size = image_width * image_height >> 1;
-	unsigned short color,color1;
-	unsigned short *loc;
-	int w = 0;
-	int h = 0;
-
-	for ( i = size; i > 0; i-- )
-	{
-		Y = buff[0];
-		U = buff[1] ;
-		Y1 = buff[2];
-		V = buff[3];
-		buff += 4;
-
-		color  = (B_FROMYU(Y,U)>>3);
-		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
-
-		w ++;
-
-		color  = ( B_FROMYU(Y1,U)>>3 );
-		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
-		color += ((R_FROMYV(Y1,V)>>3)<<11);
-
-		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
-
-		w ++;
-		if ( w == image_width )
-		{
-			w = 0;
-			h ++;
-		}
-	}
-
-	return FOUR_TWO_TWO;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  RGB_Functions
- *  Description:  RGB_Functions sets
- *
- *  R = Y + 1.403V'
- *  G = Y - 0.344U' - 0.714V'
- *  B = Y + 1.770U'
- * =====================================================================================
- */
-unsigned char Video::R_FROMYV(unsigned char y, unsigned char v)
-{
-	return CLIP(y + LutRv[v]);
-}
-
-unsigned char Video::G_FROMYUV(unsigned char y, unsigned char u, unsigned char v)
-{
-	return CLIP(y + LutGu[u] + LutGv[v]);
-}
-
-unsigned char Video::B_FROMYU(unsigned char y, unsigned char u)
-{
-	return CLIP(y + LutBu[u]);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Pic
- *  Description:  Sample picture 
- * =====================================================================================
- */
-void Video::Sample_Pic()
-{
-	for ( int i=0;i<2;i++ )
-	{
-		uvcGrab(videoIn);
-	}
-	get_pictureYV2(videoIn->framebuffer,videoIn->width,videoIn->height);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Pic
- *  Description:  Sample picture 
- * =====================================================================================
- */
-void Video::Sample_Pic2(unsigned char* pic)
-{
-	if ( uvcGrab(videoIn) != -1 )
-		fill_bufYV2((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Pic
- *  Description:  Sample picture 
- * =====================================================================================
- */
-void Video::Sample_Pic3(unsigned char* pic,short scr_w,short scr_h)
-{
-	if ( uvcGrab(videoIn) != -1 )
-	{
-		if 	( videoIn->width == 160 && videoIn->height == 120 )
-			Pyuv422torbut16_Low((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
-		else if ( videoIn->width == 320 && videoIn->height == 240 )
-			Pyuv422torbut16_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
-	}
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Pic4
- *  Description:  Smart5097 Used Function 
- * =====================================================================================
- */
-void Video::Sample_Pic4(unsigned char* pic,short scr_w,short scr_h)
-{
-	if ( uvcGrab(videoIn) != -1 )
-	{
-		if 	( videoIn->width == 160 && videoIn->height == 120 )
-			Pyuv422torbut16_5097_Low((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
-		else if ( videoIn->width == 320 && videoIn->height == 240 )
-			Pyuv422torbut16_5097_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
-		else if ( videoIn->width == 640 && videoIn->height == 480 )
-			Pyuv422torbut16_5097_Super_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Adjust_Light
- *  Description:  flag == false more light 
- *                flag == true more dark
- * =====================================================================================
- */
-void Video::Adjust_Light(bool flag)
-{
-	if ( flag == false )
-		m_AdjLight ++;
-	else
-		m_AdjLight --;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Video_Info
- *  Description:  Show Video Infomation 
- * =====================================================================================
- */
-void Video::Show_Video_Info()
-{
-	struct vdIn	*vd = videoIn;
-	memset(&vd->fmt, 0, sizeof(struct v4l2_format));
-	vd->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	if (ioctl(vd->fd, VIDIOC_G_FMT, &vd->fmt) < 0)
-	{
-		printf("get format failed\n");
-	}
-	else
-	{
-		printf("Video Width = %d\n", vd->fmt.fmt.pix.width);
-		printf("Video Height = %d\n", vd->fmt.fmt.pix.height);
-	 	unsigned char F1,F2,F3,F4;	
-		F1 = vd->fmt.fmt.pix.pixelformat & 0xff;
-		F2 = ( vd->fmt.fmt.pix.pixelformat >> 8 ) & 0xff;
-		F3 = ( vd->fmt.fmt.pix.pixelformat >> 16 ) & 0xff;
-		F4 = ( vd->fmt.fmt.pix.pixelformat >> 24 ) & 0xff;
-		printf ( "Video Format = %c%c%c%c\n",F1,F2,F3,F4 );
-	}
-
-//	v4l2_std_id id;
-//	int ret;
-//	int add=0;
-//	do{
-//		ret = ioctl(vd->fd,VIDIOC_QUERYSTD,&id);
-//		add ++;
-//	}while( ret == -1 && add < 1000 );
-//
-//	if ( add >= 999 )
-//	{
-//		printf ( "can't get value\n" );
-//	}
-//
-//	if 	( id == V4L2_STD_NTSC )
-//	{
-//		printf ( "Video std = ntsc \n" );
-//	}
-//	else if ( id == V4L2_STD_PAL )
-//	{
-//		printf ( "Video std = pal \n" );
-//	}
-//	else
-//	{
-//		printf ( "no found std\n" );
-//	}
-
-
-//	struct v4l2_fmtdesc* argp;
-//	memset(argp, 0, sizeof(struct v4l2_fmtdesc));
-//	if (ioctl(vd->fd, VIDIOC_ENUM_FMT, argp) < 0)
-//	{
-//		printf ( "%d\n",argp->type );
-//	}
-}
diff --git a/src/EVA11/Video.h b/src/EVA11/Video.h
deleted file mode 100644
index e992c0e..0000000
--- a/src/EVA11/Video.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  Video.h
- *
- *    Description:  Manage USB port camera class
- *
- *        Version:  1.0
- *        Created:  2011年12月05日 20时14分48秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  Eddysun Xiamen
- *
- * =====================================================================================
- */
-
-#ifndef  _VIDEO_INC
-#define  _VIDEO_INC
-
-#include	"VideoHead.h"
-
-class Video
-{
-	public:
-		Video();
-		~Video();
-		bool Init_Video(int width,int height);
-		void Release_Video();
-		void Sample_Pic();
-		void Sample_Pic2(unsigned char*);
-		void Sample_Pic3(unsigned char*,short scr_w,short scr_h);
-		void Sample_Pic4(unsigned char*,short scr_w,short scr_h);
-		void Adjust_Light(bool);
-
-		void Set_Output_Pos(const int& x,const int& y); 
-	private:
-		int init_videoIn(struct vdIn *vd, char *device, 
-				int width, int height, int fps,
-			        int format, int grabmethod, char *avifilename);
-		int init_v4l2(struct vdIn *vd);
-		int close_v4l2(struct vdIn *vd);
-		void initLut(void);
-		void freeLut(void);
-		int video_disable(struct vdIn *vd);
-		int video_enable(struct vdIn *vd);
-		int uvcGrab(struct vdIn *vd);
-		int get_pictureYV2(unsigned char *buf,int width,int height);
-		int fill_bufYV2(unsigned char *buf,unsigned char *pic,int width,int height);
-		void getPictureName (char *Picture, int fmt);
-		unsigned char R_FROMYV(unsigned char y, unsigned char v);
-		unsigned char G_FROMYUV(unsigned char y,unsigned char u ,unsigned char v);
-		unsigned char B_FROMYU(unsigned char y, unsigned char u);
-		unsigned int  Pyuv422torgb24(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height);
-
-		unsigned int  Pyuv422torbut16_Low(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
-		unsigned int  Pyuv422torbut16_High(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
-
-		unsigned int  Pyuv422torbut16_5097_Super_High(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
-		unsigned int  Pyuv422torbut16_5097_High(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
-		unsigned int  Pyuv422torbut16_5097_Low(unsigned char * input_ptr, unsigned char * output_ptr, 
-			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
-
-		void Show_Video_Info();
-	private:
-#ifdef ARM9
-		constexpr static double	m_FactR = static_cast<double>(31) / static_cast<double>(255);
-		constexpr static double	m_FactG = static_cast<double>(63) / static_cast<double>(255);
-		constexpr static double	m_FactB = static_cast<double>(31) / static_cast<double>(255);
-#endif
-
-#ifdef X86 
-		const static double	m_FactR = 31. / 255.;
-		const static double	m_FactG = 63. / 255.;
-		const static double	m_FactB = 31. / 255.;
-#endif
-
-		int		m_Width;
-		int		m_Height;
-		int 		*LutRv ;
-		int 		*LutGu ;
-		int 		*LutGv ;
-		int		*LutBu ;
-		struct vdIn	*videoIn;
-		v4l2_buffer     t_buf;
-		v4l2_buffer 	q_buf;
-		unsigned char	m_AdjLight;
-
-		int		m_Posx;
-		int		m_Posy;
-};
-#endif   /* ----- #ifndef _VIDEO_INC  ----- */
diff --git a/src/EVA11/VideoHead.h b/src/EVA11/VideoHead.h
deleted file mode 100644
index e413877..0000000
--- a/src/EVA11/VideoHead.h
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  VideoHead.h
- *
- *    Description:  Video class used head file
- *
- *        Version:  1.0
- *        Created:  2011年12月05日 20时42分28秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  kevin.wang (), kevin.wang2004@gmail.com
- *        Company:  Eddysun Xiamen
- *
- * =====================================================================================
- */
-#ifndef  _VIDEOHEAD_INC
-#define  _VIDEOHEAD_INC
-
-#include 	<cstdio>
-#include	<cstdlib>
-#include 	<string.h>
-#include 	<fcntl.h>
-#include 	<unistd.h>
-#include 	<errno.h>
-#include 	<sys/ioctl.h>
-#include 	<sys/mman.h>
-#include 	<sys/select.h>
-#include 	<linux/videodev2.h>
-
-#define NB_BUFFER 	    	4//4
-#define AVI_MAX_TRACKS  	2
-
-#define uint32_t 		unsigned int 
-#define uint8_t  		unsigned char 
-#define uint16_t 		unsigned short
-#define uint64_t 		unsigned long long
-
-typedef struct
-{
-	off_t key;
-	off_t pos;
-	off_t len;
-} video_index_entry;
-
-typedef struct
-{
-	off_t pos;
-	off_t len;
-	off_t tot;
-} audio_index_entry;
-
-typedef struct track_s
-{
-	long   a_fmt;             /* Audio format, see #defines below */
-	long   a_chans;           /* Audio channels, 0 for no audio */
-	long   a_rate;            /* Rate in Hz */
-	long   a_bits;            /* bits per audio sample */
-	long   mp3rate;           /* mp3 bitrate kbs*/
-	long   audio_strn;        /* Audio stream number */
-	off_t  audio_bytes;       /* Total number of bytes of audio data */
-	long   audio_chunks;      /* Chunks of audio data in the file */
-	char   audio_tag[4];      /* Tag of audio data */
-	long   audio_posc;        /* Audio position: chunk */
-	long   audio_posb;        /* Audio position: byte within chunk */
-	off_t a_codech_off;       /* absolut offset of audio codec information */ 
-	off_t a_codecf_off;       /* absolut offset of audio codec information */ 
-	audio_index_entry *audio_index;
-} track_t;
-
-typedef struct
-{
-	uint32_t	bi_size;
-	uint32_t  bi_width;
-	uint32_t  bi_height;
-	uint16_t  bi_planes;
-	uint16_t  bi_bit_count;
-	uint32_t  bi_compression;
-	uint32_t  bi_size_image;
-	uint32_t  bi_x_pels_per_meter;
-	uint32_t  bi_y_pels_per_meter;
-	uint32_t  bi_clr_used;
-	uint32_t  bi_clr_important;
-} BITMAPINFOHEADER_avilib;
-
-typedef struct
-{
-	uint16_t  w_format_tag;
-	uint16_t  n_channels;
-	uint32_t  n_samples_per_sec;
-	uint32_t  n_avg_bytes_per_sec;
-	uint16_t  n_block_align;
-	uint16_t  w_bits_per_sample;
-	uint16_t  cb_size;
-} WAVEFORMATEX_avilib;
-
-typedef struct
-{
-	uint32_t fcc_type; 
-	uint32_t fcc_handler; 
-	uint32_t dw_flags; 
-	uint32_t dw_caps; 
-	uint16_t w_priority;
-	uint16_t w_language;
-	uint32_t dw_scale;
-	uint32_t dw_rate;
-	uint32_t dw_start;
-	uint32_t dw_length;
-	uint32_t dw_initial_frames;
-	uint32_t dw_suggested_buffer_size;
-	uint32_t dw_quality;
-	uint32_t dw_sample_size;
-	uint32_t dw_left;
-	uint32_t dw_top;
-	uint32_t dw_right;
-	uint32_t dw_bottom;
-	uint32_t dw_edit_count;
-	uint32_t dw_format_change_count;
-	char     sz_name[64];
-} AVISTREAMINFO;
-
-typedef struct
-{
-	long   fdes;              /* File descriptor of AVI file */
-	long   mode;              /* 0 for reading, 1 for writing */
-
-	long   width;             /* Width  of a video frame */
-	long   height;            /* Height of a video frame */
-	double fps;               /* Frames per second */
-	char   compressor[8];     /* Type of compressor, 4 bytes + padding for 0 byte */
-	char   compressor2[8];     /* Type of compressor, 4 bytes + padding for 0 byte */
-	long   video_strn;        /* Video stream number */
-	long   video_frames;      /* Number of video frames */
-	char   video_tag[4];      /* Tag of video data */
-	long   video_pos;         /* Number of next frame to be read
-			       (if index present) */
-
-	unsigned long max_len;    /* maximum video chunk present */
-
-	track_t track[AVI_MAX_TRACKS];  // up to AVI_MAX_TRACKS audio tracks supported
-
-	off_t pos;        /* position in file */
-	long   n_idx;             /* number of index entries actually filled */
-	long   max_idx;           /* number of index entries actually allocated */
-
-	off_t v_codech_off;       /* absolut offset of video codec (strh) info */ 
-	off_t v_codecf_off;       /* absolut offset of video codec (strf) info */ 
-
-	unsigned char (*idx)[16]; /* index entries (AVI idx1 tag) */
-	video_index_entry *video_index;
-
-	off_t last_pos;          /* Position of last frame written */
-	unsigned long last_len;          /* Length of last frame written */
-	int must_use_index;              /* Flag if frames are duplicated */
-	off_t movi_start;
-
-	int anum;            // total number of audio tracks 
-	int aptr;            // current audio working track 
-
-	BITMAPINFOHEADER_avilib *bitmap_info_header;
-	WAVEFORMATEX_avilib *wave_format_ex[AVI_MAX_TRACKS];
-} avi_t;
-
-struct vdIn {
-	int fd;
-	char *videodevice;
-	char *status;
-	char *pictName;
-	struct v4l2_capability cap;
-	struct v4l2_format fmt;
-	struct v4l2_buffer buf;
-	struct v4l2_requestbuffers rb;
-	void *mem[NB_BUFFER];
-	int mapbuflength[NB_BUFFER];
-	unsigned char *framebuffer;
-	int isstreaming;
-	int grabmethod;
-	int width;
-	int height;
-	int fps;
-	int formatIn;
-	int formatOut;
-	int framesizeIn;
-	int signalquit;
-	int toggleAvi;
-	int getPict;
-	int rawFrameCapture;
-	/* raw frame capture */
-	unsigned int fileCounter;
-	/* raw frame stream capture */
-	unsigned int rfsFramesWritten;
-	unsigned int rfsBytesWritten;
-	/* raw stream capture */
-	FILE *captureFile;
-	unsigned int framesWritten;
-	unsigned int bytesWritten;
-	avi_t *avifile;
-	char *avifilename;
-	int framecount;
-	int recordstart;
-	int recordtime;
-};
-#endif   /* ----- #ifndef videohead_INC  ----- */
-
diff --git a/src/EVA11/VideoPanel.cpp b/src/EVA11/VideoPanel.cpp
deleted file mode 100644
index bbc35ed..0000000
--- a/src/EVA11/VideoPanel.cpp
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  VideoPanel.cpp
- *
- *    Description:  implementation of VideoPanel class
- *
- *        Version:  1.0
- *        Created:  2012年07月19日 10时57分49秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Video.h"
-#include 	"Msgbox.h"
-#include 	"Algorithm.h"
-
-#include 	"Object.h"
-#include 	"BasePanel.h"
-#include 	"VideoPanel.h"
-
-#include 	"FreeType.h"
-
-VideoPanel::VideoPanel (int x,int y,int width,int heigh)
-	: BasePanel(x,y,width,heigh)
-{
-}
-
-VideoPanel::~VideoPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI screen object 
- * =====================================================================================
- */
-void VideoPanel::Init_GUI(Graphic& g)
-{
-	m_pVideo                = new Video;
-
-	m_VideoX                = 100;
-	m_VideoY                = 109;
-
-	m_pVideo->Set_Output_Pos(m_VideoX,m_VideoY);
-
-	m_VideoW                = 320;
-	m_VideoH                = 240;
-
-	m_Status                = 0;
-	resolution_x            = 160;
-	resolution_y            = 120;
-	
-	m_bVideoEnableFlag      = false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI object 
- * =====================================================================================
- */
-void VideoPanel::Destroy_GUI()
-{
-	if ( m_bVideoEnableFlag == true )
-	{
-		m_pVideo->Release_Video();
-	}
-	delete m_pVideo;
-	m_pVideo = NULL;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Only Drawme on screen 
- * =====================================================================================
- */
-void VideoPanel::Drawme(Graphic& g,bool flag)
-{
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0x000000));
-	DrawColorbar(g);
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawColorbar
- *  Description:  
- * =====================================================================================
- */
-void VideoPanel::DrawColorbar(Graphic& g)
-{
-	int step = (m_VideoW >> 3);
-	g.DrawFillRect(m_VideoX,m_VideoY,step,m_VideoH,g.RGB24_16(0xff0000));
-	g.DrawFillRect(m_VideoX+step,m_VideoY,step,m_VideoH,g.RGB24_16(0xff00ff));
-	g.DrawFillRect(m_VideoX+2*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x0000ff));
-	g.DrawFillRect(m_VideoX+3*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x00ffff));
-	g.DrawFillRect(m_VideoX+4*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x00ff00));
-	g.DrawFillRect(m_VideoX+5*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0xffff00));
-	g.DrawFillRect(m_VideoX+6*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x000000));
-	g.DrawFillRect(m_VideoX+7*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0xffffff));
-}
-		
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Status
- *  Description:  Set the video status
- * =====================================================================================
- */
-void VideoPanel::Set_Status(int status)
-{
-	if 	( status == 0 )
-	{
-		resolution_x = 160;
-		resolution_y = 120;
-	}
-	else if ( status == 1 )
-	{
-		resolution_x = 320;
-		resolution_y = 240;
-	}
-	else if ( status == 2 )
-	{
-		resolution_x = 640;
-		resolution_y = 480;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Video
- *  Description:  Init the video device when enter the loop
- * =====================================================================================
- */
-void VideoPanel::Init_Video(Graphic& g)
-{
-	if 	( m_bVideoEnableFlag == false )
-	{
-		if 	( m_pVideo->Init_Video(resolution_x,resolution_y) == true )
-		{
-			m_bVideoEnableFlag = true;
-		}
-		else
-		{
-			Language *pl = Language::Instance();
-			Msgbox *ms = new Msgbox(200,170,260,80,pl->GetText(INFORMESG22),Msgbox::MSG_OK);
-			ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-			ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-			ms->Showme(g);
-			delete ms;
-			ms = NULL;
-		}
-	}
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  
- * =====================================================================================
- */
-int VideoPanel::Loop_Panel(Graphic& g)
-{
-	if 	( g.Get_bpp() == 8 )
-		return 0;
-
-	if 	( m_bVideoEnableFlag == true )
-	{
-		m_pVideo->Sample_Pic4(g.Get_Screen_Ptr(),640,480);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void VideoPanel::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_FX_Fun
- *  Description:  Key Function process 
- * =====================================================================================
- */
-int VideoPanel::Key_F2_Fun(Graphic& g)
-{
-}
-int VideoPanel::Key_F3_Fun(Graphic& g)
-{
-}
-int VideoPanel::Key_F4_Fun(Graphic& g)
-{
-}
-int VideoPanel::Key_F6_Fun(Graphic& g)
-{
-}
-int VideoPanel::Key_NL1_Fun(Graphic& g,int sub)
-{
-	if 	( m_bVideoEnableFlag == false )
-		Init_Video(g);
-}
-int VideoPanel::Key_NR1_Fun(Graphic& g,int sub)
-{
-	if 	( m_bVideoEnableFlag == false )
-		Init_Video(g);
-}
-int VideoPanel::Key_NL2_Fun(Graphic& g,int sub)
-{
-	if 	( m_bVideoEnableFlag == true )
-	{
-		m_pVideo->Release_Video();
-		m_bVideoEnableFlag = false;
-		g.DrawFillRect(m_VideoX,m_VideoY,m_VideoW,m_VideoH+1,g.RGB24_16(0x000000));
-		DrawColorbar(g);
-	}
-}
-int VideoPanel::Key_NR2_Fun(Graphic& g,int sub)
-{
-	if 	( m_bVideoEnableFlag == true )
-	{
-		m_pVideo->Release_Video();
-		m_bVideoEnableFlag = false;
-		g.DrawFillRect(m_VideoX,m_VideoY,m_VideoW,m_VideoH+1,g.RGB24_16(0x000000));
-		DrawColorbar(g);
-	}
-}
-int VideoPanel::Key_NL3_Fun(Graphic& g,int sub)
-{
-	if ( m_bVideoEnableFlag == true )
-	{
-		if ( m_Status == 0 )
-			m_Status = 1;
-		else
-			m_Status --;
-
-		Set_Status(m_Status);
-		m_pVideo->Release_Video();
-		m_bVideoEnableFlag = false;
-		Init_Video(g);
-	}
-}
-int VideoPanel::Key_NR3_Fun(Graphic& g,int sub)
-{
-	if ( m_bVideoEnableFlag == true )
-	{
-		if ( m_Status == 1 )
-			m_Status = 0;
-		else
-			m_Status ++;
-
-		Set_Status(m_Status);
-		m_pVideo->Release_Video();
-		m_bVideoEnableFlag = false;
-		Init_Video(g);
-	}
-}
diff --git a/src/EVA11/VideoPanel.h b/src/EVA11/VideoPanel.h
deleted file mode 100644
index ac99e26..0000000
--- a/src/EVA11/VideoPanel.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  VideoPanel.h
- *
- *    Description:  only display vieo
- *
- *        Version:  1.0
- *        Created:  2012年07月19日 10时55分42秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _VIDEOPANEL_INC
-#define  _VIDEOPANEL_INC
-
-class BasePanel;
-class Video;
-class VideoPanel : public BasePanel
-{
-	public:
-		VideoPanel (int x,int y,int width,int heigh);
-		~VideoPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-
-		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-
-		void Init_Video(Graphic& g);
-		void Set_Status(int);
-
-	protected:
-
-		void DrawColorbar(Graphic& g);
-
-	private:
-		Video			*m_pVideo;
-
-		int			m_VideoX;
-		int			m_VideoY;
-		int			m_VideoW;
-		int			m_VideoH;
-
-		bool			m_bVideoEnableFlag;
-
-		int			m_Status;                 /* 0:low   1:high   2:super high */
-		int 			resolution_x;
-                int                	resolution_y;
-};
-
-#endif
diff --git a/src/EVA11/ZKPanel.cpp b/src/EVA11/ZKPanel.cpp
deleted file mode 100644
index 8e6bea7..0000000
--- a/src/EVA11/ZKPanel.cpp
+++ /dev/null
@@ -1,941 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ZKPanel.cpp
- *
- *    Description:  implementation of ZKPanel class
- *
- *        Version:  1.0
- *        Created:  2012年07月23日 20时01分10秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#include 	<new>
-
-#include 	"Object.h"
-#include 	"IDataProcess.h"
-#include 	"ConcreteDataProcess.h"
-#include 	"Language.h"
-#include 	"Graphic.h"
-#include 	"Global.h"
-#include 	"Bufferbar.h"
-#include 	"Device.h"
-#include 	"DataRepo.h"
-#include 	"Label.h"
-#include 	"Chart.h"
-#include 	"Language.h"
-
-#include 	"Msgbox.h"
-
-#include 	"AlarmManage.h"
-#include 	"Basescreen.h"
-#include 	"ZScreen.h"
-#include 	"BasePanel.h"
-#include 	"ZKPanel.h"
-
-#include 	"FreeType.h"
-
-#include 	"Logic.h"
-#include 	"Resource.h"
-
-const static  char* AlarmText[8] = {"A","B","C","D","E","F","G","H"};
-
-ZKPanel::ZKPanel (int x,int y,int width,int heigh)
-	: BasePanel(x,y,width,heigh)
-{
-}
-
-ZKPanel::~ZKPanel ()
-{
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Drawme
- *  Description:  Draw the GUI on scree
- * =====================================================================================
- */
-void ZKPanel::Drawme(Graphic& g,bool flag)
-{
-	DataRepo *datarepo = DataRepo::Instance();
-	if 	( flag == true )
-		g.Switch_Screen();
-	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
-
-	Refresh_FREQ(g);
-	Refresh_Signal(g);
-	Swtich_Status(g);
-
-	m_LabFreMsg->Drawme(g,false);
-	m_LabAMPMsg->Drawme(g,false);
-	m_LabPHAMsg->Drawme(g,false);
-	m_LabCHAMsg->Drawme(g,false);
-	m_LabAlarmSt->Drawme(g,false);
-
-	m_Zscreen->Drawme(g,false);
-	m_Chart->Drawme(g,false);
-	m_AlarmManage->Draw_Alarm_Sets(g,false);
-
-	if 	( flag == true )
-	{
-		g.Switch_Screen();
-		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_GUI
- *  Description:  Init the GUI object 
- * =====================================================================================
- */
-void ZKPanel::Init_GUI(Graphic& g)
-{
-	Global *gp = Global::Instance();
-
-	m_Zscreen = new(std::nothrow) Zscreen(2+130,13+31,400,399);
-	m_Zscreen->Set_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
-
-	m_Zscreen->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
-	m_Zscreen->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
-	m_Zscreen->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
-	m_Zscreen->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
-	m_Zscreen->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
-	m_Zscreen->Set_ID(1);
-
-	m_Bufbar = new(std::nothrow) Bufferbar(2,2,532,6);
-	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
-	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
-	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
-
-	m_LabFreMsg = new Label(131+265,8,104,18);
-	m_LabFreMsg->Set_Label_Type(Label::LA_THIN);
-	m_LabFreMsg->Set_Font_Size(16);
-	m_LabFreMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_LabFreMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_LabFreMsg->Set_Text(" ");
-
-	m_LabAMPMsg = new Label(131+265,25,104,18);
-	m_LabAMPMsg->Set_Label_Type(Label::LA_THIN);
-	m_LabAMPMsg->Set_Font_Size(16);
-	m_LabAMPMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_LabAMPMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_LabAMPMsg->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	m_LabAMPMsg->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	m_LabAMPMsg->Set_Focus(true);
-	m_LabAMPMsg->Set_Text(" ");
-
-	m_LabPHAMsg = new Label(42+265,25,90,18);
-	m_LabPHAMsg->Set_Label_Type(Label::LA_THIN);
-	m_LabPHAMsg->Set_Font_Size(16);
-	m_LabPHAMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_LabPHAMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_LabPHAMsg->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
-	m_LabPHAMsg->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
-	m_LabPHAMsg->Set_Focus(true);
-	m_LabPHAMsg->Set_Text(" ");
-
-	m_LabCHAMsg = new Label(42+265,8,90,18);
-	m_LabCHAMsg->Set_Label_Type(Label::LA_THIN);
-	m_LabCHAMsg->Set_Font_Size(16);
-	m_LabCHAMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
-	m_LabCHAMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
-	m_LabCHAMsg->Set_Display_Type(Label::LA_DT_LEFT);
-	m_LabCHAMsg->Set_Text(" ");
-
-	m_LastStatus = 0xff;
-
-	m_LabAlarmSt = new(std::nothrow) Label(235+265,9,30,32);
-	m_LabAlarmSt->Set_Label_Type(Label::LA_THIN);
-	m_LabAlarmSt->Set_Font_Size(24);
-	m_LabAlarmSt->Set_Text(" ");
-	m_LabAlarmSt->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	m_LabAlarmSt->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-
-	if 	( gp->DrawMode == 0 )
-		m_Zscreen->Set_Draw_Mode(Zscreen::POINT);
-	else if ( gp->DrawMode == 1 )
-		m_Zscreen->Set_Draw_Mode(Zscreen::LINE);
-	else if ( gp->DrawMode == 2 )
-		m_Zscreen->Set_Draw_Mode(Zscreen::AUTO);
-
-	m_DataProcess = new(std::nothrow) ZKDataProcess;
-
-	m_AlarmManage = new(std::nothrow) AlarmManage(2+130,13+31,400,399);
-	m_AlarmManage->Init_Alarm_Sets(g);
-
-	gp->bSNeedResetAlarmArea = true;                    // Notice when init we need let DZK to load alarm para
-	Load_Alarm_Para();
-
-	m_Chart = new(std::nothrow) Chart(2,13+31,130,399);
-	m_Chart->Set_Chart_Direct(Chart::VERTICAL);
-	m_Chart->Set_Coef(m_Heigh);
-
-	m_gp->bSingleSrcPause = false;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Alarm_Para
- *  Description:  Load Alarm Parameters from Global 
- *                When Load Para from device call this function
- * =====================================================================================
- */
-void ZKPanel::Load_Alarm_Para()
-{
-	Global* gp = Global::Instance();
-	if 	( gp->bSNeedResetAlarmArea == true )
-	{
-		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
-		for ( int i=0;i<3;i++ )
-		{
-			m_AlarmManage->Set_Alarm_Index(i,gp->SAlarmIndex[i]);
-			m_AlarmManage->Set_Alarm_Count(i,gp->SAlarmCount[i]);
-		}
-		m_AlarmManage->Load_Alarm_Para(gp->SAlarmPara);
-
-		m_AlarmManage->Create_Alarm_Area_Mask();
-		gp->bSNeedResetAlarmArea = false;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Destroy_GUI
- *  Description:  Destroy the GUI Object 
- * =====================================================================================
- */
-void ZKPanel::Destroy_GUI()
-{
-	if ( m_Zscreen != NULL )
-	{
-		delete m_Zscreen;
-		m_Zscreen = NULL;
-	}
-	if ( m_LabFreMsg != NULL )
-	{
-		delete m_LabFreMsg;
-		m_LabFreMsg = NULL;
-	}
-	if ( m_LabAMPMsg != NULL )
-	{
-		delete m_LabAMPMsg;
-		m_LabAMPMsg = NULL;
-	}
-	if ( m_LabPHAMsg != NULL )
-	{
-		delete m_LabPHAMsg;
-		m_LabPHAMsg = NULL;
-	}
-	if ( m_LabCHAMsg != NULL )
-	{
-		delete m_LabCHAMsg;
-		m_LabCHAMsg = NULL;
-	}
-
-	if ( m_LabAlarmSt != NULL )
-	{
-		delete m_LabAlarmSt;
-		m_LabAlarmSt = NULL;
-	}
-	if ( m_DataProcess != NULL )
-	{
-		delete m_DataProcess;
-		m_DataProcess = NULL;
-	}
-	if ( m_Bufbar != NULL )
-	{
-		delete m_Bufbar;
-		m_Bufbar = NULL;
-	}
-	if ( m_Chart != NULL )
-	{
-		delete m_Chart;
-		m_Chart = NULL;
-	}
-	m_AlarmManage->Destroy_Alarm_Sets();
-	if ( m_AlarmManage != NULL )
-	{
-		delete m_AlarmManage;
-		m_AlarmManage = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Loop_Panel
- *  Description:  important function, deal with data
- * =====================================================================================
- */
-int ZKPanel::Loop_Panel(Graphic& g)
-{
-	if ( m_gp->bSingleSrcPause == true ) return 0;
-
-	m_DataProcess->Data_Process();
-
-	m_DataProcess->Get_Data(m_RawBuf);
-
-	int x,y;
-	int result;
-
-	m_Zscreen->Draw_ET_Point(g,m_RawBuf[(m_gp->DebugChan<<1)],m_RawBuf[(m_gp->DebugChan<<1)+1]);
-
-//	if ( m_gp->sos == true )
-//	{
-//		printf ( "sos end\n" );
-//		m_gp->sos = false;
-//	}
-
-	m_Zscreen->Get_SX_SY(x,y);
-	result = m_AlarmManage->Is_In_Alarm(x,y);
-
-	switch ( m_gp->TimeScaleDisp )
-	{
-		case 0:
-			{
-				m_Chart->Mapping_Value(g,m_RawBuf[(m_gp->DebugChan<<1)]);
-				for ( int i=0;i<m_gp->TimeScaleSpeed;i++ )
-					m_Chart->Roll_Bar(g);
-
-				if ( m_oldtick != m_gp->Tick )
-				{
-					m_Chart->Set_TimeScale(g);
-					m_oldtick = m_gp->Tick;
-				}
-			}
-			break;
-
-		case 1:
-			{
-				m_Chart->Mapping_Value(g,m_RawBuf[(m_gp->DebugChan<<1)+1]);
-				for ( int i=0;i<m_gp->TimeScaleSpeed;i++ )
-					m_Chart->Roll_Bar(g);
-
-				if ( m_oldtick != m_gp->Tick )
-				{
-					m_Chart->Set_TimeScale(g);
-					m_oldtick = m_gp->Tick;
-				}
-			}
-			break;
-
-		default:
-			break;
-	}				/* -----  end switch  ----- */
-
-	if (  result != 0xff )
-	{
-		if 	( result != m_LastStatus )
-		{
-			m_LabAlarmSt->Set_Text(AlarmText[result]);
-			m_LabAlarmSt->Drawme(g);
-			m_LastStatus = result;
-//			m_gp->AlarmStatus.set(m_LastStatus);
-		}
-	}
-	else
-	{
-		if 	( result != m_LastStatus )
-		{
-//			m_gp->AlarmStatus.reset(m_LastStatus);
-			m_LabAlarmSt->Set_Text(" ");
-			m_LabAlarmSt->Drawme(g);
-			m_LastStatus = result;
-		}
-	}
-
-	m_Bufbar->Save_Bytes_Number(g,1<<2);
-
-	return 0;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Show_Help_System
- *  Description:  Show the help message
- * =====================================================================================
- */
-void ZKPanel::Show_Help_System(Graphic& g,int x,int y)
-{
-	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
-	Language  *pl = Language::Instance();
-
-	FreeType *font = FreeType::Instance();
-	font->Set_Color(FreeType::FGCOLOR,fgcolor);
-	font->Set_Color(FreeType::BGCOLOR,bgcolor);
-	font->Set_Font_Size(16);
-	font->Set_Transparce(true);
-
-	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
-	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
-	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
-	font->Text(x+30,y+90,pl->GetText(HELPB1F2));
-	font->Text(x+30,y+110,pl->GetText(HELPB1F3));
-	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
-	font->Text(x+30,y+150,pl->GetText(HELPB1F5));
-	font->Text(x+30,y+170,pl->GetText(HELPB1F6));
-	font->Text(x+30,y+190,pl->GetText(HELPB1F7));
-	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
-	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_ZKScreen
- *  Description:  Clean the ZKScreen 
- * =====================================================================================
- */
-void ZKPanel::Clean_ZKScreen(Graphic& g)
-{
-	m_LabFreMsg->Drawme(g,true);
-	m_LabCHAMsg->Drawme(g,true);
-	m_LabAlarmSt->Drawme(g,true);
-
-	m_LabAMPMsg->Set_Text(" ");
-	m_LabPHAMsg->Set_Text(" ");
-	m_LabAMPMsg->Drawme(g,true);
-	m_LabPHAMsg->Drawme(g,true);
-
-	m_Zscreen->Drawme(g,true);
-	m_AlarmManage->Draw_Alarm_Sets(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Key_FX_Fun
- *  Description:  Shot Functions 
- * =====================================================================================
- */
-int ZKPanel::Key_F2_Fun(Graphic& g)
-{
-	if 	( m_gp->bSingleSrcPause == false )
-		Clean_ZKScreen(g);
-	else
-	{
-		Language *m_pl = Language::Instance();
-		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-		if ( ms->Showme(g) == true )
-		{
-			delete ms;
-			ms = NULL;
-			m_Zscreen->Clean_Photo();
-			m_Zscreen->Drawme(g);
-			return 0; 
-		}
-		delete ms;
-		ms = NULL;
-	}
-}
-int ZKPanel::Key_F3_Fun(Graphic& g)
-{
-	if 	( m_gp->DrawMode == 0 )
-	{
-		m_gp->DrawMode = 1;
-		m_Zscreen->Set_Draw_Mode(Zscreen::LINE);
-	}
-	else if ( m_gp->DrawMode == 1 )
-	{
-		m_gp->DrawMode = 2;
-		m_Zscreen->Set_Draw_Mode(Zscreen::AUTO);
-	}
-	else if ( m_gp->DrawMode == 2 )
-	{
-		m_gp->DrawMode = 0;
-		m_Zscreen->Set_Draw_Mode(Zscreen::POINT);
-	}
-	m_Zscreen->Reset_Trace();
-}
-int ZKPanel::Key_F4_Fun(Graphic& g)
-{
-	if 	( m_gp->bSingleSrcPause == false )
-	{
-		m_DataProcess->Trigger_Balacne_Process();
-		m_gp->sos = true;
-	}
-	else
-	{
-		m_Zscreen->Save_Photo(g);
-		m_Zscreen->Drawme(g);
-	}
-}
-int ZKPanel::Key_F6_Fun(Graphic& g)
-{
-	Language* m_pl = Language::Instance();
-	Msgbox *ms = new Msgbox(200,170,260,80,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
-	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
-	if ( ms->Showme(g) == false )
-	{
-		delete ms;
-		ms = NULL;
-		return 0;
-	}
-	delete ms;
-	ms = NULL;
-	m_Bufbar->Clean_Buffer_Bar(g);
-}
-
-int ZKPanel::Key_NL1_Fun(Graphic& g,int sub)
-{
-	Refresh_Signal(g);
-	Refresh_FREQ(g);
-	m_LabCHAMsg->Drawme(g,true);
-	m_LabFreMsg->Drawme(g,true);
-}
-int ZKPanel::Key_NR1_Fun(Graphic& g,int sub)
-{
-	Refresh_Signal(g);
-	Refresh_FREQ(g);
-	m_LabCHAMsg->Drawme(g,true);
-	m_LabFreMsg->Drawme(g,true);
-}
-int ZKPanel::Key_NL2_Fun(Graphic& g,int sub)         // gain
-{
-	m_gp->bSingleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
-	Refresh_AMP_PHA(g);
-}
-int ZKPanel::Key_NR2_Fun(Graphic& g,int sub)         // gain
-{
-	m_gp->bSingleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
-	Refresh_AMP_PHA(g);
-}
-int ZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bSingleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
-	Refresh_AMP_PHA(g);
-}
-int ZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // degree
-{
-	m_gp->bSingleSrcPause = true;
-	Swtich_Status(g);
-	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
-	Refresh_AMP_PHA(g);
-}
-int ZKPanel::Key_NL4_Fun(Graphic& g,int sub)
-{
-	Refresh_FREQ(g);
-	m_LabFreMsg->Drawme(g,true);
-}
-int ZKPanel::Key_NR4_Fun(Graphic& g,int sub)
-{
-	Refresh_FREQ(g);
-	m_LabFreMsg->Drawme(g,true);
-}
-
-int ZKPanel::Key_Enter_Fun(Graphic& g)
-{
-	m_gp->bSingleSrcPause = false;
-	Swtich_Status(g);
-
-	m_LabFreMsg->Drawme(g,true);
-	m_LabCHAMsg->Drawme(g,true);
-	m_LabAlarmSt->Drawme(g,true);
-
-	m_LabAMPMsg->Set_Text(" ");
-	m_LabPHAMsg->Set_Text(" ");
-	m_LabAMPMsg->Drawme(g,true);
-	m_LabPHAMsg->Drawme(g,true);
-
-	m_Zscreen->Drawme(g,true);
-	m_AlarmManage->Draw_Alarm_Sets(g,true);
-}
-
-/* --------------------------------------------------------------------- */
-/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
-/* --------------------------------------------------------------------- */
-
-int ZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->SAlarmType == 0  ) gp->SAlarmType = 3;
-		else gp->SAlarmType --;
-		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->SAlarmType == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->SAlarmIndex[gp->SAlarmType] == 0 )
-				gp->SAlarmIndex[gp->SAlarmType] = gp->SAlarmCount[gp->SAlarmType];
-			else
-				gp->SAlarmIndex[gp->SAlarmType] -= 1; 
-		}
-		m_AlarmManage->Set_Alarm_Index(gp->SAlarmType,gp->SAlarmIndex[gp->SAlarmType]);
-	}
-}
-int ZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->SAlarmType == 3  ) gp->SAlarmType = 0;
-		else gp->SAlarmType ++;
-		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		if ( gp->SAlarmType == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->SAlarmIndex[gp->SAlarmType] == 7 || 
-					gp->SAlarmIndex[gp->SAlarmType] >= gp->SAlarmCount[gp->SAlarmType] )
-			{
-				gp->SAlarmIndex[gp->SAlarmType] = 0;
-			}
-			else
-				gp->SAlarmIndex[gp->SAlarmType] += 1;
-		}
-		m_AlarmManage->Set_Alarm_Index(gp->SAlarmType,gp->SAlarmIndex[gp->SAlarmType]);
-	}
-}
-int ZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->SAlarmType == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->SAlarmCount[gp->SAlarmType] == 0 )
-				gp->SAlarmCount[gp->SAlarmType] = 7;
-			else
-			{
-				gp->SAlarmCount[gp->SAlarmType] --;
-				if ( gp->SAlarmCount[gp->SAlarmType] < gp->SAlarmIndex[gp->SAlarmType] )
-				{
-					gp->SAlarmIndex[gp->SAlarmType] = gp->SAlarmCount[gp->SAlarmType];
-				}
-			}
-			m_AlarmManage->Set_Alarm_Count(gp->SAlarmType,gp->SAlarmCount[gp->SAlarmType]);
-		}
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->SAlarmType == 3 )
-			return 0;
-		else
-		{
-			if 	( gp->SAlarmCount[gp->SAlarmType] == 7 )
-				gp->SAlarmCount[gp->SAlarmType] = 0;
-			else
-				gp->SAlarmCount[gp->SAlarmType] ++;
-			m_AlarmManage->Set_Alarm_Count(gp->SAlarmType,gp->SAlarmCount[gp->SAlarmType]);
-		}
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P1((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
-		else gp->AlarmBeep =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P2((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
-		else gp->AlarmOutput =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P3((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
-		else gp->AlarmDisplay =true;
-	}
-	else if ( sub == 2 )
-	{
-		m_AlarmManage->Adj_P4((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
-		Drawme(g,true);
-		gp->bSNeedResetAlarmArea = true;
-	}
-}
-int ZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-	}
-	else if ( sub == 2 )
-	{
-
-	}
-}
-int ZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
-{
-	Global *gp = Global::Instance();
-	if 	( sub == 1 )
-	{
-	}
-	else if ( sub == 2 )
-	{
-
-	}
-}
-
-int ZKPanel::Para_NL1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen->Adjust_Center_Point(g,Zscreen::LEFT,3);
-		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
-	}
-}
-int ZKPanel::Para_NR1_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen->Adjust_Center_Point(g,Zscreen::RIGHT,3);
-		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
-	}
-}
-int ZKPanel::Para_NL2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen->Adjust_Center_Point(g,Zscreen::UP,3);
-		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
-	}
-}
-int ZKPanel::Para_NR2_Fun(Graphic& g,int sub)
-{
-	if ( sub == 3 )
-	{
-		m_Zscreen->Adjust_Center_Point(g,Zscreen::DOWN,3);
-		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Panel
- *  Description:  Switch panel call this function 
- * =====================================================================================
- */
-void ZKPanel::Switch_Panel()
-{
-	Device* device = Device::Instance();
-	device->Write_Para_Func(Device::NORMAL);
-
-	for ( int ch=0;ch<1;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 1;			// ECT
-		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int ch=1;ch<Global::CHANCOUNT;ch++ )
-	{
-		m_gp->ProbeFun[ch] = 0;		       // CLOSE
-		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
-		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
-		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
-		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
-	}
-	for ( int i=0;i<Global::FREQCOUNT;i++ )
-	{
-		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
-	}
-
-	device->Write_Para_Driver(m_gp->Driver);
-	device->Write_Para_Offset(m_gp->Offset);
-	device->Write_Para_SignalWave(0);
-
-	device->Transfer_ECT_Parameters();
-
-	Load_Alarm_Para();
-
-	m_DataProcess->Trigger_Balacne_Process();       // very Important
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Switch_Status
- *  Description:  When stop the signal switch the system status 
- * =====================================================================================
- */
-void ZKPanel::Swtich_Status(Graphic& g)
-{
-	if 	( m_gp->bSingleSrcPause == true )
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,8,5,15);
-	}
-	else
-	{
-		Resource *res = Resource::Instance();
-		res->Show_Resource_Png(g,9,5,15);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_AMP_PHA
- *  Description:  Display the AMP and PHA value 
- * =====================================================================================
- */
-void ZKPanel::Refresh_AMP_PHA(Graphic& g)
-{
-	std::stringstream strtmp;
-	strtmp<<"A:"<<m_Zscreen->Get_AMP();
-	std::string str(strtmp.str());
-	m_LabAMPMsg->Set_Text(str.c_str());
-	m_LabAMPMsg->Drawme(g,true);
-
-	strtmp.clear();
-	strtmp.str("");
-	str.clear();
-
-	strtmp<<"P:"<<m_Zscreen->Get_PHA();
-	str = strtmp.str();
-	m_LabPHAMsg->Set_Text(str.c_str());
-	m_LabPHAMsg->Drawme(g,true);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_FREQ
- *  Description:  Display Frequence value 
- * =====================================================================================
- */
-void ZKPanel::Refresh_FREQ(Graphic& g)
-{
-	char *msg = new char[100];
-
-	Logic *m_lo = Logic::Instance();
-	m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[0]],msg);
-	m_LabFreMsg->Set_Text(msg);
-
-	delete[] msg;
-	msg = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refresh_Signal
- *  Description:  
- * =====================================================================================
- */
-void ZKPanel::Refresh_Signal(Graphic& g)
-{
-	char *msg = new char[100];
-
-	if 	( m_gp->ProbeFun[0] == 0 )
-		sprintf(msg," S%d OFF",1);
-	else
-	{
-		Logic *m_lo = Logic::Instance();
-		m_lo->Probe_Fun_2_Char(1,m_gp->ProbeFun[0],m_gp->FreqIndex[0]+1,msg);
-	}
-
-	m_LabCHAMsg->Set_Text(msg);
-	delete[] msg;
-	msg = NULL;
-}
diff --git a/src/EVA11/ZKPanel.h b/src/EVA11/ZKPanel.h
deleted file mode 100644
index 645a348..0000000
--- a/src/EVA11/ZKPanel.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ZKPanel.h
- *
- *    Description:  Just Draw ZKscreen 
- *
- *        Version:  1.0
- *        Created:  2012年07月23日 19时59分06秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ZKPANEL_INC
-#define  _ZKPANEL_INC
-
-class BasePanel;
-class Zscreen;
-class Bufferbar;
-class ZKDataProcess;
-class AlarmManage;
-class Label;
-class Chart;
-
-class ZKPanel : public BasePanel
-{
-	public:
-		ZKPanel (int x,int y,int width,int heigh);
-		~ZKPanel ();
-
-		virtual void Init_GUI(Graphic& g);
-		virtual void Destroy_GUI();
-		virtual void Drawme(Graphic& g,bool flag=true);
-		virtual int  Loop_Panel(Graphic& g);
-
-		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
-		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
-
-		virtual int Key_F2_Fun(Graphic& g);
-		virtual int Key_F3_Fun(Graphic& g);
-		virtual int Key_F4_Fun(Graphic& g);
-		virtual int Key_F6_Fun(Graphic& g);
-
-		virtual int Key_Enter_Fun(Graphic& g);
-
-		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
-		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
-
-		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
-		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
-		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
-
-		virtual void Show_Help_System(Graphic& g,int x,int y);
-		virtual void Switch_Panel();
-	protected:
-
-	private:
-		void Refresh_AMP_PHA(Graphic& g);
-		void Refresh_FREQ(Graphic& g);
-		void Refresh_Signal(Graphic& g);
-		void Swtich_Status(Graphic& g);
-		void Clean_ZKScreen(Graphic& g);
-		void Load_Alarm_Para();
-
-	private:
-		Label*					m_LabAlarmSt;
-
-		Label*					m_LabFreMsg;
-		Label*					m_LabAMPMsg;
-		Label*					m_LabPHAMsg;
-		Label*					m_LabCHAMsg;
-
-		Bufferbar				*m_Bufbar;
-		Zscreen					*m_Zscreen;
-		ZKDataProcess    			*m_DataProcess;
-		AlarmManage				*m_AlarmManage;
-		Chart					*m_Chart;	
-		int					m_LastStatus;
-		int					 m_oldtick;
-};
-#endif   /* ----- #ifndef _ZKPANEL_INC  ----- */
diff --git a/src/EVA11/ZScreen.cpp b/src/EVA11/ZScreen.cpp
deleted file mode 100644
index 36d56f7..0000000
--- a/src/EVA11/ZScreen.cpp
+++ /dev/null
@@ -1,999 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ZScreen.cpp
- *
- *    Description:  implementation of ZScreen class
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 09时23分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include	<string.h>
-
-#include 	"Object.h"
-#include 	"Label.h"
-#include 	"Graphic.h"
-#include 	"Global.h"
-#include 	"DataRepo.h"
-#include 	"Algorithm.h"
-
-#include 	"Object.h"
-#include 	"Basescreen.h"
-#include 	"ZScreen.h"
-
-#include 	"Language.h"
-#include 	"MixingManage.h"
-
-#include 	"Msgbox.h"
-#include 	"CalculateCenter.h"
-
-Zscreen::Zscreen (int x,int y,int width,int heigh)
-	: Basescreen(x,y,width,heigh)
-	, m_BackCoordinate(GRID) , m_DrawMode(LINE) , m_ID(1)
-{
-	m_Trace                 = NULL;
-	int leng                = (m_Width-2)*(m_Heigh-2);
-	m_Trace                 = new unsigned char[leng];
-	memset(m_Trace,0,leng);
-	m_Data_Ball.databuff    = NULL;
-	m_Data_Ball.databuff    = new ETDATA[DISP_DATA_LENGTH];
-	for ( int i             = 0;i<DISP_DATA_LENGTH;i++ )
-	{
-		m_Data_Ball.databuff[i] = 0;
-	}
-	m_Data_Ball.dataindex   = 0;
-
-	CHAR temp[5];
-	sprintf(temp,"%d",m_ID);
-
-	m_Focus = false;
-
-	m_labID			= new Label(m_X+m_Width-19,m_Y+m_Heigh-23,16,20);
-	m_labID->Set_Text(temp);
-	m_labID->Set_Label_Type(Label::LA_THIN);
-	m_labID->Set_Font_Size(16);
-
-	if ( m_Focus == false )
-	{
-		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	}                                     
-	else                                  
-	{                                     
-		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGFO_CO);
-		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXFO_CO);
-	}
-	m_alg = Algorithm::Instance();
-	
-	m_Photo = NULL;
-}
-
-Zscreen::~Zscreen ()
-{
-	if 	( m_Trace != NULL ) 
-	{
-		delete[] m_Trace;
-		m_Trace = NULL;
-	}
-
-	if 	( m_Data_Ball.databuff != NULL )
-	{
-		delete[] m_Data_Ball.databuff;
-		m_Data_Ball.databuff = NULL;
-	}
-	if ( m_labID != NULL )
-	{
-		delete m_labID;
-		m_labID = NULL;
-	}
-	if ( m_Photo != NULL )
-	{
-		delete[] m_Photo;
-		m_Photo = NULL;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Refreshme
- *  Description:  Only Draw the Zscreen class GUI object 
- * =====================================================================================
- */
-void Zscreen::Refreshme(Graphic& g)
-{
-	COLORTYPE co;
-	co = g.Getcolor();
-	g.Setcolor(m_FGColor);
-	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
-	if ( m_BackCoordinate == GRID )
-		DrawGrid(g);
-	Draw_Photo(g);
-	m_labID->Drawme(g);
-
-	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
-	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
-	g.Setcolor(co);
-	Init_Variables();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Back_Coordinate
- *  Description:  Set the Back Coordinate of screen object  
- * =====================================================================================
- */
-void Zscreen::Set_Back_Coordinate(BACKCOOR back)
-{
-	m_BackCoordinate = back;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_ID
- *  Description:  Set the ID of screen 
- * =====================================================================================
- */
-void Zscreen::Set_ID(int id)
-{
-	m_ID = id;
-	CHAR temp[5];
-	sprintf(temp,"%d",m_ID);
-	m_labID->Set_Text(temp);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_ET_Point
- *  Description:  Draw ET pointers to screen
- * =====================================================================================
- */
-void Zscreen::Draw_ET_Point(Graphic& g,const int& x,const int& y)
-{
-	switch ( m_DrawMode  )
-	{
-		case POINT: 
-			{
-				if 	( (m_last_p_x != x) && (m_last_p_y != y) )
-				{
-					if ( (m_last_p_x != m_cDPV) && (m_last_p_y != m_cDPV) )
-						DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x ,m_Center_Y+m_Offset_Y+m_last_p_y);
-					m_last_p_x = x;
-					m_last_p_y = y;
-					m_SX = m_Center_X+m_Offset_X+x;
-					m_SY = m_Center_Y+m_Offset_Y+y;
-					DrawFocus(g,m_SX,m_SY);
-				}
-			}
-			break;
-		case LINE:
-			{
-				if 	( m_last_l_x == m_cDPV && m_last_l_y == m_cDPV )
-				{
-					m_SX = m_Center_X+m_Offset_X+x;
-					m_SY = m_Center_Y+m_Offset_Y+y;
-					m_last_l_x = m_SX;
-					m_last_l_y = m_SY;
-				}
-				else
-				{
-					m_SX = m_Center_X+m_Offset_X+x;
-					m_SY = m_Center_Y+m_Offset_Y+y;
-					Draw_Line_In_Arrange(g,m_SX,m_SY,m_last_l_x,m_last_l_y,m_PointColor);
-					m_last_l_x = m_SX;
-					m_last_l_y = m_SY;
-				}
-			}
-			break;
-		case AUTO:
-			{
-				Global *gp = Global::Instance();
-				int MAXi = gp->Auto_Disappear * (  DISP_DATA_LENGTH >> 7  ) ; 
-				int index = m_Data_Ball.dataindex;
-				g.SetMode(Graphic::MODE_SRC_XOR_DST);
-
-				if ( index ==  MAXi )
-				{
-					m_Data_Ball.dataindex = 0;
-					index = 0;
-				}
-
-				if ( index == MAXi - 2 )
-				{
-					Draw_Line_In_Trace(g,
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[MAXi-2],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[MAXi-1],
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[0],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[1],m_PointColor^m_BGColor,false);
-				}
-				else
-				{
-					Draw_Line_In_Trace(g,
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+1],
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index+2],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+3],m_PointColor^m_BGColor,false);
-				}
-
-				m_Data_Ball.databuff[m_Data_Ball.dataindex]   = x;
-				m_Data_Ball.databuff[m_Data_Ball.dataindex+1] = y;
-
-				if ( index == 0 )
-				{
-					Draw_Line_In_Trace(g,
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[MAXi-2],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[MAXi-1],
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[0],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[1],m_PointColor^m_BGColor,true);
-				}
-				else
-				{
-					Draw_Line_In_Trace(g,
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index-2],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index-1],
-							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index],
-							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+1],m_PointColor^m_BGColor,true);
-				}
-				m_Data_Ball.dataindex += 2;
-				g.SetMode(Graphic::MODE_SRC);
-
-				m_SX = m_Center_X+m_Offset_X+x;
-				m_SY = m_Center_Y+m_Offset_Y+y;
-			}
-			break;
-		case SPEC:					// only used by OZKPanel
-			{
-				if 	( m_AlarmStatus == true )
-				{
-					if 	( m_LastAlarmStatus == false )
-					{
-						if 	( (m_last_p_x != m_cDPV) && (m_last_p_y != m_cDPV) )
-							DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x,m_Center_Y+m_Offset_Y+m_last_p_y);
-
-						m_last_p_x = m_cDPV;
-						m_last_p_y = m_cDPV;
-
-						m_last_l_x = m_Center_X+m_Offset_X+x;
-						m_last_l_y = m_Center_Y+m_Offset_Y+y;
-					}
-					else
-					{
-						if 	( (m_last_l_x == m_cDPV) && (m_last_l_y == m_cDPV) )
-						{
-							m_last_l_x = m_Center_X+m_Offset_X+x;
-							m_last_l_y = m_Center_Y+m_Offset_Y+y;
-						}
-						else
-						{
-							Draw_Line_In_Trace(g,
-									   m_Center_X+m_Offset_X+x,
-									   m_Center_Y+m_Offset_Y+y,
-									   m_last_l_x, 
-									   m_last_l_y,m_PointColor^m_BGColor,true);
-							m_last_l_x = m_Center_X+m_Offset_X+x;
-							m_last_l_y = m_Center_Y+m_Offset_Y+y;
-						}
-					}
-				}
-				else
-				{
-					if ( m_LastAlarmStatus == false )
-					{
-						if ( m_Decay == 0 )
-						{
-							if ( (m_last_p_x != x) || (m_last_p_y != y) )
-							{
-								if 	((m_last_p_x != m_cDPV) && (m_last_p_x != m_cDPV))
-									DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x,m_Center_Y+m_Offset_Y+m_last_p_y);
-								m_last_p_x = x;
-								m_last_p_y = y;
-								DrawFocus(g,m_Center_X+m_Offset_X+x,m_Center_Y+m_Offset_Y+y);
-								goto Exit;
-							}
-							else
-								goto Exit;
-						}
-						else
-						{
-							if 	( (m_last_l_x == m_cDPV) && (m_last_l_y == m_cDPV) )
-							{
-								m_last_l_x = m_Center_X + m_Offset_X + x;
-								m_last_l_y = m_Center_Y + m_Offset_Y + y;
-							}
-							else
-							{
-								Draw_Line_In_Trace(g,
-										   m_Center_X+m_Offset_X+x,
-										   m_Center_Y+m_Offset_Y+y,
-										   m_last_l_x, 
-										   m_last_l_y,m_PointColor^m_BGColor,true);
-								m_last_l_x  = m_Center_X+m_Offset_X+x;
-								m_last_l_y  = m_Center_Y+m_Offset_Y+y;
-							}
-							m_Decay --;
-						}
-					}
-					else
-					{
-						Draw_Line_In_Trace(g,
-								   m_Center_X+m_Offset_X+x,
-								   m_Center_Y+m_Offset_Y+y,
-								   m_last_l_x, 
-								   m_last_l_y,m_PointColor^m_BGColor,true);
-
-						m_last_l_x = m_Center_X + m_Offset_X + x;
-						m_last_l_y = m_Center_Y + m_Offset_Y + y;
-						m_Decay    = 480;
-						m_last_p_x = m_cDPV;
-						m_last_p_y = m_cDPV;
-					}
-				}
-Exit:				m_LastAlarmStatus = m_AlarmStatus;
-			}
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  DrawFocus
- *  Description:  Draw a arrow on screen of grid for each display trace
- * =====================================================================================
- */
-void Zscreen::DrawFocus(Graphic &g,const int x,const int y)
-{
-	Graphic::CopyMode save_mode;
-	save_mode = g.GetMode();
-	g.SetMode(Graphic::MODE_SRC_XOR_DST);
-	for (int i=1;i<5;i++)
-	{
-		if ( ((x-i) > m_Left) && ((x-i) < m_Right) && ((y) < m_Down) && ((y) > m_Up) ) 
-			g.Setpixel(x-i,y,m_FGColor);
-		if ( ((x+i) > m_Left) && ((x+i) < m_Right) && ((y) < m_Down) && ((y) > m_Up) ) 
-			g.Setpixel(x+i,y,m_FGColor);
-		if ( ((x) > m_Left) && ((x) < m_Right) && ((y+i) < m_Down) && ((y+i) > m_Up) ) 
-			g.Setpixel(x,y+i,m_FGColor);
-		if ( ((x) > m_Left) && ((x) < m_Right) && ((y-i) < m_Down) && ((y-i) > m_Up) ) 
-			g.Setpixel(x,y-i,m_FGColor);
-	}
-	g.SetMode(save_mode);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Variables
- *  Description:  Init variables of screen 
- *                Often call this function, after redraw screen
- * =====================================================================================
- */
-void Zscreen::Init_Variables()
-{
-	m_last_p_x = m_cDPV;
-	m_last_p_y = m_cDPV;
-
-	m_last_l_x = m_cDPV;
-	m_last_l_y = m_cDPV;
-
-	m_Decay    = 0;
-
-	Reset_Trace();
-
-	m_Data_Ball.dataindex = 0;
-	for (int j=0;j<DISP_DATA_LENGTH;j++)
-	{
-		m_Data_Ball.databuff[j] = 0x00;
-	}
-	m_bDrawFocus = false;
-
-
-	m_AlarmStatus     = false;
-	m_LastAlarmStatus = false;
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Draw_Mode
- *  Description:  Set the Draw mode parameters 
- * =====================================================================================
- */
-void Zscreen::Set_Draw_Mode(DRAWMODE mode)
-{
-	m_DrawMode = mode;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Line_In_Trace
- *  Description:  Draw line in screen arrange
- * =====================================================================================
- */
-void Zscreen::Draw_Line_In_Trace(Graphic &g,int x1,int y1,int x2,int y2,
-				    int color,bool flag)
-{
-	int dx,dy;
-	if ( y1 > y2) 
-	{
-		int t = y1;
-		y1 = y2;
-		y2 = t;
-		t = x1;
-		x1 = x2;
-		x2 = t;
-	}
-	dx = x2-x1;
-	dy = y2-y1;
-	if (dx > 0) 
-	{
-		if (dx > dy)
-			draw_xish_line_Trace(g,x1, y1, dx, dy, 1,color,flag);
-		else
-			draw_yish_line_Trace(g,x1, y1, dx, dy, 1,color,flag);
-	} 
-	else 
-	{
-		dx = -dx;
-		if (dx > dy)
-			draw_xish_line_Trace(g,x1, y1, dx, dy, -1,color,flag);
-		else
-			draw_yish_line_Trace(g,x1, y1, dx, dy, -1,color,flag);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  draw_xish_line_Trace
- *  Description:  Draw line on ZKScreen depending on the x y
- * =====================================================================================
- */
-void Zscreen::draw_xish_line_Trace(Graphic &g,int x,int y,int dx,int dy,int xdir,
-		                      int ncolor,bool flag)
-{
-	int dyX2=dy+dy;
-	int dyX2mdxX2=dyX2-(dx+dx);
-	int error=dyX2-dx;
-	int offset_x,offset_y;
-
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
-	{
-		if ( flag == true )
-		{
-			offset_x = x - (m_X+1);
-			offset_y = y - (m_Y+1); 
-			m_Trace[offset_x+offset_y*(m_Width-2)] ++;
-			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
-				g.Setpixel(x, y, ncolor);
-		}
-		else
-		{
-			offset_x = x - (m_X+1);
-			offset_y = y - (m_Y+1); 
-			m_Trace[offset_x+offset_y*(m_Width-2)] --;
-			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
-				g.Setpixel(x, y, ncolor);
-		}
-	}
-	while (dx--) 
-	{
-		if (error >= 0) 
-		{
-			y++;
-			error += dyX2mdxX2;
-		} 
-		else 
-		{
-			error += dyX2;
-		}
-		x += xdir;
-		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
-		{
-			if ( flag == true )
-			{
-				offset_x = x - (m_X+1);
-				offset_y = y - (m_Y+1); 
-				m_Trace[offset_x+offset_y*(m_Width-2)] ++;
-				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
-					g.Setpixel(x, y, ncolor);
-			}
-			else
-			{
-				offset_x = x - (m_X+1);
-				offset_y = y - (m_Y+1); 
-				m_Trace[offset_x+offset_y*(m_Width-2)] --;
-				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
-					g.Setpixel(x, y, ncolor);
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  draw_yish_line_Trace
- *  Description:  Draw line on screen depending on y direct
- * =====================================================================================
- */
-void Zscreen::draw_yish_line_Trace(Graphic &g,int x,int y,int dx,int dy,int xdir,
-				      int ncolor,bool flag)
-{
-	int dxX2=(dx<<1) ;
-	int dxX2mdyX2=dxX2-(dy<<1);
-	int error=dxX2-dy;
-	int offset_x,offset_y;
-
-	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
-	{
-		if ( flag == true )
-		{
-			offset_x = x - (m_X+1);
-			offset_y = y - (m_Y+1); 
-			m_Trace[offset_x+offset_y*(m_Width-2)] ++;
-			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
-				g.Setpixel(x, y, ncolor);
-		}
-		else
-		{
-			offset_x = x - (m_X+1);
-			offset_y = y - (m_Y+1); 
-			m_Trace[offset_x+offset_y*(m_Width-2)] --;
-			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
-				g.Setpixel(x, y, ncolor);
-		}
-	}
-	while (dy--) 
-	{
-		if (error >= 0) 
-		{
-			x+= xdir;
-			error += dxX2mdyX2;
-		} else 
-		{
-			error += dxX2;
-		}
-		y++;
-		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
-		{
-			if ( flag == true )
-			{
-				offset_x = x - (m_X+1);
-				offset_y = y - (m_Y+1); 
-				m_Trace[offset_x+offset_y*(m_Width-2)] ++;
-				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
-					g.Setpixel(x, y, ncolor);
-			}
-			else
-			{
-				offset_x = x - (m_X+1);
-				offset_y = y - (m_Y+1); 
-				m_Trace[offset_x+offset_y*(m_Width-2)] --;
-				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
-					g.Setpixel(x, y, ncolor);
-			}
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Focus
- *  Description:  Set the Zscreen 
- * =====================================================================================
- */
-void Zscreen::Set_Focus(Graphic& g,bool value,bool redraw)
-{
-	m_Focus = value;
-	if ( m_Focus == false )
-	{
-		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	}                                     
-	else                                  
-	{                                     
-		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGFO_CO);
-		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXFO_CO);
-	}
-	if ( redraw == true )
-		m_labID->Drawme(g);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Gain_Degree_ReDraw
- *  Description:  When set the Gain or Degree Re-draw single on screen 
- * =====================================================================================
- */
-void Zscreen::Set_Gain_Degree_ReDraw(Graphic& g,int channel,int loopstart,int loopend)
-{
-	g.Switch_Screen();
-	Refreshme(g);
-	Reset_Trace();
-	DRAWMODE drawmode = m_DrawMode;
-	double X_temp,Y_temp;
-	ETDATA X_,Y_;
-	m_DrawMode = LINE;
-	DataRepo *repo = DataRepo::Instance();
-	MixingManage *mixm = MixingManage::Instance();
-	Global *gp     = Global::Instance();
-
-	if 	( repo->GetLoopCount() < loopend ) { loopstart =  repo->GetLoopCount(); loopend = 0; }
-	else if ( repo->GetLoopCount() > loopend && repo->GetLoopCount() < loopstart )
-		loopstart =  repo->GetLoopCount();
-
-	CalculateCenter cc;
-	cc.Init_Object();
-
-	ETDATA *rawdata = new ETDATA[repo->Get_Each_Loop_Word_Count()];
-
-	for ( int loop=loopstart;loop!=loopend;loop-- )
-	{
-		repo->Get_One_Loop_Back(rawdata,loop);
-		if 	( channel == 2 )
-		{
-			mixm->Mixing(0,rawdata[0],rawdata[1],rawdata[2],rawdata[3]);
-			X_temp = rawdata[2]   * gp->SoftMixGain[channel-2];
-			Y_temp = 0 - rawdata[3] * gp->SoftMixGain[channel-2];
-			Y_temp = m_alg->Gain_Ratio(Y_temp);
-			m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
-			Y_ = 0 - Y_;
-			Draw_ET_Point(g,X_,Y_);
-			cc.Calculate_Graphic_MAX_MIN_Value(rawdata[2],
-							   m_alg->Gain_Ratio(static_cast<double>(rawdata[3])));
-		}
-		else
-		{
-			X_temp = rawdata[(channel<<1)]   * gp->SoftGain[channel];
-			Y_temp = 0 - rawdata[(channel<<1)+1] * gp->SoftGain[channel];
-			Y_temp = m_alg->Gain_Ratio(Y_temp);
-			m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
-			Y_ = 0 - Y_;
-			Draw_ET_Point(g,X_,Y_);
-			cc.Calculate_Graphic_MAX_MIN_Value(rawdata[(channel<<1)],
-							   m_alg->Gain_Ratio(static_cast<double>(rawdata[(channel<<1)+1])));
-		}
-	}
-
-	cc.Calculate_Graphic_Center();
-	cc.Reset_AMPBALL();
-
-	if 	( channel == 2 )
-	{
-		for ( int loop=loopstart;loop!=loopend;loop-- )
-		{
-			repo->Get_One_Loop_Back(rawdata,loop);
-			mixm->Mixing(0,rawdata[0],rawdata[1],rawdata[2],rawdata[3]);
-			cc.Record_MAXValue(rawdata[2],m_alg->Gain_Ratio(static_cast<double>(rawdata[3])));
-		}
-	}
-	else
-	{
-		for ( int loop=loopstart;loop!=loopend;loop-- )
-		{
-			repo->Get_One_Loop_Back(rawdata,loop);
-			cc.Record_MAXValue(rawdata[(channel<<1)],m_alg->Gain_Ratio(static_cast<double>(rawdata[(channel<<1)+1])));
-		}
-	}
-
-	int rx,ry,lx,ly;
-	cc.Get_MAX_Point(rx,ry,lx,ly);
-	cc.Calculate_AMP_PHA();
-
-	m_AMP = cc.Get_AMP();
-	if 	( channel == 2 )
-		m_AMP = static_cast<long long>(static_cast<double>(cc.Get_AMP()) * gp->SoftMixGain[channel-2]);
-	else
-		m_AMP = static_cast<long long>(static_cast<double>(cc.Get_AMP()) * gp->SoftGain[channel]);
-
-	if 	( channel == 2 )
-		m_PHA = cc.Get_PHA() + gp->MixDegree[channel-2];
-	else
-		m_PHA = cc.Get_PHA() + gp->Degree[channel];
-	if 	( m_PHA < 0 ) m_PHA += 360;
-	else if ( m_PHA >= 360 ) m_PHA -= 360;
-
-	if 	( channel == 2 )
-	{
-		X_temp = lx * gp->SoftMixGain[channel-2];
-		Y_temp = 0 - ly * gp->SoftMixGain[channel-2];
-		m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
-		lx = X_; ly = 0 - Y_;
-
-		X_temp = rx * gp->SoftMixGain[channel-2];
-		Y_temp = 0 - ry * gp->SoftMixGain[channel-2];
-		m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
-		rx = X_; ry = 0 - Y_;
-	}
-	else
-	{
-		X_temp = lx * gp->SoftGain[channel];
-		Y_temp = 0 - ly * gp->SoftGain[channel];
-		m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
-		lx = X_; ly = 0 - Y_;
-
-		X_temp = rx * gp->SoftGain[channel];
-		Y_temp = 0 - ry * gp->SoftGain[channel];
-		m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
-		rx = X_; ry = 0 - Y_;
-	}
-
-	if ( cc.Get_LR_Point() == true )
-		Draw_MAXAMP_Point(g,rx,ry,lx,ly,g.RGB24_16(0x00ff00),g.RGB24_16(0xffffff));
-	else
-		Draw_MAXAMP_Point(g,rx,ry,lx,ly,g.RGB24_16(0xffffff),g.RGB24_16(0x00ff00));
-
-	delete[] rawdata;
-	rawdata = NULL;
-	m_DrawMode = drawmode;
-	g.Switch_Screen();
-	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Mixing_Parameters_Calculate
- *  Description: Calculat the Mixing parameters 
- * =====================================================================================
- */
-void Zscreen::Mixing_Parameters_Calculate(Graphic& g,int loopstart,int loopend)
-{
-	MixingManage *mixm = MixingManage::Instance();
-	mixm->Clean_Data_From_Buffer(0);
-	DataRepo *repo = DataRepo::Instance();
-	ETDATA *rawdata = new ETDATA[repo->Get_Each_Loop_Word_Count()];
-	
-	if 	( repo->GetLoopCount() < loopend ) { loopstart =  repo->GetLoopCount(); loopend = 0; }
-	else if ( repo->GetLoopCount() > loopend && repo->GetLoopCount() < loopstart )
-		loopstart =  repo->GetLoopCount();
-
-	mixm->Clean_Data_From_Buffer(0);
-	for ( int loop=loopstart;loop!=loopend;loop-- )
-	{
-		repo->Get_One_Loop_Back(rawdata,loop);
-		mixm->Load_Data_Into_Buffer(0,rawdata);
-	}
-
-	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
-	g.Load_Disp_Area(0,0,639,479,mem);
-
-	Language *m_pl = Language::Instance();
-	Label *lab = new Label(220,230,250,25);
-	lab->Set_Label_Type(Label::LA_THIN);
-	lab->Set_Text(m_pl->GetText(MIXINGINFO1));
-	lab->Set_Font_Size(16);
-	lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
-	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
-	lab->Drawme(g);
-	delete lab;
-	lab = NULL;
-	mixm->Calculate_Mix_Para(0);
-
-	g.Restore_Disp_Area(0,0,639,479,mem);
-	delete[] mem;
-	mem = NULL;
-
-	delete[] rawdata;
-	rawdata = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Reset_Trace
- *  Description:  Reset the Screen Trace 
- * =====================================================================================
- */
-void Zscreen::Reset_Trace()
-{
-	int leng = (m_Width-2)*(m_Heigh-2);
-	memset(m_Trace,0,leng);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_MAXAMP_Point
- *  Description:  Draw the MAX AMP points on screen which calculated before 
- * =====================================================================================
- */
-void Zscreen::Draw_MAXAMP_Point(Graphic &g,int rx,int ry,int lx,int ly,int lcolor,int rcolor)
-{
-	BresenhamCircle(g,m_Center_X+m_Offset_X+rx,m_Center_Y+m_Offset_Y+ry,6,rcolor);
-	BresenhamCircle(g,m_Center_X+m_Offset_X+lx,m_Center_Y+m_Offset_Y+ly,6,lcolor);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  BresenhamCircle
- *  Description:  The second drawing circle algorithmic
- * =====================================================================================
- */
-void Zscreen::BresenhamCircle(Graphic &g,int xc,int yc,int radius,int color)
-{
-	int x=0;
-	int y=radius;
-	int d=3-(radius<<1);
-	while(x<y)
-	{
-		WholeCircle(g,xc,yc,x,y,color);
-		if (d<0) d = d + (x<<2) + 6;
-		else 
-		{
-			d = d + ((x-y)<<2) + 10;
-			y--;
-		}
-		x++;
-	}
-	if ( x==y ) WholeCircle(g,xc,yc,x,y,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  WholeCircle
- *  Description:  The second circle drawing meathod
- * =====================================================================================
- */
-void Zscreen::WholeCircle(Graphic &g,int xc,int yc,int x,int y,int color)
-{
-	if ( xc+x > m_Left && xc+x < m_Right && yc+y > m_Up && yc+y < m_Down )
-		g.Setpixel(xc+x,yc+y,color);
-	if ( xc-x > m_Left && xc-x < m_Right && yc+y > m_Up && yc+y < m_Down )
-		g.Setpixel(xc-x,yc+y,color);
-	if ( xc+x > m_Left && xc+x < m_Right && yc-y > m_Up && yc-y < m_Down )
-		g.Setpixel(xc+x,yc-y,color);
-	if ( xc-x > m_Left && xc-x < m_Right && yc-y > m_Up && yc-y < m_Down )
-		g.Setpixel(xc-x,yc-y,color);
-	if ( xc+y > m_Left && xc+y < m_Right && yc+x > m_Up && yc+x < m_Down )
-		g.Setpixel(xc+y,yc+x,color);
-	if ( xc-y > m_Left && xc-y < m_Right && yc+x > m_Up && yc+x < m_Down )
-		g.Setpixel(xc-y,yc+x,color);
-	if ( xc+y > m_Left && xc+y < m_Right && yc-x > m_Up && yc-x < m_Down )
-		g.Setpixel(xc+y,yc-x,color);
-	if ( xc-y > m_Left && xc-y < m_Right && yc-x > m_Up && yc-x < m_Down )
-		g.Setpixel(xc-y,yc-x,color);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Center_Point
- *  Description:  Set the center point of the screen 
- * =====================================================================================
- */
-void Zscreen::Set_Center_Point(const int x,const int y)
-{
-	m_Offset_X = x;
-	m_Offset_Y = y;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Center_Point
- *  Description: Get the center point of the screen  
- * =====================================================================================
- */
-void Zscreen::Get_Center_Point(int& x,int& y)
-{
-	x = m_Offset_X;
-	y = m_Offset_Y;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Adjust_Center_Point
- *  Description: Adjust the Center Point of Screen  
- * =====================================================================================
- */
-void Zscreen::Adjust_Center_Point(Graphic& g,DIRECT dir,int value)
-{
-	if 	( m_bDrawFocus == false )
-	{
-		DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
-		m_bDrawFocus = true;
-		return;
-	}
-	else
-		DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
-
-	for ( int v=0;v<value;v++ )
-	{
-		switch ( dir ) 
-		{
-			case UP:
-				{
-					m_Offset_Y --; 
-					if ( m_Center_Y + m_Offset_Y < m_Up + 10 )
-						m_Offset_Y = m_Up + 10 - m_Center_Y;
-				}
-				break;
-
-			case LEFT:
-				{
-					m_Offset_X --; 
-					if ( m_Center_X + m_Offset_X < m_Left + 10 )
-						m_Offset_X = m_Left + 10 - m_Center_X;
-				}
-				break;
-
-			case RIGHT:
-				{
-					m_Offset_X ++; 
-					if ( m_Center_X + m_Offset_X > m_Right - 10 )
-						m_Offset_X = m_Right - 10 - m_Center_X;
-				}
-				break;
-
-			case DOWN:
-				{
-					m_Offset_Y ++; 
-					if ( m_Center_Y + m_Offset_Y > m_Down - 10 )
-						m_Offset_Y = m_Down - 10 - m_Center_Y;
-				}
-				break;
-		}				/* -----  end switch  ----- */
-	}
-	DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Draw_Photo
- *  Description:  Draw the Photo on to Screen 
- * =====================================================================================
- */
-void Zscreen::Draw_Photo(Graphic& g)
-{
-	if ( m_Photo == NULL )
-		return;
-
-	for ( int x=m_Left+1;x<m_Right;x++ )
-	{
-		for ( int y=m_Up+1;y<m_Down;y++ )
-		{
-			if ( m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)]  != 0 )
-				g.Setpixel(x,y,m_GRIDColor);
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Save_Photo
- *  Description:  Save the Screen Picture into Buffer 
- * =====================================================================================
- */
-void Zscreen::Save_Photo(Graphic& g)
-{
-	if ( m_Photo == NULL )
-	{
-		m_Photo = new char[(m_Width-2)*(m_Heigh-2)];
-		memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
-	}
-	else
-	{
-		memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
-	}
-
-	for ( int x=m_Left+1;x<m_Right;x++ )
-	{
-		for ( int y=m_Up+1;y<m_Down;y++ )
-		{
-			if ( g.Getpixel(x,y) == m_PointColor )
-				m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)] = 1;
-			else
-				m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)] = 0;
-		}
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clean_Photo
- *  Description:  Clean the Screen Photo 
- * =====================================================================================
- */
-void Zscreen::Clean_Photo()
-{
-	memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
-}
diff --git a/src/EVA11/ZScreen.h b/src/EVA11/ZScreen.h
deleted file mode 100644
index 854e7f7..0000000
--- a/src/EVA11/ZScreen.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  ZScreen.h
- *
- *    Description:  Head File of ZScreen Class
- *
- *        Version:  1.0
- *        Created:  2012年07月10日 09时18分37秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ZSCREEN_INC
-#define  _ZSCREEN_INC
-
-#include 	"main.h"
-
-class Label;
-class Basescreen;
-class Algorithm;
-class Zscreen : public Basescreen 
-{
-	public:
-		enum BACKCOOR 
-		{
-			BKNONE = 0,
-			GRID   = 1,
-		};
-		typedef enum BACKCOOR BACKCOOR;
-
-		enum DRAWMODE 
-		{
-			POINT = 0,
-			LINE  = 1,
-			AUTO  = 2,
-			SPEC  = 3
-		};
-
-		typedef enum DRAWMODE DRAWMODE;
-
-		enum DIRECT
-		{
-			LEFT  = 0,
-			UP    = 1,	
-			RIGHT = 2,
-			DOWN  = 3
-		};
-
-		typedef enum DIRECT DIRECT;
-
-		Zscreen (int x,int y,int width,int heigh);
-		~Zscreen ();
-		void Set_Back_Coordinate(BACKCOOR);
-		void Set_Draw_Mode(DRAWMODE);
-
-		void Draw_ET_Point(Graphic& g,const int& x,const int& y);
-		void Set_ID(int id);
-
-		void inline Get_SX_SY(int& x,int& y){ x = m_SX; y = m_SY; }
-		void inline Map_XY_To_Scr(int& x,int& y) { x = m_Center_X+m_Offset_X+x; y = m_Center_Y+m_Offset_Y+y; }
-		void inline Set_Alarm_Status(bool v) { m_AlarmStatus = v; }
-
-		void Set_Focus(Graphic& g,bool value,bool redraw=false);
-
-		void Set_Gain_Degree_ReDraw(Graphic& g,int ch,int start=9000,int end=100);
-		void Mixing_Parameters_Calculate(Graphic& g,int start=9000,int end=100);
-
-		inline long long Get_AMP() { return m_AMP; }
-		inline int	 Get_PHA() { return m_PHA; }
-
-		void Set_Center_Point(const int x,const int y);
-		void Get_Center_Point(int& x,int& y);
-
-		void Adjust_Center_Point(Graphic&,DIRECT,int);
-
-		void Reset_Trace();
-		void Save_Photo(Graphic& g);
-		void Clean_Photo();
-
-	protected:
-		virtual void Refreshme(Graphic& g);
-	private:
-		void DrawFocus(Graphic &g,const int x,const int y);
-		void Init_Variables();
-
-		void Draw_Line_In_Trace(Graphic &g,
-				          int x1,int y1,
-				          int x2,int y2,
-					  int color,
-					  bool flag=true);
-		void draw_xish_line_Trace(Graphic &g, 
-				            int x,int y,
-					    int dx,int dy,
-					    int xdir,int ncolor,
-					    bool flag=true);
-		void draw_yish_line_Trace(Graphic &g, 
-				            int x,int y,
-					    int dx,int dy,
-					    int xdir,int ncolor,
-					    bool flag=true);
-
-		void Draw_MAXAMP_Point(Graphic &g,int rx,int ry,int lx,int ly,int lcolor,int rcolor);
-
-		void WholeCircle(Graphic &g,int xc,int yc,int x,int y,int color);
-		void BresenhamCircle(Graphic &g,int xc,int yc,int radius,int color);
-		void Draw_Photo(Graphic& g);
-	private:
-		struct DATABALL 
-		{
-			ETDATA* databuff;
-			long    dataindex;
-		};
-		typedef struct DATABALL DATABALL;
-
-		static const int		DISP_DATA_LENGTH = 7680;
-		static const int		m_cDPV           = 0x7fff;
-		BACKCOOR			m_BackCoordinate;
-		DRAWMODE			m_DrawMode;
-
-		int				m_ID;
-
-		int				m_last_p_x;
-		int				m_last_p_y;
-		int				m_last_l_x;
-		int				m_last_l_y;
-
-		unsigned char			*m_Trace;
-		DATABALL 			m_Data_Ball;
-
-		Label*				m_labID;
-
-		int				m_SX;
-		int				m_SY;
-
-		Algorithm*			m_alg;
-
-		long long 			m_AMP;
-		int	 			m_PHA;
-
-		bool				m_bDrawFocus;
-
-		char*				m_Photo;
-
-		int				m_Offset_X;
-		int				m_Offset_Y;
-
-		/*-----------------------------------------------------------------------------
-		 * Special Draw Mode
-		 *-----------------------------------------------------------------------------*/
-		bool 				m_AlarmStatus;             /* True when alarm, False when normal */
-		bool 				m_LastAlarmStatus;
-		double 				m_LastResult;              /* Record Last Detect value */
-		int 				m_Decay;
-};
-#endif
diff --git a/src/EVA11/base/ASMS/Asm_Fun_Sets.s b/src/EVA11/base/ASMS/Asm_Fun_Sets.s
new file mode 100644
index 0000000..e1b847e
--- /dev/null
+++ b/src/EVA11/base/ASMS/Asm_Fun_Sets.s
@@ -0,0 +1,123 @@
+@
+@	the file only for test ARM assemble language
+@
+@      ARM Register:
+@      R0~R3  : a1~a4
+@      R4~R11 : v1~v8    R11:fp
+@      R12    : ip
+@      R13    : sp
+@      R14    : lr 
+@      R15    : pc
+@
+@
+@
+@
+	.arch armv4t
+	.fpu softvfp
+	.text
+
+
+	.align	2
+	.global	Asm_Add
+	.type	Asm_Add, %function
+	@
+	@ int Asm_Add(int,int)
+	@
+Asm_Add:
+	mov	ip, sp
+	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
+	stmfd	sp!, {fp, ip, lr, pc}
+	@ stmfd: forward down 
+	@ sp = sp - 4 * 4
+	@ 
+	@ pc			   high meory
+	@ lr 
+	@ ip 
+	@ fp  <-----  sp           low memory
+	@
+	@sub	fp, ip, #4
+	@sub	sp, sp, #8
+
+	add	r0, r0, r1
+	@ 载入一个大数的伪代码
+	ldr	r1, =0xFFFFFFFF
+	add	r0, r0, r1
+
+	@sub	sp, ip, #16
+	ldmfd	sp, {fp, sp, lr}
+	bx	lr
+	.size	Asm_Add, .-Asm_Add
+
+
+	.align	2
+	.global	Asm_Mul
+	.type	Asm_Mul, %function
+	@
+	@ int Asm_Mul(int,int)
+	@
+Asm_Mul:
+	mov	ip, sp
+	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
+	stmfd	sp!, {fp, ip, lr, pc}
+
+	mul	r2, r0, r1
+	mov     r0, r2
+
+	ldmfd	sp, {fp, sp, lr}
+	bx	lr
+	.size	Asm_Mul, .-Asm_Mul
+
+
+	.align	2
+	.global	Asm_Point
+	.type	Asm_Point, %function
+	@
+	@ int Asm_Point(int*)
+	@
+Asm_Point:
+	mov	ip, sp
+	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
+	stmfd	sp!, {fp, ip, lr, pc}
+	sub	fp, ip, #4
+	sub	sp, sp, #8
+
+	ldr	r2, .L1_PTR
+	ldr	r1, [r2,#0]
+	str     r1, [r0,#0]
+
+	sub	sp, fp, #12
+	ldmfd	sp, {fp, sp, lr}
+	bx	lr
+	.size	Asm_Point, .-Asm_Point
+
+	.align	2
+.L1_PTR:
+	.word	ScrPtr
+
+
+	.align	2
+	.global	Asm_Init
+	.type	Asm_Init, %function
+	@
+	@ void Asm_Init(void)
+	@
+Asm_Init:
+	mov	ip, sp
+	@ fp:R11     ip:R12      sp:R13       lr:R14      pc:R15
+	stmfd	sp!, {fp, ip, lr, pc}
+	sub	fp, ip, #4
+	sub	sp, sp, #8
+
+	ldr	r0, .L1_PTR
+	mov     r1, #101
+	str	r1, [r0,#0]
+
+	sub	sp, fp, #12
+	ldmfd	sp, {fp, sp, lr}
+	bx	lr
+	.size	Asm_Init, .-Asm_Init
+
+
+	.ident	"GCC: (crosstool-NG-1.7.2) 4.3.2"
+	.comm	ScrPtr,4,4
+	.section	.note.GNU-stack,"",%progbits
diff --git a/src/EVA11/base/AlarmManage.cpp b/src/EVA11/base/AlarmManage.cpp
new file mode 100644
index 0000000..8a1be1b
--- /dev/null
+++ b/src/EVA11/base/AlarmManage.cpp
@@ -0,0 +1,238 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmManage.cpp
+ *
+ *    Description:  implementation of ManageAlarm class
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月21日 15时01分53秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<new>
+#include 	<string.h>
+
+#include 	"Graphic.h"
+#include 	"Global.h"
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"AlarmRegion.h"
+#include 	"AlarmManage.h"
+
+AlarmManage::AlarmManage (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_AlarmMask = NULL;
+	m_AlarmMask = new char[(width-2)*(heigh-2)];
+	memset(m_AlarmMask,0xff,(width-2)*(heigh-2));
+}
+
+AlarmManage::~AlarmManage()
+{
+	if ( m_AlarmMask != NULL )
+	{
+		delete[] m_AlarmMask;
+		m_AlarmMask = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Alarm_Sets
+ *  Description:  Init the Alarm parameters 
+ * =====================================================================================
+ */
+void AlarmManage::Init_Alarm_Sets(Graphic&)
+{
+	for ( int i=0;i<m_cMAXAlarmCount;i++ )
+	{
+		m_Alarm[0][i] = new(std::nothrow) AmpAlarm(m_X,m_Y,m_Width,m_Heigh);
+		m_Alarm[0][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+
+		m_Alarm[1][i] = new(std::nothrow) HAmpAlarm(m_X,m_Y,m_Width,m_Heigh);
+		m_Alarm[1][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+
+		m_Alarm[2][i] = new(std::nothrow) RectAlarm(m_X,m_Y,m_Width,m_Heigh);
+		m_Alarm[2][i]->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_Alarm_Sets
+ *  Description:  Destroy the Alarm Sets 
+ * =====================================================================================
+ */
+void AlarmManage::Destroy_Alarm_Sets()
+{
+	for ( int i=0;i<m_cMAXAlarmCount;i++ )
+	{
+		delete m_Alarm[0][i];
+		m_Alarm[0][i] = NULL;
+		delete m_Alarm[1][i];
+		m_Alarm[1][i] = NULL;
+		delete m_Alarm[2][i];
+		m_Alarm[2][i] = NULL;
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm window parameters into Object 
+ * =====================================================================================
+ */
+void AlarmManage::Load_Alarm_Para(int gpalarm[3][8][4])
+{
+	for ( int type = 0;type < 3; type ++ )
+	{
+		for ( int i=0;i<m_cMAXAlarmCount;i++ )
+		{
+			m_Alarm[type][i]->Set_4Para(gpalarm[type][i][0],
+						    gpalarm[type][i][1],
+						    gpalarm[type][i][2],
+						    gpalarm[type][i][3]);
+		}
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Alarm_Para
+ *  Description:  Save Alarm window parameters into Object 
+ * =====================================================================================
+ */
+void AlarmManage::Save_Alarm_Para(int gpalarm[3][8][4])
+{
+	for ( int type = 0;type < 3;type ++ )
+	{
+		for ( int i=0;i<m_cMAXAlarmCount;i++ )
+		{
+			gpalarm[type][i][0] = m_Alarm[type][i]->Get_P1();
+		        gpalarm[type][i][1] = m_Alarm[type][i]->Get_P2();
+		        gpalarm[type][i][2] = m_Alarm[type][i]->Get_P3();
+		        gpalarm[type][i][3] = m_Alarm[type][i]->Get_P4();
+		}
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Alarm_Sets
+ *  Description:  Draw all class manage alarm on screen 
+ * =====================================================================================
+ */
+void AlarmManage::Draw_Alarm_Sets(Graphic& g,bool bufflag)
+{
+	if 	( m_AlarmType == 3 ) return;
+
+	if ( bufflag == true )
+		g.Switch_Screen();
+
+	for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
+	{
+		m_Alarm[m_AlarmType][i]->Drawme(g,false);
+	}
+
+	if ( bufflag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Adj_P1
+ *  Description:  Adjust the 4 parameters of device 
+ * =====================================================================================
+ */
+void AlarmManage::Adj_P1(int v,int gpalarm[3][8][4])
+{
+	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P1(v);
+	Save_Alarm_Para(gpalarm);
+}
+void AlarmManage::Adj_P2(int v,int gpalarm[3][8][4])
+{
+	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P2(v);
+	Save_Alarm_Para(gpalarm);
+}
+void AlarmManage::Adj_P3(int v,int gpalarm[3][8][4])
+{
+	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P3(v);
+	Save_Alarm_Para(gpalarm);
+}
+void AlarmManage::Adj_P4(int v,int gpalarm[3][8][4])
+{
+	m_Alarm[m_AlarmType][m_AlarmIndex[m_AlarmType]]->Adj_P4(v);
+	Save_Alarm_Para(gpalarm);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Create_Alarm_Area_Mask
+ *  Description:  When Reset Alarm Window Area Call it to create the alram window mask 
+ * =====================================================================================
+ */
+void AlarmManage::Create_Alarm_Area_Mask()
+{
+	memset(m_AlarmMask,0xff,(m_Width-2)*(m_Heigh-2));
+	if ( m_AlarmType == 3 ) return;
+
+	for ( int y = m_Up + 1; y < m_Down; y++ )
+	{
+		for ( int x = m_Left + 1; x < m_Right; x++ )
+		{
+			for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
+			{
+				if ( m_Alarm[m_AlarmType][i]->Is_In_Region(x,y) )
+					m_AlarmMask[(y-(m_Up+1))*(m_Width-2)+(x-(m_Left+1))] = i;
+			}
+		}
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Alarm
+ *  Description:  Judge the signal whether in Alarm 
+ * =====================================================================================
+ */
+int AlarmManage::Is_In_Alarm(const int& x,const int& y)
+{
+	if ( m_AlarmType == 3 ) return 0xff;
+
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
+		return m_AlarmMask[(y-(m_Up+1))*(m_Width-2)+(x-(m_Left+1))];
+	else
+		return 0xff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Test
+ *  Description:  Just for Test Alarm region is OK 
+ * =====================================================================================
+ */
+void AlarmManage::Test(Graphic& g)
+{
+	if ( m_AlarmType == 3 ) return;
+	for ( int x=m_Left+1;x<m_Right;x++ )
+	{
+		for ( int y=m_Up+1;y<m_Down;y++ )
+		{
+			for ( int i=0;i<=m_AlarmCount[m_AlarmType];i++ )
+			{
+				if ( m_Alarm[m_AlarmType][i]->Is_In_Region(x,y) )
+					g.Setpixel(x,y,g.RGB24_16(0xff0000));
+			}
+		}
+	}
+}
diff --git a/src/EVA11/base/AlarmManage.h b/src/EVA11/base/AlarmManage.h
new file mode 100644
index 0000000..9c105c1
--- /dev/null
+++ b/src/EVA11/base/AlarmManage.h
@@ -0,0 +1,68 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmManage.h
+ *
+ *    Description:  Manage the all alarm widown in system
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月21日 14时56分39秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef  _ALARMMANAGE_INC
+#define  _ALARMMANAGE_INC
+
+class Object;
+class Graphic;
+class IAlarm;
+class AlarmManage : public Object
+{
+	public:
+		AlarmManage (int x,int y,int width,int heigh);
+		virtual ~AlarmManage ();
+
+		void Init_Alarm_Sets(Graphic&);
+		void Destroy_Alarm_Sets();
+
+		void Load_Alarm_Para(int gpalarm[3][8][4]);
+		void Save_Alarm_Para(int gpalarm[3][8][4]);
+
+		void Draw_Alarm_Sets(Graphic& g,bool bufflag=false);
+
+		void Adj_P1(int,int gpalarm[3][8][4]); 
+		void Adj_P2(int,int gpalarm[3][8][4]); 
+		void Adj_P3(int,int gpalarm[3][8][4]); 
+		void Adj_P4(int,int gpalarm[3][8][4]); 
+
+		void Create_Alarm_Area_Mask();
+		int Is_In_Alarm(const int& x,const int& y); 
+
+		void Test(Graphic& g);
+		/*-----------------------------------------------------------------------------
+		 * Attrib Operation of Alarm  
+		 *-----------------------------------------------------------------------------*/
+		inline void Set_Alarm_Type(int type) { m_AlarmType = type; }
+		inline int Get_Alarm_Type() { return m_AlarmType; }
+		inline void Set_Alarm_Count(int index,int value) { m_AlarmCount[index] = value; }
+		inline int Get_Alarm_Count(int index) { return m_AlarmCount[index]; }
+		inline void Set_Alarm_Index(int index,int value) { m_AlarmIndex[index] = value; }
+		inline int Get_Alarm_Index(int index) { return m_AlarmIndex[index]; }
+
+	protected:
+
+	private:
+		static const int	m_cMAXAlarmCount = 8;
+		IAlarm*			m_Alarm[3][m_cMAXAlarmCount];
+		char*			m_AlarmMask;
+
+		int			m_AlarmType;
+		int			m_AlarmCount[3];
+		int			m_AlarmIndex[3];
+};
+#endif
diff --git a/src/EVA11/base/AlarmRegion.cpp b/src/EVA11/base/AlarmRegion.cpp
new file mode 100644
index 0000000..dd0c673
--- /dev/null
+++ b/src/EVA11/base/AlarmRegion.cpp
@@ -0,0 +1,1102 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmRegion.cpp
+ *
+ *    Description:  Declaration of AlarmRegion class
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月18日 10时07分56秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<cmath>
+#include 	<vector>
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"AlarmRegion.h"
+#include 	"Graphic.h"
+#include 	"Algorithm.h"
+
+IAlarm::IAlarm (int x,int y,int width,int height)
+	: Basescreen(x,y,width,height)
+{
+	alg = Algorithm::Instance();
+}
+
+IAlarm::~IAlarm ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Border
+ *  Description:  Set the border of View 
+ * =====================================================================================
+ */
+void IAlarm::Set_4Para(int p1,int p2,int p3,int p4)
+{
+	m_P1	  = 	p1;
+	m_P2 	  =	p2;
+	m_P3	  =  	p3;
+	m_P4	  = 	p4;
+}
+
+int IAlarm::Get_P1() { return m_P1; }
+int IAlarm::Get_P2() { return m_P2; }
+int IAlarm::Get_P3() { return m_P3; }
+int IAlarm::Get_P4() { return m_P4; }
+
+void IAlarm::Set_P1(int v) { m_P1 = v; }
+void IAlarm::Set_P2(int v) { m_P2 = v; }
+void IAlarm::Set_P3(int v) { m_P3 = v; }
+void IAlarm::Set_P4(int v) { m_P4 = v; }
+
+/* ----------------------------------------------------------------------------------- */
+
+RectAlarm::RectAlarm(int x,int y,int width,int height)
+	: IAlarm(x,y,width,height)
+{
+}
+RectAlarm::~RectAlarm()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw self on screen 
+ * =====================================================================================
+ */
+void RectAlarm::Refreshme(Graphic& g)
+{
+	ColorObj *colorobj = ColorObj::Instance();
+
+	short *datax = new short[4];
+	short *datay = new short[4];
+
+	datax[0] = m_P1;
+	datax[1] = m_P3;
+	datax[2] = m_P3;
+	datax[3] = m_P1;
+
+	datay[0] = m_P2;
+	datay[1] = m_P2;
+	datay[2] = m_P4;
+	datay[3] = m_P4+1;
+
+	g.FillPolygonColor(datax,datay,4,colorobj->Get_ColorVP(1)->color32);
+	g.PolygonColor(datax,datay,4,colorobj->Get_ColorVP(13)->color32);
+
+	delete[] datax;
+	datax = NULL;
+	delete[] datay;
+	datay = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Region
+ *  Description:  Judge the point is it in alram region 
+ * =====================================================================================
+ */
+bool RectAlarm::Is_In_Region(int x,int y)
+{
+	if ( x>m_P1 && x <m_P3 && y > m_P2 && y < m_P4 )
+		return true;
+	else 
+		return false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Px
+ *  Description:  Set the 4 parameters of Rect region
+ *      caution:  P1:left P2:Up P3:Right P4:Down
+ * =====================================================================================
+ */
+void RectAlarm::Adj_P1(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			m_P1 ++;
+			if 	( m_P1 >= m_P3 )
+				m_P1 = m_P3 - 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			m_P1 --;
+			if 	( m_P1 <= m_X )
+				m_P1 = m_X + 1; 
+		}
+	}
+}
+void RectAlarm::Adj_P2(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			m_P2 ++;
+			if 	( m_P2 >= m_P4 )
+				m_P2 = m_P4 - 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			m_P2 --;
+			if 	( m_P2 <= m_Up )
+				m_P2 = m_Up + 1; 
+		}
+	}
+}
+void RectAlarm::Adj_P3(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			m_P3 ++;
+			if 	( m_P3 >= m_Right )
+				m_P3 = m_Right - 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			m_P3 --;
+			if 	( m_P3 <= m_P1 )
+				m_P3 = m_P1 + 1;
+		}
+	}
+}
+void RectAlarm::Adj_P4(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			m_P4 ++;
+			if 	( m_P4 >= m_Down )
+				m_P4 = m_Down - 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			m_P4 --;
+			if 	( m_P4 <= m_P2 )
+				m_P4 = m_P2 + 1; 
+		}
+	}
+}
+
+/* ----------------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------------------- */
+
+AmpAlarm::AmpAlarm (int x,int y,int width,int height)
+	: IAlarm(x,y,width,height)
+{
+}
+
+AmpAlarm::~AmpAlarm()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw me on screen 
+ * =====================================================================================
+ */
+void AmpAlarm::Refreshme(Graphic& g)
+{
+	ColorObj *colorobj = ColorObj::Instance();
+	std::vector<int> vx1,vy1,vx2,vy2;
+
+	int starpointx;
+	int starpointy;
+	int endpointx;
+	int endpointy;
+
+	int _starpointx;
+	int _starpointy;
+	int _endpointx;
+	int _endpointy;
+
+	short dg1=0,dg2=0;                       /* the really degree */
+
+	int x,y;
+
+	if (m_P1 != 90)
+	{
+		double k;
+		k=alg->Get_Tan_Value(m_P1) * m_P3 / m_P4;
+		dg1 = static_cast<int>(180*atan(k)/3.1415926); 
+		if (dg1 < 0) dg1 += 180;
+	}
+	else { dg1 = 90; }
+	if (m_P2 != 90)
+	{
+		double k;
+		k=alg->Get_Tan_Value(m_P2) * m_P3 / m_P4;
+		dg2 = static_cast<int>(180*atan(k)/3.1415926); 
+		if (dg2 < 0) dg2 += 180;
+	}
+	else { dg2 = 90; }
+
+	starpointx = static_cast<int>(m_Center_X+m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
+	starpointy = static_cast<int>(m_Center_Y-m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
+	endpointx  = static_cast<int>(m_Center_X+m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
+	endpointy  = static_cast<int>(m_Center_Y-m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
+	_starpointx = static_cast<int>(m_Center_X-m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
+	_starpointy = static_cast<int>(m_Center_Y+m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
+	_endpointx  = static_cast<int>(m_Center_X-m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
+	_endpointy  = static_cast<int>(m_Center_Y+m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
+
+	for (int i=(180-static_cast<int>(dg2));i<(180-static_cast<int>(dg1));i++)
+	{
+		vx1.push_back(static_cast<int>(m_Center_X+m_P3*alg->Get_Cos_Value(i)));
+		vy1.push_back(static_cast<int>(m_Center_Y-m_P4*alg->Get_Sin_Value(i)));
+
+		vx2.push_back(static_cast<int>(m_Center_X-m_P3*alg->Get_Cos_Value(i)));
+		vy2.push_back(static_cast<int>(m_Center_Y+m_P4*alg->Get_Sin_Value(i)));
+	}
+
+	vx1.push_back(starpointx);
+	vy1.push_back(starpointy);
+
+	vx2.push_back(_starpointx);
+	vy2.push_back(_starpointy);
+
+
+	int flag = 0;
+	if 	( (dg1 > 0) && (dg1 < 90) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
+		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx1.push_back(m_Left+1);
+			vy1.push_back(m_Center_Y-y);
+			vx2.push_back(m_Right-1);
+			vy2.push_back(m_Center_Y+y);
+			flag = 0;
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			vx1.push_back(m_Center_X+x);
+			vy1.push_back(m_Up+1);
+			vx2.push_back(m_Center_X-x);
+			vy2.push_back(m_Down-1);
+			flag = 1;
+		}
+	}
+	else if (dg1 == 90 || dg1 == 91)
+	{
+		vx1.push_back(starpointx);
+		vy1.push_back(m_Up+1);
+		
+		vx2.push_back(starpointx);
+		vy2.push_back(m_Down-1);
+		flag = 2;
+	}
+	else if ( (dg1 > 91) && (dg1 < 180) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
+		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx1.push_back(m_Right-1);
+			vy1.push_back(m_Center_Y-y);
+
+			vx2.push_back(m_Left+1);
+			vy2.push_back(m_Center_Y+y);
+			flag = 4;
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			vx1.push_back(m_Center_X+x);
+			vy1.push_back(m_Up+1);
+
+			vx2.push_back(m_Center_X-x);
+			vy2.push_back(m_Down-1);
+			flag = 3;
+		}
+	}
+
+//--------------------------
+	if ( (dg2 > 0) && (dg2 < 90) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
+		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx1.push_back(m_Left+1);
+			vy1.push_back(m_Center_Y-y);
+
+			vx2.push_back(m_Right-1);
+			vy2.push_back(m_Center_Y+y);
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+
+			if ( flag == 0 )
+			{
+				vx1.push_back(m_Left+1);
+				vy1.push_back(m_Up+1);
+
+				vx2.push_back(m_Right-1);
+				vy2.push_back(m_Down-1);
+			}
+
+			vx1.push_back(m_Center_X+x);
+			vy1.push_back(m_Up+1);
+
+			vx2.push_back(m_Center_X-x);
+			vy2.push_back(m_Down-1);
+		}
+	}
+	else if ( dg2 == 90 || dg2 == 91 )
+	{
+		if ( flag == 0 )
+		{
+			vx1.push_back(m_Left+1);
+			vy1.push_back(m_Up+1);
+
+			vx2.push_back(m_Right-1);
+			vy2.push_back(m_Down-1);
+		}
+
+		vx1.push_back(endpointx);
+		vy1.push_back(m_Up+1);
+
+		vx2.push_back(endpointx);
+		vy2.push_back(m_Down-1);
+	}
+	else if ( (dg2 > 91) && (dg2 < 180) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
+		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			if ( flag == 0 )
+			{
+				vx1.push_back(m_Left+1);
+				vy1.push_back(m_Up+1);
+
+				vx1.push_back(m_Right-1);
+				vy1.push_back(m_Up+1);
+
+				vx2.push_back(m_Right-1);
+				vy2.push_back(m_Down-1);
+
+				vx2.push_back(m_Left+1);
+				vy2.push_back(m_Down-1);
+			}
+			else if ( flag != 0 && flag != 4 )
+			{
+				vx1.push_back(m_Right-1);
+				vy1.push_back(m_Up+1);
+
+				vx2.push_back(m_Left+1);
+				vy2.push_back(m_Down-1);
+			}
+
+			vx1.push_back(m_Right-1);
+			vy1.push_back(m_Center_Y-y);
+
+			vx2.push_back(m_Left+1);
+			vy2.push_back(m_Center_Y+y);
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+
+			if ( flag == 0 )
+			{
+				vx1.push_back(m_Left+1);
+				vy1.push_back(m_Up+1);
+
+				vx2.push_back(m_Right-1);
+				vy2.push_back(m_Down-1);
+			}
+
+			vx1.push_back(m_Center_X+x);
+			vy1.push_back(m_Up+1);
+
+			vx2.push_back(m_Center_X-x);
+			vy2.push_back(m_Down-1);
+		}
+	}
+
+	int len = vx1.size();
+	short *datax1 = new short[len];
+	short *datay1 = new short[len];
+	short *datax2 = new short[len];
+	short *datay2 = new short[len];
+
+	for ( int i=0;i<len;i++ )
+	{
+		datax1[i] = vx1[i];
+		datay1[i] = vy1[i];
+		datax2[i] = vx2[i];
+		datay2[i] = vy2[i];
+	}
+
+	g.FillPolygonColor(datax1,datay1,len,colorobj->Get_ColorVP(1)->color32);
+	g.PolygonColor(datax1,datay1,len,colorobj->Get_ColorVP(13)->color32);
+
+	g.FillPolygonColor(datax2,datay2,len,colorobj->Get_ColorVP(1)->color32);
+	g.PolygonColor(datax2,datay2,len,colorobj->Get_ColorVP(13)->color32);
+
+//	g.Ascii(starpointx,starpointy,'A',colorobj->Get_ColorVP(16)->color32);
+
+	delete[] datax1;
+	datax1 = NULL;
+	delete[] datay1;
+	datay1 = NULL;
+	delete[] datax2;
+	datax2 = NULL;
+	delete[] datay2;
+	datay2 = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Region
+ *  Description:  Judge the point is it in alram region 
+ * =====================================================================================
+ */
+bool AmpAlarm::Is_In_Region(int x,int y)
+{
+	int x_tmp = 0;
+	int y_tmp = 0;
+
+	if ( y > m_Center_Y )
+	{
+		y_tmp = m_Center_Y - abs( y - m_Center_Y );
+		if ( x > m_Center_X ) 
+			x_tmp = m_Center_X - ( x - m_Center_X );
+		else
+			x_tmp = m_Center_X + ( m_Center_X - x );
+	}
+	else
+	{
+		x_tmp = x;
+		y_tmp = y;
+	}
+
+	int t1,t2,t3,t4;
+	if ( (m_P1 != 90) && (m_P2 != 90)  )
+	{
+		y_tmp = m_Center_Y - y_tmp;
+		t1 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));	
+		t2 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
+		if ( ((x_tmp > (t1 - 1) ) && (x_tmp > (t2 - 1))) || ( ( x_tmp <  t1 ) && ( x_tmp <  t2 )))
+		{
+			return false;
+		}	
+		else
+		{
+			x_tmp = abs(m_Center_X - x_tmp); 
+			t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+			t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+			if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1)
+				return true;
+			else
+				return false;
+		}
+	}
+	else
+	{
+		if (m_P1 == 90)
+		{
+			y_tmp = m_Center_Y - y_tmp;
+			t1 = m_Center_X;
+			t2 = m_Center_X - static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
+			if ( ((x_tmp > ( t1 - 1) ) && (x_tmp > ( t2 - 1))) || ( x_tmp < ( t1 ) && x_tmp < ( t2 )))
+			{
+				return false;
+			}	
+			else            /* the point is in the fan area */
+			{
+				x_tmp = abs(m_Center_X - x_tmp);
+				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) 
+					return true;
+				else
+					return false;
+			}
+		}
+		else            /* p2 == 90 degree */
+		{
+			y_tmp = m_Center_Y - y_tmp;
+			t1 = m_Center_X-static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));	;
+			t2 = m_Center_X;
+			if ( ((x_tmp > ( t1 - 1) ) && (x_tmp > ( t2 - 1))) || ( x_tmp < ( t1 ) && x_tmp < ( t2 )))
+				return false;
+			else
+			{
+				x_tmp = abs(m_Center_X - x_tmp);
+				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1)
+					return true;
+				else
+					return false;
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Px
+ *  Description:  Set the 4 parameters of Rect region
+ *      caution:  P1:left P2:Up P3:Right P4:Down
+ * =====================================================================================
+ */
+void AmpAlarm::Adj_P1(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			if ( m_P1 == ( m_P2 - 5 ) ) m_P1 = m_P1;
+			else m_P1 += 1; 
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			if ( m_P1 == 3 ) m_P1 = m_P1;
+			else m_P1 -= 1; 
+		}
+	}
+}
+void AmpAlarm::Adj_P2(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			if 	( m_P2 == 177 ) m_P2 = m_P2;
+			else m_P2 += 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			if 	( m_P2 == ( m_P1 + 5 ) ) m_P2 = m_P2;
+			else m_P2 -= 1;
+		}
+	}
+}
+void AmpAlarm::Adj_P3(int v)
+{
+	m_P3 += v;
+	if 	( m_P3 < (m_Width>>3) ) m_P3 = (m_Width>>3);
+	else if ( m_P3 > ((m_Width>>2)+(m_Width>>3)) ) m_P3 = (m_Width>>2)+(m_Width>>3);
+
+	if 	( m_P3 < m_P4 )
+	{
+		m_P3 = m_P4;
+	}
+}
+void AmpAlarm::Adj_P4(int v)
+{
+	m_P4 += v;
+	if 	( m_P4 < (m_Width>>3) ) m_P4 = (m_Width>>3);
+	else if ( m_P4 > ((m_Width>>2)+(m_Width>>3)) ) m_P4 = (m_Width>>2)+(m_Width>>3);
+
+	if 	( m_P4 > m_P3 )
+	{
+		m_P4 = m_P3;
+	}
+}
+
+/* ----------------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------------------- */
+
+HAmpAlarm::HAmpAlarm (int x,int y,int width,int height)
+	: IAlarm(x,y,width,height)
+{
+}
+
+HAmpAlarm::~HAmpAlarm()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw me on screen 
+ * =====================================================================================
+ */
+void HAmpAlarm::Refreshme(Graphic& g)
+{
+	ColorObj *colorobj = ColorObj::Instance();
+	std::vector<int> vx,vy;
+
+	int x,y;
+	int starpointx;
+	int starpointy;
+	int endpointx;
+	int endpointy;
+
+	int dg1=0,dg2=0;                       /* the really degree */
+	if 	(m_P1 != 90)
+	{
+		double k;
+		k=alg->Get_Tan_Value(m_P1) * m_P3 / m_P4;
+		dg1 = static_cast<int>(180*atan(k)/3.1415926); 
+		if (dg1 < 0) dg1 += 180;
+	}
+	else { dg1 = 90; }
+	if 	( m_P2 != 90 )
+	{
+		double k;
+		k=alg->Get_Tan_Value(m_P2) * m_P3 / m_P4;
+		dg2 = static_cast<int>(180*atan(k)/3.1415926); 
+		if (dg2 < 0) dg2 += 180;
+	}
+	else { dg2 = 90; }
+
+	starpointx     = static_cast<int>(m_Center_X+m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg1)));
+
+	starpointy     = static_cast<int>(m_Center_Y-m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg1)));
+
+	endpointx      = static_cast<int>(m_Center_X+m_P3 *
+			alg->Get_Cos_Value(180-static_cast<int>(dg2)));
+
+	endpointy      = static_cast<int>(m_Center_Y-m_P4 *
+			alg->Get_Sin_Value(180-static_cast<int>(dg2)));
+
+	for (int i=(180-static_cast<int>(dg2));i<(180-static_cast<int>(dg1));i++)
+	{
+		vx.push_back(static_cast<int>(m_Center_X+m_P3*alg->Get_Cos_Value(i)));
+		vy.push_back(static_cast<int>(m_Center_Y-m_P4*alg->Get_Sin_Value(i)));
+	}
+
+	vx.push_back(starpointx);
+	vy.push_back(starpointy);
+
+	int flag = 0;
+	if 	( (dg1 > 0) && (dg1 < 90) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
+		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx.push_back(m_Left+1);
+			vy.push_back(m_Center_Y-y);
+			flag = 0;
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			vx.push_back(m_Center_X+x);
+			vy.push_back(m_Up+1);
+			flag = 1;
+		}
+	}
+	else if ( dg1 == 90 || dg1 == 91 )
+	{
+		vx.push_back(starpointx);
+		vy.push_back(m_Up+1);
+		flag = 2;
+	}
+	else if	( (dg1 > 91) && (dg1 < 180) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,starpointx - m_Center_X,m_Center_Y - starpointy,k,b);
+		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx.push_back(m_Right-1);
+			vy.push_back(m_Center_Y-y);
+			flag = 4;
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			vx.push_back(m_Center_X+x);
+			vy.push_back(m_Up+1);
+			flag = 3;
+		}
+	}
+//--------------------------
+	if 	( (dg2 > 0) && (dg2 < 90) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
+		y = static_cast<short>((m_Left+1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			vx.push_back(m_Left+1);
+			vy.push_back(m_Center_Y-y);
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			if ( flag == 0 )
+			{
+				vx.push_back(m_Left+1);
+				vy.push_back(m_Up+1);
+			}
+
+			vx.push_back(m_Center_X+x);
+			vy.push_back(m_Up+1);
+		}
+	}
+	else if (dg2 == 90 || dg2 == 91 )
+	{
+		if ( flag == 0 )
+		{
+			vx.push_back(m_Left+1);
+			vy.push_back(m_Up+1);
+		}
+
+		vx.push_back(endpointx);
+		vy.push_back(m_Up+1);
+	}
+	else if ( (dg2 > 91) && (dg2 < 180) )
+	{
+		double k=0,b=0;
+		alg->Get_K_b_Value(0,0,endpointx - m_Center_X,m_Center_Y - endpointy,k,b);
+		y = static_cast<short>((m_Right-1 - m_Center_X )*k+b);
+
+		if ( m_Center_Y - y >  m_Up + 1 )
+		{
+			if ( flag == 0 )
+			{
+				vx.push_back(m_Left+1);
+				vy.push_back(m_Up+1);
+
+				vx.push_back(m_Right-1);
+				vy.push_back(m_Up+1);
+
+			}
+			else if ( flag != 0 && flag != 4 )
+			{
+				vx.push_back(m_Right-1);
+				vy.push_back(m_Up+1);
+			}
+
+			vx.push_back(m_Right-1);
+			vy.push_back(m_Center_Y-y);
+		}
+		else
+		{
+			x = static_cast<short>((m_Center_Y-(m_Up+1)-b)/k);
+			if ( flag == 0 )
+			{
+				vx.push_back(m_Left+1);
+				vy.push_back(m_Up+1);
+			}
+
+			vx.push_back(m_Center_X+x);
+			vy.push_back(m_Up+1);
+		}
+	}
+
+	int len = vx.size();
+	short *datax = new short[len];
+	short *datay = new short[len];
+
+	for ( int i=0;i<len;i++ )
+	{
+		datax[i] = vx[i];
+		datay[i] = vy[i];
+	}
+
+	g.FillPolygonColor(datax,datay,len,colorobj->Get_ColorVP(1)->color32);
+	g.PolygonColor(datax,datay,len,colorobj->Get_ColorVP(13)->color32);
+
+//	g.Ascii(starpointx,starpointy,'A',colorobj->Get_ColorVP(16)->color32);
+
+	delete[] datax;
+	datax = NULL;
+	delete[] datay;
+	datay = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Region
+ *  Description:  Judge the point is it in alram region 
+ * =====================================================================================
+ */
+bool HAmpAlarm::Is_In_Region(int x,int y)
+{
+	int x_tmp = 0;
+	int y_tmp = 0;
+
+	if ( y > m_Center_Y )
+		return false;
+		
+	int t1,t2,t3,t4;
+	if ( (m_P1 != 90) && (m_P2 != 90)  )
+	{
+		y_tmp = m_Center_Y - y;
+		t1 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));
+		t2 = m_Center_X -static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));
+		if ( ((x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( ( x <  t1 ) && ( x <  t2 )))
+			return false;
+		else
+		{
+			x_tmp = abs(m_Center_X - x); 
+			t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+			t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+			if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1 )                        /* outsize of the ellipse area */
+				return true; 
+			else
+				return false;
+		}
+	}
+	else
+	{
+		if (m_P1 == 90)
+		{
+			y_tmp = m_Center_Y - y;
+			t1 = m_Center_X;
+			t2 = m_Center_X - static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P2 ));	
+			if (( (x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( x < ( t1 ) && x < ( t2 )))
+				return false;
+			else
+			{
+				x_tmp = abs(m_Center_X - x);
+				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) /* outsize of the ellipse area */
+					return true;
+				else
+					return false;
+			}
+		}
+		else            /* p2 == 90 degree */
+		{
+			y_tmp = m_Center_Y - y;
+			t1 = m_Center_X-static_cast<int>( y_tmp / alg->Get_Tan_Value( m_P1 ));
+			t2 = m_Center_X;
+			if ( ((x > ( t1 - 1) ) && (x > ( t2 - 1))) || ( x < ( t1 ) && x < ( t2 )))
+				return false;
+			else
+			{
+				x_tmp = abs(m_Center_X - x);
+				t3 = static_cast<int>(m_P3 * m_P3); /* a*a */
+				t4 = static_cast<int>(m_P4 * m_P4); /* b*b */
+				if ( static_cast<float>(x_tmp*x_tmp)/static_cast<float>(t3)+static_cast<float>(y_tmp*y_tmp)/static_cast<float>(t4) > 1) /* outsize of the ellipse area */
+					return true;
+				else
+					return false;
+			}
+		}
+	}
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Px
+ *  Description:  Set the 4 parameters of Rect region
+ *      caution:  P1:left P2:Up P3:Right P4:Down
+ * =====================================================================================
+ */
+void HAmpAlarm::Adj_P1(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			if ( m_P1 == ( m_P2 - 5 ) ) m_P1 = m_P1;
+			else m_P1 += 1; 
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			if ( m_P1 == 3 ) m_P1 = m_P1;
+			else m_P1 -= 1; 
+		}
+	}
+}
+void HAmpAlarm::Adj_P2(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			if 	( m_P2 == 177 ) m_P2 = m_P2;
+			else m_P2 += 1;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			if 	( m_P2 == ( m_P1 + 5 ) ) m_P2 = m_P2;
+			else m_P2 -= 1;
+		}
+	}
+}
+void HAmpAlarm::Adj_P3(int v)
+{
+	m_P3 += v;
+	if 	( m_P3 < (m_Width>>3) ) m_P3 = (m_Width>>3);
+	else if ( m_P3 > ((m_Width>>3)+(m_Width>>2)) ) m_P3 = (m_Width>>2)+(m_Width>>3);
+
+	if 	( m_P3 < m_P4 )
+	{
+		m_P3 = m_P4;
+	}
+}
+void HAmpAlarm::Adj_P4(int v)
+{
+	m_P4 += v;
+	if 	( m_P4 < (m_Width>>3) ) m_P4 = (m_Width>>3);
+	else if ( m_P4 > ((m_Width>>3)+(m_Width>>2)) ) m_P4 = (m_Width>>2)+(m_Width>>3);
+
+	if 	( m_P4 > m_P3 )
+	{
+		m_P4 = m_P3;
+	}
+}
+
+SLimitAlarm::SLimitAlarm (int x,int y,int width,int height)
+	: IAlarm(x,y,width,height)
+{
+}
+
+SLimitAlarm::~SLimitAlarm()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw me on screen 
+ * =====================================================================================
+ */
+void SLimitAlarm::Refreshme(Graphic& g)
+{
+	ColorObj *colorobj = ColorObj::Instance();
+
+	short *datax = new short[4];
+	short *datay = new short[4];
+
+	datax[0] = m_Left + 1;
+	datax[1] = m_Right - 1;
+	datax[2] = m_Right - 1;
+	datax[3] = m_Left + 1;
+
+	datay[0] = m_Center_Y + m_P1;
+	datay[1] = m_Center_Y + m_P1;
+	datay[2] = m_Up + 1;
+	datay[3] = m_Up + 1 + 1;
+
+	g.FillPolygonColor(datax,datay,4,colorobj->Get_ColorVP(1)->color32);
+	g.PolygonColor(datax,datay,4,colorobj->Get_ColorVP(13)->color32);
+
+	delete[] datax;
+	datax = NULL;
+	delete[] datay;
+	datay = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Region
+ *  Description:  Judge the point is it in alram region 
+ * =====================================================================================
+ */
+bool SLimitAlarm::Is_In_Region(int x,int y)
+{
+	if ( y <= ( m_Center_Y + m_P1 ) )
+		return true;
+	return false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Px
+ *  Description:  Set the 4 parameters of Rect region
+ *      caution:  P1:left P2:Up P3:Right P4:Down
+ * =====================================================================================
+ */
+void SLimitAlarm::Adj_P1(int v)
+{
+	if 	( v > 0 )
+	{
+		for ( int i=0;i<v;i++ )
+		{
+			m_P1 ++;
+			if 	( m_Center_Y + m_P1 >= m_Down - 10 )
+				m_P1 = m_Down - 10 - m_Center_Y;
+		}
+	}
+	else
+	{
+		for ( int i=0;i<-v;i++ )
+		{
+			m_P1 --;
+			if 	( m_Center_Y + m_P1 <= m_Up + 10 )
+				m_P1 = m_Up + 10 - m_Center_Y; 
+		}
+	}
+}
+void SLimitAlarm::Adj_P2(int v)
+{
+}
+void SLimitAlarm::Adj_P3(int v)
+{
+}
+void SLimitAlarm::Adj_P4(int v)
+{
+}
diff --git a/src/EVA11/base/AlarmRegion.h b/src/EVA11/base/AlarmRegion.h
new file mode 100644
index 0000000..1106906
--- /dev/null
+++ b/src/EVA11/base/AlarmRegion.h
@@ -0,0 +1,137 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmRegion.h
+ *
+ *    Description:  AlarmRegion class declaration
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月18日 10时04分12秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ALARMREGION_INC
+#define  _ALARMREGION_INC
+
+/*-----------------------------------------------------------------------------
+ *  Base class of All Alarm Region class
+ *-----------------------------------------------------------------------------*/
+class Graphic;
+class Basescreen;
+class Algorithm;
+class IAlarm : public Basescreen
+{
+	public:
+		IAlarm (int x,int y,int width,int height);   		/* Becare this function  set the bordor of alarm */
+		virtual ~IAlarm ();
+
+		virtual void Refreshme(Graphic &g)     = 0;
+		virtual bool Is_In_Region(int x,int y) = 0;
+
+		void Set_4Para(int p1,int p2,int p3,int p4);
+
+		/*-----------------------------------------------------------------------------
+		 *  Operation of set parameters
+		 *-----------------------------------------------------------------------------*/
+		void virtual Adj_P1(int) = 0;
+		void virtual Adj_P2(int) = 0;
+		void virtual Adj_P3(int) = 0;
+		void virtual Adj_P4(int) = 0;
+
+		virtual int Get_P1() 	    ;
+		virtual int Get_P2() 	    ;
+		virtual int Get_P3() 	    ;
+		virtual int Get_P4() 	    ;
+
+		virtual void Set_P1(int)    ;
+		virtual void Set_P2(int)    ;
+		virtual void Set_P3(int)    ;
+		virtual void Set_P4(int)    ;
+
+	protected:
+		int			m_P1;
+		int			m_P2;
+		int			m_P3;
+		int			m_P4;
+
+		Algorithm*		alg;
+
+	private:
+};
+
+class RectAlarm : public IAlarm
+{
+	public:
+		RectAlarm (int x,int y,int width,int height);
+		~RectAlarm ();
+
+		virtual void Refreshme(Graphic &g);
+		virtual bool Is_In_Region(int x,int y);
+
+		void virtual Adj_P1(int);
+		void virtual Adj_P2(int);
+		void virtual Adj_P3(int);
+		void virtual Adj_P4(int);
+
+	protected:
+
+	private:
+
+};
+
+class AmpAlarm : public IAlarm
+{
+	public:
+		AmpAlarm(int x,int y,int width,int height);
+		~AmpAlarm();
+
+		virtual void Refreshme(Graphic &g);
+		virtual bool Is_In_Region(int x,int y);
+
+		void virtual Adj_P1(int);
+		void virtual Adj_P2(int);
+		void virtual Adj_P3(int);
+		void virtual Adj_P4(int);
+	protected:
+
+	private:
+
+};
+
+class HAmpAlarm : public IAlarm
+{
+	public:
+		HAmpAlarm(int x,int y,int width,int height);
+		~HAmpAlarm();
+
+		virtual void Refreshme(Graphic &g);
+		virtual bool Is_In_Region(int x,int y);
+
+		void virtual Adj_P1(int);
+		void virtual Adj_P2(int);
+		void virtual Adj_P3(int);
+		void virtual Adj_P4(int);
+};
+
+class SLimitAlarm : public IAlarm
+{
+	public:
+		SLimitAlarm(int x,int y,int width,int height);
+		~SLimitAlarm();
+
+		virtual void Refreshme(Graphic &g);
+		virtual bool Is_In_Region(int x,int y);
+
+		void virtual Adj_P1(int);
+		void virtual Adj_P2(int);
+		void virtual Adj_P3(int);
+		void virtual Adj_P4(int);
+};
+
+#endif
diff --git a/src/EVA11/base/AlarmView.cpp b/src/EVA11/base/AlarmView.cpp
new file mode 100644
index 0000000..97b6f04
--- /dev/null
+++ b/src/EVA11/base/AlarmView.cpp
@@ -0,0 +1,213 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmView.cpp
+ *
+ *    Description:  Implementation of AlarmView class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月17日 13时34分43秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdlib>
+#include 	<cstdio>
+
+#include 	"Graphic.h"
+#include	"Global.h"
+#include 	"Device.h"
+#include 	"Language.h"
+
+#include 	"Object.h"
+
+#include 	"BasePanel.h"
+#include 	"IView.h"
+#include	"DetectView.h"
+#include 	"AlarmView.h"
+
+#include 	"FreeType.h"
+
+AlarmView::AlarmView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+	m_DetectView = NULL;
+}
+
+AlarmView::~AlarmView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view sets 
+ * =====================================================================================
+ */
+void AlarmView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  
+ * =====================================================================================
+ */
+void AlarmView::Release_View()
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  Loop View
+ * =====================================================================================
+ */
+int AlarmView::Loop_View(Graphic& g)
+{
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_DetectView_Object
+ *  Description:  For Alarm view draw GUI on screen 
+ * =====================================================================================
+ */
+void AlarmView::Load_View_Object(IView* obj)
+{
+	m_DetectView = dynamic_cast<DetectView *>(obj);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message system
+ * =====================================================================================
+ */
+void AlarmView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI Object 
+ * =====================================================================================
+ */
+void AlarmView::Init_GUI(Graphic& g)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void AlarmView::Destroy_GUI()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ * =====================================================================================
+ */
+void AlarmView::Drawme(Graphic& g)
+{
+	if ( m_DetectView != NULL )
+	{
+		m_DetectView->Drawme(g);
+//		Global *global = Global::Instance();
+//		global->bNeedResetAlarmArea = true;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Swtich_View
+ *  Description:  when chang the view called it
+ * =====================================================================================
+ */
+void AlarmView::Switch_View()
+{
+	if ( m_DetectView != NULL )
+		m_DetectView->Switch_View();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fn_Fun
+ *  Description:  Key Function 
+ * =====================================================================================
+ */
+int AlarmView::Key_NL1_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL1_Fun(g,sub);
+}
+int AlarmView::Key_NR1_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR1_Fun(g,sub);
+}
+int AlarmView::Key_NL2_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL2_Fun(g,sub);
+}
+int AlarmView::Key_NR2_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR2_Fun(g,sub);
+}
+int AlarmView::Key_NL3_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL3_Fun(g,sub);
+}
+int AlarmView::Key_NR3_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR3_Fun(g,sub);
+}
+int AlarmView::Key_NL4_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL4_Fun(g,sub);
+}
+int AlarmView::Key_NR4_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR4_Fun(g,sub);
+}
+int AlarmView::Key_NL5_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL5_Fun(g,sub);
+}
+int AlarmView::Key_NR5_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR5_Fun(g,sub);
+}
+int AlarmView::Key_NL6_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NL6_Fun(g,sub);
+}
+int AlarmView::Key_NR6_Fun(Graphic& g,int sub)
+{
+	return m_DetectView->m_Panel[m_DetectView->m_PanelType]->Alarm_NR6_Fun(g,sub);
+}
diff --git a/src/EVA11/base/AlarmView.h b/src/EVA11/base/AlarmView.h
new file mode 100644
index 0000000..1a88e06
--- /dev/null
+++ b/src/EVA11/base/AlarmView.h
@@ -0,0 +1,60 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlarmView.h
+ *
+ *    Description:  Process Alarm view function
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月17日 13时31分45秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ALARMVIEW_INC
+#define  _ALARMVIEW_INC
+
+class IView;
+class DetectView;
+class AlarmView : public IView
+{
+	public:
+		AlarmView (int x,int y,int width,int heigh);
+		~AlarmView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		virtual void Drawme(Graphic&);
+
+		void Load_View_Object(IView* obj);
+		void Switch_View();
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		DetectView*		m_DetectView;
+	private:
+};
+#endif
diff --git a/src/EVA11/base/AlgMixing.cpp b/src/EVA11/base/AlgMixing.cpp
new file mode 100644
index 0000000..e6e44b5
--- /dev/null
+++ b/src/EVA11/base/AlgMixing.cpp
@@ -0,0 +1,560 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlgMixing.cpp
+ *
+ *    Description:  Implementation of AlgMixing
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月16日 09时07分27秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cmath>
+#include 	<cstdio>
+
+#include 	<algorithm>
+#include 	"AlgMixing.h"
+#include 	"CalculateCenter.h"
+
+#include 	"Algorithm.h"
+#include 	"Global.h"
+
+#include 	"Logic.h"
+
+#include	<gsl/gsl_rng.h> 
+#include	<gsl/gsl_randist.h> 
+#include	<gsl/gsl_vector.h> 
+#include	<gsl/gsl_matrix.h> 
+#include	<gsl/gsl_multifit.h> 
+#include	<gsl/gsl_multifit_nlin.h> 
+#include 	<gsl/gsl_blas.h>
+
+#include 	"FitHead.h"
+
+extern "C"
+{
+	int expb_f(const gsl_vector* x,void* data,gsl_vector* f);
+	int expb_df(const gsl_vector* x,void* data,gsl_matrix* J);
+	int expb_fdf(const gsl_vector* x,void* data,gsl_vector* f,gsl_matrix* J);
+};
+
+struct AlgMixing::Mixp
+{
+	double 				Sx;
+	double 				Sy;
+	double 				Cos;
+	double 				Sin;
+
+	int				Sita;
+};
+
+struct AlgMixing::MixV2
+{
+	double 				a;	
+	double 				b;
+	double 				c;
+	double 				d;
+};
+
+struct AlgMixing::PImpl
+{
+	std::vector<ETDATA>		m_vX1;
+	std::vector<ETDATA>		m_vY1;
+
+	std::vector<ETDATA>		m_vX2;
+	std::vector<ETDATA>		m_vY2;
+
+	struct Mixp			m_Mp;
+	struct MixV2			m_MV2;
+
+	int				m_AlgMix_Version;
+};
+
+AlgMixing::AlgMixing ()
+	: m_Imple(new struct PImpl)
+{
+}
+
+AlgMixing::~AlgMixing ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Object
+ *  Description:  Init the Object 
+ * =====================================================================================
+ */
+bool AlgMixing::Init_Object()
+{
+	m_Imple->m_vX1.clear();
+	m_Imple->m_vY1.clear();
+	     
+	m_Imple->m_vX2.clear();
+	m_Imple->m_vY2.clear();
+
+	m_Imple->m_Mp.Sx    = 1;
+	m_Imple->m_Mp.Sy    = 1;
+	m_Imple->m_Mp.Cos   = 1;
+	m_Imple->m_Mp.Sin   = 0;
+	m_Imple->m_Mp.Sita  = 0;
+
+	m_Imple->m_MV2.a    = 1;
+	m_Imple->m_MV2.b    = 0;
+	m_Imple->m_MV2.c    = 1;
+	m_Imple->m_MV2.d    = 0;
+
+	m_Imple->m_AlgMix_Version
+			    = 0;
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy
+ *  Description:  Destroy the object of class 
+ * =====================================================================================
+ */
+void AlgMixing::Destroy_Object()
+{
+	m_Imple->m_vX1.clear();
+	m_Imple->m_vY1.clear();
+	     
+	m_Imple->m_vX2.clear();
+	m_Imple->m_vY2.clear();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Mix_Para
+ *  Description:  Calculate the mixing parameters
+ * =====================================================================================
+ */
+void AlgMixing::Calculate_Mix_Para_V2()
+{
+	int len = m_Imple->m_vX1.size();
+
+	long long y2x1 = 0;
+	long long x1x2 = 0;
+	long long y1x2 = 0;
+	long long y1y2 = 0;
+	long long x2x2 = 0;
+	long long y2y2 = 0;
+	double a;
+	double a1,b1,c1;
+
+	for ( int i=0;i<len;i++ )
+	{
+		y2x1 += static_cast<long long >(m_Imple->m_vY2[i]) * static_cast<long long >(m_Imple->m_vX1[i]);
+		x1x2 += static_cast<long long >(m_Imple->m_vX1[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
+		y1x2 += static_cast<long long >(m_Imple->m_vY1[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
+		y1y2 += static_cast<long long >(m_Imple->m_vY1[i]) * static_cast<long long >(m_Imple->m_vY2[i]);
+		x2x2 += static_cast<long long >(m_Imple->m_vX2[i]) * static_cast<long long >(m_Imple->m_vX2[i]);
+		y2y2 += static_cast<long long >(m_Imple->m_vY2[i]) * static_cast<long long >(m_Imple->m_vY2[i]);
+	}
+
+	a1 = (static_cast<double>(y1y2)*static_cast<double>(y2x1))/static_cast<double>(y2y2)-(static_cast<double>(y1x2)*static_cast<double>(x1x2))/static_cast<double>(x2x2);
+	b1 = (static_cast<double>(x1x2)*static_cast<double>(x1x2))/static_cast<double>(x2x2)-(static_cast<double>(y1x2)*static_cast<double>(y1x2))/static_cast<double>(x2x2)-
+	     (static_cast<double>(y2x1)*static_cast<double>(y2x1))/static_cast<double>(y2y2)+(static_cast<double>(y1y2)*static_cast<double>(y1y2))/static_cast<double>(y2y2); 
+	c1 = (static_cast<double>(x1x2)*static_cast<double>(y1x2))/static_cast<double>(x2x2)-(static_cast<double>(y1y2)*static_cast<double>(y2x1))/static_cast<double>(y2y2);
+
+	a = ( -b1 + sqrt(b1*b1-4*a1*c1) ) / ( 2 * a1 ); 
+
+	m_Imple->m_Mp.Cos = + sqrt( 1 / ( a * a + 1 ) );
+	m_Imple->m_Mp.Sin = a * m_Imple->m_Mp.Cos;
+
+	m_Imple->m_Mp.Sx  = ( m_Imple->m_Mp.Cos * static_cast<double>(x1x2) - m_Imple->m_Mp.Sin * static_cast<double>(y1x2) ) / static_cast<double>(x2x2);
+	m_Imple->m_Mp.Sy  = ( m_Imple->m_Mp.Sin * static_cast<double>(y2x1) + m_Imple->m_Mp.Cos * static_cast<double>(y1y2) ) / static_cast<double>(y2y2);
+
+	Calculate_Deviation();
+}
+void AlgMixing::Calculate_Mix_Para()
+{
+	int len = m_Imple->m_vX1.size();
+	double *x1 = new double[len];
+	double *y1 = new double[len];
+	double *x2 = new double[len];
+	double *y2 = new double[len];
+
+	for ( int i=0;i<len;i++ )
+	{
+		x1[i] = m_Imple->m_vX1[i];
+		y1[i] = m_Imple->m_vY1[i];
+		x2[i] = m_Imple->m_vX2[i];
+		y2[i] = m_Imple->m_vY2[i];
+	}
+
+	NoLine_Fitting(x1,y1,x2,y2,len);
+
+	delete[] x1;
+	delete[] y1;
+	delete[] x2;
+	delete[] y2;
+	x1 = NULL;
+	y1 = NULL;
+	x2 = NULL;
+	y2 = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mixing
+ *  Description:  Mixing the Signal value 
+ * =====================================================================================
+ */
+void AlgMixing::Mixing_V2(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y)
+{
+	double tx;
+	double ty;
+
+	tx = m_Imple->m_Mp.Sy * y * m_Imple->m_Mp.Sin + m_Imple->m_Mp.Sx * x * m_Imple->m_Mp.Cos;
+	ty = m_Imple->m_Mp.Sy * y * m_Imple->m_Mp.Cos - m_Imple->m_Mp.Sx * x * m_Imple->m_Mp.Sin;
+
+	x = static_cast<ETDATA>(tx);
+	y = static_cast<ETDATA>(ty);
+
+	x = xb - x;
+	y = yb - y;
+}
+void AlgMixing::Mixing(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y)
+{
+	double tx = m_Imple->m_MV2.a * x + m_Imple->m_MV2.b * y;
+	double ty = m_Imple->m_MV2.c * y + m_Imple->m_MV2.d * x;
+
+	x = xb - static_cast<ETDATA>(tx);
+	y = yb - static_cast<ETDATA>(ty);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Data_Into_Buffer
+ *  Description:  Load Data into Buffer of object 
+ * =====================================================================================
+ */
+void AlgMixing::Load_Data_Into_Buffer(ETDATA *data)
+{
+	if 	( gsl_hypot(data[0],data[1]) <= 10 )
+		return;
+
+	m_Imple->m_vX1.push_back(data[0]);
+	m_Imple->m_vY1.push_back(data[1]);
+
+	m_Imple->m_vX2.push_back(data[2]);
+	m_Imple->m_vY2.push_back(data[3]);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Process_Data_Center
+ *  Description:  Process Data, Let the Data focus to center 
+ * =====================================================================================
+ */
+void AlgMixing::Process_Data_Center()
+{
+	int len = m_Imple->m_vX1.size();
+	CalculateCenter cc1;
+	cc1.Init_Object();
+	CalculateCenter cc2;
+	cc2.Init_Object();
+
+	for ( int i=0;i<len;i++ )
+	{
+		cc1.Calculate_Graphic_MAX_MIN_Value(m_Imple->m_vX1[i],
+						    m_Imple->m_vY1[i]);
+		cc2.Calculate_Graphic_MAX_MIN_Value(m_Imple->m_vX2[i],
+						    m_Imple->m_vY2[i]);
+	}
+
+	cc1.Calculate_Graphic_Center();
+	cc2.Calculate_Graphic_Center();
+
+	int cx,cy;
+	cc1.Get_Center_Point(cx,cy);
+	for ( int i=0;i<len;i++ )
+	{
+		m_Imple->m_vX1[i] -= cx;
+		m_Imple->m_vY1[i] -= cy;
+	}
+
+	cc2.Get_Center_Point(cx,cy);
+	for ( int i=0;i<len;i++ )
+	{
+		m_Imple->m_vX2[i] -= cx;
+		m_Imple->m_vY2[i] -= cy;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_Data_From_Buffer
+ *  Description:  Clean Data from Buffer 
+ * =====================================================================================
+ */
+void AlgMixing::Clean_Data_From_Buffer()
+{
+	m_Imple->m_vX1.clear();
+	m_Imple->m_vY1.clear();
+	     
+	m_Imple->m_vX2.clear();
+	m_Imple->m_vY2.clear();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  NoLine_Fitting
+ *  Description:  NoLine Fitting 
+ * =====================================================================================
+ */
+void AlgMixing::NoLine_Fitting(double *x1,double *y1,double *x2,double *y2,int len)
+{
+	const int32_t n = len;
+	const int32_t p = 4;      // need
+	double sigma[n];
+
+	double *yr = new double[n];
+	for ( int i=0;i<n;i++ )
+		yr[i] = 0;
+
+	DATA d = {n,x1,y1,x2,y2,yr,sigma};
+	const gsl_multifit_fdfsolver_type *T;
+	gsl_multifit_fdfsolver *s;
+	gsl_multifit_function_fdf f;
+	f.f = &expb_f;
+	f.df = &expb_df;
+	f.fdf = &expb_fdf;
+	f.n = n;
+	f.p = p;
+	f.params = &d;
+
+//	double x_init[p] = {0.2623,0.1603,0.2916,0.085};    // need
+
+	double x_init[p] = {m_Imple->m_MV2.a,m_Imple->m_MV2.b,m_Imple->m_MV2.c,m_Imple->m_MV2.d};    // need
+	gsl_vector_view x = gsl_vector_view_array(x_init,p);
+
+	double max,min,temp;
+	for ( int i=0;i<len;i++ )
+	{
+		temp = gsl_hypot(x2[i],y2[i]);
+		if ( i==0 )
+		{
+			max = temp;
+			min = max;
+			continue;
+		}
+		if ( max < temp )
+		{
+			max = temp;
+		}
+		if ( min > temp )
+		{
+			min = temp;
+		}
+	}
+
+	/*  ---------    filled the data   --------  */
+	for ( int i=0;i<n;i++ )
+	{
+		sigma[i] = 1;
+	}
+
+	T = gsl_multifit_fdfsolver_lmsder;
+	s = gsl_multifit_fdfsolver_alloc(T,n,p);
+	gsl_multifit_fdfsolver_set(s,&f,&x.vector);
+
+	gsl_vector *g = gsl_vector_alloc(4);;
+
+	gsl_multifit_gradient(s->J,s->f,g);
+	/*  ---------    find the fit variablelue   --------  */
+	int iter = 0;
+	int status = 0;
+	do
+	{
+		iter++;
+		status = gsl_multifit_fdfsolver_iterate (s);
+		if (status)
+			break;
+
+//		status = gsl_multifit_test_delta (s->dx, s->x,
+//				0.0001, 0.0001);
+
+		status = gsl_multifit_test_gradient (g,0.00001);
+
+		printf ( "(%d) a=%f b=%f c=%f d=%f |fit(x)|=%f,\n",iter,
+						   gsl_vector_get(s->x,0),
+		                                   gsl_vector_get(s->x,1),
+						   gsl_vector_get(s->x,2),
+		                                   gsl_vector_get(s->x,3),
+		      				   gsl_blas_dnrm2(s->f));
+	}
+	while (status == GSL_CONTINUE && iter < 500);
+
+	m_Imple->m_MV2.a = gsl_vector_get(s->x,0);
+	m_Imple->m_MV2.b = gsl_vector_get(s->x,1);
+	m_Imple->m_MV2.c = gsl_vector_get(s->x,2);
+	m_Imple->m_MV2.d = gsl_vector_get(s->x,3);
+
+	gsl_vector_free(g);
+
+	delete[] yr;
+	yr = NULL;
+	gsl_multifit_fdfsolver_free(s);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Deviation
+ *  Description:  Give the calculate the deviation to user 
+ * =====================================================================================
+ */
+void AlgMixing::Calculate_Deviation()
+{
+	long long sum = 0;
+	int len = m_Imple->m_vX1.size();
+	ETDATA x1,y1,x2,y2,xm,ym;
+	long long distance = 0;
+	int indexdistance=0;
+	int dx,dy;
+	for ( int i=0;i<len;i++ )
+	{
+		x1 = m_Imple->m_vX1[i];
+		y1 = m_Imple->m_vY1[i];
+		x2 = m_Imple->m_vX2[i];
+		y2 = m_Imple->m_vY2[i];
+		xm = x2;
+		ym = y2;
+		Mixing(x1,y1,xm,ym);
+
+		sum += (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
+
+		if ( distance == 0 )
+		{
+			distance = (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
+			indexdistance = 0;
+			dx = x1-xm;
+			dy = y1-ym;
+		}
+		else
+		{
+			if ( distance < (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym) )
+			{
+				distance = (x1-xm)*(x1-xm) + (y1-ym)*(y1-ym);
+				indexdistance = i;
+				dx = x1-xm;
+				dy = y1-ym;
+			}
+		}
+	}
+
+	printf ( "deviation sum %lld\n",sum );
+	printf ( "deviation max %lld index %d\n",distance,indexdistance );
+	printf ( "dx %d dy %d\n",dx,dy );
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_AlgMix_Version
+ *  Description:  Set the Mixing Algorithm Version 
+ * =====================================================================================
+ */
+void AlgMixing::Set_AlgMix_Version(int value)
+{
+	m_Imple->m_AlgMix_Version = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_AlgMix_Version
+ *  Description:  
+ * =====================================================================================
+ */
+int  AlgMixing::Get_AlgMix_Version()
+{
+	return m_Imple->m_AlgMix_Version;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_Sets
+ *  Description:  Set the parameters function sets 
+ * =====================================================================================
+ */
+void AlgMixing::Set_Sx(double v)
+{
+	m_Imple->m_Mp.Sx = v;
+}
+void AlgMixing::Set_Sy(double v)
+{
+	m_Imple->m_Mp.Sy = v;
+}
+void AlgMixing::Set_Cos(double v)
+{
+	m_Imple->m_Mp.Cos = v;
+}
+void AlgMixing::Set_Sin(double v)
+{
+	m_Imple->m_Mp.Sin = v;
+}
+
+void AlgMixing::Set_a(double v)
+{
+	m_Imple->m_MV2.a = v;
+}
+void AlgMixing::Set_b(double v)
+{
+	m_Imple->m_MV2.b = v;
+}
+void AlgMixing::Set_c(double v)
+{
+	m_Imple->m_MV2.c = v;
+}
+void AlgMixing::Set_d(double v)
+{
+	m_Imple->m_MV2.d = v;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Para_Fun_Sets
+ *  Description:  Get the parameters
+ * =====================================================================================
+ */
+double AlgMixing::Get_Sx()
+{
+	return m_Imple->m_Mp.Sx;
+}
+double AlgMixing::Get_Sy()
+{
+	return m_Imple->m_Mp.Sy;
+}
+double AlgMixing::Get_Sin()
+{
+	return m_Imple->m_Mp.Sin;
+}
+double AlgMixing::Get_Cos()
+{
+	return m_Imple->m_Mp.Cos;
+}
+
+double AlgMixing::Get_a()
+{
+	return m_Imple->m_MV2.a;
+}
+double AlgMixing::Get_b()
+{
+	return m_Imple->m_MV2.b;
+}
+double AlgMixing::Get_c()
+{
+	return m_Imple->m_MV2.c;
+}
+double AlgMixing::Get_d()
+{
+	return m_Imple->m_MV2.d;
+}
diff --git a/src/EVA11/base/AlgMixing.h b/src/EVA11/base/AlgMixing.h
new file mode 100644
index 0000000..5bacd1d
--- /dev/null
+++ b/src/EVA11/base/AlgMixing.h
@@ -0,0 +1,80 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AlgMixing.h
+ *
+ *    Description:  Declearation of catchlculate Mixing algorithm
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月16日 09时05分32秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ALGMIXING_INC
+#define  _ALGMIXING_INC
+
+#include 	<memory>	
+#include 	<vector>
+#include 	"main.h"
+
+class AlgMixing
+{
+	public:
+		AlgMixing ();
+		~AlgMixing ();
+		bool Init_Object();
+		void Destroy_Object();
+		void Clean_Data_From_Buffer();
+
+		void Load_Data_Into_Buffer(ETDATA *data);
+
+		void Calculate_Mix_Para();
+		void Mixing(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y);
+
+		void Calculate_Mix_Para_V2();
+		void Mixing_V2(const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA& y);
+
+		void Set_Sx(double);
+		void Set_Sy(double);
+		void Set_Cos(double);
+		void Set_Sin(double);
+
+		double Get_Sx();
+		double Get_Sy();
+		double Get_Sin();
+		double Get_Cos();
+
+		void Set_a(double);
+		void Set_b(double);
+		void Set_c(double);
+		void Set_d(double);
+
+		double Get_a();
+		double Get_b();
+		double Get_c();
+		double Get_d();
+
+		void Set_AlgMix_Version(int);
+		int  Get_AlgMix_Version();
+
+	protected:
+
+	private:
+		void Calculate_Deviation();
+		void Process_Data_Center();
+		void NoLine_Fitting(double *x1,double *y1,double *x2,double *y2,int len);
+
+	private:
+		struct Mixp;
+		struct MixV2;
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif   /* ----- #ifndef _ALGMIXING_INC  ----- */
diff --git a/src/EVA11/base/Algorithm.cpp b/src/EVA11/base/Algorithm.cpp
new file mode 100644
index 0000000..b3697ae
--- /dev/null
+++ b/src/EVA11/base/Algorithm.cpp
@@ -0,0 +1,717 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Algorithm.cpp
+ *
+ *    Description:  Declare of Algorithm class 
+ *
+ *        Version:  1.0
+ *        Created:  2010年03月26日 19时12分10秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+#include        <math.h>
+#include        <cstdio>
+#include        <cstdlib>
+#include 	<unistd.h>
+#include 	<sys/time.h>
+
+#include	<gsl/gsl_vector.h> 
+#include	<gsl/gsl_matrix.h> 
+#include	<gsl/gsl_multifit.h> 
+#include	<gsl/gsl_math.h> 
+
+#include        "Algorithm.h"
+#include 	"Global.h"
+#include 	"DFilter.h"
+
+std::auto_ptr<Algorithm> Algorithm::m_Instance;
+
+Algorithm::Algorithm ()                             
+{
+}
+
+Algorithm::~Algorithm ()
+{
+	m_Instance.get()->Release_Digital_Fileter_Value();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Make sure there is only one object in memory 
+ * =====================================================================================
+ */
+Algorithm* Algorithm::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Algorithm() );
+		/*-----------------------------------------------------------------------------
+		 *  Pre-calculate the Sin Cos Tan Tables
+		 *-----------------------------------------------------------------------------*/
+		m_Instance.get()->Init_SinCosTan_Table_Value();
+		m_Instance.get()->Init_SQRT_Table_Value();
+		/*-----------------------------------------------------------------------------
+		 *  Init table value for Digital filter
+		 *-----------------------------------------------------------------------------*/
+		m_Instance.get()->Init_Digital_Filter_Value(Global::CHANCOUNT);
+		m_Instance.get()->m_fGainPercent = 1.0;
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_SinCosTan_Table_Value
+ *  Description:  Init Sin Cos Tan table value
+ * =====================================================================================
+ */
+void Algorithm::Init_SinCosTan_Table_Value()
+{
+	double coefficient = M_PI / 180;
+
+	for (int index=0;index<360;index++)
+	{
+		m_Sin[index] = sin(static_cast<double>(index * coefficient));
+		m_Cos[index] = cos(static_cast<double>(index * coefficient));
+	}
+	for (int i=0;i<180;i++)
+	{
+		m_Tan[i] = tan(static_cast<double>(i * coefficient));
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_SQRT_Table_Value
+ *  Description:  Init the sqrt Table value 
+ * =====================================================================================
+ */
+void Algorithm::Init_SQRT_Table_Value()
+{
+	for ( int i = 0; i < MAXTABLELONG; i ++ )
+	{
+		for ( int j = 0; j < MAXTABLELONG; j ++ )
+		{
+			m_Tab_XX[i][j] = (i) * (i) + (j) * (j);
+			m_Tab_Sqrt[i][j] = sqrt(m_Tab_XX[i][j]);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Rotation
+ *  Description:  Rotation the Degree 
+ *
+ *		old
+ *                x' = x*cos0 - y*sin0
+ *                y' = x*sin0 + y*cos0
+ *
+ *              new
+ *                x' = x*cos0 + y*sin0
+ *                y' = y*cos0 - x*sin0 
+ *
+ * =====================================================================================
+ */
+void Algorithm::Rotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo)
+{
+	xo = static_cast<ETDATA>( y * m_Sin[deg] + x * m_Cos[deg] );
+	yo = static_cast<ETDATA>( y * m_Cos[deg] - x * m_Sin[deg] );
+}
+void Algorithm::MyRotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo)
+{
+	xo = static_cast<ETDATA>( -y * m_Sin[deg] + x * m_Cos[deg]);
+	yo = static_cast<ETDATA>(  y * m_Cos[deg] + x * m_Sin[deg]);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Digital_Filter_Value
+ *  Description:  Init the data struct used for digital filter 
+ * =====================================================================================
+ */
+void Algorithm::Init_Digital_Filter_Value( int count )
+{
+	for 	( int i=0;i<count;i++ )
+	{
+		DFilter *dfbuf = new DFilter;
+		m_DFBuffer.push_back(dfbuf);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_Digital_Filter_Value
+ *  Description:  Release the Digital filter value 
+ * =====================================================================================
+ */
+void Algorithm::Release_Digital_Fileter_Value()
+{
+	int length = m_DFBuffer.size();
+
+	for ( int i=0;i<length;i++ )
+	{
+		delete m_DFBuffer[i];
+	}
+
+	m_DFBuffer.clear();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_MAX_Value
+ *  Description:  When chang the signal channel call this function init the parameters 
+ *  Note:
+ *                sigchan: Which signal need to be digital filter
+ *                value:   from 0 to 7 
+ * =====================================================================================
+ */
+void Algorithm::Reset_MAX_Value(unsigned char sigchan,int value)
+{
+	m_DFBuffer[sigchan]->Reset_MAX_Value(value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Digital_Filter_Value
+ *  Description:  Calculate the Digital Filter Value of device
+ * =====================================================================================
+ */
+void Algorithm::Calculate_Digital_Filter_Value(unsigned char sigchan,ETDATA& x,ETDATA& y)
+{
+	m_DFBuffer[sigchan]->Calculate_Digital_Filter_Value(x,y);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_K_b_Value
+ *  Description:  For getting K and b value for one function 
+ * =====================================================================================
+ */
+void Algorithm::Get_K_b_Value(int x1,int y1,int x2,int y2,double &k,double &b)
+{
+	k = static_cast<double>(( y1 - y2 )) / static_cast<double>(( x1 - x2 ));
+	b = y2 - k * x2;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  IRCP
+ *  Description:  Calculate the quadratic function coefficient 
+ *  Input X[]  Y[] at least 2 points
+ *  Output 
+ *  y = A[0] + A[1] * x + A[2] * x * x
+ * =====================================================================================
+ */
+void Algorithm::PCIR(double * x, double * y, int n,double * a, int m )
+{
+    int i,j,k;
+    double z,p,c,g,q=0,d1,d2,s[20],t[20],b[20];
+    double ta[20],XX;
+    double dt[3]; dt[0]=0.0; dt[1]=0.0; dt[2]=0.0;
+
+    for (i=0; i<=m-1; i++)
+    {
+	a[i]=0.0;
+	ta[i]=0.0;
+    }
+    XX=0.0;
+    for (i=0; i<=n-1; i++)
+    {
+	XX +=x[i];
+    }
+    XX=XX/n;
+
+    if (m>n) m=n;
+    if (m>20) m=20;
+    z=0.0;
+    for (i=0; i<=n-1; i++) z=z+x[i]/(1.0*n);
+    b[0]=1.0; d1=1.0*n; p=0.0; c=0.0;
+    for (i=0; i<=n-1; i++)
+      { p=p+(x[i]-z); c=c+y[i];}
+    c=c/d1; p=p/d1;
+    a[0]=c*b[0];
+    if (m>1)
+      { t[1]=1.0; t[0]=-p;
+	d2=0.0; c=0.0; g=0.0;
+	for (i=0; i<=n-1; i++)
+	  { q=x[i]-z-p; d2=d2+q*q;
+	    c=c+y[i]*q;
+	    g=g+(x[i]-z)*q*q;
+	  }
+	c=c/d2; p=g/d2; q=d2/d1;
+	d1=d2;
+	a[1]=c*t[1]; a[0]=c*t[0]+a[0];
+      }
+    for (j=2; j<=m-1; j++)
+      { s[j]=t[j-1];
+	s[j-1]=-p*t[j-1]+t[j-2];
+	if (j>=3)
+	  for (k=j-2; k>=1; k--)
+	    s[k]=-p*t[k]+t[k-1]-q*b[k];
+	s[0]=-p*t[0]-q*b[0];
+	d2=0.0; c=0.0; g=0.0;
+	for (i=0; i<=n-1; i++)
+	  { q=s[j];
+	    for (k=j-1; k>=0; k--)
+	      q=q*(x[i]-z)+s[k];
+	    d2=d2+q*q; c=c+y[i]*q;
+	    g=g+(x[i]-z)*q*q;
+	  }
+	c=c/d2; p=g/d2; q=d2/d1;
+	d1=d2;
+	a[j]=c*s[j]; t[j]=s[j];
+	for (k=j-1; k>=0; k--)
+	  { a[k]=c*s[k]+a[k];
+	    b[k]=t[k]; t[k]=s[k];
+	  }
+      }
+
+
+    for (i=0; i<=n-1; i++)
+      { q=a[m-1];
+	for (k=m-2; k>=0; k--)
+	  q=a[k]+q*(x[i]-z);
+	p=q-y[i];
+	if (fabs(p)>dt[2]) dt[2]=fabs(p);
+	dt[0]=dt[0]+p*p;
+	dt[1]=dt[1]+fabs(p);
+      }
+
+    /* to convert the (X-XX) to X */
+    ta[0] = a[0]-a[1]*XX + a[2]*XX*XX;
+    ta[1] = a[1] - 2*a[2]*XX;
+    ta[2] = a[2];
+
+    /*return the recount value*/
+    a[0] = ta[0];
+    a[1] = ta[1];
+    a[2] = ta[2];
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Approx
+ *  Description:  New Algorithm 
+ *            m:  Points Count 
+ *            n:  Times such   2 3 4
+ *          n=2:  a0+a1*x+a2*x*x 
+ *          n=3:  a0+a1*x+a2*x*x+a3*x*x*x 
+ * =====================================================================================
+ */
+void Algorithm::Approx(double *x,double *y,int m,int n,double* coe)
+{
+	double *c,*a;   
+	c = new double[((n+1)*(n+2)*sizeof(double))];   
+	for(int i=0;i<=n;i++)   
+	{
+		for ( int j=0;j<=n;j++)
+		{
+		    *(c+i*(n+2)+j)=0.0;
+		    for(int t=0;t<=m-1;t++)
+			*(c+i*(n+2)+j)+=power(i+j,x[t]);
+		}
+		*(c+i*(n+2)+n+1)=0.0;
+
+		for(int j=0;j<=m-1;j++)
+		    *(c+i*(n+2)+n+1)+=y[j]*power(i,x[j]);
+	}
+	a=ColPivot((double *)c,n+1);   
+	delete[] c;
+	c = NULL;
+
+	for ( int i=0;i<=n;i++ )
+	{
+		coe[i] = a[i];
+	}
+	delete[] a;
+	a = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  power
+ *  Description:  
+ * =====================================================================================
+ */
+double Algorithm::power(int i,double v)   
+{   
+       	double a=1.0;
+	while(i--)
+	a*=v;
+	return a;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ColPivot
+ *  Description:  
+ * =====================================================================================
+ */
+double *Algorithm::ColPivot(double *a,int n)   
+{   
+	int i,j,t,k;   
+	double *x,*c,p;   
+	x=new double[(n*sizeof(double))];   
+	c=new double[(n*(n+1)*sizeof(double))];   
+	for(i=0;i<=n-1;i++)   
+		for (j=0;j<=n;j++)   
+		    *(c+i*(n+1)+j)=(*(a+i*(n+1)+j));   
+	for(i=0;i<=n-2;i++)   
+	{   
+	k=i;   
+	for(j=i+1;j<=n-1;j++)   
+	    if(fabs(*(c+j*(n+1)+i))>(fabs(*(c+k*(n+1)+i))))   
+		k=j;   
+	    if(k!=j)   
+		for(j=i;j<=n;j++)   
+		{   
+		    p=*(c+i*(n+1)+j);   
+		    *(c+i*(n+1)+j)=*(c+k*(n+1)+j);   
+		    *(c+k*(n+1)+j)=p;   
+		}   
+	    for(j=i+1;j<=n-1;j++)   
+	    {   
+		p=(*(c+j*(n+1)+i))/(*(c+i*(n+1)+i));   
+		for(t=i;t<=n-1;t++)   
+		    *(c+j*(n+1)+t)=*(c+j*(n+1)+t)-p*(*(c+i*(n+1)+t));   
+		*(c+j*(n+1)+n)-=*(c+i*(n+1)+n)*p;   
+	    }   
+	}   
+	for( i=n-1;i>=0;i-- )   
+	{   
+		for( j=n-1;j>=i+1;j--)   
+		    (*(c+i*(n+1)+n))-=x[j]*(*(c+i*(n+1)+j));   
+		x[i]=*(c+i*(n+1)+n)/(*(c+i*(n+1)+i));   
+	}   
+	delete[] c;   
+	c = NULL;
+	return x;   
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  PolyFit
+ *函数功能：最小二乘法曲线拟合   
+ *使用方法：double *x ---- 存放n个数据点的X坐标   
+ *          double *y ---- 存放n个数据点的Y坐标   
+ *          int n -------- 给定数据点个数   
+ *          double *a ---- 返回m-1次拟合多项式的m个系数   
+ *          int m -------- 拟合多项式的项数，即拟合多项式的最高次为m-1。要求m=n,且   
+ *                         m=20。若m>n或m>20，则本函数自动按m=min{n,20}处理   
+ *          double *dt --- dt[0]返回拟合多项式与各数据点误差的平方和；dt[1]返回拟合多   
+ *                         项式与各数据点的误差绝对值之和；dt[2]返回拟合多项式与各数据   
+ *                         点误差绝对值的最大值   
+ *注意事项：拟合多项式的形式为 y = b0 + b1*(x-Xavr)...   
+ * =====================================================================================
+ */
+void Algorithm::PolyFit(double *x, double *y, int n, double *a, int m, double *dt)
+{
+	int i, j, k;   
+	double z, p, c, g, q, d1, d2, s[20], t[20], b[20];   
+	for (i = 0; i <= m-1; i++)   
+	{   
+		a[i] = 0.0;   
+	}   
+	if (m > n)   
+	{   
+		m = n;   
+	}   
+	if (m > 20)   
+	{   
+		m = 20;   
+	}   
+	z = 0.0;   
+	for (i = 0; i <= n-1; i++)   
+	{   
+		z = z+x[i]/(1.0 *n);   
+	}   
+	b[0] = 1.0;   
+	d1 = 1.0 * n;   
+	p = 0.0;   
+	c = 0.0;   
+	for (i = 0; i <= n-1; i++)   
+	{   
+		p = p+(x[i]-z);   
+		c = c+y[i];   
+	}   
+	c = c/d1;   
+	p = p/d1;   
+	a[0] = c * b[0];   
+	if (m > 1)   
+	{   
+		t[1] = 1.0;   
+		t[0] = -p;   
+		d2 = 0.0;   
+		c = 0.0;   
+		g = 0.0;   
+		for (i = 0; i <= n-1; i++)   
+		{   
+			q = x[i]-z-p;   
+			d2 = d2+q * q;   
+			c = c+y[i] *q;   
+			g = g+(x[i]-z) *q * q;   
+		}   
+		c = c/d2;   
+		p = g/d2;   
+		q = d2/d1;   
+		d1 = d2;   
+		a[1] = c * t[1];   
+		a[0] = c * t[0]+a[0];   
+	}   
+	for (j = 2; j <= m-1; j++)   
+	{   
+		s[j] = t[j-1];   
+		s[j-1] = -p * t[j-1]+t[j-2];   
+		if (j >= 3)   
+			for (k = j-2; k >= 1; k--)   
+			{   
+				s[k] = -p * t[k]+t[k-1]-q * b[k];   
+			}   
+		s[0] = -p * t[0]-q * b[0];   
+		d2 = 0.0;   
+		c = 0.0;   
+		g = 0.0;   
+		for (i = 0; i <= n-1; i++)   
+		{   
+			q = s[j];   
+			for (k = j-1; k >= 0; k--)   
+			{   
+				q = q *(x[i]-z)+s[k];   
+			}   
+			d2 = d2+q * q;   
+			c = c+y[i] *q;   
+			g = g+(x[i]-z) *q * q;   
+		}   
+		c = c/d2;   
+		p = g/d2;   
+		q = d2/d1;   
+		d1 = d2;   
+		a[j] = c * s[j];   
+		t[j] = s[j];   
+		for (k = j-1; k >= 0; k--)   
+		{   
+			a[k] = c * s[k]+a[k];   
+			b[k] = t[k];   
+			t[k] = s[k];   
+		}   
+	}   
+	dt[0] = 0.0;   
+	dt[1] = 0.0;   
+	dt[2] = 0.0;   
+	for (i = 0; i <= n-1; i++)   
+	{   
+		q = a[m-1];   
+		for (k = m-2; k >= 0; k--)   
+		{   
+			q = a[k]+q *(x[i]-z);   
+		}   
+		p = q-y[i];   
+		if (fabs(p) > dt[2])   
+		{   
+			dt[2] = fabs(p);   
+		}   
+		dt[0] = dt[0]+p * p;   
+		dt[1] = dt[1]+fabs(p);   
+	}   
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  MDelay
+ *  Description:  Delay ms milliseconds 
+ * =====================================================================================
+ */
+void Algorithm::MDelay(int ms)
+{
+	struct timeval tpStart, tpEnd;
+	float timeUse;
+	gettimeofday(&tpStart, NULL);
+	do 
+	{
+		gettimeofday(&tpEnd, NULL);
+		timeUse = 1000 * (tpEnd.tv_sec - tpStart.tv_sec) + (tpEnd.tv_usec - tpStart.tv_usec)/1000;
+	} while(timeUse < ms);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Alpha_Color
+ *  Description:  Alpha Color calculate,only called in Alpha parameters exist
+ * =====================================================================================
+ */
+int Algorithm::Alpha_Color(int r,int g,int b,int alph,short bkcolor)
+{
+	int nr    = r;
+	int ng    = g;
+	int nb    = b;
+	int alpha = alph;
+
+	int oldr  = (( bkcolor >> 11 ) & 0x1f)<<3;
+	int oldg  = (( bkcolor >> 5 ) & 0x3f)<<2;
+	int oldb  = (( bkcolor ) & 0x1f)<<3;
+
+	nr        = (((nr - oldr)*alpha)>>8) + oldr;
+	ng        = (((ng - oldg)*alpha)>>8) + oldg;
+	nb        = (((nb - oldb)*alpha)>>8) + oldb;
+
+	return ( nr << 16 ) + ( ng << 8 ) + nb;
+}
+int Algorithm::Alpha_Color(short fgcolor,int alph,short bkcolor)
+{
+	int nr    = (( fgcolor >> 11 ) & 0x1f)<<3;
+	int ng    = (( fgcolor >> 5) & 0x3f)<<2;
+	int nb    = (( fgcolor ) & 0x1f)<<3;
+	int alpha = alph;
+
+	int oldr  = (( bkcolor >> 11 ) & 0x1f)<<3;
+	int oldg  = (( bkcolor >> 5 ) & 0x3f)<<2;
+	int oldb  = (( bkcolor ) & 0x1f)<<3;
+
+	nr        = (((nr - oldr)*alpha)>>8) + oldr;
+	ng        = (((ng - oldg)*alpha)>>8) + oldg;
+	nb        = (((nb - oldb)*alpha)>>8) + oldb;
+
+	return ( nr << 16 ) + ( ng << 8 ) + nb;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_SX_SY
+ *  Description:  Calculate the X Gain and Y Gain 
+ * =====================================================================================
+ */
+void Algorithm::Calculate_SX_SY(const int& x1,const int& y1,
+				const int& x2,const int& y2,
+				double& sx,double& sy)
+{
+//	double k1 = y1 / x1;
+//	double k2 = y2 / x2;
+//
+//	sx = sqrt( ( 1 + k2 * k2 ) / ( 1 + k1 * k1 ) );
+//	sy = sx * ( ( static_cast<double>(y1) * static_cast<double>(x2) ) / ( static_cast<double>(x1) * static_cast<double>(y2) ) );
+
+//	sx = static_cast<double>(abs(x1)) / static_cast<double>(abs(x2));
+//	sy = static_cast<double>(abs(y1)) / static_cast<double>(abs(y2));
+
+	sx = sqrt((static_cast<double>(x1)*x1+static_cast<double>(y1)*y1)/(static_cast<double>(x2)*x2+static_cast<double>(y2)*y2));
+	sy = sx;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Angle
+ *  Description:  
+ * =====================================================================================
+ */
+int Algorithm::Calculate_Angle(const int& x,const int& y)
+{
+	if 	( x == 0 )
+	{
+		if ( y > 0 )
+			return 90;
+		else 
+			return 270;
+	}
+	else if ( y == 0 )
+	{
+		if ( x > 0 )
+			return 180;
+		else 
+			return 0;
+	}
+	else 
+	{
+		if 	( x < 0 && y > 0 )
+			return 180 * atan(static_cast<double>(abs(y))/abs(x)) / M_PI;
+		else if ( x < 0 && y < 0 )
+			return 180 * atan(static_cast<double>(abs(x))/abs(y)) / M_PI + 270;
+		else if ( x > 0 && y > 0 )
+			return 180 * atan(static_cast<double>(abs(x))/abs(y)) / M_PI + 90;
+		else if ( x > 0 && y < 0 )
+			return 180 * atan(static_cast<double>(abs(y))/abs(x)) / M_PI + 180;
+	}
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Gain_Ratio
+ *  Description:  Calculate the Gain Ratio 
+ * =====================================================================================
+ */
+void Algorithm::Calculate_Gain_Ratio(int value)
+{
+	m_fGainPercent = static_cast<double>(value) / 10;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Polynomial_Fitting
+ *  Description:  Calculate the Polynomial factor 
+ *        terms:  ex.: x^4 + x^3 + x^2   
+ *                terms: 4
+ *          coe:  coe[0]x^4 + coe[1]x^3 + coe[2]x^2 + coe[3]x^1 + coe[4]x^0
+ * =====================================================================================
+ */
+bool Algorithm::Polynomial_Fitting(double* x0,double* y0,int datalen,int terms,double* coe)
+{
+	if 	( datalen <= terms )
+	{
+		printf("at least datalen more than %d \n",terms);
+		return false;
+	}
+
+	double chisq;
+	gsl_matrix *X,*cov;
+	gsl_vector *y,*w,*c;
+	int n = datalen;
+
+	X = gsl_matrix_alloc(n,terms+1);
+	y = gsl_vector_alloc(n);
+	w = gsl_vector_alloc(n);
+	c = gsl_vector_alloc(terms+1);
+	cov = gsl_matrix_alloc(terms+1,terms+1);
+
+	for ( int i=0;i<n;i++ )
+	{
+		for ( int j=0;j<=terms;j++ )
+		{
+			gsl_matrix_set(X,i,j,gsl_pow_int(x0[i],j));
+		}
+
+		gsl_vector_set(y,i,y0[i]);
+		gsl_vector_set(w,i,1);
+	}
+
+	gsl_multifit_linear_workspace *work = gsl_multifit_linear_alloc(n,terms+1);
+	gsl_multifit_wlinear(X,w,y,c,cov,&chisq,work);
+
+	for ( int i=0;i<=terms;i++ )
+	{
+		coe[terms-i] = gsl_vector_get(c,i);
+	}
+
+	for ( int i=0;i<terms;i++ )
+	{
+		std::cout<<coe[i]<<"*"<<"X^"<<terms-i<<"+";
+	}
+	std::cout<<coe[terms]<<std::endl;
+
+	gsl_multifit_linear_free(work);
+
+	gsl_matrix_free(cov);
+	gsl_vector_free(c);
+	gsl_vector_free(w);
+	gsl_vector_free(y);
+	gsl_matrix_free(X);
+
+	return true;
+}
diff --git a/src/EVA11/base/Algorithm.h b/src/EVA11/base/Algorithm.h
new file mode 100644
index 0000000..2ce6074
--- /dev/null
+++ b/src/EVA11/base/Algorithm.h
@@ -0,0 +1,115 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Algorithm.h
+ *
+ *    Description:  The class create for special mathmatic algorithm
+ *
+ *        Version:  1.0
+ *        Created:  2010年03月26日 19时07分26秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef _ALGORITHM_H
+#define _ALGORITHM_H
+
+#include 	<memory>
+#include 	<vector>
+
+#include 	"main.h" 
+
+class DFilter;
+class Algorithm
+{
+	public:
+		/* ====================  LIFECYCLE     ======================================= */
+		static Algorithm* Instance();
+
+		void MDelay(int ms);
+		/*-----------------------------------------------------------------------------
+		 *  About Get degree Sin Cos Tan value
+		 *-----------------------------------------------------------------------------*/
+		inline double Get_Sin_Value(int degree) { return m_Sin[degree]; }
+		inline double Get_Cos_Value(int degree) { return m_Cos[degree]; }
+		inline double Get_Tan_Value(int degree) { return m_Tan[degree]; }
+		inline double Get_XX_Value(int v1,int v2) { return m_Tab_XX[v1][v2]; }
+		inline double Get_Sqrt_Value(int v1,int v2) { return m_Tab_Sqrt[v1][v2]; }
+		/*-----------------------------------------------------------------------------
+		 *  ET Data Process function 
+		 *-----------------------------------------------------------------------------*/
+		void Rotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo);
+		void MyRotation(int deg,const double& x,const double& y,ETDATA& xo,ETDATA& yo);
+		/*-----------------------------------------------------------------------------
+		 *  Digital filter used  
+		 *-----------------------------------------------------------------------------*/
+		void Reset_MAX_Value(unsigned char sigchan,int value);
+		void Calculate_Digital_Filter_Value(unsigned char sigchan,ETDATA& x,ETDATA& y);
+		/*-----------------------------------------------------------------------------
+		 *  For getting K and b value for one function 
+		 *-----------------------------------------------------------------------------*/
+		void Get_K_b_Value(int x1,int y1,int x2,int y2,double &k,double &b);
+		inline double Get_Rate(int x,int y,int centx,int centy) { 
+			return static_cast<double>(centy-y) / static_cast<double>(centx-x);
+		}
+		/*-----------------------------------------------------------------------------
+		 *  New Special Mix Frequence Algorithm 
+		 *-----------------------------------------------------------------------------*/
+		void PCIR(double * x, double * y, int n,double * a, int m );
+		/*-----------------------------------------------------------------------------
+		 *  New Calculate Algorithm 
+		 *-----------------------------------------------------------------------------*/
+		void Approx(double *x,double *y,int m,int n,double* coe);
+		double power(int i,double v);
+ 		double *ColPivot(double *a,int n);
+
+		void PolyFit(double *x, double *y, int n, double *a, int m, double *dt);
+
+		int Alpha_Color(int r,int g,int b,int alph,short bkcolor);
+		int Alpha_Color(short fgcolor,int alpha,short bkcolor);
+
+		void Calculate_SX_SY(const int& x1,const int& y1,
+				     const int& x2,const int& y2,
+				     double& sx,double& sy);
+		int Calculate_Angle(const int& x,const int& y);
+		void Calculate_Gain_Ratio(int);
+
+		inline double Gain_Ratio(double yvalue){ return yvalue * m_fGainPercent; }
+
+		bool Polynomial_Fitting(double* x,double* y,int datalen,int terms,double* c);
+	protected:
+	private:
+		Algorithm ();
+		~Algorithm ();
+		Algorithm (const Algorithm&);
+		Algorithm& operator = (const Algorithm&);
+
+		void Init_SinCosTan_Table_Value();
+		void Init_SQRT_Table_Value();
+
+		void Init_Digital_Filter_Value(int count);
+		void Release_Digital_Fileter_Value();
+	private:
+		friend class std::auto_ptr<Algorithm>;
+		static std::auto_ptr<Algorithm>		m_Instance;
+
+		static const int MAXTABLELONG = 210;
+		static const int MAXDFCHANG   = 32; 
+		/*-----------------------------------------------------------------------------
+		*  Sin Cos function values array
+		*-----------------------------------------------------------------------------  */
+		double m_Cos[360];                                                              /* previously calculate                             */
+		double m_Sin[360];
+		double m_Tan[180];
+		double m_Tab_Sqrt[MAXTABLELONG][MAXTABLELONG];                                  /* The Tables of sqr(A*2 + B*2) for scale calculate */
+		double m_Tab_XX[MAXTABLELONG][MAXTABLELONG];                                    /* The Tables of A*2 + B*2 for scale calculate      */
+		double m_fGainPercent;
+
+		std::vector<DFilter *> m_DFBuffer;                                              /* Only used for Digital Filter                     */
+}; /* -----  end of class Algorithm  ----- */
+#endif
diff --git a/src/EVA11/base/AnalyzeView.cpp b/src/EVA11/base/AnalyzeView.cpp
new file mode 100644
index 0000000..25dda93
--- /dev/null
+++ b/src/EVA11/base/AnalyzeView.cpp
@@ -0,0 +1,151 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AnalyzeView.cpp
+ *
+ *    Description:  Implementation of AnalyzeView class
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月20日 08时59分44秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+
+#include 	"Language.h"
+#include 	"Algorithm.h"
+
+#include 	"IView.h"
+#include	"DetectView.h"
+#include 	"AnalyzeView.h"
+
+#include 	"FreeType.h"
+
+AnalyzeView::AnalyzeView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+}
+
+AnalyzeView::~AnalyzeView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view
+ * =====================================================================================
+ */
+void AnalyzeView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  
+ * =====================================================================================
+ */
+void AnalyzeView::Release_View() 
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  
+ * =====================================================================================
+ */
+int  AnalyzeView::Loop_View(Graphic& g)
+{
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_DetectView_Object
+ *  Description:  For Alarm view draw GUI on screen 
+ * =====================================================================================
+ */
+void AnalyzeView::Load_View_Object(IView* obj)
+{
+	m_DetectView = dynamic_cast<DetectView *>(obj);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Swtich_View
+ *  Description:  when chang the view called it
+ * =====================================================================================
+ */
+void AnalyzeView::Switch_View()
+{
+	if ( m_DetectView != NULL )
+		m_DetectView->Switch_View();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI Object 
+ * =====================================================================================
+ */
+void AnalyzeView::Init_GUI(Graphic& g)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void AnalyzeView::Destroy_GUI()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the Videw GUI object 
+ * =====================================================================================
+ */
+void AnalyzeView::Drawme (Graphic& g)
+{
+	if ( m_DetectView != NULL )
+		m_DetectView->Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void AnalyzeView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
diff --git a/src/EVA11/base/AnalyzeView.h b/src/EVA11/base/AnalyzeView.h
new file mode 100644
index 0000000..1d44f54
--- /dev/null
+++ b/src/EVA11/base/AnalyzeView.h
@@ -0,0 +1,48 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  AnalyzeView.h
+ *
+ *    Description: Analyze function
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月20日 08时57分16秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ANALYZEVIEW_INC
+#define  _ANALYZEVIEW_INC
+
+class IView;
+class DetectView;
+class AnalyzeView : public IView
+{
+	public:
+		AnalyzeView (int x,int y,int width,int heigh);
+		~AnalyzeView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View() 	;
+		virtual int  Loop_View(Graphic&);
+		virtual void Drawme (Graphic&)  ;
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		void Load_View_Object(IView* obj);
+		void Switch_View();
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		DetectView*		m_DetectView;
+	private:
+
+};
+
+#endif   /* ----- #ifndef _ANALYZEVIEW_INC  ----- */
diff --git a/src/EVA11/base/BasePanel.cpp b/src/EVA11/base/BasePanel.cpp
new file mode 100644
index 0000000..fded375
--- /dev/null
+++ b/src/EVA11/base/BasePanel.cpp
@@ -0,0 +1,38 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  BasePanel.cpp
+ *
+ *    Description:  implementation of BasePanel
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 14时54分50秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Global.h"
+#include 	"Graphic.h"
+#include 	"Object.h"
+#include 	"BasePanel.h"
+
+BasePanel::BasePanel (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_gp = Global::Instance();
+	
+	m_RawBuf = new(std::nothrow) ETDATA[Global::CHANCOUNT<<1];
+}
+
+BasePanel::~BasePanel ()
+{
+	delete[] m_RawBuf;
+	m_RawBuf = NULL;
+}
+
+void BasePanel::Switch_Panel(){;}
diff --git a/src/EVA11/base/BasePanel.h b/src/EVA11/base/BasePanel.h
new file mode 100644
index 0000000..c118b48
--- /dev/null
+++ b/src/EVA11/base/BasePanel.h
@@ -0,0 +1,47 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  BasePanel.h
+ *
+ *    Description:  Base class of all kinds of panels
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 14时52分09秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _BASEPANEL_INC
+#define  _BASEPANEL_INC
+
+class Object;
+class Graphic;
+class Global;
+
+#include 	"main.h"
+#include 	"KFInterface.h"
+class BasePanel : public Object , public BaseKFInterface , public DetectKFInterface , public AlarmKFInterface , public ParaKFInterface
+{
+	public:
+		BasePanel (int x,int y,int width,int heigh);
+		virtual ~BasePanel ();
+
+		virtual void Init_GUI(Graphic& g)   	  	      = 0;
+		virtual void Destroy_GUI() 	    	  	      = 0;
+		virtual void Drawme(Graphic& g,bool flag=true) 	      = 0;
+		virtual int  Loop_Panel(Graphic& g) 	  	      = 0;
+		virtual void Show_Help_System(Graphic& g,int x,int y) = 0;
+
+		virtual void Switch_Panel();
+
+	protected:
+		Global					*m_gp;
+		ETDATA					*m_RawBuf;
+	private:
+};
+#endif
diff --git a/src/EVA11/base/Basescreen.cpp b/src/EVA11/base/Basescreen.cpp
new file mode 100644
index 0000000..baa2f25
--- /dev/null
+++ b/src/EVA11/base/Basescreen.cpp
@@ -0,0 +1,286 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Basescreen.cpp
+ *
+ *    Description:  implementation of Basescreen class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 13时12分12秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdlib>
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Basescreen.h"
+
+Basescreen::Basescreen (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_Msg        = new char[100];
+
+	m_Ch         = 0;
+	m_Focus      = false;
+}
+
+Basescreen::~Basescreen ()
+{
+	delete[] m_Msg;
+	m_Msg 	     = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Color
+ *  Description:  Set the color of Zscreen object 
+ * =====================================================================================
+ */
+void Basescreen::Set_Color(LABCOLOR ct,short color)
+{
+	switch ( ct ) 
+	{
+		case LA_FG_COLOR: 
+			m_FGColor = color;
+			break;
+
+		case LA_BG_COLOR: 
+			m_BGColor = color;
+			break;
+
+		case LA_GRID_COLOR: 
+			m_GRIDColor = color;
+			break;
+
+		case LA_POINT_COLOR:
+			m_PointColor = color;
+			break;
+
+		case LA_FOCUS_COLOR:
+			m_FocusColor = color;
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawGrid
+ *  Description:  Draw the grid of screen 
+ * =====================================================================================
+ */
+void Basescreen::DrawGrid(Graphic &g)
+{
+	int i,j;
+	j=0;
+	while(m_Center_X+LineSpace*j<m_Right)
+	{
+		i=0; 
+		while(m_Center_Y+SmallSpace*i<m_Down)
+		{
+			g.Setpixel(m_Center_X+LineSpace*j,m_Center_Y+SmallSpace*i,m_GRIDColor);	
+			i++;
+		}
+		i=0; 
+		while(m_Center_Y-SmallSpace*i>m_Up)
+		{
+			g.Setpixel(m_Center_X+LineSpace*j,m_Center_Y-SmallSpace*i,m_GRIDColor);	
+			i++;
+		}
+		j++;
+	}
+	j=0;
+	while(m_Center_X-LineSpace*j>m_Left)
+	{
+		i=0; 
+		while(m_Center_Y+SmallSpace*i<m_Down)
+		{
+			g.Setpixel(m_Center_X-LineSpace*j,m_Center_Y+SmallSpace*i,m_GRIDColor);	
+			i++;
+		}
+		i=0; 
+		while(m_Center_Y-SmallSpace*i>m_Up)
+		{
+			g.Setpixel(m_Center_X-LineSpace*j,m_Center_Y-SmallSpace*i,m_GRIDColor);	
+			i++;
+		}
+		j++;
+	}
+
+	j=0;
+	while(m_Center_Y+LineSpace*j<m_Down)
+	{
+		i=0; 
+		while(m_Center_X+SmallSpace*i<m_Right)
+		{
+			g.Setpixel(m_Center_X+SmallSpace*i,m_Center_Y+LineSpace*j,m_GRIDColor);	
+			i++;
+		}
+		i=0; 
+		while(m_Center_X-SmallSpace*i>m_Left)
+		{
+			g.Setpixel(m_Center_X-SmallSpace*i,m_Center_Y+LineSpace*j,m_GRIDColor);	
+			i++;
+		}
+		j++;
+	}
+	j=0;
+	while(m_Center_Y-LineSpace*j>m_Up)
+	{
+		i=0; 
+		while(m_Center_X+SmallSpace*i<m_Right)
+		{
+			g.Setpixel(m_Center_X+SmallSpace*i,m_Center_Y-LineSpace*j,m_GRIDColor);	
+			i++;
+		}
+		i=0; 
+		while(m_Center_X-SmallSpace*i>m_Left)
+		{
+			g.Setpixel(m_Center_X-SmallSpace*i,m_Center_Y-LineSpace*j,m_GRIDColor);	
+			i++;
+		}
+		j++;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  draw_xish_line_arrange
+ *  Description:  Draw line on ZKScreen depending on the x y
+ * =====================================================================================
+ */
+void Basescreen::draw_xish_line_arrange(Graphic &g,int x,int y,int dx,int dy,int xdir,short ncolor)
+{
+	int dyX2=dy+dy;
+	int dyX2mdxX2=dyX2-(dx+dx);
+	int error=dyX2-dx;
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+	{
+		g.Setpixel(x, y, ncolor);
+	}
+	while (dx--) 
+	{
+		if (error >= 0) 
+		{
+			y++;
+			error += dyX2mdxX2;
+		} 
+		else 
+		{
+			error += dyX2;
+		}
+		x += xdir;
+		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+		{
+			g.Setpixel(x, y, ncolor);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  draw_yish_line_arrange
+ *  Description:  Draw line on screen depending on y direct
+ * =====================================================================================
+ */
+void Basescreen::draw_yish_line_arrange(Graphic &g,int x,int y,int dx,int dy,int xdir,short ncolor)
+{
+	int dxX2=(dx<<1) ;
+	int dxX2mdyX2=dxX2-(dy<<1);
+	int error=dxX2-dy;
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+	{
+		g.Setpixel(x, y, ncolor);
+	}
+	while (dy--) 
+	{
+		if (error >= 0) 
+		{
+			x+= xdir;
+			error += dxX2mdyX2;
+		} else 
+		{
+			error += dxX2;
+		}
+		y++;
+		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+		{
+			g.Setpixel(x, y, ncolor);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Line_In_Arrange
+ *  Description:  Draw line in screen arrange
+ * =====================================================================================
+ */
+void Basescreen::Draw_Line_In_Arrange(Graphic &g,int x1,int y1,int x2,int y2,short color)
+{
+	int dx,dy;
+	if ( y1 > y2) 
+	{
+		int t = y1;
+		y1 = y2;
+		y2 = t;
+		t = x1;
+		x1 = x2;
+		x2 = t;
+	}
+	dx = x2-x1;
+	dy = y2-y1;
+	if (dx > 0) 
+	{
+		if (dx > dy)
+			draw_xish_line_arrange(g,x1, y1, dx, dy, 1,color);
+		else
+			draw_yish_line_arrange(g,x1, y1, dx, dy, 1,color);
+	} 
+	else 
+	{
+		dx = -dx;
+		if (dx > dy)
+			draw_xish_line_arrange(g,x1, y1, dx, dy, -1,color);
+		else
+			draw_yish_line_arrange(g,x1, y1, dx, dy, -1,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on screen 
+ * =====================================================================================
+ */
+void Basescreen::Drawme(Graphic &g,bool bufflag )
+{
+	if ( bufflag == true )
+		g.Switch_Screen();
+	Refreshme(g);
+	if ( bufflag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Setpixel_In_Arrange
+ *  Description:  Setpixel on screen 
+ * =====================================================================================
+ */
+void Basescreen::Setpixel_In_Arrange(Graphic& g,int x,int y)
+{
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+	{
+		g.Setpixel(x, y, m_FGColor);
+	}
+}
diff --git a/src/EVA11/base/Basescreen.h b/src/EVA11/base/Basescreen.h
new file mode 100644
index 0000000..2ae0f8e
--- /dev/null
+++ b/src/EVA11/base/Basescreen.h
@@ -0,0 +1,77 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Basescreen.h
+ *
+ *    Description:  Mange the Basescreen class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 13时09分47秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _BASESCREEN_INC
+#define  _BASESCREEN_INC
+
+class Graphic;
+class Basescreen : public Object
+{
+	public:
+		enum LABCOLOR
+		{
+			LA_FG_COLOR,
+			LA_BG_COLOR,
+			LA_GRID_COLOR,
+			LA_POINT_COLOR,
+			LA_FOCUS_COLOR,
+		};
+		typedef enum LABCOLOR LABCOLOR;
+
+		Basescreen (int x,int y,int width,int heigh);
+		~Basescreen ();
+
+		void Drawme(Graphic &g,bool bufflag = true);
+		void Set_Color(LABCOLOR ct,short color);
+
+		virtual void Refreshme(Graphic &g) = 0;
+	protected:
+		void DrawGrid(Graphic &g);
+
+		void Setpixel_In_Arrange(Graphic& g,int x,int y);
+		void Draw_Line_In_Arrange(Graphic &g,
+				          int x1,int y1,
+				          int x2,int y2,
+					  short color
+					 );
+		void draw_xish_line_arrange(Graphic &g,
+				            int x,int y,
+					    int dx,int dy,
+					    int xdir,short ncolor
+					   );
+		void draw_yish_line_arrange(Graphic &g,
+				            int x,int y,
+					    int dx,int dy,
+					    int xdir,short ncolor
+					   );
+	protected:
+		static const int			SmallSpace  =  3;
+		static const int			LineSpace   =  33;
+		int					m_Ch;
+
+		short               			m_FGColor;		
+		short               			m_BGColor;		
+		short                   		m_GRIDColor;		
+		short                   		m_PointColor;
+		short                   		m_FocusColor;
+
+		char					*m_Msg;
+		bool					m_Focus;
+
+}; /* -----  end of class Basescreen  ----- */
+#endif   /* ----- #ifndef _BASESCREEN_INC  ----- */
diff --git a/src/EVA11/base/Basewin.cpp b/src/EVA11/base/Basewin.cpp
new file mode 100644
index 0000000..47d9634
--- /dev/null
+++ b/src/EVA11/base/Basewin.cpp
@@ -0,0 +1,414 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Basewin.cpp
+ *
+ *    Description:  implementation of Basewin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月28日 10时29分06秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<new>
+
+#include 	<SDL.h>
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include	"Logic.h"
+#include	"Global.h"
+#include	"Language.h"
+#include 	"Device.h"
+#include 	"Battery.h"
+#include 	"Graphic.h"
+#include 	"Algorithm.h"
+#include	"Msgbox.h"
+#include 	"Basewin.h"
+#include 	"DataRepo.h"
+#include 	"ColorObj.h"
+
+Basewin::Basewin ()
+{
+	m_lo          = Logic::Instance();
+	m_gp          = Global::Instance();
+	m_pl          = Language::Instance();
+	m_device      = Device::Instance();
+	m_alg         = Algorithm::Instance();
+	m_repo	      = DataRepo::Instance();
+
+	m_Msg         = new(std::nothrow) char[100];
+	m_BottomFocus = 1;
+
+	m_MAXGetkeyTimes
+		      = 128;
+	m_GetKeyTimes = m_MAXGetkeyTimes;
+}  /* -----  end of method Basewin::Basewin  (constructor)  ----- */
+
+Basewin::~Basewin ()
+{
+	if 	( m_Msg != NULL )
+	{
+		delete[] m_Msg;
+		m_Msg = NULL;
+	}
+}  /* -----  end of method Basewin::Basewin  (destructor)  ----- */
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Command_Process
+ *       return:  0: goto Exit;
+ *                1: Cancel nothing happend
+ * =====================================================================================
+ */
+int Basewin::Command_Process(Graphic& g)
+{
+	m_Battery->Set_Value(g,*m_lo);
+
+	m_GetKeyTimes --;
+	if ( m_GetKeyTimes == 0 )
+		m_GetKeyTimes = m_MAXGetkeyTimes;
+	else
+		return CO_NONE;
+
+	switch ( m_lo->Get_Key() )
+	{
+		case KEY_F1:
+			return Key_F1_Fun(g);
+			break;
+
+		case KEY_F2:
+			return Key_F2_Fun(g);
+			break;
+
+		case KEY_F3:
+			return Key_F3_Fun(g);
+			break;
+
+		case KEY_F4:
+			return Key_F4_Fun(g);
+			break;
+
+		case KEY_F5:
+			return Key_F5_Fun(g);
+			break;
+
+		case KEY_F6:
+			return Key_F6_Fun(g);
+			break;
+
+		case KEY_F7:
+			return Key_F7_Fun(g);
+			break;
+
+		case KEY_BOTTOM1:
+			return Key_Bom1_Fun(g);
+			break;
+
+		case KEY_BOTTOM2:
+			return Key_Bom2_Fun(g);
+			break;
+
+		case KEY_BOTTOM3:
+			return Key_Bom3_Fun(g);
+			break;
+
+		case KEY_BOTTOM4:
+			return Key_Bom4_Fun(g);
+			break;
+
+		case KEY_BOTTOM5:
+			return Key_Bom5_Fun(g);
+			break;
+
+		case KEY_BOTTOM6:
+			return Key_Bom6_Fun(g);
+			break;
+
+		case KEY_BOTTOM7:
+			return Key_Bom7_Fun(g);
+			break;
+
+		case KEY_FUN1L:
+			return Key_NL1_Fun(g);
+			break;
+		case KEY_FUN1R:
+			return Key_NR1_Fun(g);
+			break;
+
+		case KEY_FUN2L:
+			return Key_NL2_Fun(g);
+			break;
+		case KEY_FUN2R:
+			return Key_NR2_Fun(g);
+			break;
+
+		case KEY_FUN3L:
+			return Key_NL3_Fun(g);
+			break;
+		case KEY_FUN3R:
+			return Key_NR3_Fun(g);
+			break;
+
+		case KEY_FUN4L:
+			return Key_NL4_Fun(g);
+			break;
+		case KEY_FUN4R:
+			return Key_NR4_Fun(g);
+			break;
+
+		case KEY_FUN5L:
+			return Key_NL5_Fun(g);
+			break;
+		case KEY_FUN5R:
+			return Key_NR5_Fun(g);
+			break;
+
+		case KEY_FUN6L:
+			return Key_NL6_Fun(g);
+			break;
+		case KEY_FUN6R:
+			return Key_NR6_Fun(g);
+			break;
+
+		case KEY_ENTER:
+			return Key_Enter_Fun(g);
+			break;
+
+		case KEY_ESC:
+			return Key_Esc_Fun(g);
+			break;
+	}				/* -----  end switch  ----- */
+
+	return CO_NONE;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void Basewin::Init_GUI(Graphic& g)
+{
+	ColorObj* colorobj = ColorObj::Instance();
+
+	m_Battery  = new Battery(2,445,15,32);
+	m_Battery->Set_Battery_Type(Battery::BAT_V);
+	m_Battery->Set_Battery_Handle(m_lo->Get_ADC_Handle());
+
+	m_BomSmall = new Label(18+7*85,445,25,33);
+	m_BomSmall->Set_Text("1");
+	m_BomSmall->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	m_BomSmall->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_BomSmall->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	m_BomSmall->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+
+	m_BomSmall->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
+	m_BomSmall->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
+	m_BomSmall->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
+	m_BomSmall->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
+	m_BomSmall->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
+	m_BomSmall->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
+
+	m_BomSmall->Set_Focus(false);
+	m_BomSmall->Set_Font_Size(25);
+	m_BomSmall->Set_Radius(10);
+	m_BomSmall->Set_Display_Type(Label::LA_DT_CENTER);
+	m_BomSmall->Set_Label_Type(Label::LA_QUAT);
+
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i] = new Label(18+i*85,445,84,33);
+		m_BomButton[i]->Set_Text(" ");
+
+		if 	( m_gp->Language == 1 )
+			m_BomButton[i]->Set_Font_Size(16);
+		else if ( m_gp->Language == 0 )
+			m_BomButton[i]->Set_Font_Size(25);
+
+		if 	( i == m_BottomFocus - 1 )
+			m_BomButton[i]->Set_Focus(true);
+		else
+			m_BomButton[i]->Set_Focus(false); 
+
+		m_BomButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_BomButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_BomButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_BomButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+
+		m_BomButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
+		m_BomButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
+		m_BomButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
+		m_BomButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
+		m_BomButton[i]->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
+		m_BomButton[i]->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
+
+		m_BomButton[i]->Set_Label_Type(Label::LA_HALFROUND);
+		m_BomButton[i]->Set_Display_Type(Label::LA_DT_CENTER);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void Basewin::Destroy_GUI()
+{
+	if 	( m_Battery != NULL )
+	{
+		delete m_Battery;
+		m_Battery = NULL;
+	}
+	if 	( m_BomSmall != NULL )
+	{
+		delete m_BomSmall;
+		m_BomSmall = NULL;
+	}
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		if 	( m_BomButton[i] != NULL )
+		{
+			delete m_BomButton[i];
+			m_BomButton[i] = NULL;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void Basewin::Drawme(Graphic& g)
+{
+	g.Clearscreen();
+	g.DrawFillRect(0,0,640,480,g.RGB24_16(0x00000000));
+	g.Setcolor(g_MAINFG_CO);
+	g.Rectangle(0,0,639,479);
+	m_Battery->Drawme(g);
+	m_Battery->Set_Value(g,*m_lo);
+	m_BomSmall->Drawme(g);
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+		m_BomButton[i]->Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  Switch the bottom focus status 
+ * =====================================================================================
+ */
+void Basewin::DrawBottomFocus(Graphic& g,int index)
+{
+	if 	( index != m_BottomFocus )
+	{
+		m_BomButton[m_BottomFocus-1]->Set_Focus(false);
+		m_BomButton[m_BottomFocus-1]->Drawme(g);
+		m_BomButton[index-1]->Set_Focus(true);
+		m_BomButton[index-1]->Drawme(g);
+		m_BottomFocus = index;
+	}
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Screen_Into_Memory
+ *  Description:  Save screen from graphic buffer into memory 
+ * =====================================================================================
+ */
+void Basewin::Save_Screen_Into_Memory(Graphic& g)
+{
+	m_Gmem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
+	g.Load_Disp_Area(0,0,639,479,m_Gmem);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restore_Screen_From_Memory
+ *  Description:  
+ * =====================================================================================
+ */
+void Basewin::Restore_Screen_From_Memory(Graphic& g)
+{
+	g.Restore_Disp_Area(0,0,639,479,m_Gmem);   			/* restore the graphic buffer */
+	delete[] m_Gmem;                           			/* release the buffer */
+	m_Gmem = NULL;
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Password_Confirm
+ *  Description:  Need enter password to confirm nect excute 
+ * =====================================================================================
+ */
+int Basewin::Password_Confirm(Graphic &g)
+{
+	int result = 0;
+	PasswdMsgbox *ms;
+	if 	( m_gp->Language == 0 )
+		ms = new PasswdMsgbox(180,170,300,120,m_pl->GetText(INFO_PASSWORD));	
+	else if ( m_gp->Language == 1 )
+		ms = new PasswdMsgbox(140,170,400,120,m_pl->GetText(INFO_PASSWORD));	
+
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+
+	if 	( ms->Showme(g) == true )
+		result = 1;
+	else
+	{
+		if 	( ms->Get_Status() == PasswdMsgbox::PWCANCEL )
+			result = 2;
+	}
+	delete ms;
+	ms = NULL;
+	return result;
+}
+
+int Basewin::Key_Enter_Fun(Graphic& g){ return 0; }
+int Basewin::Key_Esc_Fun(Graphic& g){return 0;} 
+
+int Basewin::Key_F1_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F2_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F3_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F4_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F5_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F6_Fun(Graphic& g){return 0;} 
+int Basewin::Key_F7_Fun(Graphic& g){return 0;} 
+
+int Basewin::Key_Bom1_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom2_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom3_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom4_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom5_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom6_Fun(Graphic& g){return 0;}
+int Basewin::Key_Bom7_Fun(Graphic& g){return 0;}
+
+int Basewin::Key_NL1_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR1_Fun(Graphic& g){return 0;}
+int Basewin::Key_NL2_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR2_Fun(Graphic& g){return 0;}
+int Basewin::Key_NL3_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR3_Fun(Graphic& g){return 0;}
+int Basewin::Key_NL4_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR4_Fun(Graphic& g){return 0;}
+int Basewin::Key_NL5_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR5_Fun(Graphic& g){return 0;}
+int Basewin::Key_NL6_Fun(Graphic& g){return 0;}
+int Basewin::Key_NR6_Fun(Graphic& g){return 0;}
diff --git a/src/EVA11/base/Basewin.h b/src/EVA11/base/Basewin.h
new file mode 100644
index 0000000..62b77fc
--- /dev/null
+++ b/src/EVA11/base/Basewin.h
@@ -0,0 +1,117 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Basewin.h
+ *
+ *    Description:  Just a interface of all win class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月28日 10时25分45秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _BASEWIN_INC
+#define  _BASEWIN_INC
+
+class Graphic;
+class Battery;
+class Language;
+class Global;
+class Logic;
+class Device;
+class Algorithm;
+class DataRepo;
+class Label;
+
+class Basewin
+{
+	public:
+		Basewin ();                             /* constructor */
+		virtual ~Basewin ();                    /* destructor  */
+
+		int Command_Process(Graphic& g);
+
+		typedef enum 
+		{
+			CO_CANCEL   = 0,
+			CO_OK       = 1,
+			CO_EXIT     = 2,
+			CO_LOADEXIT = 3,
+			CO_NONE     = 999
+		} COMMAND;				/* ----------  end of enum COMMAND  ---------- */
+	protected:
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g);
+		virtual void DrawBottomFocus(Graphic& g,int index);
+
+		virtual int Key_Enter_Fun(Graphic& g); 
+		virtual int Key_Esc_Fun(Graphic& g); 
+
+		virtual int Key_F1_Fun(Graphic& g); 
+		virtual int Key_F2_Fun(Graphic& g); 
+		virtual int Key_F3_Fun(Graphic& g); 
+		virtual int Key_F4_Fun(Graphic& g); 
+		virtual int Key_F5_Fun(Graphic& g); 
+		virtual int Key_F6_Fun(Graphic& g); 
+		virtual int Key_F7_Fun(Graphic& g); 
+
+		virtual int Key_Bom1_Fun(Graphic& g);
+		virtual int Key_Bom2_Fun(Graphic& g);
+		virtual int Key_Bom3_Fun(Graphic& g);
+		virtual int Key_Bom4_Fun(Graphic& g);
+		virtual int Key_Bom5_Fun(Graphic& g);
+		virtual int Key_Bom6_Fun(Graphic& g);
+		virtual int Key_Bom7_Fun(Graphic& g);
+
+		virtual int Key_NL1_Fun(Graphic& g);
+		virtual int Key_NR1_Fun(Graphic& g);
+		virtual int Key_NL2_Fun(Graphic& g);
+		virtual int Key_NR2_Fun(Graphic& g);
+		virtual int Key_NL3_Fun(Graphic& g);
+		virtual int Key_NR3_Fun(Graphic& g);
+		virtual int Key_NL4_Fun(Graphic& g);
+		virtual int Key_NR4_Fun(Graphic& g);
+		virtual int Key_NL5_Fun(Graphic& g);
+		virtual int Key_NR5_Fun(Graphic& g);
+		virtual int Key_NL6_Fun(Graphic& g);
+		virtual int Key_NR6_Fun(Graphic& g);
+
+		void Save_Screen_Into_Memory(Graphic& g);
+		void Restore_Screen_From_Memory(Graphic& g);
+
+		int Password_Confirm(Graphic &g);
+
+		inline void Set_MAX_Get_Key_Interval(int value) { m_MAXGetkeyTimes = value; m_GetKeyTimes = m_MAXGetkeyTimes; }
+	protected:
+		static const int  		     MAXBOMCOUNT   = 7;
+		int               		     m_BottomFocus;
+
+		unsigned int			     m_MAXGetkeyTimes;
+		unsigned int			     m_GetKeyTimes;
+
+		char				     *m_Msg;
+
+		Logic				     *m_lo;
+		Language			     *m_pl; 
+		Global				     *m_gp;
+		Device				     *m_device;
+		Algorithm			     *m_alg;
+		DataRepo			     *m_repo;
+
+		Battery          		     *m_Battery;
+		Label                                *m_BomSmall;
+		Label				     *m_BomButton[MAXBOMCOUNT];
+
+	private:
+
+		unsigned char 			     *m_Gmem;
+
+}; /* -----  end of class Basewin  ----- */
+#endif   /* ----- #ifndef _BASEWIN_INC  ----- */
diff --git a/src/EVA11/base/Battery.cpp b/src/EVA11/base/Battery.cpp
new file mode 100644
index 0000000..416d5ee
--- /dev/null
+++ b/src/EVA11/base/Battery.cpp
@@ -0,0 +1,315 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Battery.cpp
+ *
+ *    Description:  The class Battery file
+ *
+ *        Version:  1.0
+ *        Created:  2009年11月27日 15时11分42秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Battery.h"
+#include 	"Msgbox.h"
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Logic.h"
+
+#define MAXTIMES 50
+
+Battery::Battery (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_Focus        = false;
+	m_Battery_Type = BAT_V;
+
+	m_BGFO_Color   = g_MAINBG_CO;
+	m_BGNO_Color   = g_MAINBG_CO;
+
+	m_FGNO_Color   = g_BATTARY_CO;
+	m_FGFO_Color   = g_BATTARY_CO;
+
+	m_MAXValue     = 6;
+	m_CurrentValue = 6;            /* 0~6 */
+	m_Times        = MAXTIMES;
+	m_Disp_Already = false;
+	
+	m_ADC_fd       = 0;
+	m_Sample_Counts= 100;
+}
+ 
+Battery::~Battery ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Battery_Type
+ *  Description:  Set the Battery Type 
+ * =====================================================================================
+ */
+void Battery::Set_Battery_Type(BATTERYTYPE type)
+{
+	m_Battery_Type = type; 
+}
+ 
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the Battery interface
+ * =====================================================================================
+ */
+void Battery::Drawme(Graphic &g)
+{
+	int cent_x = m_X + ( m_Width>>1 );
+	int cent_y = m_Y + ( m_Heigh>>1 );
+	short txcolor,bgcolor;
+	short hicolor,locolor;
+
+	if ( m_Focus == true )
+	{
+		txcolor = m_FGFO_Color;
+		bgcolor = m_BGFO_Color;
+		hicolor = g_LIGHT_CO;
+		locolor = g_SHADOW_CO;
+	}
+	else
+	{
+		txcolor = m_FGNO_Color;
+		bgcolor = m_BGNO_Color;
+		hicolor = g_SHADOW_CO;
+		locolor = g_LIGHT_CO;
+	}
+
+	g.Switch_Screen();
+
+	if ( m_Battery_Type == BAT_V )
+	{
+		short sc = g.Getcolor();
+		g.Setcolor(g_MAINBG_CO);
+		g.DrawFillRect(m_X,m_Y,m_Width+1,m_Heigh);
+		g.Setcolor(txcolor);
+		g.DrawRect(m_X,m_Y+5,m_Width,m_Heigh-5);
+		g.Setcolor(sc);
+		g.DrawFillRect(cent_x-(m_Width>>2),m_Y+1,m_Width>>1,5,txcolor);
+		g.DrawFillRect(cent_x-(m_Width>>2)-2,m_Y+3,(m_Width>>1)+4,3,txcolor);
+
+		for ( int i=0;i<m_CurrentValue;i++ )
+		{
+			g.DrawFillRect(cent_x-(m_Width>>2)-2,m_Y+27-4*i,(m_Width>>1)+4,4,txcolor);
+		}
+	}
+	else if ( m_Battery_Type == BAT_H )
+	{
+		short sc = g.Getcolor();
+		g.Setcolor(g_MAINBG_CO);
+		g.DrawFillRect(m_X,m_Y,m_Width+1,m_Heigh+1);
+		g.Setcolor(txcolor);
+		g.DrawRect(m_X,m_Y,m_Width-5,m_Heigh);
+		g.Setcolor(sc);
+
+		g.DrawFillRect(m_X+m_Width-2-1,cent_y-(m_Heigh>>2),5,m_Heigh>>1,txcolor);
+		g.DrawFillRect(m_X+m_Width-2-3,cent_y-(m_Heigh>>2)-2,3,(m_Heigh>>1)+4,txcolor);
+
+		for ( int i=0;i<m_CurrentValue;i++ )
+		{
+			g.DrawFillRect(m_X+m_Width-3-27+4*i,cent_y-(m_Heigh>>2)-2,4,(m_Heigh>>1)+4,txcolor);
+		}
+	}
+
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Value
+ *  Description:  Set the battery value and showing message
+ *  		  Dynamic Version
+ * =====================================================================================
+ */
+void Battery::Set_Value(Graphic& g,Logic& lo)
+{
+	m_Sample_Counts --;
+	if ( m_Sample_Counts == 0 )
+	{
+		m_Sample_Counts = 100;
+	}
+	else
+		return;
+
+	int value = Get_Battary_Value();
+
+	if 	( value != m_CurrentValue )
+	{
+		m_CurrentValue = value;
+
+		Drawme(g);	
+		if      ( value == 0 && m_Disp_Already == false )
+		{
+			Language* pl = Language::Instance(); 
+			Msgbox *ms = new Msgbox(200,170,260,80,pl->GetText(INFORMESG08),Msgbox::MSG_AUTO);	
+			ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+			ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+			ms->Showme(g);
+			delete ms;
+			ms = NULL;
+			m_Disp_Already = true;
+		}
+	}
+
+	if 	( value == 0 && m_Disp_Already == true )
+	{
+		if 	( Get_Auto_Shutdown_Flag() == true )
+		{
+			lo.Shutdown();
+		}
+	}
+	else if ( value > 2 && m_Disp_Already == true ) /* Means re-insert power plugin */
+	{
+		m_Disp_Already = false;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Battery_Handle
+ *  Description:  Set the Battery Handle 
+ * =====================================================================================
+ */
+void Battery::Set_Battery_Handle(int handle)
+{
+#ifdef X86
+	m_Last_Adc = 0x370;
+#else
+	m_ADC_fd = handle;
+	if ( m_ADC_fd != 0 )
+	{
+		ssize_t r = read(m_ADC_fd,&m_Last_Adc,2);
+		r = r;
+	}
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Battery_Value
+ *  Description:  Get the Battery Value 
+ * =====================================================================================
+ */
+int  Battery::Get_Battary_Value()
+{
+#ifdef X86
+	return 6;
+#else
+	unsigned short adc_value;	
+
+	size_t re = read(m_ADC_fd,&adc_value,2);
+	re = re;
+
+	m_Last_Adc = ( ( ( adc_value - m_Last_Adc ) << 3 ) >> 8 ) + m_Last_Adc;
+
+	adc_value = m_Last_Adc;
+
+#ifdef ARM9
+	switch ( adc_value ) 
+	{
+		case 0x370 ... 0xfff: 
+			return 6;
+			break;
+
+		case 0x355 ... 0x36f: 
+			return 5;
+			break;
+
+		case 0x341 ... 0x354: 
+			return 4;
+			break;
+
+		case 0x330 ... 0x340: 
+			return 3;
+			break;
+
+		case 0x325 ... 0x32f: 
+			return 2;
+			break;
+
+		case 0x315 ... 0x324: 
+			return 1;
+			break;
+
+		case 0 ... 0x314:
+			return 0;
+			break;
+
+		default:	
+			return m_CurrentValue;
+			break;
+	}				/* -----  end switch  ----- */
+#endif
+
+#ifdef ARM11
+	switch ( adc_value )
+	{
+		case 0x328 ... 0xfff: 
+			return 6;
+			break;
+
+		case 0x307 ... 0x327: 
+			return 5;
+			break;
+
+		case 0x2f8 ... 0x306: 
+			return 4;
+			break;
+
+		case 0x2ee ... 0x2f7: 
+			return 3;
+			break;
+
+		case 0x2e1 ... 0x2ed: 
+			return 2;
+			break;
+
+		case 0x2b1 ... 0x2e0: 
+			return 1;
+			break;
+
+		case 0 ... 0x2b0:
+			return 0;
+			break;
+
+		default:	
+			return m_CurrentValue;
+			break;
+	}				/* -----  end switch  ----- */
+#endif
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Auto_Shutdown_Flag
+ *  Description:  If need auto shutdown device return true 
+ * =====================================================================================
+ */
+bool Battery::Get_Auto_Shutdown_Flag()
+{
+#ifdef X86
+	return true;
+#else
+	unsigned short adc_value;	
+	size_t re = read(m_ADC_fd,&adc_value,2);
+	re = re;
+	if ( adc_value <= 0x285 ) return true;
+	else return false;
+#endif
+}
diff --git a/src/EVA11/base/Battery.h b/src/EVA11/base/Battery.h
new file mode 100644
index 0000000..207b0f9
--- /dev/null
+++ b/src/EVA11/base/Battery.h
@@ -0,0 +1,71 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Battery.h
+ *
+ *    Description:  THe head file for Battery class 
+ *
+ *        Version:  1.0
+ *        Created:  2009年12月29日 16时13分38秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _BATTERY_INC
+#define  _BATTERY_INC
+
+class Logic;
+class Graphic; 
+class Object;
+
+class Battery  : public Object
+{
+	public:
+		enum BATTERYTYPE 
+		{
+			BAT_V,
+			BAT_H,
+		};				/* ----------  end of enum BATTERYTYPE  ---------- */
+		typedef enum BATTERYTYPE BATTERYTYPE;
+
+		Battery (int x,int y,int width,int heigh); /* constructor Init with Graphic class */
+		~Battery ();
+		void Drawme(Graphic &g);                   /* Draw the Battery surface  	*/
+		void Set_Battery_Handle(int);		   /* Get the handle of Battery(adc)    */
+		void Set_Value(Graphic &g,Logic& lo);      /* Set the value 			*/
+		void Set_Battery_Type(BATTERYTYPE);
+		bool Get_Auto_Shutdown_Flag();
+		int  Get_Battary_Value();
+		bool m_Focus;                              /* Whether the Battery is focus 	*/
+	protected:
+	private:
+
+		/*-----------------------------------------------------------------------------
+		 *  position of Battery
+		 *-----------------------------------------------------------------------------*/
+		int          m_FontType;       		 /* The big or small of the font type */
+
+		int          m_MAXValue;
+		int          m_CurrentValue;
+		unsigned int m_Times;
+
+		short        m_BGFO_Color;
+		short        m_FGFO_Color;
+		short        m_BGNO_Color;
+		short        m_FGNO_Color;
+
+		BATTERYTYPE  m_Battery_Type;
+
+		bool         m_Disp_Already;
+
+		int	     				m_ADC_fd;
+		unsigned short                          m_Last_Adc;
+		int	     m_Sample_Counts;
+}; /* -----  end of class Battery  ----- */
+#endif   /* ----- #ifndef _BATTERY_INC  ----- */
+
diff --git a/src/EVA11/base/Bufferbar.cpp b/src/EVA11/base/Bufferbar.cpp
new file mode 100644
index 0000000..fcf490a
--- /dev/null
+++ b/src/EVA11/base/Bufferbar.cpp
@@ -0,0 +1,145 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Bufferbar.cpp
+ *
+ *    Description:  Implementation of Bufferbar class
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月01日 15时39分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	"Object.h"
+#include 	"Bufferbar.h"
+#include 	"Graphic.h"
+
+Bufferbar::Bufferbar (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+}
+
+Bufferbar::~Bufferbar ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on screen 
+ * =====================================================================================
+ */
+void Bufferbar::Drawme(Graphic &g,uint64_t len,bool bufflag)
+{
+	if 	( bufflag == true )
+		g.Switch_Screen();
+	Refreshme(g);
+	if 	( bufflag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Bufferbar::Refreshme(Graphic &g)
+{
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BG_Color);
+	g.DrawFillRect(m_X+1,m_Y+1,m_X+1+m_Buffer_Index,m_Heigh-3+2,m_FG_Color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Color
+ *  Description:  Set the Color of GUI object 
+ * =====================================================================================
+ */
+void Bufferbar::Set_Color(BUFCOLOR ct,short color)
+{
+	switch ( ct )
+	{
+		case BUF_FG_COLOR:
+			m_FG_Color = color;
+			break;
+		case BUF_BG_COLOR:
+			m_BG_Color = color;
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Buffer_Bar
+ *  Description:  Init the buffer bar GUI object 
+ *     len Unit:  Bytes
+ * =====================================================================================
+ */
+void Bufferbar::Init_Buffer_Bar(Graphic& g,uint64_t len)
+{
+	m_Length 		= len;
+	m_One_Step_Bytes	= len / ( m_Width - 2 );
+	m_Remain_Bytes		= len - m_One_Step_Bytes * ( m_Width - 2 );
+
+	m_Current_Bytes 	= 0;
+	m_Buffer_Index          = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Uint
+ *  Description:  Draw the unit on screen 
+ * =====================================================================================
+ */
+void Bufferbar::Draw_Unit(Graphic& g)
+{
+	for ( int32_t i=0;i<m_Heigh-2;i++ )
+	{
+		g.Setpixel(m_X+1+m_Buffer_Index,m_Y+1+i,m_FG_Color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Bytes_Number
+ *  Description:  Set the bytes count into buffer 
+ * =====================================================================================
+ */
+void Bufferbar::Save_Bytes_Number(Graphic& g,uint32_t count)
+{
+	m_Current_Bytes += count;
+	if 	( m_Current_Bytes >= m_One_Step_Bytes )
+	{
+		m_Current_Bytes -= m_One_Step_Bytes;
+		if 	( m_Buffer_Index < m_Width - 4 )
+		{
+			m_Buffer_Index ++;
+			Draw_Unit(g);
+		}
+		else if ( m_Buffer_Index == m_Width - 4 )
+		{
+			Draw_Unit(g);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_Buffer_Bar
+ *  Description:  Call this function to clean buffer bar
+ * =====================================================================================
+ */
+void Bufferbar::Clean_Buffer_Bar(Graphic& g)
+{
+	Init_Buffer_Bar(g,m_Length);
+	Drawme(g,true);
+}
diff --git a/src/EVA11/base/Bufferbar.h b/src/EVA11/base/Bufferbar.h
new file mode 100644
index 0000000..75c3753
--- /dev/null
+++ b/src/EVA11/base/Bufferbar.h
@@ -0,0 +1,58 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Bufferbar.h
+ *
+ *    Description:  Indicate the Buffer count 
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月01日 15时35分25秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _BUFFERBAR_INC
+#define  _BUFFERBAR_INC
+
+#include 	<stdint.h>
+class Graphic;
+class Object;
+class Bufferbar : public Object
+{
+	public:
+		enum BUFCOLOR 
+		{
+			BUF_FG_COLOR,
+			BUF_BG_COLOR,
+		};
+		typedef enum BUFCOLOR BUFCOLOR;
+		Bufferbar (int x,int y,int width,int height);
+		~Bufferbar ();
+
+		void Drawme(Graphic &g,uint64_t len = 0,bool bufflag = true);
+		void Set_Color(BUFCOLOR ct,short color);
+		void Init_Buffer_Bar(Graphic& g,uint64_t len);
+		void Save_Bytes_Number(Graphic& g,uint32_t count);
+		void Draw_Unit(Graphic& g);
+		void Clean_Buffer_Bar(Graphic& g);
+	protected:
+
+	private:
+		void Refreshme(Graphic &g);
+	private:
+		short			m_BG_Color;
+		short			m_FG_Color;
+
+		uint64_t 		m_Length;
+		uint32_t		m_One_Step_Bytes;
+		uint32_t		m_Remain_Bytes;
+		uint32_t		m_Current_Bytes;
+		int32_t			m_Buffer_Index;
+};
+
+#endif
diff --git a/src/EVA11/base/CZKPanel.cpp b/src/EVA11/base/CZKPanel.cpp
new file mode 100644
index 0000000..71bba52
--- /dev/null
+++ b/src/EVA11/base/CZKPanel.cpp
@@ -0,0 +1,815 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  CZKPanel.cpp
+ *
+ *    Description:  implementation of CZKPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2013年05月06日 16时01分28秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"BasePanel.h"
+#include 	"DZKPanel.h"
+#include 	"CZKPanel.h"
+
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+#include 	"Graphic.h"
+#include 	"Language.h"
+#include 	"Global.h"
+#include 	"Bufferbar.h"
+#include 	"Device.h"
+#include 	"DataRepo.h"
+#include 	"Label.h"
+#include 	"Msgbox.h"
+#include 	"Chart.h"
+
+#include 	"AlarmManage.h"
+#include 	"Basescreen.h"
+#include 	"ZScreen.h"
+#include 	"Language.h"
+
+#include 	"Resource.h"
+
+const static  char* AlarmText[8] = {"A","B","C","D","E","F","G","H"};
+
+CZKPanel::CZKPanel (int x,int y,int width,int heigh)
+	: DZKPanel(x,y,width,heigh)
+{
+}
+
+CZKPanel::~CZKPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void CZKPanel::Init_GUI(Graphic& g)
+{
+	DZKPanel::Init_GUI(g);
+	m_gp->bCompositeSrcPause = false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void CZKPanel::Destroy_GUI()
+{
+	DZKPanel::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void CZKPanel::Drawme(Graphic& g,bool flag)
+{
+	DZKPanel::Drawme(g,flag);
+
+	for ( int i = 0; i < 2; i += 1 ) 
+	{
+		m_Chart[i]->Drawme(g,flag);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  important function, deal with data
+ * =====================================================================================
+ */
+int CZKPanel::Loop_Panel(Graphic& g)
+{
+	if 	( m_gp->bCompositeSrcPause == true )
+		return 0;
+
+	m_DataProcess->Data_Process();
+	m_DataProcess->Get_Data(m_RawBuf);
+
+	int x,y;
+	int result;
+	for ( int i=0;i<2;i++ )
+	{
+		m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[(m_gp->ScrSigM[i]<<1)],m_RawBuf[(m_gp->ScrSigM[i]<<1)+1]);
+		m_Zscreen[i]->Get_SX_SY(x,y);
+		result = m_AlarmManage[i]->Is_In_Alarm(x,y);
+		if (  result != 0xff )
+		{
+			if 	( result != m_LastStatus[i] )
+			{
+				m_LabAlarmSt[i]->Set_Text(AlarmText[result]);
+				m_LabAlarmSt[i]->Drawme(g);
+				m_LastStatus[i] = result;
+			}
+		}
+		else
+		{
+			if 	( result != m_LastStatus[i] )
+			{
+				m_LabAlarmSt[i]->Set_Text(" ");
+				m_LabAlarmSt[i]->Drawme(g);
+				m_LastStatus[i] = result;
+			}
+		}
+	}
+
+	for ( int i = 0; i < 2; i += 1 ) 
+		m_Chart[i]->Draw_AScan_Signal(g,m_RawBuf[4]);
+
+	m_Bufbar->Save_Bytes_Number(g,2<<2);
+
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_ZScreen_Object
+ *  Description:  Init the ZScreen GUI Object 
+ * =====================================================================================
+ */
+void CZKPanel::Init_ZScreen_Object(Graphic& g)
+{
+	Global *gp = Global::Instance();
+
+	m_DataProcess = new CZKDataProcess;
+
+	m_Zscreen[0] = new Zscreen(2,44,265,269);
+	m_Zscreen[1] = new Zscreen(2+265,44,265,269);
+
+	m_Zscreen[0]->Set_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
+	m_Zscreen[1]->Set_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_ID(i+1);
+
+		Refresh_ZKScreen_Focus(g,false);
+	}
+
+	m_Chart[0] = new Chart(2,313,530,65);
+	m_Chart[0]->Set_Coef(265);				   // we need switch other coe
+
+	m_Chart[1] = new Chart(2,378,530,65);
+	m_Chart[1]->Set_Coef(265);				   // we need switch other coe
+
+	m_AlarmManage[0] = new(std::nothrow) AlarmManage(2,44,265,269);
+	m_AlarmManage[1] = new(std::nothrow) AlarmManage(2+265,44,265,269);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_AlarmManage[i]->Init_Alarm_Sets(g);
+
+	gp->bCNeedResetAlarmArea = true;                    	   // Notice when init we need let OZK to load alarm para
+	Load_Alarm_Para();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_ZScreen_Object
+ *  Description:  Destroy the ZScreen GUI Object
+ * =====================================================================================
+ */
+void CZKPanel::Destroy_ZScreen_Object()
+{
+	if 	( m_DataProcess != NULL )
+	{
+		delete m_DataProcess;
+		m_DataProcess = NULL;
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		if ( m_Zscreen[i] != NULL )
+		{
+			delete m_Zscreen[i];
+			m_Zscreen[i] = NULL;
+		}
+
+		m_AlarmManage[i]->Destroy_Alarm_Sets();
+		if ( m_AlarmManage[i] != NULL )
+		{
+			delete m_AlarmManage[i];
+			m_AlarmManage[i] = NULL;
+		}
+	}
+
+	for ( int i = 0; i < 2; i += 1 ) 
+	{
+		delete m_Chart[i];
+		m_Chart[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Panel
+ *  Description:  Switch panel call this function 
+ * =====================================================================================
+ */
+void CZKPanel::Switch_Panel()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+
+	for ( int ch=0;ch<2;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 1;			// ECT
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+
+	for ( int ch=2;ch<4;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 3;			// EMS
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+
+	for ( int ch=4;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 0;		       // CLOSE
+		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	device->Write_Para_Driver(m_gp->Driver);
+	device->Write_Para_Offset(m_gp->Offset);
+	device->Write_Para_SignalWave(0);
+
+	device->Transfer_ECT_Parameters();
+
+	Load_Alarm_Para();
+
+	m_DataProcess->Trigger_Balacne_Process();       // very Important
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm Parameters from Global 
+ *                When Load Para from device call this function
+ * =====================================================================================
+ */
+void CZKPanel::Load_Alarm_Para()
+{
+	Global* gp = Global::Instance();
+	if ( gp->bCNeedResetAlarmArea == true )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_AlarmManage[i]->Set_Alarm_Type(gp->CAlarmType[i]);
+			for ( int j=0;j<3;j++ )
+			{
+				m_AlarmManage[i]->Set_Alarm_Count(j,gp->CAlarmCount[i][j]);
+				m_AlarmManage[i]->Set_Alarm_Index(j,gp->CAlarmIndex[i][j]);
+			}
+			m_AlarmManage[i]->Load_Alarm_Para(gp->CAlarmPara[i]);
+		}
+
+		m_AlarmManage[0]->Create_Alarm_Area_Mask();
+		m_AlarmManage[1]->Create_Alarm_Area_Mask();
+		gp->bCNeedResetAlarmArea = false;
+	}
+}
+
+int CZKPanel::Key_Enter_Fun(Graphic& g)
+{
+	m_gp->bCompositeSrcPause = false;
+	Do_Enter_Fun(g);
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
+/* --------------------------------------------------------------------- */
+int CZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->ScrSigFocus == 0 ) gp->ScrSigFocus = 1;
+		else gp->ScrSigFocus --;
+		Refresh_ZKScreen_Focus(g,true);
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 0 )
+				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]];
+			else
+				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] -= 1; 
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
+		}
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->ScrSigFocus == 1 ) gp->ScrSigFocus = 0;
+		else gp->ScrSigFocus ++;
+		Refresh_ZKScreen_Focus(g,true);
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 7 || 
+					gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] >= gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]])
+			{
+				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 0;
+			}
+			else
+				gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] += 1;
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
+		}
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 0  ) gp->CAlarmType[gp->ScrSigFocus] = 3;
+		else gp->CAlarmType[gp->ScrSigFocus] --;
+		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->CAlarmType[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 3  ) gp->CAlarmType[gp->ScrSigFocus] = 0;
+		else gp->CAlarmType[gp->ScrSigFocus] ++;
+		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->CAlarmType[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P1((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 0 )
+				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 7;
+			else
+			{
+				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] --;
+				if ( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] < gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] )
+				{
+					gp->CAlarmIndex[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]];
+				}
+			}
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
+		}
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->CAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] == 7 )
+				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] = 0;
+			else
+				gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]] ++;
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->CAlarmType[gp->ScrSigFocus],gp->CAlarmCount[gp->ScrSigFocus][gp->CAlarmType[gp->ScrSigFocus]]);
+		}
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P2((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P3((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P4((m_gp->MultiKey*2 + 1),gp->CAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bCNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int CZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+//	else if ( sub == 2 )
+//	{
+//		m_AlarmManage[0]->Test(g);
+//		m_AlarmManage[1]->Test(g);
+//	}
+	return 0;
+}
+int CZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+//	else if ( sub == 2 )
+//	{
+//		m_AlarmManage[0]->Test(g);
+//		m_AlarmManage[1]->Test(g);
+//	}
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_FX_Fun
+ *  Description:  Shot Functions 
+ * =====================================================================================
+ */
+int CZKPanel::Key_F2_Fun(Graphic& g)
+{
+	if 	( m_gp->bCompositeSrcPause == false )
+		Clean_ZKScreen(g);
+	else
+	{
+		Language *m_pl = Language::Instance();
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		if 	( ms->Showme(g) == true )
+		{
+			delete ms;
+			ms = NULL;
+			m_Zscreen[m_gp->ScrSigFocus]->Clean_Photo();
+			m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
+			return 0; 
+		}
+		delete ms;
+		ms = NULL;
+	}
+	return 0;
+}
+int CZKPanel::Key_F3_Fun(Graphic& g)
+{
+	if 	( m_gp->DrawMode2[m_gp->ScrSigFocus] == 0 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 1;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::LINE);
+	}
+	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus] == 1 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 2;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::AUTO);
+	}
+	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus]== 2 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 0;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::POINT);
+	}
+	m_Zscreen[m_gp->ScrSigFocus]->Reset_Trace();
+	return 0;
+}
+int CZKPanel::Key_F4_Fun(Graphic& g)
+{
+	if 	( m_gp->bCompositeSrcPause == false )
+		m_DataProcess->Trigger_Balacne_Process();
+	else
+	{
+		m_Zscreen[m_gp->ScrSigFocus]->Save_Photo(g);
+		m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
+	}
+	return 0;
+}
+int CZKPanel::Key_F6_Fun(Graphic& g)
+{
+//	Language* m_pl = Language::Instance();
+//	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
+//	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+//	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+//	if ( ms->Showme(g) == false )
+//	{
+//		delete ms;
+//		ms = NULL;
+//		return 0;
+//	}
+//	delete ms;
+//	ms = NULL;
+//	m_Bufbar->Clean_Buffer_Bar(g);
+	return 0;
+}
+
+int CZKPanel::Key_F7_Fun(Graphic& g)
+{
+//	int callen = 10000;
+//	if 	( m_gp->bCompositeSrcPause == false )
+//	{
+//		m_gp->bCompositeSrcPause = true;
+//		Swtich_Status(g);
+//		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+//		return 0;
+//	}
+//
+//	m_Zscreen[m_gp->ScrSigFocus]->Mixing_Parameters_Calculate(g,callen,100);
+//	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+//
+//	Language* m_pl = Language::Instance();
+//	MixingManage *algm = MixingManage::Instance();
+//	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(SAVEMIXCOMFIRM),Msgbox::MSG_OKCANCEL);
+//	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+//	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+//	ms->Set_Transparce(120);
+//	if ( ms->Showme(g) == true )
+//	{
+//		algm->Sync_Mixing_Para(true);
+//		delete ms;
+//		ms = NULL;
+//	}
+//	else
+//	{
+//		algm->Sync_Mixing_Para(false);
+//		delete ms;
+//		ms = NULL;
+//		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+//	}
+	return 0;
+}
+
+int CZKPanel::Para_NL1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::LEFT,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
+	}
+	return 0;
+}
+int CZKPanel::Para_NR1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
+	}
+	return 0;
+}
+int CZKPanel::Para_NL2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::UP,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
+	}
+	return 0;
+}
+int CZKPanel::Para_NR2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::DOWN,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->CompositeCentX1,m_gp->CompositeCentY1);
+	}
+	return 0;
+}
+int CZKPanel::Para_NL3_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::LEFT,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
+	}
+	return 0;
+}
+int CZKPanel::Para_NR3_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
+	}
+	return 0;
+}
+int CZKPanel::Para_NL4_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::UP,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
+	}
+	return 0;
+}
+int CZKPanel::Para_NR4_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::DOWN,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->CompositeCentX2,m_gp->CompositeCentY2);
+	}
+	return 0;
+}
+
+int CZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // gain        
+{
+	m_gp->bCompositeSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int CZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // gain        
+{
+	m_gp->bCompositeSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int CZKPanel::Key_NL4_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bCompositeSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+
+}
+int CZKPanel::Key_NR4_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bCompositeSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Status
+ *  Description:  When stop the signal switch the system status 
+ * =====================================================================================
+ */
+void CZKPanel::Swtich_Status(Graphic& g)
+{
+	if 	( m_gp->bCompositeSrcPause == true )
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,8,253,15);
+	}
+	else
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,9,253,15);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_ZKScreen_Focus
+ *  Description:  Refresh ZKScreen Focus status
+ * =====================================================================================
+ */
+void CZKPanel::Refresh_ZKScreen_Focus(Graphic&g,bool flag)
+{
+	for ( int i=0;i<2;i++ )
+	{
+		if ( i == m_gp->ScrSigFocus )
+			m_Zscreen[i]->Set_Focus(g,true,flag);
+		else
+			m_Zscreen[i]->Set_Focus(g,false,flag);
+	}
+}
diff --git a/src/EVA11/base/CZKPanel.h b/src/EVA11/base/CZKPanel.h
new file mode 100644
index 0000000..a4e9a19
--- /dev/null
+++ b/src/EVA11/base/CZKPanel.h
@@ -0,0 +1,82 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  CZKPanel.h
+ *
+ *    Description:  Declearation of CZKPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2013年05月06日 15时58分25秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  CZKPANEL_INC
+#define  CZKPANEL_INC
+
+class CZKDataProcess;
+class Chart;
+class CZKPanel : public DZKPanel
+{
+	public:
+		CZKPanel (int x,int y,int width,int heigh);
+		~CZKPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
+
+		virtual int Key_Enter_Fun(Graphic& g);
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+		virtual int Key_F7_Fun(Graphic& g);
+
+		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
+
+		virtual void Switch_Panel();
+		virtual void Swtich_Status(Graphic& g);
+	protected:
+		virtual void Init_ZScreen_Object(Graphic& g);
+		virtual void Destroy_ZScreen_Object();
+		virtual void Load_Alarm_Para();
+
+		void Refresh_ZKScreen_Focus(Graphic&g,bool flag);
+	private:
+		Chart					*m_Chart[2];
+		CZKDataProcess    			*m_DataProcess;
+};
+
+#endif   /* ----- #ifndef CZKPANEL_INC  ----- */
diff --git a/src/EVA11/base/CalculateCenter.cpp b/src/EVA11/base/CalculateCenter.cpp
new file mode 100644
index 0000000..7c84dac
--- /dev/null
+++ b/src/EVA11/base/CalculateCenter.cpp
@@ -0,0 +1,310 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  CalculateCenter.cpp
+ *
+ *    Description:  implementation of CalculateCenter class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月14日 09时23分59秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include        <math.h>
+#include 	<cstdlib>
+#include 	<cstdio>
+#include 	"CalculateCenter.h"
+
+struct CalculateCenter::PImpl
+{
+#ifdef ARM9
+	const double		m_cPI = 3.1415926;
+#endif
+
+#ifdef X86
+	static const double	m_cPI = 3.1415926;
+#endif
+	bool			m_bInitial;
+	int			m_MAX_X;
+	int			m_MAX_Y;
+	int			m_MIN_X;
+	int			m_MIN_Y;
+
+	int			m_Graphic_Center_X;
+	int			m_Graphic_Center_Y;
+
+	AMPBALL                 m_LMAXAMP;
+	AMPBALL                 m_RMAXAMP;
+	RLPOINT                 m_RL_Point;
+
+	long long		m_AMP;
+	long long		m_YAMP;
+	int			m_PHA;
+};
+
+CalculateCenter::CalculateCenter () : m_Imple(new struct PImpl)
+{
+}
+
+CalculateCenter::~CalculateCenter ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Object
+ *  Description:  Init the Object of CalculateCenter 
+ * =====================================================================================
+ */
+void CalculateCenter::Init_Object()
+{
+	m_Imple->m_bInitial           = false;
+
+	m_Imple->m_MAX_X              = 0;
+	m_Imple->m_MAX_Y              = 0;
+	m_Imple->m_MIN_X              = 0;
+	m_Imple->m_MIN_Y              = 0;
+	m_Imple->m_Graphic_Center_X   = 0;
+	m_Imple->m_Graphic_Center_Y   = 0;
+
+	m_Imple->m_LMAXAMP.X          = 0;
+	m_Imple->m_LMAXAMP.Y          = 0;
+	m_Imple->m_LMAXAMP.AMP        = 0;
+
+	m_Imple->m_RMAXAMP.X          = 0;
+	m_Imple->m_RMAXAMP.Y          = 0;
+	m_Imple->m_RMAXAMP.AMP        = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Graphic_MAX_MIN_Value
+ *  Description:  
+ * =====================================================================================
+ */
+void CalculateCenter::Calculate_Graphic_MAX_MIN_Value(short x,short y)
+{
+	if ( m_Imple->m_bInitial == false )
+	{
+		m_Imple->m_MAX_X = x; m_Imple->m_MIN_X = x;
+		m_Imple->m_MAX_Y = y; m_Imple->m_MIN_Y = y;
+		m_Imple->m_bInitial = true;
+		return;
+	}
+
+	if ( m_Imple->m_MAX_X < x )
+	{
+		m_Imple->m_MAX_X = x;
+	}
+	else 
+	{
+		if ( m_Imple->m_MIN_X > x ) 
+		{
+			m_Imple->m_MIN_X = x;
+		}
+	}
+
+	if ( m_Imple->m_MAX_Y < y )
+	{
+		m_Imple->m_MAX_Y = y;
+	}
+	else 
+	{
+		if ( m_Imple->m_MIN_Y > y ) 
+		{
+			m_Imple->m_MIN_Y = y;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Graphic_Center
+ *  Description:  Calculate the Graphic Center 
+ * =====================================================================================
+ */
+void CalculateCenter::Calculate_Graphic_Center()
+{
+	m_Imple->m_Graphic_Center_X = ( m_Imple->m_MIN_X + m_Imple->m_MAX_X ) >> 1;
+	m_Imple->m_Graphic_Center_Y = ( m_Imple->m_MIN_Y + m_Imple->m_MAX_Y ) >> 1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Record_MAXValue
+ *  Description:  Record the Left and Right MAX AMP value
+ * =====================================================================================
+ */
+void CalculateCenter::Record_MAXValue(short x,short y)
+{
+	double amp;
+	if ( x > m_Imple->m_Graphic_Center_X )                   /* Right */
+	{
+		amp = sqrt(abs(x-m_Imple->m_Graphic_Center_X) * abs(x-m_Imple->m_Graphic_Center_X) +
+			    abs(y-m_Imple->m_Graphic_Center_Y) * abs(y-m_Imple->m_Graphic_Center_Y));
+
+		if ( amp > m_Imple->m_RMAXAMP.AMP )
+		{
+			m_Imple->m_RMAXAMP.AMP = amp;
+			m_Imple->m_RMAXAMP.X = x; 
+			m_Imple->m_RMAXAMP.Y = y;
+			m_Imple->m_RL_Point = RLPOINT_R;
+		}
+	}
+	else                                             /* Left */
+	{
+		amp = sqrt(abs(x-m_Imple->m_Graphic_Center_X) * abs(x-m_Imple->m_Graphic_Center_X) +
+			    abs(y-m_Imple->m_Graphic_Center_Y) * abs(y-m_Imple->m_Graphic_Center_Y));
+		if ( amp > m_Imple->m_LMAXAMP.AMP )
+		{
+			m_Imple->m_LMAXAMP.AMP = amp;
+			m_Imple->m_LMAXAMP.X = x; 
+			m_Imple->m_LMAXAMP.Y = y;
+			m_Imple->m_RL_Point = RLPOINT_L;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_AMPBALL
+ *  Description:  Set the AMP points to Zero 
+ * =====================================================================================
+ */
+void CalculateCenter::Reset_AMPBALL()
+{
+	m_Imple->m_LMAXAMP.X   = 0;
+	m_Imple->m_LMAXAMP.Y   = 0;
+	m_Imple->m_LMAXAMP.AMP = 0;
+
+	m_Imple->m_RMAXAMP.X   = 0;
+	m_Imple->m_RMAXAMP.Y   = 0;
+	m_Imple->m_RMAXAMP.AMP = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_MAX_Point
+ *  Description:  Get the MAX ponit 
+ * =====================================================================================
+ */
+void CalculateCenter::Get_MAX_Point(int& rx,int& ry,int& lx,int& ly)
+{
+	rx = m_Imple->m_RMAXAMP.X;
+	ry = m_Imple->m_RMAXAMP.Y;
+
+	lx = m_Imple->m_LMAXAMP.X;
+	ly = m_Imple->m_LMAXAMP.Y;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_AMP_PHA
+ *  Description:  Calculate the AMP and PHA value in the digital surface
+ * =====================================================================================
+ */
+void CalculateCenter::Calculate_AMP_PHA()
+{
+	double dx 	= static_cast<double>(m_Imple->m_RMAXAMP.X) - static_cast<double>(m_Imple->m_LMAXAMP.X);
+	double dy 	= static_cast<double>(m_Imple->m_RMAXAMP.Y) - static_cast<double>(m_Imple->m_LMAXAMP.Y);
+	m_Imple->m_AMP  = static_cast<long long>(sqrt(dx*dx+dy*dy)); 
+	m_Imple->m_YAMP = static_cast<long long>(abs(m_Imple->m_RMAXAMP.Y-m_Imple->m_LMAXAMP.Y)); 
+	m_Imple->m_PHA  = static_cast<int>(180 * asin(static_cast<double>( m_Imple->m_YAMP ) / static_cast<double>(m_Imple->m_AMP)) / m_Imple->m_cPI);
+
+	/*-----------------------------------------------------------------------------
+	 *  4 kind situation                                   big  different from display coordicate
+	 *
+	 *  *               *        \           /
+	 *   \             /          \         /
+	 *    \           /            *       *
+	 *                                                     small
+	 *
+	 * In data coordicate    small 
+	 *                       big
+	 *-----------------------------------------------------------------------------*/
+
+	if ( m_Imple->m_RL_Point == RLPOINT_R )           /* Left point to Right */
+	{
+		if ( m_Imple->m_LMAXAMP.Y < m_Imple->m_RMAXAMP.Y ) /* Becare the compare must in hardware data arrange */
+		{
+			m_Imple->m_PHA += 180;
+		}
+		else
+		{
+			m_Imple->m_PHA = 180 - m_Imple->m_PHA;
+		}
+	}
+	else                                     /* Right point to Left */
+	{
+		if ( m_Imple->m_LMAXAMP.Y < m_Imple->m_RMAXAMP.Y )
+		{
+			m_Imple->m_PHA += 0;
+		}
+		else
+		{
+			m_Imple->m_PHA = 360 - m_Imple->m_PHA;
+		}
+	}
+
+	if 	( m_Imple->m_PHA < 0 ) m_Imple->m_PHA += 360;
+	else if ( m_Imple->m_PHA > 360 ) m_Imple->m_PHA -= 360;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_PHA
+ *  Description:   
+ * =====================================================================================
+ */
+int CalculateCenter::Get_PHA()
+{
+	return m_Imple->m_PHA;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_AMP
+ *  Description:  
+ * =====================================================================================
+ */
+long long CalculateCenter::Get_AMP()
+{
+	return m_Imple->m_AMP;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Center_Point
+ *  Description:  Get the Center point 
+ * =====================================================================================
+ */
+void CalculateCenter::Get_Center_Point(int& x,int& y)
+{
+	x = m_Imple->m_Graphic_Center_X;
+	y = m_Imple->m_Graphic_Center_Y;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_LR_Point
+ *  Description:  Get the Left and Right Point 
+ *       result:  true  	Left
+ *                false 	Right
+ * =====================================================================================
+ */
+bool CalculateCenter::Get_LR_Point()
+{
+	if 	( m_Imple->m_RL_Point == RLPOINT_L )
+		return true;
+	else if ( m_Imple->m_RL_Point == RLPOINT_R )
+		return false;
+	else 
+		return false;
+	return false;
+}
diff --git a/src/EVA11/base/CalculateCenter.h b/src/EVA11/base/CalculateCenter.h
new file mode 100644
index 0000000..9eaf0f5
--- /dev/null
+++ b/src/EVA11/base/CalculateCenter.h
@@ -0,0 +1,64 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  CalculateCenter.h
+ *
+ *    Description:  It is a temp class only used to calculate the Graphic center
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月14日 09时22分21秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _CALCULATECENTER_INC
+#define  _CALCULATECENTER_INC
+
+#include 	<memory>	
+class CalculateCenter
+{
+	public:
+		typedef struct 
+		{
+			short X;
+			short Y;
+			double AMP;
+		}AMPBALL;
+
+		typedef enum 
+		{
+			RLPOINT_L=0,
+			RLPOINT_R=1,
+		} RLPOINT;
+
+		CalculateCenter ();
+		~CalculateCenter ();
+
+		void Init_Object();
+		void Calculate_Graphic_MAX_MIN_Value(short x,short y);
+		void Calculate_Graphic_Center();
+		void Record_MAXValue(short x,short y);
+		void Reset_AMPBALL();
+
+		void Get_MAX_Point(int& rx,int& ry,int& lx,int& ly);
+		void Get_Center_Point(int& x,int& y);
+
+		void Calculate_AMP_PHA();
+
+		int Get_PHA();
+		long long Get_AMP();
+
+		bool Get_LR_Point();
+	protected:
+
+	private:
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif
diff --git a/src/EVA11/base/Chart.cpp b/src/EVA11/base/Chart.cpp
new file mode 100644
index 0000000..35f947a
--- /dev/null
+++ b/src/EVA11/base/Chart.cpp
@@ -0,0 +1,228 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Chart.cpp
+ *
+ *    Description:  Implementation of Chart class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月08日 15时48分13秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"Object.h"
+#include 	"Chart.h"
+#include 	"Global.h"
+
+Chart::Chart (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_FGColor    = g_MOVBFG_CO;
+	m_BGColor    = g_MOVBBG_CO;
+	m_TXColor    = g_MOVBTX_CO;
+	m_ChartType  = HORIZONTAL;
+	m_Step       = 0;
+
+	if 	( m_ChartType == VERTICAL )
+	{
+		m_Mid_Point  = m_X + ( m_Width >> 1 );
+		m_Half_Width = ( m_Width >> 1 ) - 1;
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		m_Mid_Point  = m_Y + ( m_Heigh >> 1 );
+		m_Half_Height = ( m_Heigh >> 1 ) - 1;
+	}
+
+	m_gp = Global::Instance();
+}
+
+Chart::~Chart ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the Chart object on screen 
+ * =====================================================================================
+ */
+void Chart::Drawme(Graphic &g,bool bufdraw)
+{
+	if 	( bufdraw == true )
+		g.Switch_Screen();
+
+	short co;
+	co = g.Getcolor();
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
+	g.Setcolor(m_FGColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
+	g.Setcolor(co);
+	m_Step = 0;
+	m_AScan_Position    = 1;
+	m_AScan_Speed_Count = 0;
+
+	if 	( bufdraw == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Roll_Bar
+ *  Description:  Roll the moving bar 
+ * =====================================================================================
+ */
+void Chart::Roll_Bar(Graphic& g)
+{
+	g.Setcolor(m_BGColor);
+	if 	( m_ChartType == VERTICAL )
+	{
+		g.Movemem(m_X+1,m_Y+(m_Heigh-3)-m_Step,-1,m_Width-2);
+		if 	( m_Step == m_Heigh-4 ) m_Step = 0;
+		else m_Step ++;
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		g.MovememH(m_X+(m_Width-3)-m_Step,m_Y+1,m_Heigh-2,+1);
+		if ( m_Step == m_Width-4 ) m_Step = 0;
+		else m_Step ++;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Coef
+ *  Description:  Set Coef value 
+ * =====================================================================================
+ */
+void Chart::Set_Coef(int value)
+{
+	if 	( m_ChartType == VERTICAL )
+		m_Rate = static_cast<double>( m_Width>>1 )  / static_cast<double>( ( (value >> 1) - 1 ) ) ;
+	else if ( m_ChartType == HORIZONTAL )
+		m_Rate = static_cast<double>( m_Heigh>>1 )  / static_cast<double>( ( (value >> 1) - 1 ) ) ;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mapping_Value
+ *  Description:  Mapping the value to chart 
+ * =====================================================================================
+ */
+void Chart::Mapping_Value(Graphic &g,int value)
+{
+	int t = static_cast<int>(value * m_Rate);  
+
+	if 	( m_ChartType == VERTICAL )
+	{
+		if 	( t >= m_Half_Width || t <= -m_Half_Width )
+			return;
+		g.Setpixel(m_Mid_Point+t,m_Y+1,m_TXColor);
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		if 	( t >= m_Half_Height || t <= -m_Half_Height )
+			return;
+		g.Setpixel(m_X+1,m_Mid_Point+t,m_TXColor);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_TimeScale
+ *  Description:  When 1 second set a time scale  
+ * =====================================================================================
+ */
+void Chart::Set_TimeScale(Graphic& g)
+{
+	if 	( m_ChartType == VERTICAL )
+	{
+		g.Setpixel(m_X+1,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+2,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+3,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+4,m_Y+1,m_FGColor);
+
+		g.Setpixel(m_X+m_Width-2,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+m_Width-3,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+m_Width-4,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+m_Width-5,m_Y+1,m_FGColor);
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		g.Setpixel(m_X+1,m_Y+1,m_FGColor);
+		g.Setpixel(m_X+1,m_Y+2,m_FGColor);
+		g.Setpixel(m_X+1,m_Y+3,m_FGColor);
+
+		g.Setpixel(m_X+1,m_Y+m_Heigh-2,m_FGColor);
+		g.Setpixel(m_X+1,m_Y+m_Heigh-3,m_FGColor);
+		g.Setpixel(m_X+1,m_Y+m_Heigh-4,m_FGColor);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_AScan_Signal
+ *  Description:  Draw the signalgnal as AScanning type
+ * =====================================================================================
+ */
+void Chart::Draw_AScan_Signal(Graphic &g,int value)
+{
+	int t = static_cast<int>(value * m_Rate);  
+
+	if 	( m_ChartType == VERTICAL )
+	{
+//		if 	( t >= m_Half_Width || t <= -m_Half_Width )
+//			return;
+//		g.Setpixel(m_Mid_Point+t,m_Y+1,m_TXColor);
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		if 	( m_AScan_Speed_Count == m_gp->AScanSpeed )
+		{
+			m_AScan_Speed_Count = 0;
+			m_AScan_Position ++;
+			if 	( m_AScan_Position >=  m_Width - 2 )
+				m_AScan_Position = 1;
+		}
+		else
+			m_AScan_Speed_Count ++;
+
+		if 	( t >= m_Half_Height || t <= -m_Half_Height )
+			return;
+
+		g.CleanArea(m_X+m_AScan_Position,m_Y+1,m_X+m_AScan_Position,m_Y+1+m_Heigh-4);
+		g.Setpixel(m_X+m_AScan_Position,m_Mid_Point+t,m_TXColor);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Chart_Direct
+ *  Description:  Set the Chart Direct
+ * =====================================================================================
+ */
+void Chart::Set_Chart_Direct(CHARTTYPE type)
+{
+	m_ChartType = type;
+
+	if 	( m_ChartType == VERTICAL )
+	{
+		m_Mid_Point  = m_X + ( m_Width >> 1 );
+		m_Half_Width = ( m_Width >> 1 ) - 1;
+	}
+	else if ( m_ChartType == HORIZONTAL )
+	{
+		m_Mid_Point  = m_Y + ( m_Heigh >> 1 );
+		m_Half_Height = ( m_Heigh >> 1 ) - 1;
+	}
+}
diff --git a/src/EVA11/base/Chart.h b/src/EVA11/base/Chart.h
new file mode 100644
index 0000000..5be53e3
--- /dev/null
+++ b/src/EVA11/base/Chart.h
@@ -0,0 +1,68 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Chart.h
+ *
+ *    Description:  manage the chart scan class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月08日 15时45分47秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _CHART_INC
+#define  _CHART_INC
+
+class Global;
+class Chart : public Object
+{
+	public:
+		enum CHARTTYPE 
+		{
+			VERTICAL   = 0,
+			HORIZONTAL = 1,
+		};
+		typedef enum CHARTTYPE CHARTTYPE;
+
+		Chart (int x,int y,int width,int heigh);                             /* constructor */
+		~Chart ();                            				     /* destructor  */
+
+		void Drawme(Graphic &g,bool bufdraw=false);
+		void Roll_Bar(Graphic &g);
+		void Set_Coef(int value);
+		void Set_TimeScale(Graphic& g);
+		void Mapping_Value(Graphic &g,int value);
+
+		void Draw_AScan_Signal(Graphic &g,int value);
+
+		void Set_Chart_Direct(CHARTTYPE);
+	protected:
+
+	private:
+
+		short			 m_FGColor;
+		short			 m_BGColor;
+		short			 m_TXColor;
+		ColorObj::ColorV*	 m_ColorP;
+
+		int			 m_Mid_Point;
+		int			 m_Step;
+		int			 m_Half_Width;
+		int			 m_Half_Height;
+		double 			 m_Rate;
+
+		int			 m_AScan_Position;
+		int			 m_AScan_Speed_Count;
+
+		CHARTTYPE		 m_ChartType;
+
+		Global*		 	 m_gp;
+};
+
+#endif   /* ----- #ifndef _CHART_INC  ----- */
diff --git a/src/EVA11/base/Color3DScan.cpp b/src/EVA11/base/Color3DScan.cpp
new file mode 100644
index 0000000..269c15c
--- /dev/null
+++ b/src/EVA11/base/Color3DScan.cpp
@@ -0,0 +1,182 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Color3DScan.cpp
+ *
+ *    Description:  Implementation of Color3DScan class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月16日 10时29分08秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Color3DScan.h"
+#include 	"FreeType.h"
+
+Color3DScan::Color3DScan (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+{
+}
+
+Color3DScan::~Color3DScan ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Color3DScan::Refreshme(Graphic& g)
+{
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
+
+	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
+
+	int x = m_X + m_Width - 65;
+	int y = m_Y + m_Heigh - 48;
+
+	g.Line(x,y,x,y-40,g.RGB24_16(0xffffff));
+	g.Line(x,y,x+50,y,g.RGB24_16(0xffffff));
+	g.Line(x,y,x-26,y+26,g.RGB24_16(0xffffff));
+
+	FreeType* ft = FreeType::Instance();
+	ft->Set_Color(FreeType::FGCOLOR,g.RGB24_16(0xffffff));
+	ft->Set_Color(FreeType::BGCOLOR,m_BGColor);
+	ft->Set_Transparce(true);
+	ft->Set_Font_Size(14);
+	ft->Text(x+40,y-20+12,"x");
+	ft->Text(x+7,y-45+12,"z");
+	ft->Text(x-15,y+20+12,"y");
+
+	g.Setcolor(co);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Color_Scan_Parameters
+ *  Description:  Init the Color scan object parameters 
+ * =====================================================================================
+ */
+void Color3DScan::Init_Color_Scan_Parameters(int scan_chan_count)
+{
+	m_Scan_Chan_Count = scan_chan_count;
+	m_vBorderArray.clear();
+	BORDER border;
+	int step     = ( m_Width - 4 ) >> 1;
+	int substep  = step / m_Scan_Chan_Count;
+	int temp     = step - substep * m_Scan_Chan_Count;
+
+	border.Left  = 0 + ( m_Width >> 1 ) - 10;
+	border.Right = 1 + ( m_Width >> 1 ) - 10;
+
+	for ( int i=0;i<m_Scan_Chan_Count;i++ )
+	{
+		if ( i < temp )
+		{
+			border.Left  = border.Right + 1;
+			border.Right = border.Left + substep;
+		}
+		else
+		{
+			border.Left  = border.Right + 1;
+			border.Right = border.Left + substep - 1;
+		}
+		m_vBorderArray.push_back(border);
+	}
+
+	m_MaxScanPosIndex = ((m_Heigh-3)>>1)+50;
+	for ( int i=0;i<m_MaxScanPosIndex;i++ )
+	{
+		m_vScanPos.push_back(m_Y+i+((m_Heigh)>>2)-15);
+	}
+	m_ScanPosIndex = 0;
+	m_vOffset      = 0;
+
+	m_ZHeigh       = 80;
+
+	m_Fact	       = static_cast<double>(m_ZHeigh) / 512;
+	m_Count        = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Fact_Value
+ *  Description:  Set the class attribe 
+ * =====================================================================================
+ */
+void Color3DScan::Set_Fact_Value(int value)
+{
+	m_Fact	       = static_cast<double>(m_ZHeigh) / value;
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ScanSpeed
+ *  Description:  Set the class attribe 
+ * =====================================================================================
+ */
+void Color3DScan::Set_ScanSpeed_Value(int value)
+{
+	m_ScanSpeed    = value;
+	m_Count	       = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ZHeigh_Value
+ *  Description:  Set ZHeigh Value 
+ * =====================================================================================
+ */
+void Color3DScan::Set_ZHeigh_Value(int value)
+{
+	m_ZHeigh = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Data_On_Scan
+ *  Description:  Draw Data on screen as 3D mode 
+ * =====================================================================================
+ */
+void Color3DScan::Draw_Data_On_Scan(Graphic& g,int i,short color,int colorindex)
+{
+	g.HLine_Fast(m_X-m_vOffset+m_vBorderArray[i].Left,
+		     m_X-m_vOffset+m_vBorderArray[i].Right,
+		     m_vScanPos[m_ScanPosIndex]-colorindex*m_Fact,color);
+
+	if	( i == 0 )
+	{
+		m_Count ++;
+
+		if 	( m_Count == m_ScanSpeed )
+		{
+			m_Count = 0;
+
+			m_ScanPosIndex ++;
+			m_vOffset ++;
+
+			if ( m_ScanPosIndex == m_MaxScanPosIndex )
+			{
+				m_ScanPosIndex = 0;
+				m_vOffset = 0;
+				Refreshme(g);
+			}
+		}
+	}
+}
diff --git a/src/EVA11/base/Color3DScan.h b/src/EVA11/base/Color3DScan.h
new file mode 100644
index 0000000..8bd2734
--- /dev/null
+++ b/src/EVA11/base/Color3DScan.h
@@ -0,0 +1,61 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Color3DScan.h
+ *
+ *    Description:  Display Data on screen as 3D mode
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月16日 10时24分18秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _COLOR3DSCAN_INC
+#define  _COLOR3DSCAN_INC
+
+#include 	<vector>
+
+class Basescreen;
+class Color3DScan : public Basescreen
+{
+	public:
+		struct BORDER 
+		{
+			int Left;
+			int Right;
+		};
+		typedef struct BORDER BORDER;
+
+		Color3DScan (int x,int y,int width,int heigh);
+		~Color3DScan ();
+
+		void Init_Color_Scan_Parameters(int scan_chan_count);
+
+		void Draw_Data_On_Scan(Graphic& g,int i,short color,int colorindex);
+		void Set_Fact_Value(int);
+		void Set_ScanSpeed_Value(int);
+
+		void Set_ZHeigh_Value(int);
+	protected:
+		virtual void Refreshme(Graphic& g);
+
+	private:
+		int				m_Scan_Chan_Count;
+		std::vector<BORDER>		m_vBorderArray;
+		std::vector<int>		m_vScanPos;
+		int				m_ScanPosIndex;
+		int				m_MaxScanPosIndex;
+		int				m_vOffset;
+		int				m_Count;
+		int				m_ScanSpeed;
+		int				m_ZHeigh;
+		double				m_Fact;
+}; /* -----  end of class Color3DScan  ----- */
+
+#endif   /* ----- #ifndef _COLOR3DSCAN_INC  ----- */
diff --git a/src/EVA11/base/ColorObj.cpp b/src/EVA11/base/ColorObj.cpp
new file mode 100644
index 0000000..7da4beb
--- /dev/null
+++ b/src/EVA11/base/ColorObj.cpp
@@ -0,0 +1,144 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorObj.cpp
+ *
+ *    Description:  implementation of ColorObj class 
+ *
+ *        Version:  1.0
+ *        Created:  2013年01月18日 11时44分42秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<SDL.h>
+#include 	"ColorObj.h"
+
+std::auto_ptr<ColorObj> ColorObj::m_Instance;
+
+struct ColorObj::PImpl
+{
+	static const int	MAXPENCOUNT 	= 32;
+	ColorV 			Pen[MAXPENCOUNT];
+};
+
+ColorObj::ColorObj () : m_Imple(new struct PImpl)
+{
+}
+
+ColorObj::~ColorObj ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+ColorObj* ColorObj::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new ColorObj() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Object
+ *  Description:  initialization of Color Object
+ * =====================================================================================
+ */
+bool ColorObj::Init_Object()
+{
+	m_Imple->Pen[0].color32  = 0x000000ff;
+	m_Imple->Pen[1].color32  = 0x45660b9f;
+	m_Imple->Pen[2].color32  = 0x0000ffff;
+	m_Imple->Pen[3].color32  = 0x00ff00ff;
+	m_Imple->Pen[4].color32  = 0xffff00ff;
+	m_Imple->Pen[5].color32  = 0xff7a00ff;
+	m_Imple->Pen[6].color32  = 0xff00ffff;
+	m_Imple->Pen[7].color32  = 0x00ffffff;
+	m_Imple->Pen[8].color32  = 0x7d9953ff;
+	m_Imple->Pen[9].color32  = 0xfffab3ff;
+	m_Imple->Pen[10].color32 = 0x000000ff;
+	m_Imple->Pen[11].color32 = 0xffff00ff;
+	m_Imple->Pen[12].color32 = 0xff0000ff;
+	m_Imple->Pen[13].color32 = 0xffffffff;
+	m_Imple->Pen[14].color32 = 0xffffffff;
+	m_Imple->Pen[15].color32 = 0xffffffff;
+	m_Imple->Pen[16].color32 = 0xf5ffccff;
+	m_Imple->Pen[17].color32 = 0x45660bff;
+	m_Imple->Pen[18].color32 = 0xd7d7d7ff;
+	m_Imple->Pen[19].color32 = 0x000000ff;
+	m_Imple->Pen[20].color32 = 0x000000ff;
+	m_Imple->Pen[21].color32 = 0xffffffff;
+	m_Imple->Pen[22].color32 = 0x000000ff;
+	m_Imple->Pen[23].color32 = 0xfffab3ff;
+	m_Imple->Pen[24].color32 = 0xff0000ff;
+	m_Imple->Pen[25].color32 = 0xf5ffccff;
+	m_Imple->Pen[26].color32 = 0x000000ff;
+	m_Imple->Pen[27].color32 = 0xff0000ff;
+	m_Imple->Pen[28].color32 = 0x000000ff;
+	m_Imple->Pen[29].color32 = 0xefe559ff;
+	m_Imple->Pen[30].color32 = 0x000000ff;
+	m_Imple->Pen[31].color32 = 0xffffffff;
+
+	SDL_Surface* p24ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,24,0xff0000,0x00ff00,0x0000ff,0x0);
+	if 	( p24ColorSurface == NULL )
+	{
+		printf("SDL Create color surface fail: %s\n",SDL_GetError());
+		return false; 
+	}
+	SDL_Surface* p16ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,16,0xf800,0x07e0,0x001f,0);
+	if 	( p16ColorSurface == NULL )
+	{
+		SDL_FreeSurface(p24ColorSurface);
+		printf("SDL Create color surface fail: %s\n",SDL_GetError());
+		return false; 
+	}
+
+	for ( int i=0;i<m_Imple->MAXPENCOUNT;i++ )
+	{
+		m_Imple->Pen[i].index = i;
+		m_Imple->Pen[i].r = (m_Imple->Pen[i].color32>>24)&0xff;
+		m_Imple->Pen[i].g = (m_Imple->Pen[i].color32>>16)&0xff;
+		m_Imple->Pen[i].b = (m_Imple->Pen[i].color32>>8 )&0xff;
+		m_Imple->Pen[i].a = (m_Imple->Pen[i].color32>>0 )&0xff;
+		m_Imple->Pen[i].color24 =  SDL_MapRGB(p24ColorSurface->format,m_Imple->Pen[i].r,m_Imple->Pen[i].g,m_Imple->Pen[i].b);
+		m_Imple->Pen[i].color16 =  SDL_MapRGB(p16ColorSurface->format,m_Imple->Pen[i].r,m_Imple->Pen[i].g,m_Imple->Pen[i].b);
+	}
+
+	SDL_FreeSurface(p16ColorSurface);
+	SDL_FreeSurface(p24ColorSurface);
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_Object
+ *  Description:  Destroy the Color Object 
+ * =====================================================================================
+ */
+void ColorObj::Destroy_Object()
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_ColorVP
+ *  Description:  Get the Color Variables Point 
+ * =====================================================================================
+ */
+ColorObj::ColorV* ColorObj::Get_ColorVP(const int index)
+{
+	return &m_Imple->Pen[index];
+}
diff --git a/src/EVA11/base/ColorObj.h b/src/EVA11/base/ColorObj.h
new file mode 100644
index 0000000..840a661
--- /dev/null
+++ b/src/EVA11/base/ColorObj.h
@@ -0,0 +1,62 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorObj.h
+ *
+ *    Description:  Manage Color 
+ *
+ *        Version:  1.0
+ *        Created:  2013年01月18日 11时41分44秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  COLOROBJ_INC
+#define  COLOROBJ_INC
+
+#include 	<inttypes.h>
+#include 	<memory>
+
+class ColorObj
+{
+	public:
+		struct ColorV 
+		{
+			uint32_t	index;
+			uint32_t	color32;
+			uint32_t	color24;
+			uint16_t	color16;
+			uint8_t		r;
+			uint8_t		g;
+			uint8_t		b;
+			uint8_t		a;
+		};
+		typedef struct ColorV ColorV;
+
+		static ColorObj* Instance();
+
+		bool Init_Object();
+		void Destroy_Object();
+		ColorV* Get_ColorVP(const int);
+	protected:
+
+	private:
+		ColorObj ();
+		ColorObj (const ColorObj&);
+		ColorObj& operator = (const ColorObj&);
+		~ColorObj ();
+
+	private:
+		friend class std::auto_ptr<ColorObj>;
+		static std::auto_ptr<ColorObj>		m_Instance;
+
+		struct PImpl;
+		std::auto_ptr<struct PImpl>		m_Imple;
+
+}; /* -----  end of class ColorObj  ----- */
+#endif   /* ----- #ifndef COLOROBJ_INC  ----- */
diff --git a/src/EVA11/base/ColorPanel.cpp b/src/EVA11/base/ColorPanel.cpp
new file mode 100644
index 0000000..8fd588a
--- /dev/null
+++ b/src/EVA11/base/ColorPanel.cpp
@@ -0,0 +1,342 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorPanel.cpp
+ *
+ *    Description:  implementation of ColorPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 15时03分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Device.h"
+#include 	"Global.h"
+#include 	"Algorithm.h"
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Color3DScan.h"
+#include 	"ColorScan.h"
+#include 	"Colorbar.h"
+#include 	"Rule.h"
+
+#include 	"BasePanel.h"
+#include 	"ColorPanel.h"
+
+#include 	"FreeType.h"
+
+ColorPanel::ColorPanel (int x,int y,int width,int heigh)
+	: BasePanel(x,y,width,heigh)
+{
+}
+
+ColorPanel::~ColorPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Create the GUI object in memory 
+ * =====================================================================================
+ */
+void ColorPanel::Init_GUI(Graphic& g)
+{
+	m_Colorbar = new Colorbar(2,2,530,25);
+	m_Colorbar->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Colorbar->Set_Color(Basescreen::LA_BG_COLOR,g_SCTX_CO);
+	m_Colorbar->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Colorbar->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Colorbar->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
+	m_Colorbar->Calculate_Color_Bar_Value(g);
+
+	m_Colorscan = new ColorScan(2,2+24,530,393);
+	m_Colorscan->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Colorscan->Set_Color(Basescreen::LA_BG_COLOR,g_BUBGNO_CO);
+	m_Colorscan->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Colorscan->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Colorscan->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
+	m_Colorscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
+
+	m_Color3Dscan = new Color3DScan(2,2+24,530,393);
+	m_Color3Dscan->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Color3Dscan->Set_Color(Basescreen::LA_BG_COLOR,g_BUBGNO_CO);
+	m_Color3Dscan->Set_Color(Basescreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Color3Dscan->Set_Color(Basescreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Color3Dscan->Set_Color(Basescreen::LA_FOCUS_COLOR,g_SCTX_CO);
+	m_Color3Dscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
+	m_Color3Dscan->Set_Fact_Value(m_Colorbar->Get_IndexCount());
+
+	Global *gp = Global::Instance();
+	m_Color3Dscan->Set_ScanSpeed_Value(gp->ColorSpotScanSpeed);
+
+	m_Rule     = new Rule(2,418,530,25);
+	m_Rule->Init_Rule_Color(g);
+
+	m_DataProcess = new ColorSpotDataProcess;
+	m_DataProcess->Reset_InTimer();
+	m_DataProcess->Reset_OutTimer();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI object 
+ * =====================================================================================
+ */
+void ColorPanel::Destroy_GUI()
+{
+	if ( m_Colorscan != NULL )
+	{
+		delete m_Colorscan;
+		m_Colorscan = NULL;
+	}
+
+	if ( m_Color3Dscan != NULL )
+	{
+		delete m_Color3Dscan;
+		m_Color3Dscan = NULL;
+	}
+
+	if ( m_Colorbar != NULL )
+	{
+		delete m_Colorbar;
+		m_Colorbar = NULL;
+	}
+
+	if ( m_Rule != NULL )
+	{
+		delete m_Rule;
+		m_Rule = NULL;
+	}
+
+	if ( m_DataProcess != NULL )
+	{
+		delete m_DataProcess;
+		m_DataProcess = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw GUI object on screen 
+ * =====================================================================================
+ */
+void ColorPanel::Drawme(Graphic& g,bool flag)
+{
+	if 	( m_gp->ColorSpotDispMode == 0 )
+	{
+		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+		m_Colorscan->Drawme(g,flag);
+	}
+	else
+	{
+		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+		m_Color3Dscan->Drawme(g,flag);
+	}
+
+	m_Colorbar->Drawme(g,flag);
+	m_Rule->Drawme(g,flag);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  important function, deal with data
+ * =====================================================================================
+ */
+int  ColorPanel::Loop_Panel(Graphic& g)
+{
+	m_DataProcess->Data_Process();
+
+	unsigned long long timer = 0;
+	if 	( m_gp->ColorSpotSampleType == 0 )
+	{
+		m_DataProcess->Get_InTimer(timer);
+		if 	( ( timer - m_InsideTimer_Value ) >= m_gp->ColorSpotSampIntervalClock )
+		{
+			m_DataProcess->Get_Data(m_RawBuf);
+			if 	( m_gp->ColorSpotDispMode == 0 )
+			{
+				for ( int i=0;i<Global::CHANCOUNT;i++ )
+				{
+					m_Colorscan->Draw_Data_On_Scan(g,i,m_Colorbar->Mapping_Color(m_RawBuf[i]));
+				}
+			}
+			else
+			{
+				short color;
+				int colorindex;
+				for ( int i=0;i<Global::CHANCOUNT;i++ )
+				{
+					m_Colorbar->Mapping_Color_Value(m_RawBuf[i],color,colorindex);
+					m_Color3Dscan->Draw_Data_On_Scan(g,i,color,colorindex);
+				}
+			}
+		}
+		m_InsideTimer_Value = timer;
+	}
+	else if ( m_gp->ColorSpotSampleType == 1 )
+	{
+		m_DataProcess->Get_OutTimer(timer);
+
+		if 	( ( timer - m_OutsideTimer_Value ) >= m_gp->ColorSPotSampOutPuls )
+		{
+			m_DataProcess->Get_Data(m_RawBuf);
+
+			if 	( m_gp->ColorSpotDispMode == 0 )
+			{
+				for ( int i=0;i<Global::CHANCOUNT;i++ )
+				{
+					m_Colorscan->Draw_Data_On_Scan(g,i,m_Colorbar->Mapping_Color(m_RawBuf[i]));
+				}
+			}
+			else
+			{
+				short color;
+				int colorindex;
+				for ( int i=0;i<Global::CHANCOUNT;i++ )
+				{
+					m_Colorbar->Mapping_Color_Value(m_RawBuf[i],color,colorindex);
+					m_Color3Dscan->Draw_Data_On_Scan(g,i,color,colorindex);
+				}
+			}
+		}
+		m_OutsideTimer_Value = timer;
+	}
+
+	return 0;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void ColorPanel::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+
+	font->Text(x+30,y+90,pl->GetText(HELPB1F1));
+	font->Text(x+30,y+110,pl->GetText(HELPB1F2));
+	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
+
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fx_Fun
+ *  Description:  Dealwith Fx function 
+ * =====================================================================================
+ */
+int ColorPanel::Key_F2_Fun(Graphic& g)
+{
+	if 	( m_gp->ColorSpotDispMode == 0 )
+	{
+		m_Colorscan->Drawme(g);
+		m_Colorscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
+	}
+	else
+	{
+		m_Color3Dscan->Drawme(g);
+		m_Color3Dscan->Init_Color_Scan_Parameters(Global::CHANCOUNT);
+	}
+
+	m_DataProcess->Reset_InTimer();
+	m_DataProcess->Reset_OutTimer();
+
+	m_InsideTimer_Value  = 0;
+	m_OutsideTimer_Value = 0;
+	
+	return 0;
+}
+int ColorPanel::Key_F4_Fun(Graphic& g)
+{
+	m_DataProcess->Trigger_Balacne_Process();
+	return 0;
+}
+
+int ColorPanel::Key_NL6_Fun(Graphic& g,int sub)
+{
+	if 	( m_gp->ColorSpotDispMode == 0 )
+	{
+		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+	}
+	else if ( m_gp->ColorSpotDispMode == 1 )
+	{
+		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+	}
+	return 0;
+}
+
+int ColorPanel::Key_NR6_Fun(Graphic& g,int sub)
+{
+	if 	( m_gp->ColorSpotDispMode == 0 )
+	{
+		m_Colorscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+	}
+	else if ( m_gp->ColorSpotDispMode == 1 )
+	{
+		m_Color3Dscan->Set_ScanSpeed_Value(m_gp->ColorSpotScanSpeed);
+	}
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Panel
+ *  Description:  Switch panel call this function 
+ * =====================================================================================
+ */
+void ColorPanel::Switch_Panel()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+
+	for ( int ch=0;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 1;			// ECT
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	device->Write_Para_Driver(m_gp->Driver);
+	device->Write_Para_Offset(m_gp->Offset);
+	device->Write_Para_SignalWave(0);
+
+	device->Transfer_ECT_Parameters();
+
+	m_DataProcess->Trigger_Balacne_Process();       // very Important
+}
diff --git a/src/EVA11/base/ColorPanel.h b/src/EVA11/base/ColorPanel.h
new file mode 100644
index 0000000..ab7707c
--- /dev/null
+++ b/src/EVA11/base/ColorPanel.h
@@ -0,0 +1,61 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorPanel.h
+ *
+ *    Description:  Declear of ColorPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 15时00分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _COLORPANEL_INC
+#define  _COLORPANEL_INC
+
+class BasePanel;
+class Color3DScan;
+class ColorScan;
+class Colorbar;
+class Rule;
+class ColorSpotDataProcess;
+
+class ColorPanel : public BasePanel
+{
+	public:
+		ColorPanel (int x,int y,int width,int heigh);
+		~ColorPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+		virtual void Switch_Panel();
+	protected:
+	private:
+		Color3DScan		*m_Color3Dscan;
+		ColorScan		*m_Colorscan;
+		Colorbar		*m_Colorbar;
+
+		Rule			*m_Rule;
+		ColorSpotDataProcess    *m_DataProcess;
+
+		unsigned long long      m_InsideTimer_Value;
+		unsigned long long      m_OutsideTimer_Value;
+};
+
+#endif
diff --git a/src/EVA11/base/ColorScan.cpp b/src/EVA11/base/ColorScan.cpp
new file mode 100644
index 0000000..6e5eb5e
--- /dev/null
+++ b/src/EVA11/base/ColorScan.cpp
@@ -0,0 +1,130 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorScan.cpp
+ *
+ *    Description:  Implementaion of ColorScan class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 15时54分31秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"ColorScan.h"
+#include 	"Graphic.h"
+
+ColorScan::ColorScan (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+{
+}
+
+ColorScan::~ColorScan ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void ColorScan::Refreshme(Graphic& g)
+{
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
+
+	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
+	g.Setcolor(co);
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Color_Scan_Parameters
+ *  Description:  Init the Color scan object parameters 
+ * =====================================================================================
+ */
+void ColorScan::Init_Color_Scan_Parameters(int scan_chan_count)
+{
+	m_Scan_Chan_Count = scan_chan_count;
+	m_vBorderArray.clear();
+	BORDER border;
+	int step     = m_Width - 4;
+	int substep  = step / m_Scan_Chan_Count;
+	int temp     = step - substep * m_Scan_Chan_Count ;
+
+	border.Left  = 0;
+	border.Right = 1;
+
+	for ( int i=0;i<m_Scan_Chan_Count;i++ )
+	{
+		if ( i < temp )
+		{
+			border.Left  = border.Right + 1;
+			border.Right = border.Left + substep;
+		}
+		else	
+		{
+			border.Left  = border.Right + 1;
+			border.Right = border.Left + substep - 1;
+		}
+		m_vBorderArray.push_back(border);
+	}
+
+	for ( int i=0;i<m_Heigh-3;i++ )
+	{
+		m_vScanPos.push_back(m_Y+2+i);
+	}
+	m_ScanPosIndex = 0;
+	m_MaxScanPosIndex = m_Heigh-3;
+
+	m_Count        = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ScanSpeed
+ *  Description:  Set the class attribe 
+ * =====================================================================================
+ */
+void ColorScan::Set_ScanSpeed_Value(int value)
+{
+	m_ScanSpeed = value;
+	m_Count	    = 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Color_Bar
+ *  Description:  Draw Color Bar 
+ * =====================================================================================
+ */
+void ColorScan::Draw_Data_On_Scan(Graphic& g,int i,short color)
+{
+	g.HLine_Fast(m_X+m_vBorderArray[i].Left,m_X+m_vBorderArray[i].Right,m_vScanPos[m_ScanPosIndex],color);
+
+	if ( i == 0 )
+	{
+		m_Count ++;
+		if 	( m_Count == m_ScanSpeed )
+		{
+			m_Count = 0;
+
+			m_ScanPosIndex ++;
+			if ( m_ScanPosIndex == m_MaxScanPosIndex )
+				m_ScanPosIndex = 0;
+		}
+
+	}
+}
diff --git a/src/EVA11/base/ColorScan.h b/src/EVA11/base/ColorScan.h
new file mode 100644
index 0000000..4c0a7c1
--- /dev/null
+++ b/src/EVA11/base/ColorScan.h
@@ -0,0 +1,53 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ColorScan.h
+ *
+ *    Description:  Declare of color scan bar 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 15时51分59秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _COLORSCAN_INC
+#define  _COLORSCAN_INC
+
+#include 	<vector>
+class Basescreen;
+class ColorScan : public Basescreen 
+{
+	public:
+		struct BORDER 
+		{
+			int Left;
+			int Right;
+		};
+		typedef struct BORDER BORDER;
+
+		ColorScan (int x,int y,int width,int heigh);
+		~ColorScan ();
+
+		void Init_Color_Scan_Parameters(int scan_chan_count);
+
+		void Draw_Data_On_Scan(Graphic& g,int i,short color);
+		void Set_ScanSpeed_Value(int);
+	protected:
+		virtual void Refreshme(Graphic& g);
+
+	private:
+		int				m_Scan_Chan_Count;
+		std::vector<BORDER>		m_vBorderArray;
+		std::vector<int>		m_vScanPos;
+		int				m_ScanPosIndex;
+		int				m_MaxScanPosIndex;
+		int				m_Count;
+		int				m_ScanSpeed;
+};
+#endif
diff --git a/src/EVA11/base/Colorbar.cpp b/src/EVA11/base/Colorbar.cpp
new file mode 100644
index 0000000..06c16d7
--- /dev/null
+++ b/src/EVA11/base/Colorbar.cpp
@@ -0,0 +1,186 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Colorbar.cpp
+ *
+ *    Description:  Implemntation of Colorbar
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 16时55分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Colorbar.h"
+#include 	"Graphic.h"
+
+Colorbar::Colorbar (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+{
+	m_IndexCount = m_Width - 2; 
+	m_ColorIndex = new unsigned short[m_IndexCount];
+}
+
+Colorbar::~Colorbar ()
+{
+	if ( m_ColorIndex != NULL )
+	{
+		delete[] m_ColorIndex;
+		m_ColorIndex = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Colorbar::Refreshme(Graphic& g)
+{
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+
+	Draw_Color_Bar(g);
+
+	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
+	g.Setcolor(co);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Color_Bar
+ *  Description:  Draw the color bar on screen 
+ * =====================================================================================
+ */
+void Colorbar::Draw_Color_Bar(Graphic& g)
+{
+	for ( int i=0;i<m_IndexCount;i++ )
+	{
+		g.Line(m_X+1+i,m_Y+1,m_X+1+i,m_Y+m_Heigh-2,m_ColorIndex[i]);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Color_Bar_Value
+ *  Description:  Calulate the Color index of color bar 
+ * =====================================================================================
+ */
+void Colorbar::Calculate_Color_Bar_Value(Graphic& g)
+{
+	unsigned char R = 0,G = 0,B = 0;
+	unsigned int rgb = 0;
+	int temp1 = m_IndexCount - 512;
+	temp1 = temp1 >> 1;
+	int temp2 = m_IndexCount >> 1;
+
+	for ( int i=0;i<temp2-temp1;i++ )
+	{
+		Get_RGB_Value(i*2,R,G,B);
+		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
+		m_ColorIndex[i] = g.RGB24_16(rgb);
+	}
+	for ( int i=temp2-temp1;i<temp2+temp1;i++ )
+	{
+		Get_RGB_Value(temp2-temp1+i,R,G,B);
+		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
+		m_ColorIndex[i] = g.RGB24_16(rgb);
+	}
+	for ( int i=temp2+temp1;i<m_IndexCount;i++ )
+	{
+		Get_RGB_Value(2*(i-temp1),R,G,B);
+		rgb = static_cast<unsigned int>(R<<16) + static_cast<unsigned int>(G<<8) + static_cast<unsigned int>(B); 
+		m_ColorIndex[i] = g.RGB24_16(rgb);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_RGB_Value
+ *  Description:  Get the RGB value coording to the index 
+ *        index:  0~1023
+ * =====================================================================================
+ */
+void Colorbar::Get_RGB_Value(int index,unsigned char &R,unsigned char &G,unsigned char &B)
+{
+	if 	( index >= 0 && index < 256 )
+	{
+		B = 255;
+		R = 0;
+		G = index;
+	}
+	else if ( index >= 256 && index < 512 )
+	{
+		B = 255 - ( index - 256 );
+		R = 0;
+		G = 255;
+	}
+	else if ( index >= 512 && index < 768 )
+	{
+		B = 0; 
+		R = index - 512;
+		G = 255;
+	}
+	else if ( index >= 768 && index < 1024 )
+	{
+		B = 0; 
+		R = 255;
+		G = 255 - ( index - 768 );
+	}
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mapping_Color
+ *  Description:  Mapping ETDATA value to color index 
+ * =====================================================================================
+ */
+short Colorbar::Mapping_Color(const ETDATA& value)
+{
+	int tmp = 0;
+	tmp = static_cast<int>( m_IndexCount * ( ( static_cast<double>(value) - m_MINValue ) / ( m_MAXValue - m_MINValue ) ) );
+
+	if ( tmp < 0 ) tmp = 0;
+	if ( tmp >= m_IndexCount ) tmp = m_IndexCount - 1;
+
+	return m_ColorIndex[tmp];
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mapping_Color_Value
+ *  Description:  Mapping ETDATA value to color index 
+ * =====================================================================================
+ */
+void Colorbar::Mapping_Color_Value(const ETDATA& value,short& color,int& colorindex)
+{
+	int tmp = 0;
+	tmp = static_cast<int>( m_IndexCount * ( ( static_cast<double>(value) - m_MINValue ) / ( m_MAXValue - m_MINValue ) ) );
+
+	if ( tmp < 0 ) tmp = 0;
+	if ( tmp >= m_IndexCount ) tmp = m_IndexCount - 1;
+
+	colorindex = tmp - ( m_IndexCount >> 1 );
+	color = m_ColorIndex[tmp];
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_IndexCount
+ *  Description:  Get the Index Count Value 
+ * =====================================================================================
+ */
+int Colorbar::Get_IndexCount()
+{
+	return m_IndexCount;
+}
diff --git a/src/EVA11/base/Colorbar.h b/src/EVA11/base/Colorbar.h
new file mode 100644
index 0000000..5d53fa6
--- /dev/null
+++ b/src/EVA11/base/Colorbar.h
@@ -0,0 +1,50 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Colorbar.h
+ *
+ *    Description:  Display the relationship between color and eddy value
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 16时50分10秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _COLORBAR_INC
+#define  _COLORBAR_INC
+
+#include 	"main.h"
+
+class Basescreen;
+class Colorbar : public Basescreen
+{
+	public:
+		Colorbar (int x,int y,int width,int heigh);
+		~Colorbar ();
+
+		void Calculate_Color_Bar_Value(Graphic& g);
+		short Mapping_Color(const ETDATA& value);
+
+		void Mapping_Color_Value(const ETDATA& value,short& color,int& colorindex);
+		int Get_IndexCount();	
+	protected:
+		virtual void Refreshme(Graphic& g);
+
+	private:
+		void Draw_Color_Bar(Graphic& g);
+		void Get_RGB_Value(int index,unsigned char &R,unsigned char &G,unsigned char &B);	
+
+	private:
+		unsigned short 		*m_ColorIndex;
+		int			m_IndexCount;
+
+		static const int	m_MAXValue = 150;			
+		static const int	m_MINValue = -150;			
+};
+#endif
diff --git a/src/EVA11/base/ConcreteDataProcess.cpp b/src/EVA11/base/ConcreteDataProcess.cpp
new file mode 100644
index 0000000..f694f15
--- /dev/null
+++ b/src/EVA11/base/ConcreteDataProcess.cpp
@@ -0,0 +1,379 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ConcreteDataProcess.cpp
+ *
+ *    Description:  Implemntaion of ZKDataProcess class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月16日 14时30分59秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cmath>
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+#include 	"Algorithm.h"
+#include 	"DataRepo.h"
+#include 	"MixingManage.h"
+
+ZKDataProcess::ZKDataProcess ()
+{
+}
+
+ZKDataProcess::~ZKDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ZKDataProcess
+ *  Description:  ZKDataProcess function sets 
+ * =====================================================================================
+ */
+void ZKDataProcess::Data_Process()
+{
+	IDataProcess::Data_Process();
+	m_repo->Save_Data_Into_Repo(m_ETData);
+	for ( int index = 0;index < 1;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+		}
+		else
+		{
+			m_Double_X[index] = ( m_ETData[index<<1] )     * m_gp->SoftGain[index];
+			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
+					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+			m_ET_Y[index] = 0 - m_ET_Y[index];
+		}
+		m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  Get Data from device 
+ * =====================================================================================
+ */
+void ZKDataProcess::Get_Data(ETDATA *rawdata)
+{
+	for ( int i=0;i<1;i++ )
+	{
+		rawdata[i<<1] 	  = m_ET_X[i] ; 
+		rawdata[(i<<1)+1] = m_ET_Y[i] ; 
+	}
+}
+
+/*     ------------------------------------------------------------------------      */
+
+DZKDataProcess::DZKDataProcess ()
+{
+}
+
+DZKDataProcess::~DZKDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ZKDataProcess
+ *  Description:  ZKDataProcess function sets 
+ * =====================================================================================
+ */
+void DZKDataProcess::Data_Process()
+{
+	IDataProcess::Data_Process();
+	m_repo->Save_Data_Into_Repo(m_ETData);
+
+	bool flag = false;
+	for ( int index = 0;index < 2;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+			flag = true;
+		}
+		else
+		{
+			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
+					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+			m_ET_Y[index] = 0 - m_ET_Y[index];
+			m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
+		}
+	}
+
+	m_mixm->Mixing(0,m_ETData[0],m_ETData[1],m_ETData[2],m_ETData[3]);
+
+	m_ETData[4] = m_ETData[2];
+	m_ETData[5] = m_ETData[3];
+	int index = 2;
+	if ( flag == false )
+	{
+		m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftMixGain[index-2];
+		m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftMixGain[index-2];
+		m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+		m_alg->Rotation(m_gp->MixDegree[index-2],m_Double_X[index],
+				m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+		m_ET_Y[index] = 0 - m_ET_Y[index];
+	}
+	else
+	{
+		m_ET_X[index] = 0;
+		m_ET_Y[index] = 0;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  Get Data from device 
+ * =====================================================================================
+ */
+void DZKDataProcess::Get_Data(ETDATA *rawdata)
+{
+	for ( int i=0;i<3;i++ )
+	{
+		rawdata[i<<1] 	  = m_ET_X[i]; 
+		rawdata[(i<<1)+1] = m_ET_Y[i]; 
+	}
+}
+
+/*     ------------------------------------------------------------------------      */
+
+CZKDataProcess::CZKDataProcess ()
+{
+}
+
+CZKDataProcess::~CZKDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  CZKDataProcess
+ *  Description:  CZKDataProcess function sets 
+ * =====================================================================================
+ */
+void CZKDataProcess::Data_Process()
+{
+	IDataProcess::Data_Process();
+	m_repo->Save_Data_Into_Repo(m_ETData);
+
+	bool flag = false;
+	for ( int index = 0;index < 2;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+			flag = true;
+		}
+		else
+		{
+			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
+					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+			m_ET_Y[index] = 0 - m_ET_Y[index];
+			m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
+		}
+	}
+
+	for ( int index = 2;index < 3;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+			flag = true;
+		}
+		else
+		{
+			m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftGain[index];
+
+			m_ET_X[index] = static_cast<ETDATA>(m_Double_X[index]);
+			m_ET_Y[index] = 0;
+		}
+	}
+
+//	m_mixm->Mixing(0,m_ETData[0],m_ETData[1],m_ETData[2],m_ETData[3]);
+//
+//	m_ETData[4] = m_ETData[2];
+//	m_ETData[5] = m_ETData[3];
+//	int index = 2;
+//	if ( flag == false )
+//	{
+//		m_Double_X[index] = ( m_ETData[index<<1] ) * m_gp->SoftMixGain[index-2];
+//		m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftMixGain[index-2];
+//		m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+//		m_alg->Rotation(m_gp->MixDegree[index-2],m_Double_X[index],
+//				m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+//		m_ET_Y[index] = 0 - m_ET_Y[index];
+//	}
+//	else
+//	{
+//		m_ET_X[index] = 0;
+//		m_ET_Y[index] = 0;
+//	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  Get Data from device 
+ * =====================================================================================
+ */
+void CZKDataProcess::Get_Data(ETDATA *rawdata)
+{
+	for ( int i=0;i<4;i++ )
+	{
+		rawdata[i<<1] 	  = m_ET_X[i]; 
+		rawdata[(i<<1)+1] = m_ET_Y[i]; 
+	}
+
+//	printf ( " EMS x = %d\n", m_ET_X[2]);
+}
+
+/*     ------------------------------------------------------------------------      */
+
+ColorSpotDataProcess::ColorSpotDataProcess ()
+{
+}
+
+ColorSpotDataProcess::~ColorSpotDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Data_Process
+ *  Description:  Data Process function sets 
+ * =====================================================================================
+ */
+void ColorSpotDataProcess::Data_Process()
+{
+	IDataProcess::Data_Process();
+	for ( int index = 0;index < Global::CHANCOUNT;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+		}
+		else
+		{
+			m_ET_X[index] = ( m_ETData[index<<1] )     * m_gp->ColorSoftGain;
+			m_ET_Y[index] = ( m_ETData[(index<<1)+1] ) * m_gp->ColorSoftGain;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  After Processing Data, Get Data by this function
+ * =====================================================================================
+ */
+void ColorSpotDataProcess::Get_Data(ETDATA *rawdata)
+{
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+	{
+		rawdata[i] = m_ET_Y[i]; 
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Timer
+ *  Description:  Get the Timer value  
+ * =====================================================================================
+ */
+void ColorSpotDataProcess::Get_InTimer(unsigned long long &value)
+{
+	value = m_InTimer[0];
+}
+void ColorSpotDataProcess::Get_OutTimer(unsigned long long &value)
+{
+	value = m_OutTimer[0];
+}
+
+/*     ------------------------------------------------------------------------      */
+
+OZKDataProcess::OZKDataProcess ()
+{
+}
+
+OZKDataProcess::~OZKDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ZKDataProcess
+ *  Description:  ZKDataProcess function sets 
+ * =====================================================================================
+ */
+void OZKDataProcess::Data_Process()
+{
+	IDataProcess::Data_Process();
+	m_repo->Save_Data_Into_Repo(m_ETData);
+	for ( int index = 0;index < 16;index ++ )
+	{
+		if ( m_gp->ProbeFun[index] == 0 )
+		{
+			m_ET_X[index] = 0;
+			m_ET_Y[index] = 0;
+		}
+		else
+		{
+			m_Double_X[index] = ( m_ETData[index<<1] )     * m_gp->SoftGain[index];
+			m_Double_Y[index] = ( 0 - m_ETData[(index<<1)+1] ) * m_gp->SoftGain[index];
+			m_Double_Y[index] = m_alg->Gain_Ratio(m_Double_Y[index]);
+			m_alg->Rotation(m_gp->Degree[index],m_Double_X[index],
+					m_Double_Y[index],m_ET_X[index],m_ET_Y[index]);
+			m_ET_Y[index] = 0 - m_ET_Y[index];
+		}
+		m_alg->Calculate_Digital_Filter_Value(index,m_ET_X[index] ,m_ET_Y[index] );
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  After Processing Data, Get Data by this function
+ * =====================================================================================
+ */
+void OZKDataProcess::Get_Data(ETDATA *rawdata)
+{
+	uint64_t temp1  = 0;
+	uint64_t temp2  = 0;
+	ETDATA   temp3  = 0;
+	for ( int i=0;i<8;i++ )
+	{
+		temp1 = static_cast<uint64_t>(m_ET_X[i<<1])*static_cast<uint64_t>(m_ET_X[i<<1]) + static_cast<uint64_t>(m_ET_Y[i<<1])*static_cast<uint64_t>(m_ET_Y[i<<1]);
+		temp2 = static_cast<uint64_t>(m_ET_X[(i<<1)+1])*static_cast<uint64_t>(m_ET_X[(i<<1)+1]) + static_cast<uint64_t>(m_ET_Y[(i<<1)+1])*static_cast<uint64_t>(m_ET_Y[(i<<1)+1]);
+		temp3 = static_cast<ETDATA>(sqrt(temp1+temp2)*m_gp->SoftCrossGain[i]);
+
+		m_alg->Rotation(m_gp->CrossDegree[i],0,
+						    temp3,
+						    rawdata[i<<1],
+						    rawdata[(i<<1)+1]);
+	}
+}
diff --git a/src/EVA11/base/ConcreteDataProcess.h b/src/EVA11/base/ConcreteDataProcess.h
new file mode 100644
index 0000000..af4088a
--- /dev/null
+++ b/src/EVA11/base/ConcreteDataProcess.h
@@ -0,0 +1,110 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ConcreteDataProcess.h
+ *
+ *    Description:  Manage ZK Data procession
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月16日 14时28分10秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _CONCREATEDATAPROCESS_INC
+#define  _CONCREATEDATAPROCESS_INC
+
+#include 	"main.h"
+class IDataProcess;
+class ZKDataProcess : public IDataProcess
+{
+	public:
+		ZKDataProcess ();
+		virtual ~ZKDataProcess ();
+
+		virtual void Data_Process();
+		void Get_Data(ETDATA *rawdata);
+	protected:
+		ETDATA			m_ET_X[1];
+		ETDATA			m_ET_Y[1];
+
+		double			m_Double_X[1];
+		double			m_Double_Y[1];
+	private:
+};
+
+class DZKDataProcess : public IDataProcess
+{
+	public:
+		DZKDataProcess ();
+		virtual ~DZKDataProcess ();
+		virtual void Data_Process();
+		 
+		void Get_Data(ETDATA *rawdata);
+	protected:
+		ETDATA			m_ET_X[3];
+		ETDATA			m_ET_Y[3];
+
+		double			m_Double_X[3];
+		double			m_Double_Y[3];
+	private:
+};
+
+class CZKDataProcess : public IDataProcess
+{
+	public:
+		CZKDataProcess ();
+		virtual ~CZKDataProcess ();
+		virtual void Data_Process();
+		 
+		void Get_Data(ETDATA *rawdata);
+	protected:
+		ETDATA			m_ET_X[4];
+		ETDATA			m_ET_Y[4];
+
+		double			m_Double_X[4];
+		double			m_Double_Y[4];
+	private:
+};
+
+class ColorSpotDataProcess : public IDataProcess
+{
+	public:
+		ColorSpotDataProcess ();
+		virtual ~ColorSpotDataProcess ();
+		virtual void Data_Process ();
+
+		void Get_Data(ETDATA *rawdata);
+		void Get_InTimer(unsigned long long&);
+		void Get_OutTimer(unsigned long long&);
+	protected:
+		ETDATA			m_ET_X[Global::CHANCOUNT];
+		ETDATA			m_ET_Y[Global::CHANCOUNT];
+
+	private:
+};
+
+class OZKDataProcess : public IDataProcess
+{
+	public:
+		OZKDataProcess ();
+		virtual ~OZKDataProcess ();
+		virtual void Data_Process ();
+
+		void Get_Data(ETDATA *rawdata);
+	protected:
+		ETDATA			m_ET_X[16];
+		ETDATA			m_ET_Y[16];
+
+		double			m_Double_X[16];
+		double			m_Double_Y[16];
+	private:
+
+};
+
+#endif
diff --git a/src/EVA11/base/ConvertCode.cpp b/src/EVA11/base/ConvertCode.cpp
new file mode 100644
index 0000000..d7c5344
--- /dev/null
+++ b/src/EVA11/base/ConvertCode.cpp
@@ -0,0 +1,99 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ConvertCode.cpp
+ *
+ *    Description:  Implementation of ConvertCode class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月02日 13时52分33秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdio>
+#include 	"ConvertCode.h"
+std::auto_ptr<ConvertCode> ConvertCode::m_Instance;
+
+ConvertCode::ConvertCode ()
+{
+	m_CCode = 0;
+}
+
+ConvertCode::~ConvertCode ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+ConvertCode* ConvertCode::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new ConvertCode() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_CodeConvert
+ *  Description:  Init the Code Convert Class 
+ *  from and to:  utf-8                  vim code
+ *                WCHAR_T                wide text  FreeType used
+ *                gb18030>gbk>gb2312     normal program text
+ * =====================================================================================
+ */
+bool ConvertCode::Init_CodeConvert(const char* from,const char* to)
+{
+	m_CCode = 0;
+	m_CCode = iconv_open(to,from);
+	if ( m_CCode == 0 )
+	{
+		perror("Cant' open iconv");
+		return false;
+	}
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_CodeConvert
+ *  Description:  Destroy the Code Convert class 
+ * =====================================================================================
+ */
+void ConvertCode::Destory_CodeConvert()
+{
+	if ( m_CCode != 0 )
+	{
+		iconv_close(m_CCode);
+		m_CCode = 0;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Code_Convert
+ *  Description:  Code Convert Function
+ * =====================================================================================
+ */
+bool ConvertCode::Code_Convert(char *inbuf,int inlen,char *outbuf,int& outlen)
+{
+	char **pin = &inbuf;
+	char **pout = &outbuf;
+	if ( static_cast<int>((iconv(m_CCode,pin,(size_t *)&inlen,pout,(size_t *)&outlen))) == -1 )
+	{
+		perror("Convert fail");
+		return false;
+	}
+	return true;
+}
diff --git a/src/EVA11/base/ConvertCode.h b/src/EVA11/base/ConvertCode.h
new file mode 100644
index 0000000..f929b74
--- /dev/null
+++ b/src/EVA11/base/ConvertCode.h
@@ -0,0 +1,49 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ConvertCode.h
+ *
+ *    Description:  Manage Convert Code to other Code
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月02日 13时47分59秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _CONVERTCODE_INC
+#define  _CONVERTCODE_INC
+
+#include 	<memory>
+#include 	<iconv.h>
+
+class ConvertCode
+{
+	public:
+		static ConvertCode* Instance();
+
+		bool Init_CodeConvert(const char* from,const char* to);
+		void Destory_CodeConvert();
+
+		bool Code_Convert(char *inbuf,int inlen,char *outbuf,int& outlen);
+	protected:
+
+	private:
+		ConvertCode ();                             /* constructor */
+		~ConvertCode ();                            /* destructor  */
+		ConvertCode (const ConvertCode&);           /* constructor */
+		ConvertCode operator = (const ConvertCode&);
+
+	private:
+		friend class std::auto_ptr<ConvertCode>;
+		static std::auto_ptr<ConvertCode>	    m_Instance;
+
+		iconv_t 				    m_CCode;
+};
+
+#endif   /* ----- #ifndef _CONVERTCODE_INC  ----- */
diff --git a/src/EVA11/base/DEPS/README b/src/EVA11/base/DEPS/README
new file mode 100644
index 0000000..e69de29
diff --git a/src/EVA11/base/DFilter.cpp b/src/EVA11/base/DFilter.cpp
new file mode 100644
index 0000000..e001e25
--- /dev/null
+++ b/src/EVA11/base/DFilter.cpp
@@ -0,0 +1,149 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DFilter.cpp
+ *
+ *    Description:  Implementation of DFilter class 
+ *
+ *        Version:  1.0
+ *        Created:  2013年06月14日 15时59分17秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include	<cstdio>
+#include 	"main.h"
+#include	"DFilter.h"
+
+struct DFilter::DFP 
+{
+	ETDATA              *bufx;
+	ETDATA              *bufy;
+	int                 capacity;
+	int                 max;
+	unsigned long long  sumx;
+	unsigned long long  sumy;
+	unsigned char       shiftv;
+	int                 index;
+	bool                overf;
+};
+
+struct DFilter::PImpl
+{
+	DFP 		dfp;
+};
+
+DFilter::DFilter() : m_Imple(new struct PImpl)
+{
+	m_Imple->dfp.capacity   = 256;
+	m_Imple->dfp.max        = m_Imple->dfp.capacity;
+	m_Imple->dfp.index      = 0; 
+	m_Imple->dfp.overf      = false;
+	m_Imple->dfp.sumx       = 0;
+	m_Imple->dfp.sumy       = 0;
+	m_Imple->dfp.shiftv     = 8;
+	m_Imple->dfp.bufx       = NULL; 
+	m_Imple->dfp.bufy       = NULL; 
+
+	m_Imple->dfp.bufx        = new ETDATA[m_Imple->dfp.capacity];
+	m_Imple->dfp.bufy        = new ETDATA[m_Imple->dfp.capacity];
+
+	for ( int index=0;index<m_Imple->dfp.max;index++ )
+	{
+		m_Imple->dfp.bufx[index] = 0;
+		m_Imple->dfp.bufy[index] = 0;
+	}
+}
+
+DFilter::~DFilter()
+{
+	if ( m_Imple->dfp.bufx != NULL ) 
+	{
+		delete[] m_Imple->dfp.bufx;
+		m_Imple->dfp.bufx = NULL;
+	}
+	if ( m_Imple->dfp.bufy != NULL ) 
+	{
+		delete[] m_Imple->dfp.bufy;
+		m_Imple->dfp.bufy = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_MAX_Value
+ *  Description:  When chang the signal channel call this function init the parameters 
+ *  Note:
+ *                value:   from 0 to 7 
+ * =====================================================================================
+ */
+void DFilter::Reset_MAX_Value(int value)
+{
+	if 	( value == 0 )
+	{
+		m_Imple->dfp.max = 0;
+		return;
+	}
+
+	m_Imple->dfp.max    = (1<<value);
+	m_Imple->dfp.index  = 0; 
+	m_Imple->dfp.overf  = false;
+	m_Imple->dfp.shiftv = value;
+	m_Imple->dfp.sumx   = 0;
+	m_Imple->dfp.sumy   = 0;
+
+	for ( int index=0;index<m_Imple->dfp.max;index++ )
+	{
+		m_Imple->dfp.bufx[index] = 0;
+		m_Imple->dfp.bufy[index] = 0;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Digital_Filter_Value
+ *  Description:  Calculate the Digital Filter Value of device
+ * =====================================================================================
+ */
+void DFilter::Calculate_Digital_Filter_Value(ETDATA& x,ETDATA& y)
+{
+	if 	( m_Imple->dfp.max == 0 ) return;
+
+	if 	( m_Imple->dfp.overf == false ) 
+	{
+		m_Imple->dfp.bufx[m_Imple->dfp.index] = x;
+		m_Imple->dfp.bufy[m_Imple->dfp.index] = y;
+
+		m_Imple->dfp.sumx += x;
+		m_Imple->dfp.sumy += y;
+		m_Imple->dfp.index ++;
+
+		if 	( m_Imple->dfp.index == m_Imple->dfp.max )
+		{
+			m_Imple->dfp.overf = true;
+			m_Imple->dfp.index = 0;
+		}
+	}
+	else
+	{
+		m_Imple->dfp.sumx = m_Imple->dfp.sumx + x - m_Imple->dfp.bufx[m_Imple->dfp.index];
+		m_Imple->dfp.sumy = m_Imple->dfp.sumy + y - m_Imple->dfp.bufy[m_Imple->dfp.index];
+
+		m_Imple->dfp.bufx[m_Imple->dfp.index] = x;
+		m_Imple->dfp.bufy[m_Imple->dfp.index] = y;
+
+		m_Imple->dfp.index ++;
+
+		if ( m_Imple->dfp.index == m_Imple->dfp.max )
+		{
+			m_Imple->dfp.index = 0;
+		}
+		x = ( m_Imple->dfp.sumx >> m_Imple->dfp.shiftv ); 
+		y = ( m_Imple->dfp.sumy >> m_Imple->dfp.shiftv ); 
+	}
+}
diff --git a/src/EVA11/base/DFilter.h b/src/EVA11/base/DFilter.h
new file mode 100644
index 0000000..dccb8e9
--- /dev/null
+++ b/src/EVA11/base/DFilter.h
@@ -0,0 +1,42 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DFilter.h
+ *
+ *    Description:  For the Digital Filter Algorithm
+ *
+ *        Version:  1.0
+ *        Created:  2010年03月26日 19时07分26秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  DFilter_INC
+#define  DFilter_INC
+
+#include 	<memory>	
+#include 	"main.h"
+
+class DFilter
+{
+	public:
+		DFilter ();                             /* constructor */
+		~DFilter ();                            /* destructor  */
+
+		void Reset_MAX_Value(int value);
+		void Calculate_Digital_Filter_Value(ETDATA& x,ETDATA& y);
+	protected:
+
+	private:
+		struct DFP;
+		struct PImpl;
+		std::auto_ptr<struct PImpl>		m_Imple;
+
+}; /* -----  end of class DFilter  ----- */
+
+#endif   /* ----- #ifndef DFilter_INC  ----- */
diff --git a/src/EVA11/base/DZKPanel.cpp b/src/EVA11/base/DZKPanel.cpp
new file mode 100644
index 0000000..9119f52
--- /dev/null
+++ b/src/EVA11/base/DZKPanel.cpp
@@ -0,0 +1,1155 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DZKPanel.cpp
+ *
+ *    Description:  Manage of DZKPanel class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月08日 09时33分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<new>
+#include 	<sstream>
+#include 	<string>	
+
+#include 	"Object.h"
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Global.h"
+#include 	"Bufferbar.h"
+#include 	"Device.h"
+#include 	"DataRepo.h"
+#include 	"Label.h"
+#include 	"FreeType.h"
+
+#include 	"Msgbox.h"
+
+#include 	"AlarmManage.h"
+#include	"MixingManage.h"
+#include 	"Basescreen.h"
+#include 	"ZScreen.h"
+#include 	"Language.h"
+#include 	"Algorithm.h"
+
+#include 	"BasePanel.h"
+#include 	"DZKPanel.h"
+
+#include 	"Logic.h"
+
+#include 	"Resource.h"
+
+const static  std::string AlarmText[8] = {CSTRING_A,CSTRING_B,CSTRING_C,CSTRING_D,CSTRING_E,CSTRING_F,CSTRING_G,CSTRING_H};
+
+DZKPanel::DZKPanel (int x,int y,int width,int heigh)
+	: BasePanel(x,y,width,heigh)
+{
+}
+
+DZKPanel::~DZKPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void DZKPanel::Init_GUI(Graphic& g)
+{
+	Global *gp = Global::Instance();
+
+	Init_ZScreen_Object(g);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		if 	( gp->DrawMode2[i] == 0 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
+		else if ( gp->DrawMode2[i] == 1 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
+		else if ( gp->DrawMode2[i] == 2 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::AUTO);
+	}
+
+	m_Bufbar = new Bufferbar(2,2,532,6);
+	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
+	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
+	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
+
+	m_LabAlarmSt[0] = new Label(3,9,30,32);
+	m_LabAlarmSt[1] = new Label(235+265+2,9,30,32);
+
+	m_LabFreMsg[1] = new Label(131+1*265+1,8,104,18);
+	m_LabAMPMsg[1] = new Label(131+1*265+1,25,104,18);
+	m_LabPHAMsg[1] = new Label(42+1*265+1,25,90,18);
+	m_LabCHAMsg[1] = new Label(42+1*265+1,8,90,18);
+
+	m_LabFreMsg[0] = new Label(131+0*265-8,8,104,18);
+	m_LabAMPMsg[0] = new Label(131+0*265-8,25,104,18);
+	m_LabPHAMsg[0] = new Label(42+0*265-8,25,90,18);
+	m_LabCHAMsg[0] = new Label(42+0*265-8,8,90,18);
+
+	for ( int i=0;i<2;i++ )
+	{
+		m_LabFreMsg[i]->Set_Label_Type(Label::LA_THIN);
+		m_LabFreMsg[i]->Set_Font_Size(16);
+		m_LabFreMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_LabFreMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+		m_LabFreMsg[i]->Set_Text(" ");
+
+		m_LabAMPMsg[i]->Set_Label_Type(Label::LA_THIN);
+		m_LabAMPMsg[i]->Set_Font_Size(16);
+		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_LabAMPMsg[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_LabAMPMsg[i]->Set_Focus(true);
+		m_LabAMPMsg[i]->Set_Text(" ");
+
+		m_LabPHAMsg[i]->Set_Label_Type(Label::LA_THIN);
+		m_LabPHAMsg[i]->Set_Font_Size(16);
+		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_LabPHAMsg[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_LabPHAMsg[i]->Set_Focus(true);
+		m_LabPHAMsg[i]->Set_Text(" ");
+
+		m_LabCHAMsg[i]->Set_Label_Type(Label::LA_THIN);
+		m_LabCHAMsg[i]->Set_Font_Size(16);
+		m_LabCHAMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_LabCHAMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+		m_LabCHAMsg[i]->Set_Display_Type(Label::LA_DT_LEFT);
+		m_LabCHAMsg[i]->Set_Text(" ");
+
+		m_LastStatus[i] = 0xff;
+
+		m_LabAlarmSt[i]->Set_Label_Type(Label::LA_THIN);
+		m_LabAlarmSt[i]->Set_Font_Size(24);
+		m_LabAlarmSt[i]->Set_Text(" ");
+		m_LabAlarmSt[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_LabAlarmSt[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	}
+
+	m_gp->bDoubleSrcPause = false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm Parameters from Global 
+ *                When Load Para from device call this function
+ * =====================================================================================
+ */
+void DZKPanel::Load_Alarm_Para()
+{
+	Global* gp = Global::Instance();
+	if ( gp->bDNeedResetAlarmArea == true )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_AlarmManage[i]->Set_Alarm_Type(gp->DAlarmType[i]);
+			for ( int j=0;j<3;j++ )
+			{
+				m_AlarmManage[i]->Set_Alarm_Count(j,gp->DAlarmCount[i][j]);
+				m_AlarmManage[i]->Set_Alarm_Index(j,gp->DAlarmIndex[i][j]);
+			}
+			m_AlarmManage[i]->Load_Alarm_Para(gp->DAlarmPara[i]);
+		}
+
+		m_AlarmManage[0]->Create_Alarm_Area_Mask();
+		m_AlarmManage[1]->Create_Alarm_Area_Mask();
+		gp->bDNeedResetAlarmArea = false;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void DZKPanel::Destroy_GUI()
+{
+	for ( int i=0;i<2;i++ )
+	{
+		if ( m_LabFreMsg[i] != NULL )
+		{
+			delete m_LabFreMsg[i];
+			m_LabFreMsg[i] = NULL;
+		}
+
+		if ( m_LabAMPMsg[i] != NULL )
+		{
+			delete m_LabAMPMsg[i];
+			m_LabAMPMsg[i] = NULL;
+		}
+
+		if ( m_LabPHAMsg[i] != NULL )
+		{
+			delete m_LabPHAMsg[i];
+			m_LabPHAMsg[i] = NULL;
+		}
+
+		if ( m_LabCHAMsg[i] != NULL )
+		{
+			delete m_LabCHAMsg[i];
+			m_LabCHAMsg[i] = NULL;
+		}
+
+		if ( m_LabAlarmSt[i] != NULL )
+		{
+			delete m_LabAlarmSt[i];
+			m_LabAlarmSt[i] = NULL;
+		}
+	}
+
+	if ( m_Bufbar != NULL )
+	{
+		delete m_Bufbar;
+		m_Bufbar = NULL;
+	}
+
+	Destroy_ZScreen_Object();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_ZScreen_Object
+ *  Description:  Init the ZScreen GUI Object 
+ * =====================================================================================
+ */
+void DZKPanel::Init_ZScreen_Object(Graphic& g)
+{
+	Global *gp = Global::Instance();
+
+	m_DataProcess = new DZKDataProcess;
+
+	m_Zscreen[0] = new Zscreen(2,13+31,265,399);
+	m_Zscreen[1] = new Zscreen(2+265,13+31,265,399);
+
+	m_Zscreen[0]->Set_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
+	m_Zscreen[1]->Set_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_ID(i+1);
+
+		Refresh_ZKScreen_Focus(g,false);
+	}
+
+	m_AlarmManage[0] = new(std::nothrow) AlarmManage(2,13+31,265,430-31);
+	m_AlarmManage[1] = new(std::nothrow) AlarmManage(2+265,13+31,265,430-31);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_AlarmManage[i]->Init_Alarm_Sets(g);
+
+	gp->bDNeedResetAlarmArea = true;                    // Notice when init we need let OZK to load alarm para
+	Load_Alarm_Para();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_ZScreen_Object
+ *  Description:  Destroy the ZScreen GUI Object
+ * =====================================================================================
+ */
+void DZKPanel::Destroy_ZScreen_Object()
+{
+	if 	( m_DataProcess != NULL )
+	{
+		delete m_DataProcess;
+		m_DataProcess = NULL;
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		if ( m_Zscreen[i] != NULL )
+		{
+			delete m_Zscreen[i];
+			m_Zscreen[i] = NULL;
+		}
+
+		m_AlarmManage[i]->Destroy_Alarm_Sets();
+		if ( m_AlarmManage[i] != NULL )
+		{
+			delete m_AlarmManage[i];
+			m_AlarmManage[i] = NULL;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void DZKPanel::Drawme(Graphic& g,bool flag)
+{
+	DataRepo *datarepo = DataRepo::Instance();
+	if ( flag == true )
+		g.Switch_Screen();
+
+	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
+
+	Refresh_FREQ(g);
+	Refresh_Signal(g);
+	Swtich_Status(g);
+
+	for ( int i=0;i<2;i++ )
+	{
+		m_LabFreMsg[i]->Drawme(g,false);
+		m_LabAMPMsg[i]->Drawme(g,false);
+		m_LabPHAMsg[i]->Drawme(g,false);
+		m_LabCHAMsg[i]->Drawme(g,false);
+		m_LabAlarmSt[i]->Drawme(g,false);
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Drawme(g,false);
+		m_AlarmManage[i]->Draw_Alarm_Sets(g,false);
+	}
+
+//	m_Chart->Drawme(g,false);
+
+	if ( flag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_ZKScreen
+ *  Description:  Clean the ZKScreen 
+ * =====================================================================================
+ */
+void DZKPanel::Clean_ZKScreen(Graphic&g)
+{
+	m_LabFreMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+	m_LabCHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+	m_LabAlarmSt[m_gp->ScrSigFocus]->Drawme(g,true);
+
+	m_LabAMPMsg[m_gp->ScrSigFocus]->Set_Text(" ");
+	m_LabPHAMsg[m_gp->ScrSigFocus]->Set_Text(" ");
+	m_LabAMPMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+	m_LabPHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+
+	m_Zscreen[m_gp->ScrSigFocus]->Drawme(g,true);
+	m_AlarmManage[m_gp->ScrSigFocus]->Draw_Alarm_Sets(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  important function, deal with data
+ * =====================================================================================
+ */
+int DZKPanel::Loop_Panel(Graphic& g)
+{
+	if 	( m_gp->bDoubleSrcPause == true )
+		return 0;
+	m_DataProcess->Data_Process();
+	m_DataProcess->Get_Data(m_RawBuf);
+	int x,y;
+	int result;
+	for ( int i=0;i<2;i++ )
+	{
+		m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[(m_gp->ScrSigM[i]<<1)],m_RawBuf[(m_gp->ScrSigM[i]<<1)+1]);
+		m_Zscreen[i]->Get_SX_SY(x,y);
+		result = m_AlarmManage[i]->Is_In_Alarm(x,y);
+		if 	(  result != 0xff )
+		{
+			if 	( result != m_LastStatus[i] )
+			{
+				m_LabAlarmSt[i]->Set_Text(AlarmText[result].c_str());
+				m_LabAlarmSt[i]->Drawme(g);
+				m_LastStatus[i] = result;
+			}
+		}
+		else
+		{
+			if 	( result != m_LastStatus[i] )
+			{
+				m_LabAlarmSt[i]->Set_Text(" ");
+				m_LabAlarmSt[i]->Drawme(g);
+				m_LastStatus[i] = result;
+			}
+		}
+	}
+	m_Bufbar->Save_Bytes_Number(g,2<<2);
+
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void DZKPanel::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor  = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+	font->Text(x+30,y+90,pl->GetText(HELPB1F2));
+	font->Text(x+30,y+110,pl->GetText(HELPB1F3));
+	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
+	font->Text(x+30,y+150,pl->GetText(HELPB1F5));
+	font->Text(x+30,y+170,pl->GetText(HELPB1F6));
+	font->Text(x+30,y+190,pl->GetText(HELPB1F7));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Panel
+ *  Description:  Switch panel call this function 
+ * =====================================================================================
+ */
+void DZKPanel::Switch_Panel()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+
+	for ( int ch=0;ch<2;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 1;			// ECT
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int ch=2;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 0;		       // CLOSE
+		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	device->Write_Para_Driver(m_gp->Driver);
+	device->Write_Para_Offset(m_gp->Offset);
+	device->Write_Para_SignalWave(0);
+
+	device->Transfer_ECT_Parameters();
+
+	Load_Alarm_Para();
+
+	m_DataProcess->Trigger_Balacne_Process();       // very Important
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_AMP_PHA
+ *  Description:  Display the AMP and PHA value 
+ * =====================================================================================
+ */
+void DZKPanel::Refresh_AMP_PHA(Graphic& g)
+{
+	std::stringstream strtmp;
+	strtmp<<"A:"<<m_Zscreen[m_gp->ScrSigFocus]->Get_AMP();
+	std::string str(strtmp.str());
+	m_LabAMPMsg[m_gp->ScrSigFocus]->Set_Text(str.c_str());
+	m_LabAMPMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+
+	strtmp.clear();
+	strtmp.str("");
+	str.clear();
+
+	strtmp<<"P:"<<m_Zscreen[m_gp->ScrSigFocus]->Get_PHA();
+	str = strtmp.str();
+	m_LabPHAMsg[m_gp->ScrSigFocus]->Set_Text(str.c_str());
+	m_LabPHAMsg[m_gp->ScrSigFocus]->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_FREQ
+ *  Description:  Display Frequence value 
+ * =====================================================================================
+ */
+void DZKPanel::Refresh_FREQ(Graphic& g)
+{
+	char *msg = new char[100];
+
+	Logic *m_lo = Logic::Instance();
+	if ( m_gp->ScrSigM[0] < 2 )
+		m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[0]]],msg);
+	else
+		sprintf(msg,"%s"," ");
+	m_LabFreMsg[0]->Set_Text(msg);
+
+	if ( m_gp->ScrSigM[1] < 2 )
+		m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[1]]],msg);
+	else 
+		sprintf(msg,"%s"," ");
+	m_LabFreMsg[1]->Set_Text(msg);
+
+	delete[] msg;
+	msg = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Signal
+ *  Description:  
+ * =====================================================================================
+ */
+void DZKPanel::Refresh_Signal(Graphic& g)
+{
+	char *msg = new char[100];
+
+	if 	( m_gp->ScrSigM[0] < 2 )
+	{
+		if 	( m_gp->ProbeFun[m_gp->ScrSigM[0]] == 0 )
+			sprintf(msg," S%d OFF",m_gp->ScrSigM[0]+1);
+		else
+		{
+			Logic *m_lo = Logic::Instance();
+			m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[0]+1,m_gp->ProbeFun[m_gp->ScrSigM[0]],m_gp->FreqIndex[m_gp->ScrSigM[0]]+1,msg);
+		}
+	}
+	else
+	{
+		if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[0]-2]] == 0 ||  
+			  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[0]-2]] == 0 )
+		{
+			sprintf(msg,"%s"," M%d:SX OFF");
+		}
+		else
+			sprintf(msg," M%d:S%d-S%d",m_gp->ScrSigM[0]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[0]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[0]-2]+1);
+	}
+	m_LabCHAMsg[0]->Set_Text(msg);
+
+	if 	( m_gp->ScrSigM[1] < 2 )
+	{
+		if 	( m_gp->ProbeFun[m_gp->ScrSigM[1]] == 0 )
+			sprintf(msg," S%d OFF",m_gp->ScrSigM[1]+1);
+		else
+		{
+			Logic *m_lo = Logic::Instance();
+			m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[1]+1,m_gp->ProbeFun[m_gp->ScrSigM[1]],m_gp->FreqIndex[m_gp->ScrSigM[1]]+1,msg);
+		}
+	}
+	else
+	{
+		if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[1]-2]] == 0 ||  
+			  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[1]-2]] == 0 )
+		{
+			sprintf(msg,"%s"," M%d:SX OFF");
+		}
+		else
+			sprintf(msg," M%d:S%d-S%d",m_gp->ScrSigM[1]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[1]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[1]-2]+1);
+	}
+	m_LabCHAMsg[1]->Set_Text(msg);
+
+	delete[] msg;
+	msg = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Status
+ *  Description:  When stop the signal switch the system status 
+ * =====================================================================================
+ */
+void DZKPanel::Swtich_Status(Graphic& g)
+{
+	if 	( m_gp->bDoubleSrcPause == true )
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,8,253,15);
+	}
+	else
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,9,253,15);
+	}
+}
+
+int DZKPanel::Key_NL2_Fun(Graphic& g,int sub)
+{
+	Refresh_Signal(g);
+	Refresh_FREQ(g);
+	m_LabCHAMsg[0]->Drawme(g,true);
+	m_LabCHAMsg[1]->Drawme(g,true);
+	m_LabFreMsg[0]->Drawme(g,true);
+	m_LabFreMsg[1]->Drawme(g,true);
+	return 0;
+}
+int DZKPanel::Key_NR2_Fun(Graphic& g,int sub)
+{
+	Refresh_Signal(g);
+	Refresh_FREQ(g);
+	m_LabCHAMsg[0]->Drawme(g,true);
+	m_LabCHAMsg[1]->Drawme(g,true);
+	m_LabFreMsg[0]->Drawme(g,true);
+	m_LabFreMsg[1]->Drawme(g,true);
+	return 0;
+}
+int DZKPanel::Key_NL4_Fun(Graphic& g,int sub)         // gain
+{
+	m_gp->bDoubleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int DZKPanel::Key_NR4_Fun(Graphic& g,int sub)         // gain
+{
+	m_gp->bDoubleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int DZKPanel::Key_NL5_Fun(Graphic& g,int sub)
+{
+	Refresh_FREQ(g);
+	m_LabFreMsg[0]->Drawme(g,true);
+	m_LabFreMsg[1]->Drawme(g,true);
+	return 0;
+}
+int DZKPanel::Key_NR5_Fun(Graphic& g,int sub)
+{
+	Refresh_FREQ(g);
+	m_LabFreMsg[0]->Drawme(g,true);
+	m_LabFreMsg[1]->Drawme(g,true);
+	return 0;
+}
+int DZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bDoubleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int DZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bDoubleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus]);
+	Refresh_AMP_PHA(g);
+	return 0;
+}
+int DZKPanel::Key_Enter_Fun(Graphic& g)
+{
+	m_gp->bDoubleSrcPause = false;
+	Do_Enter_Fun(g);
+	return 0;
+}
+		
+void DZKPanel::Do_Enter_Fun(Graphic& g)
+{
+	Swtich_Status(g);
+
+	m_LabFreMsg[0]->Drawme(g,true);
+	m_LabCHAMsg[0]->Drawme(g,true);
+	m_LabAlarmSt[0]->Drawme(g,true);
+
+	m_LabFreMsg[1]->Drawme(g,true);
+	m_LabCHAMsg[1]->Drawme(g,true);
+	m_LabAlarmSt[1]->Drawme(g,true);
+
+	m_LabAMPMsg[0]->Set_Text(" ");
+	m_LabPHAMsg[0]->Set_Text(" ");
+	m_LabAMPMsg[0]->Drawme(g,true);
+	m_LabPHAMsg[0]->Drawme(g,true);
+
+	m_LabAMPMsg[1]->Set_Text(" ");
+	m_LabPHAMsg[1]->Set_Text(" ");
+	m_LabAMPMsg[1]->Drawme(g,true);
+	m_LabPHAMsg[1]->Drawme(g,true);
+
+	m_Zscreen[0]->Drawme(g,true);
+	m_Zscreen[1]->Drawme(g,true);
+	m_AlarmManage[0]->Draw_Alarm_Sets(g,true);
+	m_AlarmManage[1]->Draw_Alarm_Sets(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_FX_Fun
+ *  Description:  Shot Functions 
+ * =====================================================================================
+ */
+int DZKPanel::Key_F2_Fun(Graphic& g)
+{
+	if 	( m_gp->bDoubleSrcPause == false )
+		Clean_ZKScreen(g);
+	else
+	{
+		Language *m_pl = Language::Instance();
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		if 	( ms->Showme(g) == true )
+		{
+			delete ms;
+			ms = NULL;
+			m_Zscreen[m_gp->ScrSigFocus]->Clean_Photo();
+			m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
+			return 0; 
+		}
+		delete ms;
+		ms = NULL;
+	}
+	return 0;
+}
+int DZKPanel::Key_F3_Fun(Graphic& g)
+{
+	if 	( m_gp->DrawMode2[m_gp->ScrSigFocus] == 0 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 1;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::LINE);
+	}
+	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus] == 1 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 2;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::AUTO);
+	}
+	else if ( m_gp->DrawMode2[m_gp->ScrSigFocus]== 2 )
+	{
+		m_gp->DrawMode2[m_gp->ScrSigFocus] = 0;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Draw_Mode(Zscreen::POINT);
+	}
+	m_Zscreen[m_gp->ScrSigFocus]->Reset_Trace();
+	return 0;
+}
+int DZKPanel::Key_F4_Fun(Graphic& g)
+{
+	if 	( m_gp->bDoubleSrcPause == false )
+		m_DataProcess->Trigger_Balacne_Process();
+	else
+	{
+		m_Zscreen[m_gp->ScrSigFocus]->Save_Photo(g);
+		m_Zscreen[m_gp->ScrSigFocus]->Drawme(g);
+	}
+	return 0;
+}
+int DZKPanel::Key_F6_Fun(Graphic& g)
+{
+	Language* m_pl = Language::Instance();
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == false )
+	{
+		delete ms;
+		ms = NULL;
+		return 0;
+	}
+	delete ms;
+	ms = NULL;
+	m_Bufbar->Clean_Buffer_Bar(g);
+	return 0;
+}
+
+int DZKPanel::Key_F7_Fun(Graphic& g)
+{
+	int callen = 10000;
+	if 	( m_gp->bDoubleSrcPause == false )
+	{
+		m_gp->bDoubleSrcPause = true;
+		Swtich_Status(g);
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+		return 0;
+	}
+
+	m_Zscreen[m_gp->ScrSigFocus]->Mixing_Parameters_Calculate(g,callen,100);
+	m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+
+	Language* m_pl = Language::Instance();
+	MixingManage *algm = MixingManage::Instance();
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(SAVEMIXCOMFIRM),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	ms->Set_Transparce(120);
+	if ( ms->Showme(g) == true )
+	{
+		algm->Sync_Mixing_Para(true);
+		delete ms;
+		ms = NULL;
+	}
+	else
+	{
+		algm->Sync_Mixing_Para(false);
+		delete ms;
+		ms = NULL;
+		m_Zscreen[m_gp->ScrSigFocus]->Set_Gain_Degree_ReDraw(g,m_gp->ScrSigM[m_gp->ScrSigFocus],callen,100);
+	}
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
+/* --------------------------------------------------------------------- */
+int DZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->ScrSigFocus == 0 ) gp->ScrSigFocus = 1;
+		else gp->ScrSigFocus --;
+		Refresh_ZKScreen_Focus(g,true);
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 0 )
+				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]];
+			else
+				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] -= 1; 
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
+		}
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->ScrSigFocus == 1 ) gp->ScrSigFocus = 0;
+		else gp->ScrSigFocus ++;
+		Refresh_ZKScreen_Focus(g,true);
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 7 || 
+					gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] >= gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]])
+			{
+				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 0;
+			}
+			else
+				gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] += 1;
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Index(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
+		}
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 0  ) gp->DAlarmType[gp->ScrSigFocus] = 3;
+		else gp->DAlarmType[gp->ScrSigFocus] --;
+		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->DAlarmType[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 3  ) gp->DAlarmType[gp->ScrSigFocus] = 0;
+		else gp->DAlarmType[gp->ScrSigFocus] ++;
+		m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Type(gp->DAlarmType[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P1((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 0 )
+				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 7;
+			else
+			{
+				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] --;
+				if ( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] < gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] )
+				{
+					gp->DAlarmIndex[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]];
+				}
+			}
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
+		}
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->DAlarmType[gp->ScrSigFocus] == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] == 7 )
+				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] = 0;
+			else
+				gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]] ++;
+			m_AlarmManage[gp->ScrSigFocus]->Set_Alarm_Count(gp->DAlarmType[gp->ScrSigFocus],gp->DAlarmCount[gp->ScrSigFocus][gp->DAlarmType[gp->ScrSigFocus]]);
+		}
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P2((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P3((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage[gp->ScrSigFocus]->Adj_P4((m_gp->MultiKey*2 + 1),gp->DAlarmPara[gp->ScrSigFocus]);
+		Drawme(g,true);
+		gp->bDNeedResetAlarmArea = true;
+	}
+	return 0;
+}
+int DZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+//	else if ( sub == 2 )
+//	{
+//		m_AlarmManage[0]->Test(g);
+//		m_AlarmManage[1]->Test(g);
+//	}
+	return 0;
+}
+int DZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+//	else if ( sub == 2 )
+//	{
+//		m_AlarmManage[0]->Test(g);
+//		m_AlarmManage[1]->Test(g);
+//	}
+	return 0;
+}
+
+int DZKPanel::Para_NL1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::LEFT,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
+	}
+	return 0;
+}
+int DZKPanel::Para_NR1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
+	}
+	return 0;
+}
+int DZKPanel::Para_NL2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::UP,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
+	}
+	return 0;
+}
+int DZKPanel::Para_NR2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[0]->Adjust_Center_Point(g,Zscreen::DOWN,3);
+		m_Zscreen[0]->Get_Center_Point(m_gp->DoubleCentX1,m_gp->DoubleCentY1);
+	}
+	return 0;
+}
+int DZKPanel::Para_NL3_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::LEFT,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
+	}
+	return 0;
+}
+int DZKPanel::Para_NR3_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
+	}
+	return 0;
+}
+int DZKPanel::Para_NL4_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::UP,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
+	}
+	return 0;
+}
+int DZKPanel::Para_NR4_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen[1]->Adjust_Center_Point(g,Zscreen::DOWN,3);
+		m_Zscreen[1]->Get_Center_Point(m_gp->DoubleCentX2,m_gp->DoubleCentY2);
+	}
+	return 0;
+}
+
+int DZKPanel::Key_NL1_Fun(Graphic& g,int sub)
+{
+	Refresh_ZKScreen_Focus(g,true);
+	return 0;
+}
+int DZKPanel::Key_NR1_Fun(Graphic& g,int sub)
+{
+	Refresh_ZKScreen_Focus(g,true);
+	return 0;
+}
+void DZKPanel::Refresh_ZKScreen_Focus(Graphic&g,bool flag)
+{
+	for ( int i=0;i<2;i++ )
+	{
+		if ( i == m_gp->ScrSigFocus )
+			m_Zscreen[i]->Set_Focus(g,true,flag);
+		else
+			m_Zscreen[i]->Set_Focus(g,false,flag);
+	}
+}
diff --git a/src/EVA11/base/DZKPanel.h b/src/EVA11/base/DZKPanel.h
new file mode 100644
index 0000000..39bdffb
--- /dev/null
+++ b/src/EVA11/base/DZKPanel.h
@@ -0,0 +1,112 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DZKPanel.h
+ *
+ *    Description:  Double ZK Panel manage class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月08日 09时30分46秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _DZKPANEL_INC
+#define  _DZKPANEL_INC
+
+class BasePanel;
+class Zscreen;
+class Bufferbar;
+class DZKDataProcess;
+class AlarmManage;
+class Label;
+class Chart;
+class DZKPanel : public BasePanel
+{
+	public:
+		DZKPanel (int x,int y,int width,int heigh);
+		~DZKPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+		virtual int Key_F7_Fun(Graphic& g);
+
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
+
+		virtual void Switch_Panel();
+		virtual void Swtich_Status(Graphic& g);
+	protected:
+		virtual void Init_ZScreen_Object(Graphic& g);
+		virtual void Destroy_ZScreen_Object();
+		virtual void Load_Alarm_Para();
+
+		void Refresh_ZKScreen_Focus(Graphic&g,bool flag);
+		void Clean_ZKScreen(Graphic&g);
+		void Refresh_AMP_PHA(Graphic& g);
+		void Refresh_FREQ(Graphic& g);
+		void Refresh_Signal(Graphic& g);
+
+		void Do_Enter_Fun(Graphic& g);
+
+	protected:
+		const static int			m_cMAXScreenCount = 2;
+		Label*					m_LabFreMsg[2];
+		Label*					m_LabAMPMsg[2];
+		Label*					m_LabPHAMsg[2];
+		Label*					m_LabCHAMsg[2];
+
+		Label*					m_LabAlarmSt[2];
+		Bufferbar				*m_Bufbar;
+		Zscreen					*m_Zscreen[m_cMAXScreenCount];
+		AlarmManage				*m_AlarmManage[m_cMAXScreenCount];
+		int					m_LastStatus[2];
+	private:
+		DZKDataProcess    			*m_DataProcess;
+};
+#endif
diff --git a/src/EVA11/base/DataRepo.cpp b/src/EVA11/base/DataRepo.cpp
new file mode 100644
index 0000000..fcbd8ea
--- /dev/null
+++ b/src/EVA11/base/DataRepo.cpp
@@ -0,0 +1,305 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DataRepo.cpp
+ *
+ *    Description:  Implemntaion of DataRepo class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月17日 17时11分34秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdlib>
+#include 	<cstdio>
+#include 	<fstream>
+#include 	<new>
+
+#include 	<zlib.h>
+
+#include 	"DataRepo.h"
+
+std::auto_ptr<DataRepo> DataRepo::m_Instance;
+DataRepo::DataRepo ()
+{
+}
+
+DataRepo::~DataRepo ()
+{
+	m_Instance->Release_Data_Repo();
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+DataRepo* DataRepo::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new DataRepo() );
+		if ( m_Instance.get()->Init_Data_Repo(m_cMAXCapacity) == false )
+			printf ( "Init data fail\n" );
+	}
+	return m_Instance.get();
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Data_Repo
+ *  Description:  Init the Data Repo 
+ * =====================================================================================
+ */
+bool DataRepo::Init_Data_Repo(uint64_t capacity)
+{
+	m_Capacity        = capacity;
+	m_Buffer_Overflow = false;
+	m_Data_Index	  = 0;
+	m_Data_MAXCount   = m_Capacity;
+	m_Each_Loop_Count = 16;
+	
+	m_Each_Loop_ShiftCount = 0;
+	while( m_Each_Loop_Count != 1 )
+	{
+		m_Each_Loop_ShiftCount ++;
+		m_Each_Loop_Count = m_Each_Loop_Count >> 1;
+	}
+	m_Each_Loop_Count = 16;
+
+	m_Data_Buffer     = new(std::nothrow) ETDATA[m_Capacity];
+	if ( m_Data_Buffer == NULL )
+		return false;
+
+	if 	( m_Data_Buffer != NULL )
+	{
+		for ( uint64_t i=0;i<(m_Capacity>>1);i++ )
+		{
+			*(uint64_t  *)(m_Data_Buffer+(i<<1)) = 0;
+		}
+		return true;
+	}
+
+	return false;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_Data_Repo
+ *  Description:  Release the Data Repo 
+ * =====================================================================================
+ */
+void DataRepo::Release_Data_Repo()
+{
+	if ( m_Data_Buffer != NULL )
+	{
+		delete[] m_Data_Buffer;
+		m_Data_Buffer = NULL;
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_Data_Repo
+ *  Description:  When User changer the databuffer, call it
+ *          len:  words count
+ * =====================================================================================
+ */
+void DataRepo::Reset_Data_Repo(uint64_t len,int32_t loop_count)
+{
+	m_Buffer_Overflow = false;
+	m_Data_Index	  = 0;
+	m_Data_MAXCount   = len;
+	m_Each_Loop_Count = loop_count;
+	m_Each_Loop_ShiftCount = 0;
+	while( m_Each_Loop_Count != 1 )
+	{
+		m_Each_Loop_ShiftCount ++;
+		m_Each_Loop_Count = m_Each_Loop_Count >> 1;
+	}
+	m_Each_Loop_Count = loop_count;
+	for ( uint64_t i=0;i<(len>>1);i++ )
+	{
+		*(uint64_t  *)(m_Data_Buffer+(i<<1)) = 0;
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Data_Into_Repo
+ *  Description:  Save the data into Repository 
+ * =====================================================================================
+ */
+void DataRepo::Save_Data_Into_Repo(ETDATA *data)
+{
+	if ( m_Data_Index == m_Data_MAXCount )
+	{
+	       	m_Data_Index = 0; m_Buffer_Overflow = true;
+	}
+	for ( int32_t i=0;i<m_Each_Loop_Count;i++ )
+	{
+		m_Data_Buffer[m_Data_Index+i] = data[i];
+	}
+	m_Data_Index += m_Each_Loop_Count;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_2_File
+ *  Description:  Write the data into flash
+ * =====================================================================================
+ */
+void DataRepo::Write_2_File(std::fstream& filestream)
+{
+	if 	( m_Buffer_Overflow == false )
+	{
+		filestream.write((char *)m_Data_Buffer,(m_Data_Index<<1));
+	}
+	else
+	{
+		filestream.write((char *)&m_Data_Buffer[m_Data_Index],(m_Data_MAXCount-m_Data_Index)<<1);
+		filestream.write((char *)m_Data_Buffer,(m_Data_Index<<1));
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Wgzip_2_File
+ *  Description:  Compress data buffer into file
+ *  		  No finish yet
+ * =====================================================================================
+ */
+void DataRepo::Wgzip_2_File(const char* path)
+{
+	gzFile fp = NULL;
+	fp=gzopen(path,"wb");
+	gzwrite(fp,(char *)m_Data_Buffer,(m_Data_Index<<1));
+	// becareful there are two status
+	gzclose(fp);
+	fp = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Rgzip_4_Memo
+ *  Description:  Read data from compress file 
+ *  		  No finish yet
+ * =====================================================================================
+ */
+void DataRepo::Rgzip_4_Memo(const char* path)
+{
+	gzFile fp = NULL;
+	fp=gzopen(path,"rb");
+	gzread(fp,(char *)m_Data_Buffer,(m_Data_Index<<1));
+	// becareful there are two status
+	gzclose(fp);
+	fp = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Read_2_Memory
+ *  Description:  Load Data from flash into memory
+ * =====================================================================================
+ */
+void DataRepo::Read_2_Memory(std::fstream& filestream)
+{
+	using namespace std;
+	uint64_t datalenth;                                  /* save the file length */
+	filestream.seekp(0,ios::end);                      /* seek the end of file */
+	datalenth = static_cast<uint64_t>(filestream.tellp()) - 2048; /* subtract the length of file head */
+	if 	( datalenth ==  ( m_Data_MAXCount  << 1 ) )
+	{
+		m_Buffer_Overflow = true;
+		filestream.seekp(2048,ios::beg);           /* seek over the file head */
+		filestream.read((CHAR *)m_Data_Buffer,datalenth);    /* Low Byte High Byte */
+		m_Data_Index = 0;
+
+	}
+	else if ( datalenth < ( m_Data_MAXCount  << 1 ) )
+	{
+		m_Buffer_Overflow = false;
+		filestream.seekp(2048,ios::beg);           /* seek over the file head */
+		filestream.read((CHAR *)m_Data_Buffer,datalenth);    /* Low Byte High Byte */
+		m_Data_Index = ( datalenth>>1 );
+	}
+	else if ( datalenth > ( m_Data_MAXCount  << 1 ) )
+	{
+		m_Buffer_Overflow = true;
+		filestream.seekp(2048,ios::beg);           /* seek over the file head */
+		filestream.read((CHAR *)m_Data_Buffer,( m_Data_MAXCount  << 1 ));    /* Low Byte High Byte */
+		m_Data_Index = 0;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bytes_Of_Buffer
+ *  Description:  Get the bytes of Buffer 
+ * =====================================================================================
+ */
+uint64_t  DataRepo::Get_Bytes_Of_Buffer()
+{
+	return ( m_Data_Index << 1 );
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GetLoopCount
+ *  Description:  Get the Loop Count of Data Repo 
+ * =====================================================================================
+ */
+uint64_t DataRepo::GetLoopCount()
+{
+	if 	( m_Buffer_Overflow == false ) return m_Data_Index / m_Each_Loop_Count;
+	else 	return m_Data_MAXCount / m_Each_Loop_Count;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_One_Loop_Back
+ *  Description:  Get any one loop from data repos 
+ *  Note:
+ *                You must comfirm that the offset not over the buffer arrange 
+ * =====================================================================================
+ */
+void DataRepo::Get_One_Loop_Back(ETDATA *data,uint64_t offsetloop)
+{
+	if 	( m_Buffer_Overflow == false )
+	{
+		for ( int i=0;i<m_Each_Loop_Count;i++ )
+		{
+			data[i] = m_Data_Buffer[m_Data_Index - ( offsetloop<<m_Each_Loop_ShiftCount ) + i];
+		}
+	}
+	else
+	{
+		offsetloop = m_Data_Index - ( offsetloop << m_Each_Loop_ShiftCount );
+		if 	( offsetloop < 0 )
+		{
+			offsetloop = offsetloop + m_Data_MAXCount;
+		}
+		for ( int i=0;i<m_Each_Loop_Count;i++ )
+		{
+			data[i] = m_Data_Buffer[offsetloop + i];
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Each_Loop_Word_Count
+ *  Description:  Get the Each Loop Word Count 
+ * =====================================================================================
+ */
+int DataRepo::Get_Each_Loop_Word_Count()
+{
+	return m_Each_Loop_Count;
+}
diff --git a/src/EVA11/base/DataRepo.h b/src/EVA11/base/DataRepo.h
new file mode 100644
index 0000000..12c2342
--- /dev/null
+++ b/src/EVA11/base/DataRepo.h
@@ -0,0 +1,72 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DataRepo.h
+ *
+ *    Description:  Mange data class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月17日 17时07分41秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  datarepo_INC
+#define  datarepo_INC
+
+#include 	<memory>
+#include 	<iosfwd>
+#include 	<stdint.h>
+
+#include 	"main.h"
+class DataRepo
+{
+	public:
+		static DataRepo* Instance();
+
+		void Reset_Data_Repo(uint64_t len,int32_t loop_count);
+		void Save_Data_Into_Repo(ETDATA *data);
+
+		void Write_2_File(std::fstream& filestream);
+		void Read_2_Memory(std::fstream& filestream);
+
+		void Wgzip_2_File(const char* path);
+		void Rgzip_4_Memo(const char* path);
+
+		uint64_t  Get_Bytes_Of_Buffer();
+		uint64_t  GetLoopCount();
+		void Get_One_Loop_Back(ETDATA* data,uint64_t offsetloop);
+		int Get_Each_Loop_Word_Count();
+	protected:
+
+	private:
+		DataRepo ();
+		~DataRepo ();
+		DataRepo (const DataRepo&);
+		DataRepo& operator = (const DataRepo&);
+
+		bool Init_Data_Repo(uint64_t);
+		void Release_Data_Repo();
+
+	private:
+		friend class std::auto_ptr<DataRepo>;
+		static std::auto_ptr<DataRepo>		m_Instance;
+		const static uint64_t         		m_cMAXCapacity = 5 * 1024 * 1024;
+		/*-----------------------------------------------------------------------------
+		 *  variables used for mangement of data
+		 *-----------------------------------------------------------------------------*/
+		ETDATA			  	        *m_Data_Buffer;
+		bool 			  	        m_Buffer_Overflow;
+		uint64_t	  	        	m_Capacity;
+
+		uint64_t 	  	        	m_Data_Index;
+		uint64_t 	  	        	m_Data_MAXCount;
+		int32_t			  	        m_Each_Loop_Count;
+		int32_t					m_Each_Loop_ShiftCount;
+};
+#endif   /* ----- #ifndef datarepo_INC  ----- */
diff --git a/src/EVA11/base/Datawin.cpp b/src/EVA11/base/Datawin.cpp
new file mode 100644
index 0000000..e715681
--- /dev/null
+++ b/src/EVA11/base/Datawin.cpp
@@ -0,0 +1,638 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Datawin.cpp
+ *
+ *    Description:  Implementation of Datawin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月24日 11时09分06秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<sys/stat.h>
+#include	<fstream>
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"Basewin.h"
+#include 	"Datawin.h"
+#include 	"Graphic.h"
+
+#include 	"Language.h"
+#include 	"Global.h"
+#include 	"DataRepo.h"
+#include 	"Msgbox.h"
+
+Datawin::Datawin (DATAWINTYPE type,char flag,int index)
+{
+	m_Type        = type;
+	m_Flag	      = flag;
+	m_Index	      = index;
+
+	for ( int i=0;i<m_cMAXItem;i++ )
+	{
+		m_Itemtime[i].flag 
+			= false;
+	}
+
+	m_BottomFocus = 1;
+	m_NormalFocus = 1;
+	m_CurrentPage = 0;
+}
+
+Datawin::~Datawin ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object
+ * =====================================================================================
+ */
+void Datawin::Init_GUI(Graphic& g)
+{
+	Basewin::Init_GUI(g);
+
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+	}	
+	m_BomButton[0]->Set_Focus(true);
+	char temp[4];
+	sprintf(temp,"%d",m_CurrentPage+1);
+	m_BomSmall->Set_Text(temp);
+
+	for ( int i=0;i<10;i++ )
+	{
+		m_NorLable[i] = new Label(4,53+39*i,315,38);
+		m_NorLable[i]->Set_Label_Type(Label::LA_3D); 
+		m_NorLable[i]->Set_Text(" ");
+		m_NorLable[i]->Set_Font_Size(18);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_NorLable[i]->Set_Display_Type(Label::LA_DT_LEFT);
+	}
+	for ( int i=0;i<10;i++ )
+	{
+		m_NorLable[10+i] = new Label(7+315,53+39*i,315,38);
+		m_NorLable[10+i]->Set_Label_Type(Label::LA_3D); 
+		m_NorLable[10+i]->Set_Text(" ");
+		m_NorLable[10+i]->Set_Font_Size(18);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_NorLable[10+i]->Set_Display_Type(Label::LA_DT_LEFT);
+	}
+
+	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+
+	if 	( m_Type == DA_SAVE ) 
+	{
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Label_Type(Label::LA_NONE); 
+		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
+	}
+	else if ( m_Type == DA_LOAD ) 
+	{
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Label_Type(Label::LA_NONE); 
+		m_Title->Set_Text(m_pl->GetText(LOADDATA));
+	}
+	else if ( m_Type == DA_DELE ) 
+	{
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Label_Type(Label::LA_NONE); 
+		m_Title->Set_Text(m_pl->GetText(DELEDATA));
+	}
+
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_Title->Set_Font_Size(26);
+
+	m_SubTitle = new Label(550,25,80,22);
+	m_SubTitle->Set_Label_Type(Label::LA_NONE); 
+	m_SubTitle->Set_Text(" ");
+	m_SubTitle->Set_Font_Size(16);
+	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+
+	if 	( m_gp->Language == 1 )
+		m_Page = new Label(10,25,100,22);
+	else
+		m_Page = new Label(10,25,80,22);
+
+	m_Page->Set_Label_Type(Label::LA_NONE); 
+	m_Page->Set_Text(m_pl->GetText(PAGE5));
+	m_Page->Set_Font_Size(16);
+	m_Page->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Page->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+
+	Init_Normal_Lines();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy thr GUI object
+ * =====================================================================================
+ */
+void Datawin::Destroy_GUI()
+{
+	Basewin::Destroy_GUI();
+	for ( int i=0;i<m_cMAXItem;i++ )
+	{
+		if 	( m_NorLable[i] != NULL )
+		{
+			delete m_NorLable[i];
+			m_NorLable[i] = NULL;
+		}
+	}
+	if 	( m_Title != NULL )
+	{
+		delete m_Title; 
+		m_Title = NULL;
+	}
+	if	( m_SubTitle != NULL )
+	{
+		delete m_SubTitle;
+		m_SubTitle = NULL;
+	}
+	if 	( m_Page != NULL )
+	{
+		delete m_Page;
+		m_Page = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ * Description:  Evey Windows class ues this function to draw himself on screen
+ * =====================================================================================
+ */
+void Datawin::Drawme(Graphic &g)
+{
+	Basewin::Drawme(g);
+
+	for ( int i=0;i<m_cMAXItem;i++ )
+	{
+		m_NorLable[i]->Drawme(g,false);
+	}
+	m_Title->Drawme(g);
+	m_SubTitle->Drawme(g);
+	m_Page->Drawme(g);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function
+ * =====================================================================================
+ */
+int  Datawin::Loopwindow(Graphic &g)
+{
+	Save_Screen_Into_Memory(g);
+	int result    = 0;
+	m_BottomFocus = 1;
+	m_NormalFocus = 1;
+
+	Init_GUI(g);
+	Drawme(g);
+
+	while( 1 )
+	{
+		result = Command_Process(g);
+		if 	( result == CO_EXIT )
+			goto Exit;
+		else if ( result == CO_OK )
+		{
+			result = CO_OK;
+			goto Exit;
+		}
+	}
+
+Exit:
+	Destroy_GUI();
+	Restore_Screen_From_Memory(g);
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  As the input parameter index to set the bottoms button status  
+ * =====================================================================================
+ */
+void Datawin::DrawBottomFocus(Graphic& g,int index)
+{
+	Basewin::DrawBottomFocus(g,index);
+
+	switch ( index ) {
+		case 1:                         /* previouse */
+			{
+				if 	( m_NormalFocus == 1 )
+				{
+				        m_NormalFocus = m_cMAXItem;
+					m_NorLable[0]->Set_Focus(false);
+					m_NorLable[0]->Drawme(g);
+					m_NorLable[19]->Set_Focus(true);
+					m_NorLable[19]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus--;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+
+			}
+			break;
+		case 2:                         /* next */
+			{
+				if ( m_NormalFocus == m_cMAXItem )
+				{
+				        m_NormalFocus = 1;
+					m_NorLable[19]->Set_Focus(false);
+					m_NorLable[19]->Drawme(g);
+					m_NorLable[0]->Set_Focus(true);
+					m_NorLable[0]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus++;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 3:                         /* left  */
+			{
+				if ( m_NormalFocus < 11 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+
+			break;
+
+		case 4:                         /* right */
+			{
+				if ( m_CurrentPage == 0 ) m_CurrentPage = 4;
+				else m_CurrentPage --;
+				Init_Normal_Lines();
+				for ( int i=0;i<m_cMAXItem;i++ )
+				{
+					m_NorLable[i]->Drawme(g,true);
+				}
+				char t[4];
+				sprintf(t,"%d",m_CurrentPage+1);
+				m_BomSmall->Set_Text(t);
+				m_BomSmall->Drawme(g);
+			}
+			break;
+		case 5:
+			{
+				if ( m_CurrentPage == 4 ) m_CurrentPage = 0;
+				else m_CurrentPage ++;
+				Init_Normal_Lines();
+				for ( int i=0;i<m_cMAXItem;i++ )
+				{
+					m_NorLable[i]->Drawme(g,true);
+				}
+				char t[4];
+				sprintf(t,"%d",m_CurrentPage+1);
+				m_BomSmall->Set_Text(t);
+				m_BomSmall->Drawme(g);
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bom_Text
+ *  Description:  Return the Bom button text 
+ *        index: from 0 to 6
+ * =====================================================================================
+ */
+const char* Datawin::Get_Bom_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0: 
+			return m_pl->GetText(PREVIOUSE);
+			break;
+
+		case 1: 
+			return m_pl->GetText(NEXT);
+			break;
+
+		case 2: 
+			return m_pl->GetText(CHCOL);
+			break;
+
+		case 3: 
+			return m_pl->GetText(PGUP);
+			break;
+
+		case 4: 
+			return m_pl->GetText(PGDN);
+			break;
+
+		case 5: 
+			return m_pl->GetText(COMFIRM);
+			break;
+
+		case 6: 
+			return m_pl->GetText(CANCEL);
+			break;
+
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}
+
+	return m_pl->GetText(NONE);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_One_Line
+ *  Description:  Init one Line value 
+ * =====================================================================================
+ */
+void Datawin::Init_Normal_One_Line(int i)
+{
+	std::fstream m_filestream;
+	char *databuf = new char[60];
+	char *filename = new char[60];
+
+	sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem);
+	m_filestream.open(filename,std::ios::binary|std::ios::in);
+	if 	( !m_filestream )
+	{
+		m_Itemtime[i].flag = false;
+		sprintf(databuf,"%s %c%02d%02d.dat         %s",m_pl->GetText(DATAFILE),m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem,m_pl->GetText(BLANK));
+		m_NorLable[i]->Set_Text(databuf);
+	}
+	else
+	{
+		struct stat info;
+		time_t seconds;
+		struct tm *p;
+		stat(filename,&info);
+		seconds             = info.st_mtime;
+		p                   = localtime(&seconds);
+		m_Itemtime[i].year  = p->tm_year + 1900;
+		m_Itemtime[i].month = p->tm_mon + 1;
+		m_Itemtime[i].day   = p->tm_mday;
+		m_Itemtime[i].flag  = true;
+		m_filestream.close();
+		sprintf(databuf,"%s %c%02d%02d.dat    %d/%d/%d",m_pl->GetText(DATAFILE),m_Flag,m_Index,i+m_CurrentPage*m_cMAXItem,m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
+		m_NorLable[i]->Set_Text(databuf);
+	}
+
+	delete[] databuf;
+	databuf = NULL;
+	delete[] filename;
+	filename = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_Lines
+ *  Description:  according the currentpage paramter initial the normal lines of screen 
+ * =====================================================================================
+ */
+void Datawin::Init_Normal_Lines()
+{
+	for ( int i=0;i<m_cMAXItem;i++ )
+	{
+		Init_Normal_One_Line(i);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Real_Do_Save_Staff
+ *  Description:  Real do the save staff job 
+ * =====================================================================================
+ */
+void Datawin::Real_Do_Save_Staff(Graphic& g)
+{
+	char *filename = new char[100];
+	sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
+
+	std::fstream m_filestream;
+	m_filestream.open(filename,std::ios::binary|std::ios::in|std::ios::out|std::ios::trunc);
+	if 	( !m_filestream )
+	{
+		perror("can't open the input data file\n");
+		delete[] filename;
+		filename = NULL;
+		return;
+	}
+
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
+	g.Load_Disp_Area(0,0,639,479,mem);
+	Label *lab = new Label(220,230,250,25);
+	lab->Set_Label_Type(Label::LA_THIN);
+	lab->Set_Text(m_pl->GetText(SAVEDATA1));
+	lab->Set_Font_Size(16);
+	lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	lab->Drawme(g);
+	delete lab;
+	lab = NULL;
+
+	m_repo->Write_2_File(m_filestream);
+	m_filestream.close();
+	sync();
+
+	delete[] filename;
+	filename = NULL;
+
+	g.Restore_Disp_Area(0,0,639,479,mem);     /* restore the graphic buffer */
+	delete[] mem;                             /* release the buffer */
+	mem = NULL;
+
+	Init_Normal_One_Line(m_NormalFocus-1);
+	m_NorLable[m_NormalFocus-1]->Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Real_Do_Load_Staff
+ *  Description:  Real do the Load staff job 
+ * =====================================================================================
+ */
+void Datawin::Real_Do_Load_Staff(Graphic& g)
+{
+	m_repo->Wgzip_2_File("/tmp/test.gz");
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Real_Do_Dele_Staff
+ *  Description:  Real do the Dele staff job 
+ * =====================================================================================
+ */
+void Datawin::Real_Do_Dele_Staff(Graphic& g)
+{
+	if ( Password_Confirm(g) == 1 )
+	{
+		char *filename = new char[100];
+		sprintf(filename,"%s%c%02d%02d.dat",DATA_PATH,m_Flag,m_Index,m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
+
+		if ( remove(filename) == 0 )
+		{
+			Init_Normal_One_Line(m_NormalFocus-1);
+			m_NorLable[m_NormalFocus-1]->Drawme(g);
+		}
+
+		delete[] filename;
+		filename = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Datawin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+	return CO_NONE;
+}
+int Datawin::Key_Bom2_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,2);
+	return CO_NONE;
+}
+int Datawin::Key_Bom3_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,3);
+	return CO_NONE;
+}
+int Datawin::Key_Bom4_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,4);
+	return CO_NONE;
+}
+int Datawin::Key_Bom5_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,5);
+	return CO_NONE;
+}
+int Datawin::Key_Bom6_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,6);
+	switch ( m_Type )
+	{
+		case DA_LOAD:
+			{
+				if ( m_Itemtime[m_NormalFocus-1].flag == true)
+				{
+					Real_Do_Load_Staff(g);
+				}
+				else
+				{
+					Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					ms->Showme(g); 
+					delete ms;
+					ms = NULL;
+				}
+			}
+			break;
+
+		case DA_SAVE:
+			{
+				if ( m_Itemtime[m_NormalFocus-1].flag == true)
+				{
+					Msgbox *ms = new Msgbox(200,170,280,80,m_pl->GetText(OVERWRITECHECK),Msgbox::MSG_OKCANCEL);	
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					if ( ms->Showme(g) == false )
+					{
+						delete ms;
+						ms = NULL;
+					}
+					else
+					{
+						Real_Do_Save_Staff(g);
+						delete ms;
+						ms = NULL;
+					}
+				}
+				else
+				{
+					Real_Do_Save_Staff(g);
+				}
+			}
+			break;
+
+		case DA_DELE:
+			{
+				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
+				{
+					Real_Do_Dele_Staff(g);
+				}
+				else
+				{       Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					ms->Showme(g); 
+					delete ms;
+					ms = NULL;
+				}
+			}
+			break;
+	}
+
+	return CO_NONE;
+}
+int Datawin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Datawin::Key_Enter_Fun(Graphic& g)
+{
+	return Key_Bom6_Fun(g);
+}
+int Datawin::Key_Esc_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
diff --git a/src/EVA11/base/Datawin.h b/src/EVA11/base/Datawin.h
new file mode 100644
index 0000000..35478f9
--- /dev/null
+++ b/src/EVA11/base/Datawin.h
@@ -0,0 +1,93 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Datawin.h
+ *
+ *    Description:  Implementation of Datawin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月24日 11时02分57秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _DATAWIN_INC
+#define  _DATAWIN_INC
+
+#include 	<string>
+
+class Datawin : public Basewin
+{
+	public:
+		enum DATAWINTYPE 
+		{
+			DA_LOAD,
+			DA_SAVE,
+			DA_DELE,
+		};
+		typedef enum DATAWINTYPE DATAWINTYPE;
+
+		struct ITEMTIME 
+		{
+			bool flag;
+			short year;
+			short month;
+			short day;
+		};
+		typedef struct ITEMTIME ITEMTIME;
+
+		Datawin (DATAWINTYPE,char,int);
+		virtual ~Datawin ();
+
+		virtual int  Loopwindow(Graphic &g);
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+		void Drawme(Graphic &g);
+
+		virtual const char*Get_Bom_Text(int);
+		void Init_Normal_Lines();
+
+		virtual int Key_Bom1_Fun(Graphic& g) ;
+		virtual int Key_Bom2_Fun(Graphic& g) ;
+		virtual int Key_Bom3_Fun(Graphic& g) ;
+		virtual int Key_Bom4_Fun(Graphic& g) ;
+		virtual int Key_Bom5_Fun(Graphic& g) ;
+		virtual int Key_Bom6_Fun(Graphic& g) ;
+		virtual int Key_Bom7_Fun(Graphic& g) ;
+
+		virtual int Key_Esc_Fun(Graphic& g)  ;
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual void DrawBottomFocus(Graphic& g,int index);
+
+		virtual void Init_Normal_One_Line(int index);
+	private:
+
+		void Real_Do_Save_Staff(Graphic& g);
+		void Real_Do_Load_Staff(Graphic& g);
+		void Real_Do_Dele_Staff(Graphic& g);
+
+	protected:
+		static const int		     m_cMAXItem = 20;
+		DATAWINTYPE			     m_Type;
+
+		Label  				    *m_NorLable[m_cMAXItem];
+		Label  				    *m_Title;
+		Label  				    *m_SubTitle;
+		Label				    *m_Page;
+
+		int 				     m_BottomFocus;
+		int 				     m_NormalFocus;
+		int 				     m_CurrentPage;
+		ITEMTIME 			     m_Itemtime[m_cMAXItem];
+
+		char				     m_Flag;
+		int				     m_Index;
+};
+#endif
diff --git a/src/EVA11/base/DebugView.cpp b/src/EVA11/base/DebugView.cpp
new file mode 100644
index 0000000..b5d26f7
--- /dev/null
+++ b/src/EVA11/base/DebugView.cpp
@@ -0,0 +1,178 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DebugView.cpp
+ *
+ *    Description:  implementation of DebugView class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 10时46分25秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<etio.h>
+
+#include 	"Graphic.h"
+#include	"Global.h"
+#include 	"Device.h"
+#include 	"Language.h"
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Sinscreen.h"
+
+#include 	"IView.h"
+#include 	"DebugView.h"
+
+#include 	"FreeType.h"
+#include 	"main.h"
+
+DebugView::DebugView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+}
+DebugView::~DebugView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void DebugView::Drawme(Graphic &g)
+{
+	m_Sinscreen->Drawme(g);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void DebugView::Init_GUI(Graphic& g)
+{
+	m_Sinscreen = new Sinscreen(m_X,m_Y,m_Width,m_Heigh);
+	m_Sinscreen->Set_Color(Sinscreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Sinscreen->Set_Color(Sinscreen::LA_BG_COLOR,g_SCBG_CO);
+	m_Sinscreen->Set_Color(Sinscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Sinscreen->Set_Color(Sinscreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Sinscreen->Set_Color(Sinscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void DebugView::Destroy_GUI()
+{
+	if ( m_Sinscreen != NULL )
+	{
+		delete m_Sinscreen;
+		m_Sinscreen = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view of Debug function 
+ * =====================================================================================
+ */
+void DebugView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_PCB_SIN_Function
+ *  Description:  Set the PCB to SIN function  
+ * =====================================================================================
+ */
+void DebugView::Set_PCB_SIN_Function()
+{
+	m_device->Write_Para_Func(Device::SIN);	
+	m_device->Transfer_ECT_Parameters();
+	m_device->Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  Release the view of Debug function 
+ * =====================================================================================
+ */
+void DebugView::Release_View()
+{
+	Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  Very important function of loop view 
+ * =====================================================================================
+ */
+int  DebugView::Loop_View(Graphic& g)
+{
+	if 	( m_device->Get_Chan_Function(m_gp->DebugChan) > 0 )
+	{
+		int datalen = m_device->Get_SampDataN();
+		int *databuf = new int[datalen];
+		m_device->Sample_Sin_Data(databuf,datalen);	
+		m_Sinscreen->Draw_SIN_Wave(g,databuf,datalen);
+		delete[] databuf;
+		databuf = NULL;
+	}
+	else
+		m_Sinscreen->Drawme(g);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_View
+ *  Description:  When Swtich view call this function
+ *  		 Very important function
+ * =====================================================================================
+ */
+void DebugView::Switch_View()
+{
+	Set_PCB_SIN_Function();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void DebugView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
diff --git a/src/EVA11/base/DebugView.h b/src/EVA11/base/DebugView.h
new file mode 100644
index 0000000..0c6b80c
--- /dev/null
+++ b/src/EVA11/base/DebugView.h
@@ -0,0 +1,50 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DebugView.h
+ *
+ *    Description:  Manage functions view 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 10时41分38秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef  _DEBUGVIDEW_INC
+#define  _DEBUGVIDEW_INC
+
+class Sinscreen;
+class IView;
+class Etio;
+
+class DebugView : public IView
+{
+	public:
+		DebugView (int x,int y,int width,int heigh);
+		~DebugView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		/* -----  Enter the DebugView call the sets function to init the view  ----- */
+
+		virtual void Drawme (Graphic&);
+		virtual void Switch_View(); 
+
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+		void Set_PCB_SIN_Function();
+	private:
+		Sinscreen				     *m_Sinscreen;
+		Etio					     *m_Etio;
+};
+#endif
diff --git a/src/EVA11/base/DetectView.cpp b/src/EVA11/base/DetectView.cpp
new file mode 100644
index 0000000..84f7ec2
--- /dev/null
+++ b/src/EVA11/base/DetectView.cpp
@@ -0,0 +1,307 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DetectView.cpp
+ *
+ *    Description:  implementation of DetectView class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 14时23分25秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Device.h"
+#include 	"Language.h"
+#include 	"Global.h"
+
+#include 	"Algorithm.h"
+
+#include 	"BasePanel.h"
+#include 	"ZKPanel.h"
+#include 	"VideoPanel.h"
+#include 	"DZKPanel.h"
+#include 	"ColorPanel.h"
+#include 	"OZKPanel.h"
+#include 	"CZKPanel.h"
+
+#include 	"Logic.h"
+
+#include 	"IView.h"
+#include 	"DetectView.h"
+
+DetectView::DetectView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh) , m_PanelType(0)
+{
+}
+
+DetectView::~DetectView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Panel_Type
+ *  Description:  Set the panel type 
+ * =====================================================================================
+ */
+void DetectView::Set_Panel_Type(int type)
+{
+	m_PanelType = type;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object on screen 
+ * =====================================================================================
+ */
+void DetectView::Init_GUI(Graphic& g)
+{
+	m_ViewDisBuffer = new unsigned char[g.Get_Disp_Area_Bytes(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1)]; 
+
+	m_Panel[0] = new ColorPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[0]->Init_GUI(g);
+
+	m_Panel[1] = new VideoPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[1]->Init_GUI(g);
+
+	m_Panel[2] = new ZKPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[2]->Init_GUI(g);
+
+	m_Panel[3] = new DZKPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[3]->Init_GUI(g);
+
+	m_Panel[4] = new OZKPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[4]->Init_GUI(g);
+
+	m_Panel[5] = new CZKPanel(m_X,m_Y,m_Width,m_Heigh);
+	m_Panel[5]->Init_GUI(g);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void DetectView::Destroy_GUI()
+{
+	if ( m_ViewDisBuffer != NULL )
+	{
+		delete[] m_ViewDisBuffer;
+		m_ViewDisBuffer = NULL;
+	}
+
+	for ( int i=0;i<m_cMAXPanelCount;i++ )
+	{
+		m_Panel[i]->Destroy_GUI();
+		delete m_Panel[i];
+		m_Panel[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view of Debug function 
+ * =====================================================================================
+ */
+void DetectView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  Release the view of Debug function 
+ * =====================================================================================
+ */
+void DetectView::Release_View()
+{
+	Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void DetectView::Drawme(Graphic &g)
+{
+	g.Switch_Screen();
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0xFFFFFF));
+	m_Panel[m_PanelType]->Drawme(g,false);
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_F2_Fun
+ *  Description:  Do F2 KEY function 
+ * =====================================================================================
+ */
+int DetectView::Key_F2_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F2_Fun(g);
+}
+int DetectView::Key_F3_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F3_Fun(g);
+}
+int DetectView::Key_F4_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F4_Fun(g);
+}
+int DetectView::Key_F5_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F5_Fun(g);
+}
+int DetectView::Key_F6_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F6_Fun(g);
+}
+int DetectView::Key_F7_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_F7_Fun(g);
+}
+
+int DetectView::Key_Enter_Fun(Graphic& g)
+{
+	return m_Panel[m_PanelType]->Key_Enter_Fun(g);
+}
+
+int DetectView::Key_NL1_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL1_Fun(g,sub);
+}
+int DetectView::Key_NR1_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR1_Fun(g,sub);
+}
+int DetectView::Key_NL2_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL2_Fun(g,sub);
+}
+int DetectView::Key_NR2_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR2_Fun(g,sub);
+}
+int DetectView::Key_NL3_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL3_Fun(g,sub);
+}
+int DetectView::Key_NR3_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR3_Fun(g,sub);
+}
+int DetectView::Key_NL4_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL4_Fun(g,sub);
+}
+int DetectView::Key_NR4_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR4_Fun(g,sub);
+}
+int DetectView::Key_NL5_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL5_Fun(g,sub);
+}
+int DetectView::Key_NR5_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR5_Fun(g,sub);
+}
+int DetectView::Key_NL6_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NL6_Fun(g,sub);
+}
+int DetectView::Key_NR6_Fun(Graphic& g,int sub)
+{
+	return m_Panel[m_PanelType]->Key_NR6_Fun(g,sub);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void DetectView::Show_Help_System(Graphic& g,int x,int y)
+{
+	m_Panel[m_PanelType]->Show_Help_System(g,x,y);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  Very important function of loop view 
+ * =====================================================================================
+ */
+int  DetectView::Loop_View(Graphic& g)
+{
+	m_Panel[m_PanelType]->Loop_Panel(g);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Lock_View
+ *  Description:  Stop the View refresh
+ * =====================================================================================
+ */
+void DetectView::Lock_View(Graphic& g)
+{
+	Algorithm *alg = Algorithm::Instance();
+	g.Load_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,m_ViewDisBuffer);
+	for ( int i=m_X;i<=((m_X+m_Width-1)>>1);i++ )
+	{
+		for ( int j=m_Y;j<m_Y+m_Heigh-1;j++ )
+		{
+			g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(239,60,25,80,g.Getpixel(i,j))));
+			g.Setpixel(m_X+m_Width-i-1,j,g.RGB24_16(alg->Alpha_Color(239,60,25,80,g.Getpixel(m_X+m_Width-i-1,j))));
+		}
+	}
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  UnLock_View
+ *  Description:  Restart the view refresh 
+ * =====================================================================================
+ */
+void DetectView::UnLock_View(Graphic& g)
+{
+	g.Restore_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,m_ViewDisBuffer);
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_View
+ *  Description:  When Swtich view call this function 
+ *                Very important function
+ * =====================================================================================
+ */
+void DetectView::Switch_View()
+{
+	Set_Panel_Type(m_gp->PanelType);
+	m_Panel[m_PanelType]->Switch_Panel();
+
+	Logic *lo = Logic::Instance();
+	lo->Reset_Data_Repo();
+}
diff --git a/src/EVA11/base/DetectView.h b/src/EVA11/base/DetectView.h
new file mode 100644
index 0000000..f787854
--- /dev/null
+++ b/src/EVA11/base/DetectView.h
@@ -0,0 +1,80 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  DetectView.h
+ *
+ *    Description:  implementation of Detect View class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 14时14分36秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _DETECTVIEW_INC
+#define  _DETECTVIEW_INC
+
+class BasePanel; 
+class IView;
+class AlarmView;
+class ParaView;
+class DetectView : public IView
+{
+	public:
+		DetectView (int x,int y,int width,int heigh);
+		~DetectView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F5_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+		virtual int Key_F7_Fun(Graphic& g);
+
+		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		virtual void Lock_View(Graphic& g);
+		virtual void UnLock_View(Graphic& g);
+
+		/* -----  Enter the DebugView call the sets function to init the view  ----- */
+
+		virtual void Switch_View();
+		virtual void Drawme (Graphic&);
+		void Set_Panel_Type(int type);
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+	private:
+		friend class 			    AlarmView; 
+		friend class 			    ParaView; 
+		unsigned char			    *m_ViewDisBuffer;
+		static const int		    m_cMAXPanelCount 	= 	6;
+		int				    m_PanelType;
+		BasePanel			    *m_Panel[m_cMAXPanelCount];
+}; /* -----  end of class DetectView  ----- */
+#endif   /* ----- #ifndef _DETECTVIEW_INC  ----- */
diff --git a/src/EVA11/base/Device.cpp b/src/EVA11/base/Device.cpp
new file mode 100644
index 0000000..e2fb598
--- /dev/null
+++ b/src/EVA11/base/Device.cpp
@@ -0,0 +1,688 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Device.cpp
+ *
+ *    Description:  Class for Operating hardware, special for ECT board data reading
+ *
+ *        Version:  1.0
+ *        Created:  2010年03月06日 22时19分33秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+
+/*-----------------------------------------------------------------------------
+ * 	PiFj:  i[0 8]  Probe     ||    j[1  8]  Frequence
+ * 	    
+ *
+ *    SignalID[ch] = 0        Close the channel
+ *
+ *
+ *    SignalID[ch] = ( i - 1 ) * 8  + j
+ *
+ *
+ *    SignalID:
+ *    0      P=0  closed
+ *
+ *    1-8    P=1
+ *    9-16   P=2
+ *    17-24  P=3
+ *    .
+ *    .
+ *    .
+ *   
+ *    SignalN  is always  8
+ *
+ *    caution:
+ *    There are two API 
+ *    For 8 	channels used SetET()
+ *    For 128 	channels used SetET2()
+ *-----------------------------------------------------------------------------*/
+
+
+#include 	<cstdlib>
+#include 	"Device.h"
+#include 	"main.h"
+#include 	"etio.h"
+
+/*-----------------------------------------------------------------------------
+ *  ECT BOARD parameters
+ *-----------------------------------------------------------------------------*/
+std::auto_ptr<Device> Device::m_Instance;
+
+Device::Device ()
+{
+	m_IntBuf = new int[1024];
+
+	m_Etio = Etio::Instance();
+}
+
+Device::~Device ()
+{
+	delete[] m_IntBuf;
+	m_IntBuf = NULL;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Device* Device::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Device() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_ET_Board
+ *  Description:  Before used the ECT board, call this function initiate the Board 
+ * =====================================================================================
+ */
+bool Device::Init_ET_Board()
+{
+	return m_Etio->InitiateETIO();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  UnInit_ET_Board
+ *  Description:  After using the ECT board, call this function to release some resource 
+ *                used by ET board
+ * =====================================================================================
+ */
+void Device::UnInit_ET_Board()
+{
+	m_Etio->UnInitiateETIO();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data_From_ECT_2
+ *  Description:  Get the Data from ECT board noblock mode 
+ * =====================================================================================
+ */
+int Device::Get_Data_From_ECT_2(short* databuf)
+{
+	m_Etio->Sample_Chan_Data(m_IntBuf,Etio::RAWECT);
+	int n = sizeof(databuf);
+	for ( int i = 0; i < n; i += 1 ) 
+	{
+		databuf[i] = (m_IntBuf[i]>>16);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data_From_ECT
+ *  Description:  Get Data from ECT board no-block mode 
+ * =====================================================================================
+ */
+int Device::Get_Data_From_ECT(int* databuf)
+{
+	m_Etio->Sample_Chan_Data(databuf,Etio::RAWECT);
+}
+
+int Device::Get_Data_From_ECT_Timer(int* databuf)
+{
+	m_Etio->Sample_Chan_Data(databuf,Etio::ALLECT);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Sin_Data
+ *  Description:  Just Get the Sin Data Value from FPGA 
+ * =====================================================================================
+ */
+int Device::Sample_Sin_Data(int* databuf,int len)
+{
+	return m_Etio->Sample_Sin_Data(databuf,len);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Transfer_ECT_Parameters
+ *  Description:  Transfer the m_Par parameters to PCB
+ * =====================================================================================
+ */
+void Device::Transfer_ECT_Parameters()
+{
+	m_Etio->Set_ET();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_par_Default_value
+ *  Description:  The function must be called after Init_ET_Board function 
+ *  		  because m_Par must be initiate before
+ * =====================================================================================
+ */
+void Device::Init_Par_Default_Value()
+{
+	m_Etio->Init_Default_Value();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequnce_Index
+ *  Description:  Return the frequnce index in m_Par parameters 
+ * =====================================================================================
+ */
+int Device::Get_Frequence_Index(int frequnce)
+{
+	return m_Etio->Get_Frequence_Index(frequnce);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequence
+ *  Description:  Return the index of frequence in m_par parameters
+ * =====================================================================================
+ */
+int Device::Get_Frequence(int index)
+{
+	return m_Etio->Get_Frequence(index);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_SignalID
+ *  Description:  Set the SignalID parameters into PCB 
+ * =====================================================================================
+ */
+void Device::Set_Para_SignalID(int chan,unsigned char probe,unsigned char freqno)
+{
+	Write_Para_SignalID(chan,probe,freqno);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_Frequence
+ *  Description:  Set the channel parameters frequence 
+ * =====================================================================================
+ */
+void Device::Set_Para_Frequence_Value(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_Frequence_Value(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_Frequence
+ *  Description:  Write the channel parameters frequence 
+ * =====================================================================================
+ */
+void Device::Write_Para_Frequence_Value(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_Frequence_Value(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_HiFilter
+ *  Description:  Set the channel parameters High filter 
+ *  		  chan: channel index 
+ *  		  value: new high filter value
+ * =====================================================================================
+ */
+void Device::Set_Para_HiFilter(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_HighFilter(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_HiFilter
+ *  Description:  Write the channel parameters High filter 
+ *  		  chan: channel index 
+ *  		  value: new high filter value
+ * =====================================================================================
+ */
+void Device::Write_Para_HiFilter(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_HighFilter(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_LowFilter
+ *  Description:  Set the channel parameters Low filter 
+ *  		  chan: channel index 
+ *  		  value: new low filter value
+ * =====================================================================================
+ */
+void Device::Set_Para_LowFilter(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_LowFilter(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_LowFilter
+ *  Description:  Write the channel parameters Low filter 
+ *  		  chan: channel index 
+ *  		  value: new low filter value
+ * =====================================================================================
+ */
+void Device::Write_Para_LowFilter(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_LowFilter(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_SignalWave
+ *  Description:  Select which channel debug signal wanted to be showed
+ * =====================================================================================
+ */
+void Device::Set_Para_SignalWave(int value)
+{
+	m_Etio->Interface_Select_Sin_Channel(value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_SignalWave
+ *  Description:  Just as title 
+ * =====================================================================================
+ */
+void Device::Write_Para_SignalWave(int value)
+{
+	m_Etio->Interface_Select_Sin_Channel(value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_HDGain
+ *  Description:  Set the channel parameters of HDGain
+ *        value:  0~7
+ * =====================================================================================
+ */
+void Device::Set_Para_HDGain(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_ProbeGain(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_HDGain
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Write_Para_HDGain(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_ProbeGain(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_DriverBal
+ *  Description:  Write the Parameters of DriverBalance into FPGA
+ *                跟随探头编码。1-15:显示“-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7
+ * =====================================================================================
+ */
+void Device::Set_Para_DriverBal(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_ProbeBalance(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_DriverBal
+ *  Description:  Write the Parameters of DriverBalance into FPGA
+ *                跟随探头编码。1-15:显示“-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7
+ * =====================================================================================
+ */
+void Device::Write_Para_DriverBal(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_ProbeBalance(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_DriveA_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Write_Para_DriveA_ID(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_CoilNumforDriverA(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_PickA_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Write_Para_PickA_ID(int chan,int value)
+{
+    	m_Etio->Interface_Set_Channels_CoilNumforPickA(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_DriveB_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Write_Para_DriveB_ID(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_CoilNumforDriverB(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_PickB_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Write_Para_PickB_ID(int chan,int value)
+{
+    	m_Etio->Interface_Set_Channels_CoilNumforPickB(chan,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_DriveA_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Set_Para_DriveA_ID(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_CoilNumforDriverA(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_PickA_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Set_Para_PickA_ID(int chan,int value)
+{
+    	m_Etio->Interface_Set_Channels_CoilNumforPickA(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_DriveB_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Set_Para_DriveB_ID(int chan,int value)
+{
+	m_Etio->Interface_Set_Channels_CoilNumforDriverB(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_PickB_ID
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Set_Para_PickB_ID(int chan,int value)
+{
+    	m_Etio->Interface_Set_Channels_CoilNumforPickB(chan,value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_Driver
+ *  Description:  Set the Driver of ECT board  
+ * =====================================================================================
+ */
+void Device::Set_Para_Driver(int value)
+{
+	m_Etio->Interface_Set_Channels_SineAmplitude(value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_Driver
+ *  Description:  Set the Parameters of ECT board 
+ * =====================================================================================
+ */
+void Device::Write_Para_Driver(int value)
+{
+	m_Etio->Interface_Set_Channels_SineAmplitude(value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_Offset
+ *  Description:  Set the Offset of ECT board  
+ * =====================================================================================
+ */
+void Device::Set_Para_Offset(int value)
+{
+	m_Etio->Interface_Set_Channels_Offset(value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_Offset
+ *  Description:  Set the Offset of ECT board  
+ * =====================================================================================
+ */
+void Device::Write_Para_Offset(int value)
+{
+	m_Etio->Interface_Set_Channels_Offset(value);
+	Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Read_Port
+ *  Description:  Read the port data 
+ * =====================================================================================
+ */
+unsigned char Device::Read_Port(int addr)	
+{
+	return m_Etio->PEEKB_TC(addr); 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Port
+ *  Description:  Write data into port  
+ * =====================================================================================
+ */
+void Device::Write_Port(int addr,unsigned char value)
+{
+	m_Etio->POKEB_TC(addr,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_SampDataN
+ *  Description:  Get the sample data pointers 
+ * =====================================================================================
+ */
+int Device::Get_SampDataN()
+{
+	return m_Etio->Sample_DataN();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_SampDataNGet_SignalWave
+ *  Description:  In Debug mode some time we will want to get signal wave 
+ * =====================================================================================
+ */
+int Device::Get_SignalWave()
+{
+	return m_Etio->Interface_Get_Sin_Channel();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Module_Version
+ *  Description:  Get the Module of ETIO version 
+ * =====================================================================================
+ */
+int Device::Get_Module_Version()
+{
+	return m_Etio->Get_Version(); 
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_FPGA_Version
+ *  Description:  Get the FPGA versiob 
+ * =====================================================================================
+ */
+int Device::Get_FPGA_Version()
+{
+	unsigned char low  =  m_Etio->PEEKB_TC(0);
+	unsigned char high =  m_Etio->PEEKB_TC(1);
+	return ( high << 8 ) + low;
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_New_Frequence
+ *  Description:  Return the next frequence index 
+ *                dir: false  Decrease
+ *                     true   Increase
+ * =====================================================================================
+ */
+unsigned int Device::Calculate_New_Frequence(bool dir,int value,unsigned int step)
+{
+	if ( dir == false )                     /* Decrease */
+	{
+		for ( unsigned int i=0;i<step;i++ )
+		{
+			if ( value != 0 ) value --;
+		}
+	}
+	else                                    /* Increase */
+	{
+		for ( unsigned int i=0;i<step;i++ )
+		{
+			if ( value != m_Etio->Get_Max_Frequence_Length()-1 ) value ++;
+		}
+	}
+	return value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_SignalID
+ *  Description:  Fill the SignalID acoording to the probe and freqNo 
+ *  Note:
+ *                probefun: 0-3   freqno: 1-8
+ * =====================================================================================
+ */
+void Device::Write_Para_SignalID(int ch,unsigned char probefun,unsigned char freqno)
+{
+	if 	( probefun == 0 )
+		m_Etio->Interface_Set_Channels_Type(ch,Etio::CLOSE);
+	else
+	{
+		switch ( probefun ) 
+		{
+			case 1:
+				m_Etio->Interface_Set_Channels_Type(ch,Etio::ECT);
+				break;
+
+			case 2:
+				m_Etio->Interface_Set_Channels_Type(ch,Etio::FECT);
+				break;
+
+			case 3:
+				m_Etio->Interface_Set_Channels_Type(ch,Etio::EMS);
+				break;
+
+			default:	
+				m_Etio->Interface_Set_Channels_Type(ch,Etio::ECT);
+				break;
+		}				/* -----  end switch  ----- */
+
+		m_Etio->Interface_Set_Channels_Map_Index(ch,freqno-1);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Para_Func
+ *  Description:  Changing m_Par parameters Func   
+ * =====================================================================================
+ */
+void Device::Write_Para_Func(ETIO_FUN value)
+{
+	if 	( value == SIN )
+		m_Etio->Set_Work_Mode(Etio::SIN);
+	else 
+		m_Etio->Set_Work_Mode(Etio::NORMAL);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Chan_Function
+ *  Description:  For Display Sin wave 
+ * =====================================================================================
+ */
+int Device::Get_Chan_Function(int index)
+{
+	return m_Etio->Interface_Get_Channels_Fun(index);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Para_RF_Filter
+ *  Description:  Enable the RF Filter or not
+ * =====================================================================================
+ */
+void Device::Set_Para_RF_Filter(bool v)
+{
+	m_Etio->Interface_Set_RF_Filter_Enable_Switch(v);
+	m_Etio->Set_ET();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Timers_Data
+ *  Description:  Get the Intimers Extimers1 Extimer2
+ * =====================================================================================
+ */
+void Device::Get_Timers_Data(int *databuf)
+{
+	m_Etio->Sample_Chan_Data(databuf,Etio::TIMERS);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_TImers
+ *  Description:  
+ * =====================================================================================
+ */
+void Device::Clean_Timers()
+{
+	for ( int i = 0; i < 3; i += 1 ) 
+		m_Etio->Clear_Timers(i);
+}
+
diff --git a/src/EVA11/base/Device.h b/src/EVA11/base/Device.h
new file mode 100644
index 0000000..82bbcbb
--- /dev/null
+++ b/src/EVA11/base/Device.h
@@ -0,0 +1,148 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Device.h
+ *
+ *    Description:  Class for operating hardware including TC board
+ *
+ *        Version:  1.0
+ *        Created:  2010年03月06日 19时09分56秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+
+
+/*
+ * =====================================================================================
+ *        Class:  Device
+ *  Description:  Operating Hardware,manage the ETIO function operation 
+ * =====================================================================================
+ */
+
+#ifndef  _DEVICE_INC
+#define  _DEVICE_INC
+
+#include 	<memory>	
+
+class Etio;
+class Device
+{
+	public:
+		enum ETIO_FUN 
+		{
+			NORMAL,
+			SIN
+		};			        /* ----------  end of enum ETIO_FUN  ---------- */
+		typedef enum ETIO_FUN ETIO_FUN;
+
+		enum CHANMODE 
+		{
+			CLOSE   =        0,
+			ECT     =        1,
+			FECT    =        2,
+			EMS     =        3
+		};				/* ----------  end of enum CHANMODE  ---------- */
+
+		typedef enum CHANMODE CHANMODE;
+
+		static Device* Instance();
+
+		/*-----------------------------------------------------------------------------
+		 *  Get module version
+		 *-----------------------------------------------------------------------------*/
+		int Get_Module_Version();
+		int Get_FPGA_Version();
+		/*-----------------------------------------------------------------------------
+		 *  Operation function of Par , the parameters of ECT board
+		 *-----------------------------------------------------------------------------*/
+		bool Init_ET_Board();
+		void UnInit_ET_Board();
+		void Init_Par_Default_Value();
+
+		void Write_Para_Func(ETIO_FUN);
+		void Write_Para_Frequence_Value(int chan,int value);
+		void Write_Para_HiFilter(int chan,int value);
+		void Write_Para_LowFilter(int chan,int value);
+		void Write_Para_SignalWave(int value);
+		void Write_Para_HDGain(int chan,int value);
+
+		void Write_Para_DriverBal(int chan,int value);
+
+		void Write_Para_DriveA_ID(int chan,int value);
+		void Write_Para_PickA_ID(int chan,int value);
+		void Write_Para_DriveB_ID(int chan,int value);
+		void Write_Para_PickB_ID(int chan,int value);
+
+		void Write_Para_Driver(int value);
+		void Write_Para_Offset(int value);
+		void Write_Para_SignalID(int chan,unsigned char probefun,unsigned char freqno);
+
+		void Transfer_ECT_Parameters();                    /* Transfer the ECT parameters to ECT board */
+		int Get_Data_From_ECT_2(short* databuf);           /* Get the Sample data from ECT board */
+
+		int Get_Data_From_ECT(int* databuf);	   	   /* it is the 32 bit transfer mode */
+		int Get_Data_From_ECT_Timer(int* databuf);
+		void Get_Timers_Data(int *databuf);
+		void Clean_Timers();
+
+		int Sample_Sin_Data(int*,int);
+
+		int Get_Frequence_Index(int); 
+		int Get_Frequence(int index);
+		int Get_SampDataN();                               /* Return this sample data pointers  */
+		int Get_SignalWave();                              /* In Debug mode get the signal index */
+		/*-----------------------------------------------------------------------------
+		 *  Channel parameters Setting
+		 *-----------------------------------------------------------------------------*/
+		unsigned int Calculate_New_Frequence(bool dir,int value,unsigned int step);
+
+		void Set_Para_Frequence_Value(int chan,int value);
+		void Set_Para_HiFilter(int chan,int value);
+		void Set_Para_LowFilter(int chan,int value);
+
+		void Set_Para_SignalWave(int value);
+		void Set_Para_HDGain(int chan,int value);
+
+		void Set_Para_DriverBal(int chan,int value);
+		void Set_Para_DriveA_ID(int chan,int value);
+		void Set_Para_PickA_ID(int chan,int value);
+		void Set_Para_DriveB_ID(int chan,int value);
+		void Set_Para_PickB_ID(int chan,int value);
+
+		void Set_Para_ChanMode(int chan,CHANMODE value);
+
+		void Set_Para_Driver(int value);
+		void Set_Para_Offset(int value);
+		void Set_Para_SignalID(int chan,unsigned char probe,unsigned char freqno);
+
+		void Set_Para_RF_Filter(bool);
+		/*-----------------------------------------------------------------------------
+		 *  Low IO operation
+		 *-----------------------------------------------------------------------------*/
+	   	unsigned char Read_Port(int addr);	
+		void Write_Port(int,unsigned char);
+
+		int Get_Chan_Function(int);
+	protected:
+	private:
+		/* ====================  LIFECYCLE     ======================================= */
+		Device ();                              	   /* constructor */
+		~Device ();                             	   /* destructor */
+		Device( const Device& );
+		Device& operator = (const Device&);
+
+		static const int	MAXCHAN = 128;
+
+		friend class std::auto_ptr<Device>;
+		static std::auto_ptr<Device>		m_Instance;
+
+		int*					m_IntBuf;
+
+		Etio*					m_Etio;
+}; /* -----  end of class Device  ----- */
+#endif   /* ----- #ifndef _DEVICE_H_INC  ----- */
diff --git a/src/EVA11/base/Filte.cpp b/src/EVA11/base/Filte.cpp
new file mode 100644
index 0000000..45d1e30
--- /dev/null
+++ b/src/EVA11/base/Filte.cpp
@@ -0,0 +1,60 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Filte.cpp
+ *
+ *    Description:  Implementation of 
+ *
+ *        Version:  1.0
+ *        Created:  2013年09月11日 15时02分49秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Filte.h"
+
+Filte::Filte()
+{
+}
+
+Filte::~Filte()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Algorithm1_Data_Structure
+ *  Description:  Init Algorithm1 Data Structure 
+ * =====================================================================================
+ */
+void Filte::Init_Algorithm1_Data_Structure()
+{
+	for ( int i = 0; i < 1024; ++i )
+	{
+		m_A1_X[i] = 0;
+		m_A1_Y[i] = 0;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Algorithm1
+ *  Description:  First Calculate Algorithm 
+ * =====================================================================================
+ */
+void Filte::Calculate_Algorithm1(int *data,int len)
+{
+	for ( int i = 0; i < len; ++i )
+	{
+		m_A1_Y[i] = data[i];
+
+		data[i] = static_cast<int>(( ( static_cast<double>(data[i]) - m_A1_X[i] ) * 0.9) + m_A1_X[i]);
+
+		m_A1_X[i] = m_A1_Y[i];
+	}
+}
diff --git a/src/EVA11/base/Filte.h b/src/EVA11/base/Filte.h
new file mode 100644
index 0000000..0d75aed
--- /dev/null
+++ b/src/EVA11/base/Filte.h
@@ -0,0 +1,37 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Filte.h
+ *
+ *    Description:  For Test Filter Algorithm 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月12日 14时01分50秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  FILTE_INC
+#define  Filte_INC
+
+class Filte
+{
+	public:
+		Filte ();                             /* constructor */
+		~Filte ();                            /* destructor  */
+
+		void Init_Algorithm1_Data_Structure();
+		void Calculate_Algorithm1(int *data,int len);
+	protected:
+
+	private:
+		int				m_A1_X[1024];
+		int				m_A1_Y[1024];
+}; /* -----  end of class Filte  ----- */
+
+#endif   /* ----- #ifndef Filte_INC  ----- */
diff --git a/src/EVA11/base/Fit.c b/src/EVA11/base/Fit.c
new file mode 100644
index 0000000..912beb0
--- /dev/null
+++ b/src/EVA11/base/Fit.c
@@ -0,0 +1,88 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  fit.c
+ *
+ *    Description:  This is_heap for noline fiting test
+ *
+ *        Version:  1.0
+ *        Created:  2013年01月08日 14时49分47秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<math.h>
+#include	<gsl/gsl_vector.h> 
+#include	<gsl/gsl_matrix.h> 
+
+#include 	"FitHead.h"
+
+int expb_f(const gsl_vector* x,void* data,gsl_vector* f)
+{
+	size_t len = ((DATA *)data)->n;
+	double *x2 = ((DATA *)data)->x1;     // becareful
+	double *y2 = ((DATA *)data)->y1;
+	double *x1 = ((DATA *)data)->x2;
+	double *y1 = ((DATA *)data)->y2;
+	double *yr = ((DATA *)data)->yr;
+
+	double *sigma = ((DATA *) data)->sigma;
+
+	double a = gsl_vector_get (x, 0);
+	double b = gsl_vector_get (x, 1);
+	double c = gsl_vector_get (x, 2);
+	double d = gsl_vector_get (x, 3);
+
+	int i;
+	double Yi;
+	for (i = 0; i < len; i++)
+	{
+		Yi = a*x1[i]*b*y1[i]+a*a*x1[i]*x1[i]-x2[i]*a*x1[i]+b*a*x1[i]*y1[i]+b*b*y1[i]*y1[i]-b*y1[i]*x2[i]-a*x1[i]*x2[i]-b*y1[i]*x2[i]
+			+x2[i]*x2[i]+c*c*y1[i]*y1[i]+c*d*y1[i]*x1[i]-y2[i]*c*y1[i]+c*d*x1[i]*y1[i]+d*d*x1[i]*x1[i]-d*x1[i]*y2[i]-c*y1[i]*y2[i]-
+			d*x1[i]*y2[i]+y2[i]*y2[i];
+
+		gsl_vector_set (f, i, (Yi - yr[i])/sigma[i]);
+	}
+
+	return GSL_SUCCESS;
+}
+
+int expb_df(const gsl_vector* x,void* data,gsl_matrix* J)
+{
+	size_t len = ((DATA *)data)->n;
+	double *x2 = ((DATA *)data)->x1;
+	double *y2 = ((DATA *)data)->y1;   // becareful
+	double *x1 = ((DATA *)data)->x2;
+	double *y1 = ((DATA *)data)->y2;
+	double *sigma = ((DATA *) data)->sigma;
+
+	double a = gsl_vector_get (x, 0);
+	double b = gsl_vector_get (x, 1);
+	double c = gsl_vector_get (x, 2);
+	double d = gsl_vector_get (x, 3);
+
+	size_t i;
+	double s;
+	for (i = 0; i < len; i++)
+	{
+		s = sigma[i];
+
+		gsl_matrix_set (J, i, 0, (x1[i]*y1[i]*b+2*a*x1[i]*x1[i]-x2[i]*x1[i]+b*x1[i]*y1[i]-x1[i]*x2[i])/s);
+		gsl_matrix_set (J, i, 1, (a*x1[i]*y1[i]+a*x1[i]*y1[i]+2*y1[i]*y1[i]*b-y1[i]*x2[i]-y1[i]*x2[i])/s);
+		gsl_matrix_set (J, i, 2, (2*c*y1[i]*y1[i]+d*y1[i]*x1[i]-y1[i]*y2[i]+d*x1[i]*y1[i]-y1[i]*y2[i])/s);
+		gsl_matrix_set (J, i, 3, (c*y1[i]*x1[i]+c*x1[i]*y1[i]+2*d*x1[i]*x1[i]-x1[i]*y2[i]-x1[i]*y2[i])/s);
+	}
+
+	return GSL_SUCCESS;
+}
+
+int expb_fdf(const gsl_vector* x,void* data,gsl_vector* f,gsl_matrix* J)
+{
+	expb_f(x,data,f);
+	expb_df(x,data,J);
+	return GSL_SUCCESS;
+}
diff --git a/src/EVA11/base/FitHead.h b/src/EVA11/base/FitHead.h
new file mode 100644
index 0000000..303a680
--- /dev/null
+++ b/src/EVA11/base/FitHead.h
@@ -0,0 +1,37 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Head.h
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2013年01月08日 15时31分53秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _HEAD_INC
+#define  _HEAD_INC
+
+#include 	"inttypes.h"
+
+typedef struct
+{
+	int32_t n;
+	double* x1;
+	double* y1;
+	double* x2;
+	double* y2;
+	double* yr;
+	double* sigma;
+} DATA;
+
+const double pi = 3.1415926;
+
+#endif   /* ----- #ifndef _HEAD_INC  ----- */
diff --git a/src/EVA11/base/FreeType.cpp b/src/EVA11/base/FreeType.cpp
new file mode 100644
index 0000000..fe7c99b
--- /dev/null
+++ b/src/EVA11/base/FreeType.cpp
@@ -0,0 +1,468 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  FreeType.cpp
+ *
+ *    Description:  Implementation of FreeType class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年10月16日 14时25分04秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	"FreeType.h"
+#include 	"Graphic.h"
+
+#include 	<wchar.h>
+#include 	<locale>
+#include 	"assert.h"
+
+#include 	"ConvertCode.h"
+
+#include 	<boost/foreach.hpp>     /* becareful this is boost library */
+
+class FreeType::Impl
+{
+public:
+	FT_Library 		m_library;
+	FT_Face 		m_face;
+	FT_GlyphSlot 		m_slot;
+	int 			m_lastp;
+	ConvertCode*		m_CC;
+
+	int			m_scrw;
+	int			m_scrh;
+	Graphic*		m_g;
+
+	short 			m_fgcolor_R;
+	short 			m_fgcolor_G;
+	short 			m_fgcolor_B;
+
+	short			m_bgcolor_R;
+	short			m_bgcolor_G;
+	short			m_bgcolor_B;
+
+	int			m_fontsize;
+	bool			m_bTranspare;
+};
+
+std::auto_ptr<FreeType> FreeType::m_Instance;
+
+FreeType::FreeType () : m_pimpl(new Impl)
+{
+}
+
+FreeType::~FreeType ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+FreeType* FreeType::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new FreeType() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_FreeType
+ *  Description:  Call this function when init freetype 
+ * =====================================================================================
+ */
+bool FreeType::Init_FreeType(Graphic& g,const char* path)
+{
+	int error;
+	m_pimpl->m_CC = ConvertCode::Instance();
+	if ( !m_pimpl->m_CC->Init_CodeConvert("gb18030","WCHAR_T") )  
+	{
+		perror("Can't Init Convert Code");
+		return false;
+	}
+
+	error = FT_Init_FreeType(&(m_pimpl->m_library));
+	if ( error )
+	{
+		perror("Can't Init FreeType Library");
+		return false;
+	}
+	error = FT_New_Face(m_pimpl->m_library,
+			    path,
+			    0,
+			    &(m_pimpl->m_face));
+	if ( error == FT_Err_Unknown_File_Format )
+	{
+		perror("Unknown File Format");
+		return false;
+	}
+	else if ( error )
+	{
+		perror("Other File error");
+		return false;
+	}
+
+	m_pimpl->m_fontsize      = 10;
+
+	error = FT_Set_Pixel_Sizes(m_pimpl->m_face,
+			m_pimpl->m_fontsize,
+			0
+			);
+
+	error = FT_Select_Charmap( m_pimpl->m_face,FT_ENCODING_UNICODE);
+	m_pimpl->m_slot = m_pimpl->m_face->glyph;
+
+	m_pimpl->m_scrw		= 	g.Get_Screen_Width();
+	m_pimpl->m_scrh  	= 	g.Get_Screen_Height();
+	m_pimpl->m_g		= 	&g;
+
+	m_pimpl->m_bgcolor_R	=       0;
+	m_pimpl->m_bgcolor_G	=       0;
+	m_pimpl->m_bgcolor_B	=       0;
+
+	m_pimpl->m_fgcolor_R	= 	(g.RGB24_16(0xff0000)>>11) & 0x1f;
+	m_pimpl->m_fgcolor_G	= 	((g.RGB24_16(0xff0000))>>5) & 0x3f;
+	m_pimpl->m_fgcolor_B	= 	g.RGB24_16(0xff0000) & 0x1f;
+
+	m_pimpl->m_bTranspare   =       false;
+
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_FreeType
+ *  Description:  Destroy the FreeType library 
+ * =====================================================================================
+ */
+void FreeType::Destroy_FreeType()
+{
+	m_pimpl->m_CC->Destory_CodeConvert();
+	FT_Done_Face(m_pimpl->m_face);
+	FT_Done_FreeType(m_pimpl->m_library);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Text_One_Char
+ *  Description:  Just Show One Charactor 
+ * =====================================================================================
+ */
+int FreeType::Text_One_Char(int& x,int& y,FT_ULong word)
+{
+	int error;
+	FT_UInt glyph_index = FT_Get_Char_Index(m_pimpl->m_face,word);
+
+	error = FT_Load_Glyph(m_pimpl->m_face,
+			      glyph_index,
+			      FT_LOAD_FORCE_AUTOHINT);
+//			      FT_LOAD_DEFAULT|FT_LOAD_NO_HINTING);
+
+	if 	( error )
+	{
+		perror("Load Glyph error");
+		return 0;
+	}
+
+	error = FT_Render_Glyph(m_pimpl->m_face->glyph,FT_RENDER_MODE_NORMAL);
+	if 	( error )
+	{
+		perror("Render Glyph error");
+		return 0;
+	}
+
+	for ( int j=0;j<m_pimpl->m_slot->bitmap.rows;j++ )
+	{
+		for ( int i=0;i<m_pimpl->m_slot->bitmap.width;i++ )
+		{
+			Set_One_Pixel(x+m_pimpl->m_slot->bitmap_left+i,y-m_pimpl->m_slot->bitmap_top+j,m_pimpl->m_slot->bitmap.buffer[i+j*m_pimpl->m_slot->bitmap.width]);
+		}
+	}
+
+	x += m_pimpl->m_slot->advance.x>>6;
+	y += m_pimpl->m_slot->advance.y>>6;
+
+	return 1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_One_Pixel
+ *  Description:  Set the one pixel of screen 
+ * =====================================================================================
+ */
+void FreeType::Set_One_Pixel(const int x,const int y,const short value)
+{
+	unsigned char *loc = m_pimpl->m_g->Get_Screen_Ptr() + (y * m_pimpl->m_scrw * 2 + x * 2);
+	if 	( value == 0 )
+	{
+		if ( m_pimpl->m_bTranspare == false )
+			*(unsigned short *)loc = Create_BG_Color(0xff); 
+	}
+	else
+		*(unsigned short *)loc = Create_FG_Color(value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Color
+ *  Description:  Set the Color of FreeType 
+ * =====================================================================================
+ */
+void FreeType::Set_Color(ESETCOLOR type,short color)
+{
+	switch ( type ) 
+	{
+		case FreeType::BGCOLOR: 
+			{
+				m_pimpl->m_bgcolor_R = (color >> 11) & 0x1f;
+				m_pimpl->m_bgcolor_G = ( color >> 5 ) & 0x3f; 
+				m_pimpl->m_bgcolor_B = color & 0x1f; 
+			}
+			break;
+
+		case FreeType::FGCOLOR:
+			{
+				m_pimpl->m_fgcolor_R = (color >> 11) & 0x1f;
+				m_pimpl->m_fgcolor_G = ( color >> 5 ) & 0x3f; 
+				m_pimpl->m_fgcolor_B = color & 0x1f; 
+			}
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Create_Color of background color or forground color
+ *  Description:  Acoordinate the gray index to create new color 
+ * =====================================================================================
+ */
+short FreeType::Create_FG_Color(const uint8_t value )
+{
+	uint16_t r = ((( m_pimpl->m_fgcolor_R - m_pimpl->m_bgcolor_R ) * value) >> 8) + m_pimpl->m_bgcolor_R;
+	uint16_t g = ((( m_pimpl->m_fgcolor_G - m_pimpl->m_bgcolor_G ) * value) >> 8) + m_pimpl->m_bgcolor_G;
+	uint16_t b = ((( m_pimpl->m_fgcolor_B - m_pimpl->m_bgcolor_B ) * value) >> 8) + m_pimpl->m_bgcolor_B;
+	return  ( r << 11 ) + ( g << 5 ) + b;
+}
+short FreeType::Create_BG_Color(const uint8_t value )
+{
+	uint16_t r = ( m_pimpl->m_bgcolor_R * value ) >> 8 ;
+	uint16_t g = ( m_pimpl->m_bgcolor_G * value ) >> 8 ;
+	uint16_t b = ( m_pimpl->m_bgcolor_B * value ) >> 8 ;
+	return  ( r << 11 ) + ( g << 5 ) + b;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Text_Char
+ *  Description:  Text char out 
+ * =====================================================================================
+ */
+void FreeType::Text_Char(const int& x,const int& y,const wchar_t* str)
+{
+	int px = x;
+	int py = y;
+	size_t len = wcslen(str);
+	for ( size_t i=0;i<len;i++ )
+	{
+		Text_One_Char(px,py,FT_ULong(str[i]));
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Font_Size
+ *  Description:  Set the font size 
+ * =====================================================================================
+ */
+void FreeType::Set_Font_Size( int value )
+{
+	int error;
+	m_pimpl->m_fontsize = value;
+	error = FT_Set_Pixel_Sizes(m_pimpl->m_face,
+			m_pimpl->m_fontsize,
+			0
+			);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Transparce
+ *  Description:  Set the Transparece of class 
+ * =====================================================================================
+ */
+void FreeType::Set_Transparce(bool value) 
+{ 
+	m_pimpl->m_bTranspare = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Transparce
+ *  Description:  Get the Transparece status 
+ * =====================================================================================
+ */
+bool FreeType::Get_Transparce()
+{
+	return m_pimpl->m_bTranspare;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  utf8towcs
+ *  Description:  Convert utf8 char to wchat_t 
+ * =====================================================================================
+ */
+bool FreeType::utf8towcs(const uint8_t *utf8, size_t length, wchar_t* outbuf)
+{
+	if(!utf8 || length == 0) return true;
+	const uint8_t* pc = (const uint8_t*)utf8;
+	const uint8_t* last = pc + length;
+	uint b;
+	uint num_errors = 0;
+	int i = 0;
+	while (pc < last)
+	{
+		b = *pc++;
+
+		if( !b ) break; // 0 - is eos in all utf encodings
+
+		if ((b & 0x80) == 0)
+		{
+			//1-byte sequence: 000000000xxxxxxx = 0xxxxxxx
+				;
+		}
+		else if ((b & 0xe0) == 0xc0)
+		{
+			// 2-byte sequence: 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
+			if(pc == last) { outbuf[i++]='?'; ++num_errors; break; }
+			b = (b & 0x1f) << 6;
+			b |= (*pc++ & 0x3f);
+		}
+		else if ((b & 0xf0) == 0xe0)
+		{
+			// 3-byte sequence: zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
+			if(pc >= last - 1) { outbuf[i++]='?'; ++num_errors; break; }
+
+			b = (b & 0x0f) << 12;
+			b |= (*pc++ & 0x3f) << 6;
+			b |= (*pc++ & 0x3f);
+			if(b == 0xFEFF &&
+					i == 0) // bom at start
+				continue; // skip it
+		}
+		else if ((b & 0xf8) == 0xf0)
+		{
+			// 4-byte sequence: 11101110wwwwzzzzyy + 110111yyyyxxxxxx = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
+			if(pc >= last - 2) { outbuf[i++]='?'; break; }
+
+			b = (b & 0x07) << 18;
+			b |= (*pc++ & 0x3f) << 12;
+			b |= (*pc++ & 0x3f) << 6;
+			b |= (*pc++ & 0x3f);
+			// b shall contain now full 21-bit unicode code point.
+			assert((b & 0x1fffff) == b);
+			if((b & 0x1fffff) != b)
+			{
+				outbuf[i++]='?';
+				++num_errors;
+				continue;
+			}
+			if( sizeof(wchar_t) == 16 ) // Seems like Windows, wchar_t is utf16 code units sequence there.
+			{
+				outbuf[i++] = wchar_t(0xd7c0 + (b >> 10));
+				outbuf[i++] = wchar_t(0xdc00 | (b & 0x3ff));
+			}
+			else if( sizeof(wchar_t) >= 21 ) // wchar_t is full ucs-4
+			{
+				outbuf[i++] = wchar_t(b);
+			}
+			else
+			{
+				assert(0); // what? wchar_t is single byte here?
+			}
+		}
+		else
+		{
+			assert(0); //bad start for UTF-8 multi-byte sequence"
+			++num_errors;
+			b = '?';
+		}
+		outbuf[i++] = wchar_t(b);
+	}
+	return num_errors == 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Text
+ *  Description:  Draw the text on screen 
+ * =====================================================================================
+ */
+void FreeType::Text(int x,int y,const char* str)
+{
+	int len = strlen(str);
+	int rc = ((len+1)<<2);                           // 4 *  length is the unicode code number
+	wchar_t *wout = new wchar_t[rc]; 
+
+	char *cstr = new char[len+1];
+	for ( int i=0;i<=len;i++ )
+	{
+		cstr[i] = str[i];        		 //  include the '\0' charactor
+	}
+
+	if ( m_pimpl->m_CC->Code_Convert(cstr,len+1,(char *)wout,rc) == true )   // len+1 : because need to point out the end of string
+		Text_Char(x,y,wout);
+	else 
+		perror("Can't convert charactor");
+
+	delete[] wout;
+	wout = NULL;
+
+	delete[] cstr;
+	cstr = NULL;
+}
+
+//void  FreeType::Test(Graphic& g)
+//{
+//	char utf_16le[] = "中国GB中华人民共和国"; 
+//	char out[100];
+//	int rc;
+//
+//	ConvertCode* cc = ConvertCode::Instance();
+//	if ( cc->Init_CodeConvert("utf-8","gbk") )  // utf-8   gb18030>gbk>gb2312   UCS-2LE
+//	{
+//		cc->Code_Convert(utf_16le,sizeof(utf_16le),out,100);
+//		g.Textout(100,20,out,g_BUTXNO_CO,g_BUBGNO_CO);
+//		cc->Destory_CodeConvert();
+//	}
+
+
+//	char utf_16le[] = TEST; 
+//	char out[100];
+//	int rc=100;
+//	wchar_t wout[100];
+//
+//	ConvertCode* cc = ConvertCode::Instance();
+//	if ( cc->Init_CodeConvert("gb18030","WCHAR_T") )  
+//	{
+//		if ( cc->Code_Convert(utf_16le,sizeof(utf_16le),(char *)wout,rc) == true )
+//		{
+//			Text_Char(300,50,wout);
+//		}
+//		else 
+//			printf ( "BAD\n" );
+//		cc->Destory_CodeConvert();
+//	}
+//}
diff --git a/src/EVA11/base/FreeType.h b/src/EVA11/base/FreeType.h
new file mode 100644
index 0000000..9c554e6
--- /dev/null
+++ b/src/EVA11/base/FreeType.h
@@ -0,0 +1,73 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  FreeType.h
+ *
+ *    Description:  Manage freetype fonts 
+ *
+ *        Version:  1.0
+ *        Created:  2012年10月16日 14时23分30秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  FREETYPE_INC
+#define  FREETYPE_INC
+
+#include 	<memory>
+
+#include 	<ft2build.h>
+#include 	<freetype/freetype.h>                       /* Becareful the head file define from FT_MACRO  */
+#include 	<stdint.h>
+
+class Graphic;
+class FreeType
+{
+	public:
+		typedef enum
+		{
+			BGCOLOR,
+			FGCOLOR,
+		} ESETCOLOR;
+
+		static FreeType* Instance();                /* only used this function to visit variables   */
+
+		bool Init_FreeType(Graphic& g,const char* path);
+		void Destroy_FreeType();
+
+		void Text_Char(const int &x,const int &y,const wchar_t* str);
+		void Set_Color(ESETCOLOR type,short color);
+		void Set_Transparce(bool value);
+		bool Get_Transparce();
+		void Set_Font_Size( int value );
+		void Text(int x,int y,const char*);
+
+//		void  Test(Graphic& g);
+	protected:
+
+	private:
+		FreeType ();
+		~FreeType ();
+		FreeType (const FreeType&);
+		FreeType& operator = (const FreeType&);
+
+		int Text_One_Char(int& x,int& y,FT_ULong word);
+		void Set_One_Pixel(const int x,const int y,const short value);
+
+		inline short Create_FG_Color(const uint8_t value );
+		inline short Create_BG_Color(const uint8_t value );
+
+		bool utf8towcs(const uint8_t *utf8, size_t length, wchar_t* outbuf);
+	private:
+		friend class std::auto_ptr<FreeType>;
+		static std::auto_ptr<FreeType>		m_Instance;
+
+		class Impl;
+		std::auto_ptr<class Impl>		m_pimpl;
+};
+#endif
diff --git a/src/EVA11/base/GUILowCode.hpp b/src/EVA11/base/GUILowCode.hpp
new file mode 100644
index 0000000..0dca1a5
--- /dev/null
+++ b/src/EVA11/base/GUILowCode.hpp
@@ -0,0 +1,850 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  GUILowCode.hpp
+ *
+ *    Description:  Recreate the GUILowCode class with template
+ *                  and with the singleton pattern 
+ *                  it is a template file
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月10日 17时09分48秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  GUILowCode_inc
+#define  GUILowCode_inc
+
+#include 	<fcntl.h> 
+#include        <unistd.h> 
+#include        <sys/ioctl.h>
+#include 	<memory>
+#include        <linux/fb.h> 
+#include 	<sys/mman.h> 
+#include 	<inttypes.h>
+
+/*-----------------------------------------------------------------------------
+ *  BP type:    16bit: uint16_t 
+ *       	 8bit: uint8_t 
+ *       	 1bit: bool
+ *-----------------------------------------------------------------------------*/
+class GUIInterface;
+template <typename BP>
+class GUILowCode
+{
+	public:
+		typedef enum
+		{
+			MODE_SRC,
+			MODE_SRC_XOR_DST,
+		} CopyMode;
+
+		static GUILowCode* Instance();
+
+		void Init_GUILowCode_Parameters(int,int,int,int,uint8_t*,uint8_t*,GUILowCode<BP>::CopyMode);
+
+		void Setpixel(int,int,BP);
+		void Line(int,int,int,int,BP);
+		void Dot_Line(int,int,int,int,BP);
+		void HLine_Fast(int,int,int,BP);
+
+		void Set_Area_Color(int,int,int,int,BP);
+		void Rectangle(int,int,int,int,BP);
+		void DrawRect(int,int,int,int,BP);
+
+		void Screen_Copy(int left,int up,int right,int down,int flag);
+		void Switch_Screen();
+
+		int Get_Disp_Area_Bytes(int left,int up,int right,int down);
+
+		void Movemem(short,short,short,short);
+		void MovememH(short,short,short,short,int);
+
+		void SetMode(CopyMode m);
+		CopyMode GetMode();
+	protected:
+
+	private:
+		GUILowCode ();
+		~GUILowCode ();
+		GUILowCode ( const GUILowCode& );
+		GUILowCode& operator = ( const GUILowCode& );
+
+		friend class std::auto_ptr< GUILowCode<BP> >;
+		static std::auto_ptr< GUILowCode<BP> >		m_Instance;
+
+		void draw_xish_line(int x,int y,int dx,int dy,int xdir,BP color);
+		void draw_yish_line(int x,int y,int dx,int dy,int ydir,BP color);
+
+		void draw_xdot_line(int x,int y,int dx,int dy,int xdir,BP color);
+		void draw_ydot_line(int x,int y,int dx,int dy,int xdir,BP color);
+
+		void WholeCircle(int,int,int,int,BP);
+		void Plot_Circle(int,int,int,int,BP,double);
+		void Word_Memcpy(uint8_t *des,uint8_t *src,int len);
+
+	private:
+		friend	class 					GUIInterface;
+		int						m_Screen_Width;
+		int						m_Screen_Height;
+		int						m_BPP;
+		int						m_BPP_Shift;
+		int						m_Buffer_Len;
+		uint8_t					       *m_Ptr;
+		uint8_t					       *m_Shadow_Ptr;
+		CopyMode					Mode;
+};
+
+template <typename BP>
+std::auto_ptr< GUILowCode<BP> > GUILowCode<BP>::m_Instance;
+
+template <typename BP>
+GUILowCode<BP>::GUILowCode()
+{
+}
+
+template <typename BP>
+GUILowCode<BP>::~GUILowCode()
+{
+}
+
+template <typename BP>
+GUILowCode<BP>* GUILowCode<BP>::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new GUILowCode<BP> );
+	}
+	return m_Instance.get();
+}
+
+template <typename BP>
+void GUILowCode<BP>::Init_GUILowCode_Parameters(int w,int h,int bpp,int len,uint8_t* ptr,uint8_t* show_ptr,CopyMode mode)
+{
+	m_Screen_Width 	= w;
+	m_Screen_Height	= h;
+	m_BPP		= bpp;
+
+	if 	( m_BPP == 1 )
+		m_BPP_Shift = 0;
+	else if ( m_BPP == 8 )
+		m_BPP_Shift = 1;
+	else if ( m_BPP == 16 )
+		m_BPP_Shift = 2;
+	else 
+		printf ( "BPP is not 1,8,16" );
+
+	m_Buffer_Len    = len;
+	m_Ptr		= ptr;
+	m_Shadow_Ptr    = show_ptr;
+	Mode		= mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Setpixel
+ *  Description:  Draw a pixel on screen
+ * =====================================================================================
+ */
+template <>
+void GUILowCode<uint16_t>::Setpixel(int x,int y,uint16_t color)
+{
+	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
+	    return;
+
+	switch ( Mode )
+	{
+		case MODE_SRC:
+			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) = color; 
+			break;
+		case MODE_SRC_XOR_DST:
+			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) ^= color;
+			break;
+		default:	
+			*(uint16_t *)( m_Ptr + y * m_Screen_Width * 2 + x * 2 ) = color;
+			break;
+	}
+}
+
+template <>
+void GUILowCode<uint8_t>::Setpixel(int x,int y,uint8_t color)
+{
+	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
+	    return;
+
+	switch ( Mode )
+	{
+		case MODE_SRC:
+			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) = color;
+			break;
+		case MODE_SRC_XOR_DST:
+			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) ^= color;
+			break;
+		default:	
+			*(uint8_t *)( m_Ptr +  y * m_Screen_Width + x ) = color;
+			break;
+	}
+}
+
+static uint8_t masktab[]={0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
+template <>
+void GUILowCode<bool>::Setpixel(int x,int y,bool color)
+{
+	if ( (x<0) || (x>=m_Screen_Width) || (y<0) || (y>=m_Screen_Height) )
+	    return;
+
+	switch ( Mode )
+	{
+		case MODE_SRC:
+			if ( color == true )
+				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) |= masktab[x&0x07];
+			else               
+				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) &= ~masktab[x&0x07];
+			break;
+		case MODE_SRC_XOR_DST:
+			if ( color == true )
+				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) ^= masktab[x&0x07];
+			break;
+		default:
+			if ( color == true )
+				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) |= masktab[x&0x07];
+			else               
+				*(uint8_t *)( m_Ptr + (y * ( m_Screen_Width >> 3 ) + ( x >> 3 ) ) ) &= ~masktab[x&0x07];
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  HLine_Fast
+ *  Description:  Fast Draw H-Line 
+ * =====================================================================================
+ */
+template <>
+void GUILowCode<uint16_t>::HLine_Fast(int x1,int x2,int y,uint16_t color)
+{
+	uint16_t *loc = (uint16_t *)( m_Ptr + ( ( y * m_Screen_Width ) << 1) );
+	for ( int i=x1;i<=x2;i++ )
+		*(loc+i) = color; 
+}
+template <>
+void GUILowCode<uint8_t>::HLine_Fast(int x1,int x2,int y,uint8_t color)
+{
+	uint8_t * loc = m_Ptr + ( y * m_Screen_Width );
+	if ( (x1&0x0001) )
+	{
+		*(loc + x1) = color;
+	}
+	else
+	{
+		*((uint16_t *)( loc ) + (x1>>1) ) = ( color<<8 ) | color;
+	}
+	if ( (x2&0x0001) )
+	{
+		*((uint16_t *)( loc ) + (x2>>1) ) = ( color<<8 ) | color;
+	}
+	else 
+	{
+		*(loc + x2) = color;
+	}
+	for ( int index = (x1>>1)+1;index < (x2>>1);index ++ ) 
+	{
+		*((uint16_t *)(loc) + index ) = ( color<<8 ) | color;
+	}
+}
+template <>
+void GUILowCode<bool>::HLine_Fast(int x1,int x2,int y,bool color)
+{
+	int x1_m = ( x1 >> 3 ) + 1;
+	int x2_m = x2 >> 3;
+	int x1_r = x1 & 0x0007;
+	int x2_r = x2 & 0x0007;
+
+	uint8_t * loc = m_Ptr + y * ( m_Screen_Width >> 3 );
+
+	if 	( color == true )
+	{
+		for ( int i=x1_m;i<x2_m;i++ )
+		{
+			*(loc+i) |= 0xff; 
+		}
+		if ( x2_m >= x1_m )
+		{
+			*(loc+x1_m-1) |= ( 0xff >> x1_r ); 
+			*(loc+x2_m)   |= ( 0xff << ( 7 - x2_r ) ); 
+		}
+		else
+		{
+			Line(x1,y,x2,y,color);
+		}
+	}
+	else
+	{
+		for ( int i=x1_m;i<x2_m;i++ )
+		{
+			*(loc+i) &= 0x00; 
+		}
+		if ( x2_m >= x1_m )
+		{
+			*(loc+x1_m-1) &= ~( 0xff >> x1_r ); 
+			*(loc+x2_m)   &= ~( 0xff << ( 7 - x2_r ) ); 
+		}
+		else
+		{
+			Line(x1,y,x2,y,color);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Area_Color
+ *  Description:  Set the area's color 
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Set_Area_Color(int x1,int y1,int x2,int y2,BP color)
+{
+	for (int i=y1;i<=y2;i++ )
+	{
+		HLine_Fast(x1,x2,i,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  darw_xish_line
+ *  Description:  Draw line on screen depending on the x y
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::draw_xish_line(int x,int y,int dx,int dy,int xdir,BP color)
+{
+	int dyX2=dy*2;
+	int dyX2mdxX2=dyX2-(dx*2);
+	int error=dyX2-dx;
+	Setpixel(x, y, color);
+	while (dx--) 
+	{
+		if (error >= 0) 
+		{
+			y++;
+			error += dyX2mdxX2;
+		}
+		else 
+		{
+			error += dyX2;
+		}
+		x += xdir;
+		Setpixel(x,y,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  darw_xdot_line
+ *  Description:  Draw Dot line on screen depending on the x y
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::draw_xdot_line(int x,int y,int dx,int dy,int xdir,BP color)
+{
+	int dyX2=dy*2;
+	int dyX2mdxX2=dyX2-(dx*2);
+	int error=dyX2-dx;
+
+	int maxspace = 1;
+	int space = maxspace;
+
+	Setpixel(x, y, color);
+	while (dx--) 
+	{
+		if (error >= 0) 
+		{
+			y++;
+			error += dyX2mdxX2;
+		}
+		else 
+		{
+			error += dyX2;
+		}
+		x += xdir;
+
+		if ( space == 0 )
+		{
+			Setpixel(x,y,color);
+			space = maxspace;
+		}
+		else
+			space --;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  darw_yish_line
+ *  Description:  Draw line on screen depending on the x y
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::draw_yish_line(int x,int y,int dx,int dy,int xdir,BP color)
+{
+	int dxX2=dx*2;
+	int dxX2mdyX2=dxX2-(dy*2);
+	int error=dxX2-dy;
+	Setpixel(x, y,color);
+	while (dy--) 
+	{
+		if (error >= 0) 
+		{
+			x+= xdir;
+			error += dxX2mdyX2;
+		} else 
+		{
+			error += dxX2;
+		}
+		y++;
+		Setpixel(x,y,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  darw_ydot_line
+ *  Description:  Draw Dot line on screen depending on the x y
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::draw_ydot_line(int x,int y,int dx,int dy,int xdir,BP color)
+{
+	int dxX2=dx*2;
+	int dxX2mdyX2=dxX2-(dy*2);
+	int error=dxX2-dy;
+
+	int maxspace = 1;
+	int space = maxspace;
+
+	Setpixel(x, y,color);
+	while (dy--) 
+	{
+		if (error >= 0) 
+		{
+			x+= xdir;
+			error += dxX2mdyX2;
+		} else 
+		{
+			error += dxX2;
+		}
+		y++;
+
+		if ( space == 0 )
+		{
+			Setpixel(x,y,color);
+			space = maxspace;
+		}
+		else
+			space --;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Line
+ *  Description:  Draw a line on screen, (x1 y1) (x2 y2)  with color
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Line(int x1,int y1,int x2,int y2,BP color)
+{
+	int dx,dy;
+	if ( y1 > y2) 
+	{
+		int t = y1;
+		y1 = y2;
+		y2 = t;
+		t = x1;
+		x1 = x2;
+		x2 = t;
+	}
+	dx = x2-x1;
+	dy = y2-y1;
+	if (dx > 0) 
+	{
+		if (dx > dy)
+			draw_xish_line(x1, y1, dx, dy, 1,color);
+		else
+			draw_yish_line(x1, y1, dx, dy, 1,color);
+	} 
+	else 
+	{
+		dx = -dx;
+		if (dx > dy)
+			draw_xish_line(x1, y1, dx, dy, -1,color);
+		else
+			draw_yish_line(x1, y1, dx, dy, -1,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Dot_Line
+ *  Description:  Draw a dot line on screen, (x1 y1) (x2 y2)  with color
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Dot_Line(int x1,int y1,int x2,int y2,BP color)
+{
+	int dx,dy;
+	if ( y1 > y2 )
+	{
+		int t = y1;
+		y1 = y2;
+		y2 = t;
+		t = x1;
+		x1 = x2;
+		x2 = t;
+	}
+	dx = x2-x1;
+	dy = y2-y1;
+	if (dx > 0) 
+	{
+		if (dx > dy)
+			draw_xdot_line(x1, y1, dx, dy, 1,color);
+		else
+			draw_ydot_line(x1, y1, dx, dy, 1,color);
+	} 
+	else 
+	{
+		dx = -dx;
+		if (dx > dy)
+			draw_xdot_line(x1, y1, dx, dy, -1,color);
+		else
+			draw_ydot_line(x1, y1, dx, dy, -1,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Rectangle
+ *  Description:  Draw a ractangel on screen
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Rectangle(int x1,int y1,int x2,int y2,BP color)
+{
+	Line(x1,y1,x2,y1,color);
+	Line(x2,y1,x2,y2,color);
+	Line(x2,y2,x1,y2,color);
+	Line(x1,y2,x1,y1,color);
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawRect
+ *  Description:  Draw the Rectangle sharp 
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::DrawRect(int x,int y,int width,int height,BP color)
+{
+	Rectangle(x,y,x+width-1,y+height-1,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  WholeCircle
+ *  Description:  The second circle drawing meathod
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::WholeCircle(int xc,int yc,int x,int y,BP color)
+{
+	Setpixel(xc+x,yc+y,color);
+	Setpixel(xc-x,yc+y,color);
+	Setpixel(xc+x,yc-y,color);
+	Setpixel(xc-x,yc-y,color);
+
+	Setpixel(xc+y,yc+x,color);
+	Setpixel(xc-y,yc+x,color);
+	Setpixel(xc+y,yc-x,color);
+	Setpixel(xc-y,yc-x,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Plot_Circle
+ *  Description:  Used for Drawing ecllipse GUILowCode 
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Plot_Circle(int x,int y,
+		 	      int x_center,int y_center,
+		 	      BP co,double ratio)
+{
+	int startx,endx,x1,starty,endy,y1;
+	starty=static_cast<int>(y*ratio); endy=static_cast<int>((y+1)*ratio);
+	startx=static_cast<int>(x*ratio); endx=static_cast<int>((x+1)*ratio);
+	for (x1=startx;x1<endx;++x1)
+	{
+		Setpixel(x1+x_center,y+y_center,co);
+		Setpixel(x1+x_center,-y+y_center,co);
+		Setpixel(-x1+x_center,-y+y_center,co);
+		Setpixel(-x1+x_center,y+y_center,co);
+	}
+	for (y1=starty;y1<endy;++y1)
+	{
+		Setpixel(y1+x_center,x+y_center,co);
+		Setpixel(y1+x_center,-x+y_center,co);
+		Setpixel(-y1+x_center,-x+y_center,co);
+		Setpixel(-y1+x_center,x+y_center,co);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Screen
+ *  Description:  Switch the screen ptr 
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Switch_Screen()
+{
+	uint8_t *temp;
+	temp = m_Shadow_Ptr;	
+	m_Shadow_Ptr = m_Ptr;
+	m_Ptr = temp;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Word_Memcpy
+ *  Description:  Copy memory to showmemory as word length
+ * =====================================================================================
+ */
+template <>
+void GUILowCode<uint16_t>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
+{
+	uint16_t *des_w,*src_w;
+	len = len >> 1;
+	des_w = (uint16_t *)des;
+	src_w = (uint16_t *)src;
+	while(len--)
+		*des_w++ = *src_w++;
+}
+
+template <>
+void GUILowCode<uint8_t>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
+{
+	if ( len == 1 )
+		while(len--)
+			*des++ = *src++;
+	else
+	{
+		uint16_t *des_w,*src_w;
+		int sub=0;
+		if ( ((int)des & 0x0001) )
+		{
+			*des = *src;
+			sub++;
+			des_w = (uint16_t *)(des+1);
+			src_w = (uint16_t *)(src+1);
+		}
+		else
+		{
+			*des     = *src;
+			*(des+1) = *(src+1);
+			sub += 2;
+			des_w = (uint16_t *)(des+2);
+			src_w = (uint16_t *)(src+2);
+		}
+		if ( ( (int)( des + len - 1 ) & 0x0001 ) )
+		{
+			*(des + len - 2) = *(src + len - 2);
+			*(des + len - 1) = *(src + len - 1);
+			sub += 2;
+		}
+		else
+		{
+			*(des + len - 1) = *(src + len - 1);
+			sub++;
+		}
+		len = ((len - sub) >> 1);
+		while(len--)
+			*des_w++ = *src_w++;
+	}
+}
+
+template <>
+void GUILowCode<bool>::Word_Memcpy(uint8_t *des,uint8_t *src,int len)
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Screen_Copy
+ *  Description:  Screen Copy function for copy scr buffer to scr shadow buffer 
+ *  	   Flag: false shadow->real
+ *               true  real->shadow
+ * =====================================================================================
+ */
+template <typename BP>
+void GUILowCode<BP>::Screen_Copy(int left,int up,int right,int down,int flag)
+{
+	if 	( flag == false )
+	{
+		for ( int i = up;i <= down;i ++ )
+		{
+			Word_Memcpy( m_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
+				    m_Shadow_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
+				    m_BPP_Shift * ( right - left + 1 ) );
+		}
+	}
+	else
+	{
+		for ( int i = up;i <= down;i ++ )
+		{
+			Word_Memcpy( m_Shadow_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
+				    m_Ptr + m_Screen_Width * m_BPP_Shift * i + m_BPP_Shift * left,
+				    m_BPP_Shift * ( right - left + 1 ) );
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Disp_Area_Bytes
+ *  Description:  Get the display area byres number
+ * =====================================================================================
+ */
+template <>
+int GUILowCode<uint16_t>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
+{
+	return 2 * ( right - left + 1) * ( down - up + 1 );
+}
+template <>
+int GUILowCode<uint8_t>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
+{
+	return ( right - left + 1) * ( down - up + 1 );
+}
+template <>
+int GUILowCode<bool>::Get_Disp_Area_Bytes(int left,int up,int right,int down)
+{
+	return ( ( right - left + 1) * ( down - up + 1 ) ) >> 3;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Movemen
+ *  Description:  Move GUI memory of screen 
+ * =====================================================================================
+ */
+template <>
+void GUILowCode<uint16_t>::Movemem(short x,short y,short height,short width)
+{
+	int nBytes;
+	int nCount;
+   	short dir = ( height<0 );
+   	if ( dir ) height = -height;
+
+	nBytes=height*m_Screen_Width*2;
+	nCount=width * 2;
+	if ( dir )  //Down Scroll
+	{ 
+		memmove(m_Ptr+((x+y*m_Screen_Width)*2)+nBytes,m_Ptr+((x+y*m_Screen_Width)*2),nCount);
+		memset(m_Ptr+((x+y*m_Screen_Width)*2),0,nCount);
+	}
+	else        //Up Scroll
+	{   
+		memmove(m_Ptr+(x+y*m_Screen_Width)*2-nBytes,m_Ptr+(x+y*m_Screen_Width)*2,nCount);
+		memset(m_Ptr+((x+y*m_Screen_Width)*2),0,nCount);
+	}
+}
+template <>
+void GUILowCode<uint8_t>::Movemem(short x,short y,short height,short width)
+{
+	int nBytes;
+	int nCount;
+   	short dir = ( height<0 );
+   	if ( dir ) height = -height;
+
+	nBytes=height*m_Screen_Width*1;
+	nCount=width * 1;
+	if ( dir )  //Down Scroll
+	{ 
+		memmove(m_Ptr+((x+y*m_Screen_Width)*1)+nBytes,m_Ptr+((x+y*m_Screen_Width)*1),nCount);
+		memset(m_Ptr+((x+y*m_Screen_Width)*1),0,nCount);
+	}
+	else        //Up Scroll
+	{   
+		memmove(m_Ptr+(x+y*m_Screen_Width)*1-nBytes,m_Ptr+(x+y*m_Screen_Width)*1,nCount);
+		memset(m_Ptr+((x+y*m_Screen_Width)*1),0,nCount);
+	}
+}
+template <>
+void GUILowCode<bool>::Movemem(short x,short y,short height,short width)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  MovemenH
+ *  Description:  Move GUI memory of horizon screen 
+ * =====================================================================================
+ */
+template <>
+void GUILowCode<uint16_t>::MovememH(short x,short y,short height,short width,int color)
+{
+	for ( int i=0; i<height; i++ )
+	{
+		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x+width)<<1))) = 
+		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x)<<1)));
+		*((unsigned short *)(m_Ptr+(((i+y)*m_Screen_Width+x)<<1))) = color; 
+	}
+}
+template <>
+void GUILowCode<uint8_t>::MovememH(short x,short y,short height,short width,int color)
+{
+	for ( int i=0; i<height; i++ )
+	{
+		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x+width)) = 
+		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x));
+		*((unsigned char *)(m_Ptr+(i+y)*m_Screen_Width+x)) = color; 
+	}
+}
+template <>
+void GUILowCode<bool>::MovememH(short x,short y,short height,short width,int color)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SetMode
+ *  Description:  SetMode of Draw Screen
+ * =====================================================================================
+ */
+template<typename BP>
+void GUILowCode<BP>::SetMode(CopyMode m)
+{
+	Mode = m;	
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GetMode
+ *  Description:  Return the Mode of GUILowCode class drawmode 
+ *      Caution:  typename very important
+ * =====================================================================================
+ */
+template<typename BP>
+typename GUILowCode<BP>::CopyMode GUILowCode<BP>::GetMode()
+{
+	return Mode;
+}
+#endif
diff --git a/src/EVA11/base/Gif.cpp b/src/EVA11/base/Gif.cpp
new file mode 100644
index 0000000..ca2f709
--- /dev/null
+++ b/src/EVA11/base/Gif.cpp
@@ -0,0 +1,251 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Gif.cpp
+ *
+ *    Description:  Imaplementation of Gif class
+ *
+ *        Version:  1.0
+ *        Created:  2013年09月04日 10时54分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdlib>
+#include 	<cstring>
+
+#include 	<SDL.h>
+
+#include 	"Gif.h"
+#include 	"Graphic.h"
+
+#define PROGRAM_NAME	"EVA11"
+#define GIF_MESSAGE(Msg) fprintf(stderr, "\n%s: %s\n", PROGRAM_NAME, Msg)
+#define GIF_EXIT(Msg)    { GIF_MESSAGE(Msg); exit(-3); }
+
+Gif::Gif() : m_DelayMSecond(100)
+{
+	g = Graphic::Instance();
+}
+
+Gif::~Gif()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Read_Gif_File
+ *  Description:  Read the gif file and display it on screen  
+ * =====================================================================================
+ */
+void Gif::Read_Gif_File(const char* path,const int& x,const int& y)
+{
+	int Error;
+    	int Size, Row, Col, Width, Height, ExtCode, Count;
+	GifRecordType RecordType;
+	GifByteType *Extension;
+	GifRowType *ScreenBuffer;
+	GifFileType *GifFile;
+	ColorMapObject *ColorMap;
+	int
+		InterlacedOffset[] = { 0, 4, 2, 1 }, /* The way Interlaced image should. */
+		InterlacedJumps[] = { 8, 8, 4, 2 };    /* be read - offsets and jumps... */
+	int ImageNum = 0;
+
+	if ((GifFile = DGifOpenFileName(path, &Error)) == NULL) 
+	{
+		PrintGifError(Error);
+		return;
+	}
+
+	if ((ScreenBuffer = (GifRowType *)
+				malloc(GifFile->SHeight * sizeof(GifRowType))) == NULL)
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+
+	Size = GifFile->SWidth * sizeof(GifPixelType);/* Size in bytes one row.*/
+	if ((ScreenBuffer[0] = (GifRowType) malloc(Size)) == NULL) /* First row. */
+		GIF_EXIT("Failed to allocate memory required, aborted.");
+
+	for (int i = 0; i < GifFile->SWidth; i++)  /* Set its color to BackGround. */
+		ScreenBuffer[0][i] = GifFile->SBackGroundColor;
+	for (int i = 1; i < GifFile->SHeight; i++) {
+		/* Allocate the other rows, and set their color to background too: */
+		if ((ScreenBuffer[i] = (GifRowType) malloc(Size)) == NULL)
+			GIF_EXIT("Failed to allocate memory required, aborted.");
+
+		memcpy(ScreenBuffer[i], ScreenBuffer[0], Size);
+	}
+
+//	unsigned char *mem = new unsigned char[g->Get_Disp_Area_Bytes(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1)];
+//	g->Load_Disp_Area(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1,mem); 	   /* save the screen graphic buffer */
+
+	/* Scan the content of the GIF file and load the image(s) in: */
+	do {
+		if (DGifGetRecordType(GifFile, &RecordType) == GIF_ERROR) 
+		{
+			PrintGifError(GifFile->Error);
+			break;
+		}
+		switch (RecordType) 
+		{
+			case IMAGE_DESC_RECORD_TYPE:
+				if (DGifGetImageDesc(GifFile) == GIF_ERROR) 
+				{
+					PrintGifError(GifFile->Error);
+					goto Fail_Exit;
+				}
+
+				Row = GifFile->Image.Top; /* Image Position relative to Screen. */
+				Col = GifFile->Image.Left;
+				Width = GifFile->Image.Width;
+				Height = GifFile->Image.Height;
+
+				if (GifFile->Image.Left + GifFile->Image.Width > GifFile->SWidth ||
+						GifFile->Image.Top + GifFile->Image.Height > GifFile->SHeight) 
+				{
+					fprintf(stderr, "Image %d is not confined to screen dimension, aborted.\n",0);
+					goto Fail_Exit;
+				}
+				if (GifFile->Image.Interlace) 
+				{
+					/* Need to perform 4 passes on the images: */
+					for (int i = 0; i < 4; i++)
+						for (int j = Row + InterlacedOffset[i]; j < Row + Height;
+								j += InterlacedJumps[i]) 
+						{
+							if (DGifGetLine(GifFile, &ScreenBuffer[j][Col],
+										Width) == GIF_ERROR) 
+							{
+								PrintGifError(GifFile->Error);
+								goto Fail_Exit;
+							}
+						}
+				}
+				else
+				{
+					for (int i = 0; i < Height; i++) 
+					{
+						if (DGifGetLine(GifFile, &ScreenBuffer[Row++][Col],
+									Width) == GIF_ERROR) 
+						{
+							PrintGifError(GifFile->Error);
+							goto Fail_Exit;
+						}
+					}
+				}
+
+				ColorMap = (GifFile->Image.ColorMap
+						? GifFile->Image.ColorMap
+						: GifFile->SColorMap);
+
+				if (ColorMap == NULL)
+				{
+					fprintf(stderr, "Gif Image does not have a colormap\n");
+					goto Fail_Exit;
+				}
+
+				Dump2Screen(x,y,
+					    ColorMap,
+					    ScreenBuffer, 
+					    GifFile->SWidth, 
+					    GifFile->SHeight);
+
+				SDL_Delay(m_DelayMSecond);
+
+				break;
+			case EXTENSION_RECORD_TYPE:
+				/* Skip any extension blocks in file: */
+				if (DGifGetExtension(GifFile, &ExtCode, &Extension) == GIF_ERROR) 
+				{
+					PrintGifError(GifFile->Error);
+					goto Fail_Exit;
+				}
+				while (Extension != NULL) 
+				{
+					if (DGifGetExtensionNext(GifFile, &Extension) == GIF_ERROR) 
+					{
+						PrintGifError(GifFile->Error);
+						goto Fail_Exit;
+					}
+				}
+				break;
+			case TERMINATE_RECORD_TYPE:
+				break;
+			default:		    /* Should be trapped by DGifGetRecordType. */
+				break;
+		}
+	} while (RecordType != TERMINATE_RECORD_TYPE);
+
+//	g->Restore_Disp_Area(x,y,x+GifFile->SWidth-1,y+GifFile->SHeight-1,mem); /* restore the graphic buffer */
+//	delete[] mem;                                                 /* release the buffer */
+//	mem = NULL;
+
+	(void)free(ScreenBuffer);
+
+Fail_Exit:
+
+	if (DGifCloseFile(GifFile) == GIF_ERROR) 
+	{
+		PrintGifError(GifFile->Error);
+		return;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  PrintGifError
+ *  Description:  Printf Error Message  
+ * =====================================================================================
+ */
+void Gif::PrintGifError(int ErrorCode)
+{
+	char *Err = GifErrorString(ErrorCode);
+
+	if (Err != NULL)
+		fprintf(stderr, "GIF-LIB error: %s.\n", Err);
+	else
+		fprintf(stderr, "GIF-LIB undefined error %d.\n", ErrorCode);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Dump2Screen
+ *  Description:  Show Gif file on screen 
+ * =====================================================================================
+ */
+void Gif::Dump2Screen(int x,int y,ColorMapObject *ColorMap, GifRowType *ScreenBuffer, int ScreenWidth, int ScreenHeight)
+{
+	uint16_t *BufferP = (uint16_t *)g->Get_Screen_Ptr() + x + y * g->Get_Screen_Width();
+
+	GifRowType GifRow;
+	GifColorType *ColorMapEntry;
+	for (int i = 0; i < ScreenHeight; i++) 
+	{
+		GifRow = ScreenBuffer[i];
+		for (int j = 0; j < ScreenWidth; j++) 
+		{
+			ColorMapEntry = &(ColorMap->Colors[GifRow[j]]);
+			*BufferP++ = g->RGB24_16((ColorMapEntry->Red<<16)+(ColorMapEntry->Green<<8)+(ColorMapEntry->Blue<<0));
+		}
+		BufferP = (uint16_t *)g->Get_Screen_Ptr() + x + y * g->Get_Screen_Width() + ( i + 1 ) * g->Get_Screen_Width();
+	}
+#ifdef X86
+	g->Update_Rect(x,y,ScreenWidth,ScreenHeight);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Delay_MSecond
+ *  Description:  Set Delay MSecond 
+ * =====================================================================================
+ */
+void Gif::Set_Delay_MSecond(int count)
+{
+	m_DelayMSecond = count;
+}
diff --git a/src/EVA11/base/Gif.h b/src/EVA11/base/Gif.h
new file mode 100644
index 0000000..2d18db1
--- /dev/null
+++ b/src/EVA11/base/Gif.h
@@ -0,0 +1,40 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Gif.h
+ *
+ *    Description:  Manage Gif picture process class
+ *
+ *        Version:  1.0
+ *        Created:  2013年09月04日 10时52分57秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  GIF_INC
+#define  GIF_INC
+
+#include 	<gif_lib.h>	
+class Graphic;
+class Gif
+{
+	public:
+		Gif ();                             				/* constructor */
+		~Gif ();                            				/* destructor  */
+		void Read_Gif_File(const char* path,const int& x,const int& y);
+		void Set_Delay_MSecond(int count);
+
+	private:	
+		void PrintGifError(int ErrorCode);
+		void Dump2Screen(int x,int y,ColorMapObject *ColorMap, GifRowType *ScreenBuffer, int ScreenWidth, int ScreenHeight);
+	private:
+		Graphic*				g;
+		int					m_DelayMSecond;
+};
+
+#endif   /* ----- #ifndef GIF_INC  ----- */
diff --git a/src/EVA11/base/Global.cpp b/src/EVA11/base/Global.cpp
new file mode 100644
index 0000000..f45af0c
--- /dev/null
+++ b/src/EVA11/base/Global.cpp
@@ -0,0 +1,752 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Global.cpp
+ *
+ *    Description:  implementation of Gobal class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月07日 09时05分33秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cmath>
+#include	<stdio.h>
+#include	<iostream>
+#include	<fstream>
+
+#include	"Global.h" 
+
+std::auto_ptr<Global> Global::m_Instance;
+
+Global::Global ()
+{
+	Tick        = 0;
+	bTickStop   = false;
+	bTickPasuse = false;
+	RunTimer.restart();
+	Time_start  = boost::posix_time::second_clock::universal_time();
+}  /* -----  end of method Global::Global  (constructor)  ----- */
+
+Global::~Global ()
+{
+}  /* -----  end of method Global::Global  (destructor)  ----- */
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Global* Global::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Global() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Global_Variables
+ *  Description:  Save the Gloabal variables into nand flash 
+ * =====================================================================================
+ */
+bool Global::Save_Global_Variables(std::string path)
+{
+	bool result = false;
+	std::ofstream oo;
+	oo.open(path.c_str(),std::ofstream::binary|std::ofstream::trunc);
+	if ( !oo )
+	{
+		perror("can't save para file");
+		result = false;
+	}
+	else
+	{
+		oo<<*this;
+		result = true;
+		oo.flush();
+		oo.close();
+		sync();
+	}
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Global_Variables
+ *  Description:  Load the Global variables from nand flash 
+ * =====================================================================================
+ */
+bool Global::Load_Global_Variables(std::string path)
+{
+	bool result = false;
+	std::ifstream io;
+	io.open(path.c_str(),std::ifstream::binary);
+	if ( !io.is_open() )
+	{
+		perror("can't load para file");
+		result = false;
+	}
+	else
+	{
+		io>>*this;
+		result = true;
+		io.close();
+		sync();
+	}
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Global_Variable
+ *  Description:  Init the GLobal variables 
+ * =====================================================================================
+ */
+void Global::Init_Global_Variables()
+{
+	for ( int i=0;i<CHANCOUNT;i++ )
+	{
+		HDGain[i]    = 4;
+		Degree[i]    = 0;
+		Gain[i]      = 250;
+		HiFilter[i]  = 0;
+		LoFilter[i]  = -1;
+		DFilter[i]   = 0;
+		ProbeFun[i]  = 0;       //0:close 1:ET 2:FET 3:EMS
+		FreqIndex[i] = 0;
+
+		DriverBal[i] = 8;
+		DriverA_ID[i]= 0;
+		DriverB_ID[i]= 1;
+		PickA_ID[i]  = 0;
+		PickB_ID[i]  = 1;
+	}
+
+	for ( int i=0;i<FREQCOUNT;i++ )
+	{
+		FreqValue[i] = 100000;  //100000
+	}
+
+	FreqValue[0] = 25000;
+	FreqValue[1] = 50000;
+	FreqValue[2] = 75000;
+
+	ProbeFun[0]  = 1;
+	ProbeFun[1]  = 1;
+	Gain[2]      = 450;
+
+	for ( int i=0;i<MIXCOUNT;i++ )
+	{
+		MixDegree[i]  =  0;
+		MixGain[i]    =  250;
+		MixPrimarySig[i] 
+			      =  0;
+		MixSecondarySig[i] 
+			      =  1;
+		MixAlgVersion[i]
+			      =  0;
+
+		Sx[i]         =  1;
+		Sy[i]         =  1;
+		Cos[i]        =  1;       
+		Sin[i]        =  0;
+
+		a[i]         =  1;
+		b[i]         =  0;
+		c[i]         =  1;       
+		d[i]         =  0;
+	}
+
+	for ( int i=0;i<CROSSCOUNT;i++ )
+	{
+		CrossDegree[i]
+			      = 0;
+		CrossGain[i]
+			      = 250;
+	}
+
+
+	for ( int i=0;i<CROSSCOUNT;i++ )
+	{
+		OCTCentX[i]  = 0;
+		OCTCentY[i]  = 0;
+	}
+	
+	Driver		     = 4;
+	Offset		     = 0;
+	Precision            = 16;
+	Language	     = 0;
+	DataBufLength        = 20 * 1024 * 1024;
+	PanelType	     = 3;
+	DrawMode	     = 1;
+	DrawMode2[0]	     = 1;
+	DrawMode2[1]	     = 1;
+	ODrawMode	     = 2;
+	ColorGain	     = 250;
+	Auto_Disappear	     = 30;
+	
+	for ( int i=0;i<SCREENCOUNT2;i++ )
+	{
+		ScrSigM[i]   = i;
+	}
+	ScrSigFocus	     = 0;
+
+	ColorSpotSampleType  = 0;
+	ColorSpotSampIntervalClock
+		             = 5000;
+	ColorSPotSampOutPuls = 50;
+	ColorSpotFreqIndex   = 0;
+	ColorSpotDispMode    = 0;
+	ColorSpotScanSpeed   = 36;
+
+	SAlarmType	     = 3;
+	for ( int i=0;i<3;i++ )
+	{
+		SAlarmCount[i]= 0;
+		SAlarmIndex[i]= 0;
+	}
+	for ( int j=0;j<8;j++ )
+	{
+		SAlarmPara[0][j][0] = 30+15*j;
+		SAlarmPara[0][j][1] = 40+15*j;
+		SAlarmPara[0][j][2] = 50;
+		SAlarmPara[0][j][3] = 50;
+
+		SAlarmPara[1][j][0] = 30+15*j;
+		SAlarmPara[1][j][1] = 40+15*j;
+		SAlarmPara[1][j][2] = 50;
+		SAlarmPara[1][j][3] = 50;
+
+		SAlarmPara[2][j][0] = 100+80+10*j; 
+		SAlarmPara[2][j][1] = 60+80+10*j; 
+		SAlarmPara[2][j][2] = 100+160+10*j; 
+		SAlarmPara[2][j][3] = 60+160+10*j; 
+	}
+
+	for ( int index=0;index<2;index++ )
+	{
+		DAlarmType[index]	     = 2;
+		for ( int i=0;i<3;i++ )
+		{
+			DAlarmCount[index][i]= 0;
+			DAlarmIndex[index][i]= 0;
+		}
+		for ( int j=0;j<8;j++ )
+		{
+			DAlarmPara[index][0][j][0] = 30+15*j;
+			DAlarmPara[index][0][j][1] = 40+15*j;
+			DAlarmPara[index][0][j][2] = 50;
+			DAlarmPara[index][0][j][3] = 50;
+
+			DAlarmPara[index][1][j][0] = 30+15*j;
+			DAlarmPara[index][1][j][1] = 40+15*j;
+			DAlarmPara[index][1][j][2] = 50;
+			DAlarmPara[index][1][j][3] = 50;
+
+			DAlarmPara[index][2][j][0] = 80+300*index+10*j; 
+			DAlarmPara[index][2][j][1] = 80+10*j; 
+			DAlarmPara[index][2][j][2] = 160+300*index+10*j; 
+			DAlarmPara[index][2][j][3] = 160+10*j; 
+		}
+	}
+
+	for ( int index=0;index<2;index++ )
+	{
+		CAlarmType[index]	     = 2;
+		for ( int i=0;i<3;i++ )
+		{
+			CAlarmCount[index][i]= 0;
+			CAlarmIndex[index][i]= 0;
+		}
+		for ( int j=0;j<8;j++ )
+		{
+			CAlarmPara[index][0][j][0] = 30+15*j;
+			CAlarmPara[index][0][j][1] = 40+15*j;
+			CAlarmPara[index][0][j][2] = 50;
+			CAlarmPara[index][0][j][3] = 50;
+
+			CAlarmPara[index][1][j][0] = 30+15*j;
+			CAlarmPara[index][1][j][1] = 40+15*j;
+			CAlarmPara[index][1][j][2] = 50;
+			CAlarmPara[index][1][j][3] = 50;
+
+			CAlarmPara[index][2][j][0] = 80+300*index+10*j; 
+			CAlarmPara[index][2][j][1] = 80+10*j; 
+			CAlarmPara[index][2][j][2] = 160+300*index+10*j; 
+			CAlarmPara[index][2][j][3] = 160+10*j; 
+		}
+	}
+
+	AlarmBeep 	= false;
+	AlarmOutput	= false;
+	AlarmDisplay	= false;
+
+	KeyBeep		= true;
+
+	TimeScaleDisp   = 1;
+	TimeScaleSpeed  = 3;
+
+	for ( int i=0;i<8;i++ )
+	{
+		OAlarmPara[i]
+			= 0;
+	}
+
+	SingleCentX	= 0;
+	SingleCentY	= 0;
+	DoubleCentX1	= 0;
+	DoubleCentY1	= 0;
+	DoubleCentX2	= 0;
+	DoubleCentY2	= 0;
+
+	CompositeCentX1	= 0;
+	CompositeCentY1	= 0;
+	CompositeCentX2	= 0;
+	CompositeCentY2	= 0;
+
+	AScanMapChan[0] = 2;
+	AScanMapChan[1] = 3;
+
+	GainRatio       = 10;
+	AScanSpeed      = 16;
+	/*    ----------------- don't need save into flash -----------------    */
+
+	DebugChan	     = 0;
+	DParaChan	     = 0;
+
+	AlarmStatus.reset();
+	AlarmMainSwitch      = true;
+
+	SingleFocusSignal    = 0;
+
+	bSingleSrcPause      = false;
+	bDoubleSrcPause      = false;
+	bQuadSrcPause	     = false;
+	bCompositeSrcPause   = false;
+
+	bSNeedResetAlarmArea  = true;
+	bDNeedResetAlarmArea  = true;
+	bONeedResetAlarmArea  = true;
+	bCNeedResetAlarmArea  = true;
+	ScopeChan	     = 0;
+	QuadChan 	     = 0;
+	CompositeChan        = 0;
+	
+	bRFFilterEnable      = false;
+}
+
+std::ofstream& operator<<(std::ofstream& oo,const Global& ob)
+{
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+	{
+		oo<<ob.HDGain[i]<<' '
+		  <<ob.Degree[i]<<' '
+		  <<ob.Gain[i]<<' '
+		  <<ob.HiFilter[i]<<' '
+		  <<ob.LoFilter[i]<<' '
+		  <<ob.DFilter[i]<<' '
+		  <<ob.ProbeFun[i]<<' '
+		  <<ob.FreqIndex[i]<<' '
+		  <<ob.DriverBal[i]<<' '
+		  <<ob.DriverA_ID[i]<<' '
+		  <<ob.DriverB_ID[i]<<' '
+		  <<ob.PickA_ID[i]<<' '
+		  <<ob.PickB_ID[i]<<' '
+		  ;
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		oo<<ob.FreqValue[i]<<' '
+			;
+	}
+
+	for ( int i=0;i<Global::MIXCOUNT;i++ )
+	{
+		oo<<ob.MixDegree[i]<<' ';
+		oo<<ob.MixGain[i]<<' ';
+		oo<<ob.MixPrimarySig[i]<<' ';
+		oo<<ob.MixSecondarySig[i]<<' ';
+		oo<<ob.MixAlgVersion[i]<<' ';
+
+		oo<<ob.Sx[i]<<' ';
+		oo<<ob.Sy[i]<<' '; 
+		oo<<ob.Cos[i]<<' ';
+		oo<<ob.Sin[i]<<' '; 
+
+		oo<<ob.a[i]<<' ';
+		oo<<ob.b[i]<<' '; 
+		oo<<ob.c[i]<<' ';
+		oo<<ob.d[i]<<' '; 
+	}
+
+	for ( int i=0;i<Global::CROSSCOUNT;i++ )
+	{
+		oo<<ob.CrossDegree[i]<<' ';
+		oo<<ob.CrossGain[i]<<' ';
+
+		oo<<ob.OCTCentX[i]<<' ';
+		oo<<ob.OCTCentY[i]<<' ';
+	}
+
+	oo<<ob.Driver<<' '
+	  <<ob.Offset<<' '
+	  <<ob.Precision<<' '
+	  <<ob.Language<<' '
+	  <<ob.DataBufLength<<' '
+	  <<ob.PanelType<<' '
+	  <<ob.DrawMode<<' '
+	  <<ob.DrawMode2[0]<<' '
+	  <<ob.DrawMode2[1]<<' '
+	  <<ob.ODrawMode<<' '
+	  <<ob.ColorGain<<' ' 
+	  <<ob.Auto_Disappear<<' ';
+
+	for ( int i=0;i<Global::SCREENCOUNT2;i++ )
+	{
+	  	oo<<ob.ScrSigM[i]<<' ';
+	}
+	oo<<ob.ScrSigFocus<<' ';
+
+	oo<<ob.ColorSpotSampleType<<' ';
+	oo<<ob.ColorSpotSampIntervalClock<<' ';
+	oo<<ob.ColorSPotSampOutPuls<<' ';
+	oo<<ob.ColorSpotFreqIndex<<' ';
+	oo<<ob.ColorSpotDispMode<<' ';
+	oo<<ob.ColorSpotScanSpeed<<' ';
+
+	oo<<ob.SAlarmType<<' ';
+	for ( int i=0;i<3;i++ )
+	{
+		oo<<ob.SAlarmCount[i]<<' ';
+		oo<<ob.SAlarmIndex[i]<<' ';
+	}
+	for ( int i=0;i<8;i++ )
+	{
+		oo<<ob.SAlarmPara[0][i][0]<<' ';
+		oo<<ob.SAlarmPara[0][i][1]<<' ';
+		oo<<ob.SAlarmPara[0][i][2]<<' ';
+		oo<<ob.SAlarmPara[0][i][3]<<' ';
+
+		oo<<ob.SAlarmPara[1][i][0]<<' ';
+		oo<<ob.SAlarmPara[1][i][1]<<' ';
+		oo<<ob.SAlarmPara[1][i][2]<<' ';
+		oo<<ob.SAlarmPara[1][i][3]<<' ';
+
+		oo<<ob.SAlarmPara[2][i][0]<<' ';
+		oo<<ob.SAlarmPara[2][i][1]<<' ';
+		oo<<ob.SAlarmPara[2][i][2]<<' ';
+		oo<<ob.SAlarmPara[2][i][3]<<' ';
+	}
+	for ( int index=0;index<2;index++ )
+	{
+		oo<<ob.DAlarmType[index]<<' ';
+		for ( int i=0;i<3;i++ )
+		{
+			oo<<ob.DAlarmCount[index][i]<<' ';
+			oo<<ob.DAlarmIndex[index][i]<<' ';
+		}
+		for ( int i=0;i<8;i++ )
+		{
+			oo<<ob.DAlarmPara[index][0][i][0]<<' ';
+			oo<<ob.DAlarmPara[index][0][i][1]<<' ';
+			oo<<ob.DAlarmPara[index][0][i][2]<<' ';
+			oo<<ob.DAlarmPara[index][0][i][3]<<' ';
+
+			oo<<ob.DAlarmPara[index][1][i][0]<<' ';
+			oo<<ob.DAlarmPara[index][1][i][1]<<' ';
+			oo<<ob.DAlarmPara[index][1][i][2]<<' ';
+			oo<<ob.DAlarmPara[index][1][i][3]<<' ';
+
+			oo<<ob.DAlarmPara[index][2][i][0]<<' ';
+			oo<<ob.DAlarmPara[index][2][i][1]<<' ';
+			oo<<ob.DAlarmPara[index][2][i][2]<<' ';
+			oo<<ob.DAlarmPara[index][2][i][3]<<' ';
+		}
+	}
+	for ( int index=0;index<2;index++ )
+	{
+		oo<<ob.CAlarmType[index]<<' ';
+		for ( int i=0;i<3;i++ )
+		{
+			oo<<ob.CAlarmCount[index][i]<<' ';
+			oo<<ob.CAlarmIndex[index][i]<<' ';
+		}
+		for ( int i=0;i<8;i++ )
+		{
+			oo<<ob.CAlarmPara[index][0][i][0]<<' ';
+			oo<<ob.CAlarmPara[index][0][i][1]<<' ';
+			oo<<ob.CAlarmPara[index][0][i][2]<<' ';
+			oo<<ob.CAlarmPara[index][0][i][3]<<' ';
+
+			oo<<ob.CAlarmPara[index][1][i][0]<<' ';
+			oo<<ob.CAlarmPara[index][1][i][1]<<' ';
+			oo<<ob.CAlarmPara[index][1][i][2]<<' ';
+			oo<<ob.CAlarmPara[index][1][i][3]<<' ';
+
+			oo<<ob.CAlarmPara[index][2][i][0]<<' ';
+			oo<<ob.CAlarmPara[index][2][i][1]<<' ';
+			oo<<ob.CAlarmPara[index][2][i][2]<<' ';
+			oo<<ob.CAlarmPara[index][2][i][3]<<' ';
+		}
+	}
+
+	oo<<ob.AlarmOutput<<' ';
+	oo<<ob.AlarmBeep<<' ';
+	oo<<ob.AlarmDisplay<<' ';
+	oo<<ob.KeyBeep<<' ';
+	oo<<ob.TimeScaleDisp<<' ';
+	oo<<ob.TimeScaleSpeed<<' ';
+
+	for ( int i=0;i<8;i++ )
+		oo<<ob.OAlarmPara[i]<<' ';
+
+	oo<<ob.SingleCentX<<' ';
+	oo<<ob.SingleCentY<<' ';
+	oo<<ob.DoubleCentX1<<' ';
+	oo<<ob.DoubleCentY1<<' ';
+	oo<<ob.DoubleCentX2<<' ';
+	oo<<ob.DoubleCentY2<<' ';
+
+	oo<<ob.CompositeCentX1<<' ';
+	oo<<ob.CompositeCentY1<<' ';
+	oo<<ob.CompositeCentX2<<' ';
+	oo<<ob.CompositeCentY2<<' ';
+
+	for ( int i = 0; i < 2; i += 1 ) 
+		oo<<ob.AScanMapChan[i]<<' ';
+
+	oo<<ob.GainRatio<<' ';
+	oo<<ob.AScanSpeed<<' ';
+	return oo;
+}
+
+std::ifstream& operator>>(std::ifstream& io,Global& ob)
+{
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+	{
+		io>>ob.HDGain[i]
+		  >>ob.Degree[i]
+		  >>ob.Gain[i]
+		  >>ob.HiFilter[i]
+		  >>ob.LoFilter[i]
+		  >>ob.DFilter[i]
+		  >>ob.ProbeFun[i]
+		  >>ob.FreqIndex[i]
+
+		  >>ob.DriverBal[i]
+		  >>ob.DriverA_ID[i]
+		  >>ob.DriverB_ID[i]
+		  >>ob.PickA_ID[i]
+		  >>ob.PickB_ID[i]
+		  ;
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		io>>ob.FreqValue[i]
+			;
+	}
+
+	for ( int i=0;i<Global::MIXCOUNT;i++ )
+	{
+		io>>ob.MixDegree[i];
+		io>>ob.MixGain[i];
+		io>>ob.MixPrimarySig[i];
+		io>>ob.MixSecondarySig[i];
+		io>>ob.MixAlgVersion[i];
+
+		io>>ob.Sx[i];
+		io>>ob.Sy[i]; 
+		io>>ob.Cos[i];
+		io>>ob.Sin[i]; 
+
+		io>>ob.a[i];
+		io>>ob.b[i]; 
+		io>>ob.c[i];
+		io>>ob.d[i]; 
+	}
+
+	for ( int i=0;i<Global::CROSSCOUNT;i++ )
+	{
+		io>>ob.CrossDegree[i];
+		io>>ob.CrossGain[i];
+
+		io>>ob.OCTCentX[i];
+		io>>ob.OCTCentY[i];
+	}
+
+	io>>ob.Driver
+	  >>ob.Offset
+	  >>ob.Precision
+	  >>ob.Language
+	  >>ob.DataBufLength
+	  >>ob.PanelType
+	  >>ob.DrawMode
+	  >>ob.DrawMode2[0]
+	  >>ob.DrawMode2[1]
+	  >>ob.ODrawMode
+	  >>ob.ColorGain
+	  >>ob.Auto_Disappear;
+
+	for ( int i=0;i<Global::SCREENCOUNT2;i++ )
+	{
+	  	io>>ob.ScrSigM[i];
+	}
+	io>>ob.ScrSigFocus;
+
+	io>>ob.ColorSpotSampleType;
+	io>>ob.ColorSpotSampIntervalClock;
+	io>>ob.ColorSPotSampOutPuls;
+	io>>ob.ColorSpotFreqIndex;
+	io>>ob.ColorSpotDispMode;
+	io>>ob.ColorSpotScanSpeed;
+
+	io>>ob.SAlarmType;
+	for ( int i=0;i<3;i++ )
+	{
+		io>>ob.SAlarmCount[i];
+		io>>ob.SAlarmIndex[i];
+	}
+	for ( int i=0;i<8;i++ )
+	{
+		io>>ob.SAlarmPara[0][i][0];
+		io>>ob.SAlarmPara[0][i][1];
+		io>>ob.SAlarmPara[0][i][2];
+		io>>ob.SAlarmPara[0][i][3];
+
+		io>>ob.SAlarmPara[1][i][0];
+		io>>ob.SAlarmPara[1][i][1];
+		io>>ob.SAlarmPara[1][i][2];
+		io>>ob.SAlarmPara[1][i][3];
+
+		io>>ob.SAlarmPara[2][i][0];
+		io>>ob.SAlarmPara[2][i][1];
+		io>>ob.SAlarmPara[2][i][2];
+		io>>ob.SAlarmPara[2][i][3];
+	}
+
+	for ( int index=0;index<2;index++ )
+	{
+		io>>ob.DAlarmType[index];
+		for ( int i=0;i<3;i++ )
+		{
+			io>>ob.DAlarmCount[index][i];
+			io>>ob.DAlarmIndex[index][i];
+		}
+		for ( int i=0;i<8;i++ )
+		{
+			io>>ob.DAlarmPara[index][0][i][0];
+			io>>ob.DAlarmPara[index][0][i][1];
+			io>>ob.DAlarmPara[index][0][i][2];
+			io>>ob.DAlarmPara[index][0][i][3];
+
+			io>>ob.DAlarmPara[index][1][i][0];
+			io>>ob.DAlarmPara[index][1][i][1];
+			io>>ob.DAlarmPara[index][1][i][2];
+			io>>ob.DAlarmPara[index][1][i][3];
+
+			io>>ob.DAlarmPara[index][2][i][0];
+			io>>ob.DAlarmPara[index][2][i][1];
+			io>>ob.DAlarmPara[index][2][i][2];
+			io>>ob.DAlarmPara[index][2][i][3];
+		}
+	}
+
+	for ( int index=0;index<2;index++ )
+	{
+		io>>ob.CAlarmType[index];
+		for ( int i=0;i<3;i++ )
+		{
+			io>>ob.CAlarmCount[index][i];
+			io>>ob.CAlarmIndex[index][i];
+		}
+		for ( int i=0;i<8;i++ )
+		{
+			io>>ob.CAlarmPara[index][0][i][0];
+			io>>ob.CAlarmPara[index][0][i][1];
+			io>>ob.CAlarmPara[index][0][i][2];
+			io>>ob.CAlarmPara[index][0][i][3];
+
+			io>>ob.CAlarmPara[index][1][i][0];
+			io>>ob.CAlarmPara[index][1][i][1];
+			io>>ob.CAlarmPara[index][1][i][2];
+			io>>ob.CAlarmPara[index][1][i][3];
+
+			io>>ob.CAlarmPara[index][2][i][0];
+			io>>ob.CAlarmPara[index][2][i][1];
+			io>>ob.CAlarmPara[index][2][i][2];
+			io>>ob.CAlarmPara[index][2][i][3];
+		}
+	}
+
+	io>>ob.AlarmOutput;
+	io>>ob.AlarmBeep;
+	io>>ob.AlarmDisplay;
+	io>>ob.KeyBeep;
+	io>>ob.TimeScaleDisp;
+	io>>ob.TimeScaleSpeed;
+
+	for ( int i=0;i<8;i++ )
+		io>>ob.OAlarmPara[i];
+
+	io>>ob.SingleCentX;
+	io>>ob.SingleCentY;
+	io>>ob.DoubleCentX1;
+	io>>ob.DoubleCentY1;
+	io>>ob.DoubleCentX2;
+	io>>ob.DoubleCentY2;
+
+	io>>ob.CompositeCentX1;
+	io>>ob.CompositeCentY1;
+	io>>ob.CompositeCentX2;
+	io>>ob.CompositeCentY2;
+
+	for ( int i = 0; i < 2; i += 1 ) 
+		io>>ob.AScanMapChan[i];
+
+	io>>ob.GainRatio;
+	io>>ob.AScanSpeed;
+	return io;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Gian
+ *  Description:  Calculate Soft Gain 
+ * =====================================================================================
+ */
+void Global::Calculate_Gain()
+{
+	double temp_gain;
+	for ( int i=0;i<CHANCOUNT;i++ )
+	{
+		temp_gain = static_cast<double>(Gain[i])/static_cast<double>(200);      
+		SoftGain[i] = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
+
+		SoftGain[i] = SoftGain[i];
+	}
+
+	temp_gain = static_cast<double>(ColorGain)/static_cast<double>(200);      
+	ColorSoftGain = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
+
+	for ( int i=0;i<MIXCOUNT;i++ )
+	{
+		temp_gain = static_cast<double>(MixGain[i])/static_cast<double>(200);      
+		SoftMixGain[i] = ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax);
+	}
+
+	for ( int i=0;i<CROSSCOUNT;i++ )
+	{
+		temp_gain = static_cast<double>(CrossGain[i])/static_cast<double>(200);      
+		SoftCrossGain[i] = 14 * ( pow(static_cast<double>(10),temp_gain)*DAfact+0.5 ) / static_cast<double>(GAINmax); 
+	}
+}
diff --git a/src/EVA11/base/Global.h b/src/EVA11/base/Global.h
new file mode 100644
index 0000000..6c07183
--- /dev/null
+++ b/src/EVA11/base/Global.h
@@ -0,0 +1,222 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Global.h
+ *
+ *    Description:  Declearation of Global variables class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月07日 09时00分25秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _GLOBAL_INC
+#define  _GLOBAL_INC
+
+#include 	<memory>
+#include	<cstdlib>
+#include	<iomanip>
+#include	<string>
+#include 	<iosfwd>
+#include 	<bitset>
+
+#include 	<boost/timer.hpp>
+#include 	<boost/date_time/posix_time/posix_time.hpp>
+
+/*
+ * =====================================================================================
+ *        Class:  Global
+ *  Description:  the class manage all global variables which only be Instanced only once 
+ * =====================================================================================
+ */
+//using namespace std;
+class Global
+{
+	public:
+		static Global* Instance();             	      /* only used this function to visit variables   */
+
+		void Init_Global_Variables();          	      /* Init the Global variables 		      */
+		bool Save_Global_Variables(std::string path);
+		bool Load_Global_Variables(std::string path);
+
+		friend std::ofstream& operator<<(std::ofstream& oo,const Global& ob);
+		friend std::ifstream& operator>>(std::ifstream& oo,Global& ob);
+
+		void Calculate_Gain();
+	public:
+		static int const 	CHANCOUNT           = 128;
+		static int const 	MIXCOUNT            = 1;
+		static int const 	FREQCOUNT           = 4;
+		static int const 	SCREENCOUNT2        = 2;
+		static int const 	CROSSCOUNT	    = 8;
+
+		/* ---------- need to save ---------- */
+
+		int              	HDGain[CHANCOUNT];
+		int              	Degree[CHANCOUNT];
+		int              	Gain[CHANCOUNT];
+		int              	HiFilter[CHANCOUNT];
+		int              	LoFilter[CHANCOUNT];
+		int              	DFilter[CHANCOUNT];
+		int			ProbeFun[CHANCOUNT];
+
+		int			DriverBal[CHANCOUNT];
+		int			PickA_ID[CHANCOUNT];
+		int			PickB_ID[CHANCOUNT];
+		int			DriverA_ID[CHANCOUNT];
+		int			DriverB_ID[CHANCOUNT];
+
+		int		 	FreqIndex[CHANCOUNT];
+		int		 	FreqValue[FREQCOUNT];
+
+		int			MixDegree[MIXCOUNT];
+		int			MixGain[MIXCOUNT];
+		int			MixPrimarySig[MIXCOUNT];
+		int			MixSecondarySig[MIXCOUNT];
+		int			MixAlgVersion[MIXCOUNT];
+
+		double			Sx[MIXCOUNT];
+		double			Sy[MIXCOUNT];
+		double			Cos[MIXCOUNT];
+		double			Sin[MIXCOUNT];
+
+		double			a[MIXCOUNT];
+		double			b[MIXCOUNT];
+		double			c[MIXCOUNT];
+		double			d[MIXCOUNT];
+
+		int			CrossDegree[CROSSCOUNT];
+		int			CrossGain[CROSSCOUNT];
+		int			OCTCentX[CROSSCOUNT];
+		int			OCTCentY[CROSSCOUNT];
+
+		int		 	Driver;
+		int		 	Offset;
+		int			Precision;
+		int	 	 	Language;             /* 0: Chinese 1: English  	      */
+		unsigned long long	DataBufLength;
+		int			PanelType;	      /* 0:3D/2D  1:video  2:signal  3:double */
+		int			DrawMode;	      /* 0:Point  1:Line  2:Auto   	      */
+		int			DrawMode2[2];	      /* 0:Point  1:Line  2:Auto   	      */
+		int			ODrawMode;	      /* 0:Point  1:Line  2:Spec   	      */
+		int			ColorGain;
+		int			Auto_Disappear;
+		int			ScrSigM[SCREENCOUNT2];
+		int			ScrSigFocus;
+		int			ColorSpotSampleType;  /* 0: InsideClock  1:Outside Plus       */
+		unsigned long long	ColorSpotSampIntervalClock;
+		unsigned long long	ColorSPotSampOutPuls;	
+		int			ColorSpotFreqIndex;   /* only used for colorspot display mode */
+		int			ColorSpotDispMode;
+		int			ColorSpotScanSpeed;
+
+		int			SAlarmType;	      /* 0: Amp  1: Half Amp  2: Rect 3: close */
+		int			SAlarmCount[3];
+		int			SAlarmIndex[3];
+		int			SAlarmPara[3][8][4];
+
+		int			DAlarmType[2];
+		int			DAlarmCount[2][3];
+		int			DAlarmIndex[2][3];
+		int			DAlarmPara[2][3][8][4];
+		int			TimeScaleSpeed;
+
+		int			CAlarmType[2];
+		int			CAlarmCount[2][3];
+		int			CAlarmIndex[2][3];
+		int			CAlarmPara[2][3][8][4];
+
+		int			OAlarmPara[8];	      /* only for signal Limit Alarm          */
+
+		bool			AlarmOutput;
+		bool			AlarmBeep;
+		bool			AlarmDisplay;
+
+		bool			KeyBeep;
+		int			TimeScaleDisp;        /* Display TimeScale signal X or Y or close; 0:X  1:Y  2:close  */
+
+		int			SingleCentX;
+		int			SingleCentY;
+		int			DoubleCentX1;
+		int			DoubleCentY1;
+		int			DoubleCentX2;
+		int			DoubleCentY2;
+
+		int			CompositeCentX1;
+		int			CompositeCentY1;
+		int			CompositeCentX2;
+		int			CompositeCentY2;
+
+		int			AScanMapChan[2];
+
+		int			GainRatio;
+		int			AScanSpeed;
+
+
+		/* ---------- don't need to save ---------- */
+
+		/* ---------- control tick thread --------- */
+		unsigned char	  	Tick;
+		bool			bTickStop;
+		bool		        bTickPasuse;
+
+		/* ---------- normal data --------- */
+		int		 	DebugChan;            /* When enter debug function, it deside which signal channel to display */
+
+		int			DParaChan;	      /* Double Signal Channel Parameters Adjust 			      */
+
+		int			MultiKey; 	      /* Multi Key Enter 						      */
+
+		int			ScopeChan;	      /*  Used by Cross display 					      */
+
+		int			QuadChan;	      /*  Focus the base channel for Cross Channel                            */
+
+		int			CompositeChan;        /*  Focus the base channel for Composite Channel			      */
+
+		double			SoftGain[CHANCOUNT];
+		double			ColorSoftGain;
+		double			SoftMixGain[MIXCOUNT];
+		double			SoftCrossGain[CROSSCOUNT];
+
+		std::bitset<8>		AlarmStatus;	      /* 0-7: Alarm1-Alarm8  	     */
+		bool			AlarmMainSwitch;      /* Control Alarm Output        */
+
+		int			SingleFocusSignal;
+
+		boost::timer	        RunTimer;
+
+		boost::posix_time::ptime Time_start,Time_now;
+
+		bool			bSingleSrcPause;
+		bool			bDoubleSrcPause;
+		bool			bQuadSrcPause;
+		bool			bCompositeSrcPause;
+
+		bool			bSNeedResetAlarmArea;
+		bool			bDNeedResetAlarmArea;
+		bool			bCNeedResetAlarmArea;
+		bool			bONeedResetAlarmArea;
+
+		bool			bRFFilterEnable;
+
+		bool                    sos;
+	protected:
+
+	private:
+		Global ();
+		~Global ();
+		Global (const Global&);
+		Global& operator = (const Global&);
+
+		friend class std::auto_ptr<Global>;
+		static std::auto_ptr<Global>		m_Instance;
+		static const int	GAINmax	= 2010;
+		static const int	DAfact  = 8;
+}; /* -----  end of class Global  ----- */
+#endif   /* ----- #ifndef _GLOBAL_INC  ----- */
diff --git a/src/EVA11/base/Gradual.cpp b/src/EVA11/base/Gradual.cpp
new file mode 100644
index 0000000..ea39466
--- /dev/null
+++ b/src/EVA11/base/Gradual.cpp
@@ -0,0 +1,113 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Gradual.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月15日 10时09分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"Object.h"
+#include 	"Gradual.h"
+#include 	"Algorithm.h"
+
+struct Gradual::PImpl
+{
+	int		m_R;
+	int		m_G;
+	int		m_B;
+	short		m_BGColor;
+	TYPE		m_Type;
+};
+
+Gradual::Gradual (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh) , m_Imple(new struct PImpl)
+{
+	m_Imple->m_R	  = 137;
+	m_Imple->m_G      = 167;
+	m_Imple->m_B      = 82;
+	m_Imple->m_BGColor 
+			  = 0xffff;
+	m_Imple->m_Type   = HTYPE;
+}
+
+Gradual::~Gradual ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the Object on screen 
+ * =====================================================================================
+ */
+void Gradual::Drawme(Graphic& g)
+{
+	Algorithm *alg = Algorithm::Instance();
+
+	if 	( m_Imple->m_Type == HTYPE )
+	{
+		for ( int i=m_X;i<m_X+m_Width;i++ )
+		{
+			for ( int j=m_Y;j<m_Y+m_Heigh;j++ )
+			{
+				g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(m_Imple->m_R,m_Imple->m_G,m_Imple->m_B,((i-m_X)*255)/m_Width,m_Imple->m_BGColor)));
+			}
+		}
+	}
+	else if ( m_Imple->m_Type == VTYPE )
+	{
+		for ( int j=m_Y;j<m_Y+m_Heigh;j++ )
+		{
+			for ( int i=m_X;i<m_X+m_Width;i++ )
+			{
+				g.Setpixel(i,j,g.RGB24_16(alg->Alpha_Color(m_Imple->m_R,m_Imple->m_G,m_Imple->m_B,((j-m_Y)*255)/m_Width,m_Imple->m_BGColor)));
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_LColor
+ *  Description:  Set the Left Color 
+ * =====================================================================================
+ */
+void Gradual::Set_RColor(short color)
+{
+	m_Imple->m_R = ( color >> 11 ) & 0x1f;
+	m_Imple->m_G = ( color >> 5 ) & 0x3f;
+	m_Imple->m_B = ( color ) & 0x1f;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_RColor
+ *  Description:  Set Right Color 
+ * =====================================================================================
+ */
+void Gradual::Set_LColor(short color)
+{
+	m_Imple->m_BGColor = color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Type
+ *  Description:  Set the Label Type 
+ * =====================================================================================
+ */
+void Gradual::Set_Type(TYPE type)
+{
+	m_Imple->m_Type = type;
+}
diff --git a/src/EVA11/base/Gradual.h b/src/EVA11/base/Gradual.h
new file mode 100644
index 0000000..bf03071
--- /dev/null
+++ b/src/EVA11/base/Gradual.h
@@ -0,0 +1,48 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Gradual.h
+ *
+ *    Description:  Gradual of color 
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月15日 10时07分05秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _GRADUAL_INC
+#define  _GRADUAL_INC
+
+#include 	<memory>	
+class Object;
+class Graphic;
+class Gradual : public Object
+{
+	public:
+		enum TYPE 
+		{
+			HTYPE = 0,
+			VTYPE = 1
+		};
+
+		typedef enum TYPE TYPE;
+		Gradual (int x,int y,int width,int heigh);
+		~Gradual ();
+		void Drawme(Graphic& g);
+
+		void Set_LColor(short);
+		void Set_RColor(short);
+		void Set_Type(TYPE);
+	protected:
+	private:
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif
diff --git a/src/EVA11/base/Graphic.cpp b/src/EVA11/base/Graphic.cpp
new file mode 100644
index 0000000..25cb4b5
--- /dev/null
+++ b/src/EVA11/base/Graphic.cpp
@@ -0,0 +1,985 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Graphic.cpp
+ *
+ *    Description:  Drawing screen class
+ *
+ *        Version:  1.0
+ *        Created:  2009年07月03日 09时21分10秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+#include        <string.h>
+#include        <sys/types.h> 
+#include        <sys/stat.h> 
+#include        <sys/ioctl.h>
+#include        <linux/fb.h> 
+#include        <unistd.h> 
+#include 	<fcntl.h> 
+#include        <math.h>
+#include 	<sys/mman.h> 
+#include        <fstream>
+#include        <iostream>
+
+#include 	<termio.h>
+
+#include 	<SDL.h>
+#include 	<SDL/SDL_gfxPrimitives.h>
+#include 	<SDL/SDL_gfxBlitFunc.h>
+#include 	<SDL/SDL_rotozoom.h>
+#include 	<SDL/SDL_image.h>
+
+#include        "Algorithm.h"
+
+#include	"Graphic.h"
+#include 	"GUILowCode.hpp"
+
+#define         FD_STDIN 0
+
+std::auto_ptr<Graphic> Graphic::m_Instance;
+
+struct Graphic::PImpl
+{
+	SDL_Surface*		m_pSurface;
+	SDL_Surface*		m_pShadowSurface;
+	SDL_Surface*		m_p32ColorSurface;
+	int			m_MaxW;
+	int			m_MaxH;
+	int			m_Bpp;
+	CopyMode 		m_Mode; 
+	int			m_Transpare;
+	int			m_Buffer_Len;
+	int			m_Color;
+	uint8_t*		m_Scr_Ptr;
+	uint8_t*		m_Shadow_Scr_Ptr;
+	GUILowCode<uint16_t>*	gc;
+	ColorObj*		cobj;
+	
+	struct termios 		new_settings;
+	struct termios		store_settings;
+	int 			m_keyflag;
+};
+
+Graphic::Graphic() : m_Imple(new struct PImpl)
+{
+	m_Imple->m_Transpare = 255;
+	m_Imple->m_Color     = 0; 
+	m_Imple->m_Mode      = MODE_SRC;
+	m_Imple->m_Scr_Ptr   = 0;
+}
+
+Graphic::~Graphic()
+{
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Graphic* Graphic::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Graphic() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Initgraph
+ *  Description:  Init the screen file and font file
+ * =====================================================================================
+ */
+bool Graphic::Initgraph(void)
+{
+	SDL_version compiled;
+	SDL_VERSION(&compiled);
+	int m = compiled.major;
+	int n = compiled.minor;
+	int p = compiled.patch;
+	std::cout<<"SDL Version: "<<m<<"."<<n<<"."<<p<<std::endl;
+
+	SDL_IMAGE_VERSION(&compiled);
+	m = compiled.major;
+	n = compiled.minor;
+	p = compiled.patch;
+	std::cout<<"SDL Image Version: "<<m<<"."<<n<<"."<<p<<std::endl;
+
+	if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
+	{
+		printf("SDL init fail!: %s\n",SDL_GetError());
+		return false; 
+	}
+
+	SDL_ShowCursor(0);
+
+	m_Imple->m_pSurface 	     = NULL;
+	m_Imple->m_pShadowSurface    = NULL;
+	m_Imple->m_MaxW     	     = 640;
+	m_Imple->m_MaxH     	     = 480;
+	m_Imple->m_Bpp      	     = 16;
+
+#ifdef X86
+	uint32_t flag = SDL_SWSURFACE;
+#else
+	uint32_t flag = SDL_HWSURFACE;
+#endif
+
+	if ( !SDL_VideoModeOK(m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,flag) )
+	{
+		printf("SDL init parameters is not support: %s\n",SDL_GetError());
+		return false;
+	}
+
+	m_Imple->m_pSurface = SDL_SetVideoMode(m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,flag);
+	if ( m_Imple->m_pSurface == NULL )
+	{
+		printf("SDL set video mode fail: %s\n",SDL_GetError());
+		return false;
+	}
+
+	char *devicename = new char[100];
+	if ( SDL_VideoDriverName(devicename,100) != NULL )
+		printf ( "Device Name:%s\n",devicename );
+	delete[] devicename;
+	devicename = NULL;
+
+	m_Imple->m_p32ColorSurface = SDL_CreateRGBSurface(SDL_SWSURFACE,1,1,32,0xff000000,0x00ff0000,0x0000ff00,0x000000ff);
+	if ( m_Imple->m_p32ColorSurface == NULL )
+	{
+		printf("SDL Create color surface fail: %s\n",SDL_GetError());
+		return false; 
+	}
+
+	m_Imple->m_MaxW  = m_Imple->m_pSurface->w;         		     /* get the screen width and height from system screen */
+	m_Imple->m_MaxH = m_Imple->m_pSurface->h;
+	m_Imple->m_Bpp 	      = m_Imple->m_pSurface->format->BitsPerPixel;
+	m_Imple->m_Buffer_Len  = m_Imple->m_MaxW*m_Imple->m_MaxH*(m_Imple->m_pSurface->format->BytesPerPixel);
+	m_Imple->m_Scr_Ptr    = static_cast<unsigned char *>(m_Imple->m_pSurface->pixels);
+
+	int result = system("/sbin/hwclock -s");                	     /* set the hardware time from system time   */
+	result = result;
+
+	m_Imple->cobj = ColorObj::Instance();
+	m_Imple->cobj->Init_Object();
+
+	Clearscreen();
+	Initkey();                                         		     /* Init the standard input environment, enable read key return immediately */
+
+	m_Imple->m_pShadowSurface = SDL_CreateRGBSurface(flag,m_Imple->m_MaxW,m_Imple->m_MaxH,m_Imple->m_Bpp,0xff000000,0x00ff0000,0x0000ff00,0x000000ff);
+	if ( m_Imple->m_pShadowSurface == NULL )
+	{
+		printf("SDL Create shadow surface fail: %s\n",SDL_GetError());
+		return false; 
+	}
+
+	m_Imple->m_Shadow_Scr_Ptr = static_cast<unsigned char *>(m_Imple->m_pShadowSurface->pixels);
+	/*-----------------------------------------------------------------------------
+	 *  Initiate the globle color
+	 *-----------------------------------------------------------------------------*/
+	Init_Color_System(m_Imple->m_Bpp);
+
+	m_Imple->gc = GUILowCode<uint16_t>::Instance();
+
+	m_Imple->gc->Init_GUILowCode_Parameters(m_Imple->m_MaxW,
+			                    	m_Imple->m_MaxH,
+					    	m_Imple->m_Bpp,
+					    	m_Imple->m_Buffer_Len,
+					    	m_Imple->m_Scr_Ptr,
+					    	m_Imple->m_Shadow_Scr_Ptr,
+					    	GUILowCode<uint16_t>::MODE_SRC);
+  	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Closegraph
+ *  Description:  Close the screen file and Chinese font file
+ * =====================================================================================
+ */
+void Graphic::Closegraph()
+{
+	m_Imple->cobj->Destroy_Object();
+
+	SDL_FreeSurface(m_Imple->m_p32ColorSurface);
+	SDL_FreeSurface(m_Imple->m_pShadowSurface);
+	SDL_FreeSurface(m_Imple->m_pSurface);
+
+	if ( SDL_WasInit(SDL_INIT_VIDEO) != 0 )
+		atexit(SDL_Quit);
+	Restorekey();                           			     /* Let the environment variables to be normal */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clearscreen
+ *  Description:  Clear the whole screen
+ * =====================================================================================
+ */
+void Graphic::Clearscreen(void)
+{
+	boxColor(m_Imple->m_pSurface,0,0,m_Imple->m_MaxW-1,m_Imple->m_MaxH-1,m_Imple->cobj->Get_ColorVP(30)->color32);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  CleanArea
+ *  Description:  Clean one area 
+ * =====================================================================================
+ */
+void Graphic::CleanArea(int x1,int y1,int x2,int y2)
+{
+	m_Imple->gc->Set_Area_Color(x1,y1,x2,y2,m_Imple->cobj->Get_ColorVP(26)->color16);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GetColor
+ *  Description:  Set the color of front
+ * =====================================================================================
+ */
+int Graphic::Getcolor()
+{
+	return m_Imple->m_Color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SetColor
+ *  Description:  Set the color of front
+ * =====================================================================================
+ */
+void Graphic::Setcolor(short color)
+{
+	m_Imple->m_Color = color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Getpixel
+ *  Description:  Get Pixel Value of Screen 
+ * =====================================================================================
+ */
+short Graphic::Getpixel(int x,int y)
+{
+	unsigned char * loc = m_Imple->m_Scr_Ptr + ((y * m_Imple->m_MaxW*2 + x*2 ));
+	return *(unsigned short *)loc; 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Setpixel
+ *  Description:  Draw a pixel on screen
+ * =====================================================================================
+ */
+void Graphic::Setpixel(int x,int y,short color)
+{
+	m_Imple->gc->Setpixel(x,y,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Line
+ *  Description:  Draw a line on screen, (x1 y1) (x2 y2) 
+ * =====================================================================================
+ */
+void Graphic::Line(int x1,int y1,int x2,int y2)
+{
+	m_Imple->gc->Line(x1,y1,x2,y2,m_Imple->m_Color);
+}
+
+void Graphic::DoLine(int x1,int y1,int x2,int y2)
+{
+	m_Imple->gc->Dot_Line(x1,y1,x2,y2,m_Imple->m_Color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Line
+ *  Description:  Draw a line on screen, (x1 y1) (x2 y2)  with color
+ * =====================================================================================
+ */
+void Graphic::Line(int x1,int y1,int x2,int y2,short color)
+{
+	m_Imple->gc->Line(x1,y1,x2,y2,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Rectangle
+ *  Description:  Draw a ractangel on screen
+ * =====================================================================================
+ */
+void Graphic::Rectangle(int x1, int y1, int x2, int y2)
+{
+	Line(x1, y1, x2, y1);
+	Line(x2, y1, x2, y2);
+	Line(x2, y2, x1, y2);
+	Line(x1, y2, x1, y1);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawRect
+ *  Description:  Draw rectangle with X Y width height
+ * =====================================================================================
+ */
+void Graphic::DrawRect(int x,int y,int width,int height)
+{
+	Rectangle(x,y,x+width-1,y+height-1);
+}
+void Graphic::DrawRect(int x,int y,int width,int height,short color)
+{
+	short save_color = m_Imple->m_Color;
+	m_Imple->m_Color = color;
+	Rectangle(x,y,x+width-1,y+height-1);
+	m_Imple->m_Color = save_color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawFillRect
+ *  Description:  Draw filled rectangle on screen
+ * =====================================================================================
+ */
+void Graphic::DrawFillRect(int x,int y,int width,int height)
+{
+	for ( int i = y; i < y+height-1; i += 1 ) 
+	{
+		m_Imple->gc->HLine_Fast(x,x+width-1,i,m_Imple->m_Color);
+	}
+}
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawFillRect
+ *  Description:  Draw filled rectangle on screen
+ * =====================================================================================
+ */
+void Graphic::DrawFillRect(int x,int y,int width,int height,short color)
+{
+	int save_color = m_Imple->m_Color;
+	m_Imple->m_Color = color;
+	for ( int i = y; i < y+height-1; i += 1 )
+	{
+		m_Imple->gc->HLine_Fast(x,x+width-1,i,m_Imple->m_Color);
+	}
+	m_Imple->m_Color = save_color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  FillRect
+ *  Description:  Draw filled rectangle on screen
+ * =====================================================================================
+ */
+void Graphic::FillRect(int x1,int y1,int x2,int y2)
+{
+	for(int j=y1;j<y2;j++)
+	{
+		HLine_Fast(x1,x2-1,j,m_Imple->m_Color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SetMode
+ *  Description:  Set the drawing mode
+ * =====================================================================================
+ */
+void Graphic::SetMode(CopyMode mode)
+{
+	m_Imple->m_Mode = mode;
+
+	switch ( mode ) 
+	{
+		case MODE_SRC: 
+			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC);
+			break;
+
+		case MODE_SRC_XOR_DST: 
+			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC_XOR_DST);
+			break;
+
+		default:	
+			m_Imple->gc->SetMode(GUILowCode<uint16_t>::MODE_SRC);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GetMode
+ *  Description:  Get the drawing mode
+ * =====================================================================================
+ */
+Graphic::CopyMode Graphic::GetMode(void) const
+{
+	return 	m_Imple->m_Mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Initkey
+ *  Description:  Init the stdin environment, for reading key value return immediatele
+ * =====================================================================================
+ */
+void Graphic::Initkey(void)
+{
+        tcgetattr(FD_STDIN,&m_Imple->store_settings);             /* save the current key environment variables in memory  */
+	m_Imple->new_settings = m_Imple->store_settings;                   /* set the new environment variables in memory */
+        m_Imple->new_settings.c_lflag &= (~ICANON);
+        m_Imple->new_settings.c_lflag &= (~ECHO);
+        m_Imple->new_settings.c_cc[VTIME] = 0;
+        m_Imple->new_settings.c_cc[VMIN] = 1;
+        tcsetattr(FD_STDIN,TCSANOW,&m_Imple->new_settings);       /* enable the new value immediately */
+	m_Imple->m_keyflag = fcntl(FD_STDIN,F_GETFL);             /* get the F_GETFL variable from environment  */
+        fcntl(FD_STDIN,F_SETFL,m_Imple->m_keyflag | O_NONBLOCK ); /* set the read key type to be NONBLOCK */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restorekey
+ *  Description:  Restore the environment variables to the last saving time 
+ * =====================================================================================
+ */
+void Graphic::Restorekey(void)
+{
+	fcntl(FD_STDIN,F_SETFL,m_Imple->m_keyflag);
+        tcsetattr(FD_STDIN,TCSANOW,&m_Imple->store_settings);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  MovememH
+ *  Description:  Move the memory of screen display from one place to another
+ * =====================================================================================
+ */
+void Graphic::MovememH(int x,int y,int height,int width)
+{
+	m_Imple->gc->MovememH(x,y,height,width,m_Imple->m_Color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Movemem
+ *  Description:  Move the memory of screen display from one place to another
+ * =====================================================================================
+ */
+void Graphic::Movemem(int x,int y,int height,int width)
+{
+	m_Imple->gc->Movemem(x,y,height,width);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  BresenhamCircle
+ *  Description:  The second drawing circle algorithmic
+ * =====================================================================================
+ */
+void Graphic::BresenhamCircle(int xc,int yc,int radius,uint32_t color)
+{
+	aacircleColor(m_Imple->m_pSurface,xc,yc,radius,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Screen_Ptr
+ *  Description:  Get the screen ptr from Graphic class templately
+ * =====================================================================================
+ */
+unsigned char * Graphic::Get_Screen_Ptr()
+{
+	return m_Imple->m_Scr_Ptr;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_Disp_Area
+ *  Description:  Clean and Initial the display area  Flag: false shadow->real true
+ *                real->shadow
+ * =====================================================================================
+ */
+void Graphic::Screen_Copy(int left,int up,int right,int down,bool flag)
+{
+	m_Imple->gc->Screen_Copy(left,up,right,down,flag);
+}
+
+void Graphic::Screen_Copy_Alpha(int left,int up,int right,int down,bool flag)
+{
+	int temp_bpp;
+	temp_bpp = m_Imple->m_Bpp >> 3;
+
+	if ( flag == false )
+	{
+		for (int i = up;i<down+1;i++)
+		{
+			Word_Memcpy_Alpha(m_Imple->m_Scr_Ptr+m_Imple->m_MaxW*temp_bpp*i+temp_bpp*(left),
+				    m_Imple->m_Shadow_Scr_Ptr+m_Imple->m_MaxW*temp_bpp*i+temp_bpp*(left),
+				    temp_bpp*(right-left+1));
+		}
+		
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Word_Memcpy_Alpha
+ *  Description:  Memory copy word by word 
+ * =====================================================================================
+ */
+void Graphic::Word_Memcpy_Alpha(unsigned char *des,unsigned char *src,long len)
+{
+	short *des_w,*src_w;
+	len = len >> 1;
+	des_w = (short *)des;
+	src_w = (short *)src;
+	Algorithm* alm = Algorithm::Instance();
+	while( len-- )
+	{
+		*des_w++ = RGB24_16(alm->Alpha_Color(*src_w++,m_Imple->m_Transpare,*des_w)); 
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Screen
+ *  Description:  Switch between real screen and shadow screen
+ * =====================================================================================
+ */
+void Graphic::Switch_Screen()
+{
+	unsigned char *temp;
+	temp = m_Imple->m_Shadow_Scr_Ptr;
+	m_Imple->m_Shadow_Scr_Ptr = m_Imple->m_Scr_Ptr;
+	m_Imple->m_Scr_Ptr = temp;
+
+	m_Imple->gc->Switch_Screen();
+	Switch_Surface();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Color_System
+ *  Description:  Init the system color
+ * =====================================================================================
+ */
+void Graphic::Init_Color_System(int b)
+{
+	if ( b == 8 )
+	{
+		for ( int i=0;i<32;i++ )
+		{
+			g_Pen[i] = 224+i;
+		}
+	}
+	else if ( b == 16 )
+	{
+		for ( int i=0;i<32;i++ )
+		{
+			g_Pen[i] = m_Imple->cobj->Get_ColorVP(i)->color16;
+		}
+	}
+
+	switch ( b )
+	{
+		case 16:
+			/*-----------------------------------------------------------------------------
+			 *  308 used color system
+			 *-----------------------------------------------------------------------------*/
+			g_BATTARY_CO = g_Pen[9];
+
+			g_SCBG_CO   = g_Pen[10]; 
+			g_SCFG_CO   = g_Pen[11]; 
+			g_SCTX_CO   = g_Pen[12]; 
+
+			g_BUTXNO_CO = g_Pen[16]; 
+			g_BUBGNO_CO = g_Pen[17];
+			g_BUBGFO_CO = g_Pen[18];
+			g_BUTXFO_CO = g_Pen[19];
+
+			g_LIGHT_CO  = g_Pen[21];
+			g_SHADOW_CO = g_Pen[20];
+
+			g_MAINBG_CO = g_Pen[22];
+			g_MAINFG_CO = g_Pen[23];
+			g_BUFFFG_CO = g_Pen[24];
+
+			g_MOVBFG_CO = g_Pen[25];
+			g_MOVBBG_CO = g_Pen[26];
+			g_MOVBTX_CO = g_Pen[27];
+
+			break;
+		case 8:	
+			/*-----------------------------------------------------------------------------
+			 *  308 used color system
+			 *-----------------------------------------------------------------------------*/
+			g_BATTARY_CO = g_Pen[9];
+
+			g_SCBG_CO   = g_Pen[10]; 
+			g_SCFG_CO   = g_Pen[11]; 
+			g_SCTX_CO   = g_Pen[12]; 
+
+			g_BUTXNO_CO = g_Pen[16]; 
+			g_BUTXFO_CO = g_Pen[19];
+			g_BUBGNO_CO = g_Pen[17];
+			g_BUBGFO_CO = g_Pen[18];
+
+			g_LIGHT_CO  = g_Pen[21];
+			g_SHADOW_CO = g_Pen[20];
+
+			g_MAINBG_CO = g_Pen[22];
+			g_MAINFG_CO = g_Pen[23];
+			g_BUFFFG_CO = g_Pen[24];
+
+			g_MOVBFG_CO = g_Pen[25];
+			g_MOVBBG_CO = g_Pen[26];
+			g_MOVBTX_CO = g_Pen[27];
+
+			g_SCBG_CO   = g_Pen[10];
+			g_SCFG_CO   = g_Pen[11];
+			g_SCTX_CO   = g_Pen[12];
+
+		        break;  
+		case 1:	
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Disp_Area_Bytes
+ *  Description:  Get the display area byres number
+ * =====================================================================================
+ */
+int Graphic::Get_Disp_Area_Bytes(int left,int up,int right,int down) /* on the frame */
+{
+	return m_Imple->gc->Get_Disp_Area_Bytes(left,up,right,down);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Disp_Area
+ *  Description:  Load the graphic memory to memory 
+ * =====================================================================================
+ */
+void Graphic::Load_Disp_Area(int left,int up,int right,int down,unsigned char * mem)
+{
+	if ( m_Imple->m_Bpp == 8 )
+	{
+		for ( int j=up;j<=down;j++ )
+		{
+			for ( int i=left;i<=right;i++ )
+			{
+				*mem = *( m_Imple->m_Scr_Ptr + ( i + j * m_Imple->m_MaxW ) ); 
+				mem ++;
+			}
+		}
+	}
+	else if ( m_Imple->m_Bpp == 16 )
+	{
+		for ( int j=up;j<=down;j++ )
+		{
+			for ( int i=left;i<=right;i++ )
+			{
+				*(unsigned short *)mem = *(unsigned short *)( m_Imple->m_Scr_Ptr + (( i + j * m_Imple->m_MaxW ) << 1) ); 
+				mem += 2;
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restore_Disp_Area
+ *  Description:  Restore the memory to Graphic memory 
+ * =====================================================================================
+ */
+void Graphic::Restore_Disp_Area(int left,int up,int right,int down,unsigned char * mem)
+{
+	if ( m_Imple->m_Bpp == 8 )                                 /* bpp 16 8 */
+	{
+		for ( int j=up;j<=down;j++ )
+		{
+			for ( int i=left;i<=right;i++ )
+			{
+				*( m_Imple->m_Scr_Ptr + ( i + j * m_Imple->m_MaxW ) ) = *mem; 
+				mem ++;
+			}
+		}
+	}
+	else if ( m_Imple->m_Bpp == 16 )
+	{
+		for ( int j=up;j<=down;j++ )
+		{
+			for ( int i=left;i<=right;i++ )
+			{
+				*(unsigned short *)( m_Imple->m_Scr_Ptr + (( i + j * m_Imple->m_MaxW )<<1) ) = *(unsigned short *)mem; 
+				mem += 2;
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  HLine_Fast
+ *  Description:  Fast Draw H-Line 
+ *  Note:
+ *                Only used by 8-bits color system
+ *                0           1
+ *                low         high
+ * =====================================================================================
+ */
+void Graphic::HLine_Fast(int x1,int x2,int y,short color)
+{
+	m_Imple->gc->HLine_Fast(x1,x2,y,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Rect_Fast
+ *  Description:  Draw Rectangle as new algorithmic 
+ * =====================================================================================
+ */
+void Graphic::Rect_Fast(int x1,int y1,int x2,int y2,short color)
+{
+	for ( int j=y1;j<=y2;j++ )
+	{
+		HLine_Fast(x1,x2,j,color);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  RGB24_16
+ *  Description:  Convert RGB24 to RGB 16 ( RGB:5:6:5 ) 
+ * =====================================================================================
+ */
+unsigned short Graphic::RGB24_16(unsigned int rgb)
+{
+	return SDL_MapRGB(m_Imple->m_pSurface->format,( rgb >> 16 ) & 0xff,( rgb >> 8 ) & 0xff,rgb & 0xff);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  FillBox
+ *  Description:  FillBox with color 
+ * =====================================================================================
+ */
+void Graphic::FillBox(int x,int y,int w,int h,int r,uint32_t color)
+{
+	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+	aacircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
+	aacircleColor(m_Imple->m_pSurface,x+r,y+h-r,r,color);
+	aacircleColor(m_Imple->m_pSurface,x+w-r,y+h-r,r,color);
+
+	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
+	filledCircleColor(m_Imple->m_pSurface,x+r,y+h-r,r,color);
+	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+h-r,r,color);
+
+	boxColor(m_Imple->m_pSurface,x+r,y+r,x+w-r,y+h-r,color);
+	boxColor(m_Imple->m_pSurface,x+r,y,x+w-r,y+r,color);
+	boxColor(m_Imple->m_pSurface,x+r,y+h-r,x+w-r,y+h,color);
+	boxColor(m_Imple->m_pSurface,x,y+r,x+r,y+h-r,color);
+	boxColor(m_Imple->m_pSurface,x+w-r,y+r,x+w,y+h-r,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  HalfFillBox
+ *  Description:  HalfFillBox with color 
+ * =====================================================================================
+ */
+void Graphic::HalfFillBox(int x,int y,int w,int h,int r,uint32_t color)
+{
+	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+	aacircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
+
+	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+	filledCircleColor(m_Imple->m_pSurface,x+w-r,y+r,r,color);
+
+	boxColor(m_Imple->m_pSurface,x,y+r,x+w,y+h-r,color);
+	boxColor(m_Imple->m_pSurface,x+r,y,x+w-r,y+r,color);
+	boxColor(m_Imple->m_pSurface,x,y+h-r,x+w,y+h,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  QuatFillBox
+ *  Description:  Quat Fill Box with color 
+ * =====================================================================================
+ */
+void Graphic::QuatFillBox(int x,int y,int w,int h,int r,uint32_t color)
+{
+	aacircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+
+	filledCircleColor(m_Imple->m_pSurface,x+r,y+r,r,color);
+
+	boxColor(m_Imple->m_pSurface,x+r,y+r,x+w-r,y+h-r,color);
+
+	boxColor(m_Imple->m_pSurface,x,y+r,x+r,y+h-r,color);
+	boxColor(m_Imple->m_pSurface,x+w-r,y+r,x+w,y+h-r,color);
+
+	boxColor(m_Imple->m_pSurface,x+r,y,x+w,y+r,color);
+	boxColor(m_Imple->m_pSurface,x,y+h-r,x+w,y+h,color);
+}
+
+void Graphic::Switch_Surface()
+{
+	SDL_Surface* tmp = m_Imple->m_pShadowSurface;
+	m_Imple->m_pShadowSurface = m_Imple->m_pSurface;
+	m_Imple->m_pSurface = tmp; 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  MapColor
+ *  Description:  Map the color to SDL color system 
+ * =====================================================================================
+ */
+int  Graphic::MapColor(int r,int g,int b)
+{
+	return SDL_MapRGB(m_Imple->m_p32ColorSurface->format,r,g,b);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  FillPolygonColor
+ *  Description:  FilledPolygonColor with specail color
+ * =====================================================================================
+ */
+void Graphic::FillPolygonColor(int16_t* x,int16_t* y,int n,uint32_t color)
+{
+	filledPolygonColor(m_Imple->m_pSurface,x,y,n,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  PolygonColor
+ *  Description:  Just draw the polygon with color 
+ * =====================================================================================
+ */
+void Graphic::PolygonColor(int16_t* x,int16_t* y,int n,uint32_t color)
+{
+	aapolygonColor(m_Imple->m_pSurface,x,y,n,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Ascii
+ *  Description:  Display the ASCII charactor on screen 
+ * =====================================================================================
+ */
+void Graphic::Ascii(int x,int y,char c,uint32_t color)
+{
+	characterColor(m_Imple->m_pSurface,x,y,c,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SmallString
+ *  Description:  Display String On Screen
+ * =====================================================================================
+ */
+void Graphic::SmallString(int x,int y,const char* str,uint32_t color)
+{
+	stringColor(m_Imple->m_pSurface,x,y,str,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get/Set_Screen_XXX
+ *  Description:  Screen Parameters set or get
+ * =====================================================================================
+ */
+int Graphic::Get_Screen_Width()
+{
+	return m_Imple->m_MaxW;
+}
+int Graphic::Get_Screen_Height()
+{
+	return m_Imple->m_MaxH;
+}
+void Graphic::Set_Screen_Width(int value)
+{
+	m_Imple->m_MaxW = value;
+}
+void Graphic::Set_Screen_Height(int value)
+{
+	m_Imple->m_MaxH = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Transparce / Get_Transparce
+ *  Description:  Set the Transparce parameters 
+ * =====================================================================================
+ */
+void Graphic::Set_Transparce(int v)
+{
+	m_Imple->m_Transpare = v;
+}
+int Graphic::Get_Transparce()
+{
+	return m_Imple->m_Transpare;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_bpp
+ *  Description:  Get the Device BPP
+ * =====================================================================================
+ */
+int Graphic::Get_bpp()
+{
+	return m_Imple->m_Bpp;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_BMP_File
+ *  Description:  Load the BMP formate file on screen with SDL_image module 
+ *	   Note:  support picture type:
+ *	   	  gif     only one frame
+ *		  ico
+ *		  bmp
+ *		  jpeg
+ *		  png
+ *
+ *		  SDL_image库的支持
+ * =====================================================================================
+ */
+void Graphic::Load_Picture_File(int x,int y,const char* path)
+{
+	SDL_Surface *surface = IMG_Load(path);
+	if ( !surface )
+		printf("IMG_Load %s\n",IMG_GetError());
+
+	SDL_Rect offset;
+	offset.x = x;
+	offset.y = y;
+
+	SDL_BlitSurface(surface,NULL,m_Imple->m_pSurface,&offset);
+	SDL_UpdateRect(m_Imple->m_pSurface,0,0,639,479);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Update_Rect
+ *  Description:  The function only used by x86 platform 
+ * =====================================================================================
+ */
+void Graphic::Update_Rect(int x,int y,int w,int h)
+{
+	SDL_UpdateRect(m_Imple->m_pSurface,x,y,w,h);
+}
diff --git a/src/EVA11/base/Graphic.h b/src/EVA11/base/Graphic.h
new file mode 100644
index 0000000..70d4f0d
--- /dev/null
+++ b/src/EVA11/base/Graphic.h
@@ -0,0 +1,155 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Graphic.h
+ *
+ *    Description:  Drawing screen directly and Init key environment variables for 
+ *       	    getchar key return immediately
+ *
+ *        Version:  1.0
+ *        Created:  2009年07月03日 09时25分31秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+#ifndef GRAPHIC_H
+#define GRAPHIC_H
+
+#include 	<stdint.h>
+#include 	<cstdio>
+#include 	<cstdlib>
+#include 	<memory>	
+#include 	<unistd.h>
+#include 	<fcntl.h>
+
+#include 	"main.h"
+#include 	"ColorObj.h"
+
+class Graphic
+{
+	public:
+		typedef enum 
+		{                                        	      /* copy mode type for drawing screen */
+			MODE_SRC,
+			MODE_SRC_XOR_DST,
+			InvalidMode
+		} CopyMode;
+
+		static Graphic* Instance();
+
+                bool Initgraph();               		      /* Init the graphic screen */
+		void Closegraph();              		      /* Close the graphic screen */
+
+		void Clearscreen();             		      /* reset the screen */
+		void CleanArea(int,int,int,int);
+
+		void Setcolor(short color);     	              /* Set the front color */
+		int Getcolor(void);     			      /* Get the front color */
+		void Setpixel(int x,int y,short Color); 	      /* Draw pixel on screen */
+		short Getpixel(int x,int y);
+
+		void Line(int x1,int y1,int x2,int y2);       /* Draw line on screen */
+		void DoLine(int x1,int y1,int x2,int y2);     /* Draw line on screen */
+		void Line(int x1,int y1,int x2,int y2,short color); 
+		                                                      /* Draw line on screen */
+
+		void Rectangle(int x1,int y1,int x2,int y2);  /* Draw ractangel on screen */
+		void DrawRect(int x,int y,int width,int height); 
+								      /* Draw rectangel on screen with x y width height */
+		void DrawRect(int x,int y,int width,int height,short color); 
+								      /* Draw rectangel on screen with x y width height */
+		void DrawFillRect(int x,int y,int width,int height); 	     
+								      /* Draw filled rectangle */
+		void DrawFillRect(int x,int y,int width,int height,short color); 
+								      /* Draw filled rectangle */
+		void FillBox(int x,int y,int width,int height,int radius,uint32_t color);
+		void HalfFillBox(int x,int y,int width,int height,int radius,uint32_t color);
+		void QuatFillBox(int x,int y,int width,int height,int radius,uint32_t color);
+		void BresenhamCircle(int xc,int yc,int radius,uint32_t color); 
+								      /* draw circle on screen 2 edition*/
+		void FillRect(int x1,int y1,int x2,int y2);   /* Draw filled rectangle */
+
+		void SetMode(CopyMode);   		              /* Set the drawing mode  */
+		CopyMode GetMode(void) const;   		      /* Get the drawing mode  */
+
+		void Movemem(int x,int y,int height,int width);       /* Move the screen memory from one address to the other */
+		void MovememH(int x,int y,int height,int width);      /* Move the screen memory from one address to the other */
+		unsigned char* Get_Screen_Ptr();   		      /* Get the screen ptr right now  */
+		void Screen_Copy(int left,int up,int right,int down,bool flag);   /* screen copy flag: false shadow->real true real->shadow */
+		void Screen_Copy_Alpha(int left,int up,int right,int down,bool flag);   /* screen copy flag: false shadow->real true real->shadow */
+		void Switch_Screen();                 		      /* switch between real screen and shadow screen  */
+		void Switch_Surface();
+
+		int Get_Disp_Area_Bytes(int left,int up,int right,int down); 
+								      /* According the bpp calculate the length of display area btes */
+		void Load_Disp_Area(int left,int up,int right,int down,unsigned char *mem);
+		void Restore_Disp_Area(int left,int up,int right,int down,unsigned char *mem);
+
+		void HLine_Fast(int x1,int x2,int y,short color);
+		void Rect_Fast(int x1,int y1,int x2,int y2,short color);
+
+		/*-----------------------------------------------------------------------------
+		 *  Memory operation
+		 *-----------------------------------------------------------------------------*/
+		void Word_Memcpy_Alpha(unsigned char *des,unsigned char *src,long len); 
+
+		/*-----------------------------------------------------------------------------
+		 * Class Parameters get/set 
+		 *-----------------------------------------------------------------------------*/
+		void Set_Transparce(int v);			      /* Set transpare parameters */
+		int  Get_Transparce();       
+
+		int Get_Screen_Width();
+		int Get_Screen_Height();
+		void Set_Screen_Width(int v);
+		void Set_Screen_Height(int v);
+		/*-----------------------------------------------------------------------------
+		 * Color convert 
+		 *-----------------------------------------------------------------------------*/
+		unsigned short RGB24_16(unsigned int rgb);
+		int  MapColor(int r,int g,int b);
+
+		int Get_bpp();
+
+		void FillPolygonColor(int16_t* x,int16_t* y,int n,uint32_t color);
+		void PolygonColor(int16_t* x,int16_t* y,int n,uint32_t color);
+		void Ascii(int x,int y,char c,uint32_t color);
+		void SmallString(int x,int y,const char* c,uint32_t color);
+
+		/*-----------------------------------------------------------------------------
+		 *  Picture Load functionns
+		 *-----------------------------------------------------------------------------*/
+		void Load_Picture_File(int,int,const char*);
+
+		/*-----------------------------------------------------------------------------
+		 * Only Used by x86 platform 
+		 *-----------------------------------------------------------------------------*/
+		void Update_Rect(int,int,int,int);
+	private:
+		Graphic ();                     		      /* constructor */
+ 		~Graphic ();					      /* destructor  */
+		Graphic (const Graphic&);          		      /* constructor */
+		Graphic& operator = (const Graphic&);    
+
+		void Init_Color_System(int bpp);       		      /* Initiate the system color */
+
+		/*-----------------------------------------------------------------------------
+		 *  Init key used variables 
+		 *-----------------------------------------------------------------------------*/
+		void Initkey(void);             		      /* Init the stdio attribution for reading key value, return immediately  */
+		void Restorekey(void);          		      /* restore the current environment to be last save time */
+	public:
+	protected:
+	private:
+		friend class std::auto_ptr<Graphic>;
+		static std::auto_ptr<Graphic>			m_Instance;
+
+		struct PImpl;
+		std::auto_ptr<struct PImpl>			m_Imple;
+
+}; /* -----  end of class Graphic  ----- */
+#endif
diff --git a/src/EVA11/base/Helpwin.cpp b/src/EVA11/base/Helpwin.cpp
new file mode 100644
index 0000000..1378c3e
--- /dev/null
+++ b/src/EVA11/base/Helpwin.cpp
@@ -0,0 +1,239 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Helpwin.cpp
+ *
+ *    Description:  implementation of Help Windows class
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月27日 15时46分42秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"Basewin.h"
+#include 	"Helpwin.h"
+#include	"JpegOper.h"
+#include 	"Logic.h"
+#include 	"Graphic.h"
+#include	"Language.h"
+#include 	"Msgbox.h"
+
+#include 	"main.h"
+
+Helpwin::Helpwin ()
+{
+}
+
+Helpwin::~Helpwin ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object of screen 
+ * =====================================================================================
+ */
+void Helpwin::Init_GUI(Graphic &g)
+{
+	Basewin::Init_GUI(g);
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Help_Text(i));
+	}	
+	m_BomSmall->Set_Text("X");
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object
+ * =====================================================================================
+ */
+void  Helpwin::Destroy_GUI()
+{
+	Basewin::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ *      Caution:  a00_hlp.jpeg
+ *                638 * 440     
+ * =====================================================================================
+ */
+void Helpwin::Drawme(Graphic& g)
+{
+	Basewin::Drawme(g);
+	sprintf(m_Msg,"%s%c%02d_hlp.jpeg",HELP_PATH,m_Flag,m_Index);
+	if ( access(m_Msg,0) != 0 )
+	{
+		Label *lab = new Label(200,220,220,30); 
+		lab->Set_Font_Size(18);
+		lab->Set_Focus(false);
+		lab->Set_Label_Type(Label::LA_NONE);
+		lab->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0x00000000));
+		lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		lab->Set_Text(m_pl->GetText(INFORMESG21));
+		lab->Drawme(g);
+		delete lab;
+		lab = NULL;
+	}
+	else
+	{
+		JpegOper *m_Jpeg     = new JpegOper;
+		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
+
+		m_Jpeg->JpegSetJpegPara(m_Msg,5,5,JCS_RGB);
+		m_Jpeg->JpegReadJpegFile();
+		m_Jpeg->JpegPlayJpeg(0,0,1,1,638,440);
+
+		delete m_Jpeg;
+		m_Jpeg = NULL;
+	}
+
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Help_Text
+ *  Description:  Get the help screen buttons text
+ * =====================================================================================
+ */
+const char *Helpwin::Get_Help_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0: 
+			return m_pl->GetText(DELETE);
+			break;
+		case 1: 
+			return m_pl->GetText(NONE);
+			break;
+		case 2: 
+			return m_pl->GetText(NONE);
+			break;
+		case 3: 
+			return m_pl->GetText(NONE);
+			break;
+		case 4: 
+			return m_pl->GetText(NONE);
+			break;
+		case 5: 
+			return m_pl->GetText(NONE);
+			break;
+		case 6: 
+			return m_pl->GetText(BACKOUT);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  
+ * =====================================================================================
+ */
+int Helpwin::Loopwindow (Graphic &g)
+{
+	int result    = 0;
+	Save_Screen_Into_Memory(g);
+	m_BottomFocus = 7;
+	Init_GUI(g);
+	Drawme(g);
+
+	while( 1 )
+	{
+		result = Command_Process(g);
+		if 	( result == CO_EXIT )
+			goto Exit;
+	}
+Exit:
+	Destroy_GUI();
+	Restore_Screen_From_Memory(g);
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Delete_Help_Documentation
+ *  Description:  Delete the help Documentation 
+ * =====================================================================================
+ */
+void Helpwin::Delete_Help_Documentation(Graphic& g)
+{
+	sprintf(m_Msg,"%s%c%02d_hlp.jpeg",HELP_PATH,m_Flag,m_Index);
+	if ( access(m_Msg,0) != 0 )
+	{
+		Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g); 
+		delete ms;
+		ms = NULL;
+	}
+	else
+	{
+		if ( Password_Confirm(g) == 1 )
+		{
+			if ( remove(m_Msg) == 0 )
+			{
+				Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(DELETEHELP),Msgbox::MSG_OK);	
+				ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+				ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+				ms->Showme(g); 
+				delete ms;
+				ms = NULL;
+				Drawme(g);
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Helpwin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+	Delete_Help_Documentation(g);
+	return CO_NONE;
+}
+int Helpwin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Helpwin::Key_Enter_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Helpwin::Key_Esc_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Helpwin::Key_F1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
diff --git a/src/EVA11/base/Helpwin.h b/src/EVA11/base/Helpwin.h
new file mode 100644
index 0000000..c0c5342
--- /dev/null
+++ b/src/EVA11/base/Helpwin.h
@@ -0,0 +1,50 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Helpwin.h
+ *
+ *    Description:  Manage of Showing Help message class
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月27日 15时44分40秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef  _HELPWIN_INC
+#define  _HELPWIN_INC
+
+class Helpwin : public Basewin
+{
+	public:
+		Helpwin ();
+		virtual ~Helpwin ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g);
+
+		int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
+		inline void Set_Flag(const char& flag) { m_Flag = flag; }
+		inline void Set_Index(const int& index) { m_Index = index; }
+	protected:
+		virtual int Key_Bom1_Fun(Graphic& g) ;
+		virtual int Key_Bom7_Fun(Graphic& g) ;
+
+		virtual int Key_Esc_Fun(Graphic& g)  ;
+		virtual int Key_Enter_Fun(Graphic& g);
+		virtual int Key_F1_Fun(Graphic& g)   ;
+
+	private:
+		void Delete_Help_Documentation(Graphic& g);
+		const char*  Get_Help_Text(int);
+	private:
+		char		m_Flag;
+		int		m_Index;
+};
+
+#endif
diff --git a/src/EVA11/base/IDataProcess.cpp b/src/EVA11/base/IDataProcess.cpp
new file mode 100644
index 0000000..17ae3be
--- /dev/null
+++ b/src/EVA11/base/IDataProcess.cpp
@@ -0,0 +1,118 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  IDataProcess.cpp
+ *
+ *    Description:  Implementation of IDataProcess
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月13日 17时22分17秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Device.h"
+#include 	"DataRepo.h"
+#include 	"IDataProcess.h"
+#include 	"Algorithm.h"
+#include 	"MixingManage.h"
+
+IDataProcess::IDataProcess ()
+{
+	m_device = Device::Instance();
+	m_gp     = Global::Instance();
+	m_repo   = DataRepo::Instance();
+	m_alg	 = Algorithm::Instance();
+	m_mixm   = MixingManage::Instance();
+}
+
+IDataProcess::~IDataProcess ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Trigger_Balance_Process
+ *  Description:  Get the Balacen point value 
+ * =====================================================================================
+ */
+void IDataProcess::Trigger_Balacne_Process()
+{
+	m_device->Get_Data_From_ECT(m_ETtemp);
+	int offset=0;
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+	{
+		if ( m_gp->ProbeFun[i] == 0 )
+		{
+			m_BalanceX[i] = 0; 
+			m_BalanceY[i] = 0; 
+		}
+		else
+		{
+			m_BalanceX[i] = ( m_ETtemp[offset<<1]>>m_gp->Precision );
+			m_BalanceY[i] = ( m_ETtemp[(offset<<1)+1]>>m_gp->Precision );
+			offset++;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Data_Process
+ *  Description:  Base class Data Process , balance and save data into buffer  
+ * =====================================================================================
+ */
+void IDataProcess::Data_Process()
+{
+	m_device->Get_Data_From_ECT_Timer(m_ETtemp);
+
+	int offset=0;
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+	{
+		if ( m_gp->ProbeFun[i] == 0 )
+		{
+			m_ETData[i<<1]     = 0;
+			m_ETData[(i<<1)+1] = 0;
+		}
+		else
+		{
+			m_ETData[i<<1]     =  static_cast<ETDATA>( ( ( m_ETtemp[offset<<1]>>m_gp->Precision )     - m_BalanceX[i] ) );
+			m_ETData[(i<<1)+1] =  static_cast<ETDATA>( ( ( m_ETtemp[(offset<<1)+1]>>m_gp->Precision ) - m_BalanceY[i] ) );
+			offset ++;
+		}
+	}
+
+	m_InTimer[0]  -= m_ETtemp[(offset<<1)+0];
+	m_InTimer[1]  -= m_ETtemp[(offset<<1)+0];
+
+	m_OutTimer[0] -= m_ETtemp[(offset<<1)+1];
+	m_OutTimer[1] -= m_ETtemp[(offset<<1)+2];
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_Timer
+ *  Description:  Reset inside ot outside timers 
+ * =====================================================================================
+ */
+void IDataProcess::Reset_InTimer()
+{
+	int data[3];
+	m_device->Get_Timers_Data(data);
+
+	m_InTimer[0]  = data[0]; 
+	m_InTimer[1]  = data[0];
+}
+void IDataProcess::Reset_OutTimer()
+{
+	int data[3];
+	m_device->Get_Timers_Data(data);
+
+	m_OutTimer[0] = data[1];
+	m_OutTimer[1] = data[2];
+}
diff --git a/src/EVA11/base/IDataProcess.h b/src/EVA11/base/IDataProcess.h
new file mode 100644
index 0000000..c737cab
--- /dev/null
+++ b/src/EVA11/base/IDataProcess.h
@@ -0,0 +1,57 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  IDataProcess.h
+ *
+ *    Description:  Interface of data process
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月13日 17时19分11秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _IDATAPROCESS_INC
+#define  _IDATAPROCESS_INC
+
+#include 	"main.h"
+#include 	"Global.h"
+class Device;
+class DataRepo;
+class Algorithm;
+class MixingManage;
+
+class IDataProcess
+{
+	public:
+		IDataProcess ();
+		virtual ~IDataProcess ();
+
+		virtual void Data_Process();
+		void Trigger_Balacne_Process();
+
+		void Reset_InTimer();
+		void Reset_OutTimer();
+	protected:
+		ETDATA 			m_ETData[(Global::CHANCOUNT<<1)+16];
+		ETDATA 			m_ETtemp[(Global::CHANCOUNT<<1)+16];
+
+		ETDATA			m_BalanceX[Global::CHANCOUNT];
+		ETDATA			m_BalanceY[Global::CHANCOUNT];
+
+		Device			*m_device;
+		Global			*m_gp;
+		DataRepo		*m_repo;
+		Algorithm		*m_alg;
+		MixingManage 		*m_mixm;
+
+		ETDATA			m_InTimer[2];
+		ETDATA			m_OutTimer[2];
+};
+
+#endif   /* ----- #ifndef _IDATAPROCESS_INC  ----- */
diff --git a/src/EVA11/base/IView.cpp b/src/EVA11/base/IView.cpp
new file mode 100644
index 0000000..89f5894
--- /dev/null
+++ b/src/EVA11/base/IView.cpp
@@ -0,0 +1,229 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  IView.cpp
+ *
+ *    Description:  implementation of IView
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 09时26分21秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include	"Global.h"
+#include 	"Device.h"
+#include 	"Graphic.h"
+#include 	"Language.h"
+#include 	"Algorithm.h"
+#include 	"Logic.h"
+#include 	"Label.h"
+#include 	"Resource.h"
+#include 	"FreeType.h"
+
+#include 	"IView.h"
+
+#include 	<boost/format.hpp>
+
+IView::IView(int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+	m_gp          = Global::Instance();
+	m_device      = Device::Instance();
+}
+IView::~IView() { }
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Do_Key_Event
+ *  Description:  Do key event for view class 
+ * =====================================================================================
+ */
+int IView::Do_Key_Event(int key,Graphic& g)
+{
+	switch ( key ) 
+	{
+		case KEY_F1:
+			return Key_F1_Fun(g);
+			break;
+
+		case KEY_F2:
+			return Key_F2_Fun(g);
+			break;
+
+		case KEY_F3:
+			return Key_F3_Fun(g);
+			break;
+
+		case KEY_F4:
+			return Key_F4_Fun(g);
+			break;
+
+		case KEY_F5:
+			return Key_F5_Fun(g);
+			break;
+
+		case KEY_F6:
+			return Key_F6_Fun(g);
+			break;
+
+		case KEY_F7:
+			return Key_F7_Fun(g);
+			break;
+	}
+	return CO_NONE;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Real show the help system 
+ * =====================================================================================
+ */
+void IView::Show_Help_System(Graphic& g,int x,int y)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_F1_Fun
+ *  Description:  Help system box 
+ * =====================================================================================
+ */
+int IView::Key_F1_Fun(Graphic& g)
+{
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
+	g.Load_Disp_Area(0,0,639,479,mem);
+
+	Language  *pl     = Language::Instance();
+	Logic	  *lo     = Logic::Instance();
+	Algorithm *alg    = Algorithm::Instance();
+
+	int ft            = 16;
+	int key           = 0;
+	UINT32 x          = 70,y = 70,width = 400,heigh = 285+50;
+	UINT32 centx      = x + ( width >> 1 );
+	UINT32 centy      = y + ( heigh >> 1 );
+	COLORTYPE bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+
+	g.DrawFillRect(x,y,width,heigh,bgcolor);
+	COLORTYPE co_sa;
+	g.Setcolor(fgcolor);
+	g.DrawRect(x,y,width,heigh);
+	g.DrawRect(x+1,y+1,width-2,heigh-2);
+	g.Setcolor(g.RGB24_16(0x000000));
+	g.DrawRect(x+2,y+2,width-4,heigh-4);
+	g.DrawRect(x+3,y+3,width-6,heigh-6);
+	g.Setcolor(fgcolor);
+	g.DrawRect(x+4,y+4,width-8,heigh-8);
+	g.Setcolor(co_sa);
+
+	Resource *res = Resource::Instance();
+	res->Show_Resource_Png(g,7,x+8,y+6);
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,g_BUTXNO_CO);
+	font->Set_Color(FreeType::BGCOLOR,g_BUBGNO_CO);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+	std::string v = str(boost::format("Ver:%s")%PROVERSION);
+	font->Text(x+55,y+35,v.c_str());
+
+	Label *button = new Label(centx-2*ft-4,y+heigh-40,4*ft,ft+8);
+	button->Set_Text(pl->GetText(COMFIRM));
+	button->Set_Font_Size(18);
+	button->Set_Label_Type(Label::LA_3D);
+	button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	button->Drawme(g);
+
+	m_gp->Time_now  = boost::posix_time::second_clock::universal_time();
+	boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
+
+	int second = time_elapse.total_seconds();
+	int hour   = second / 3600;
+	int min    = ( second - hour * 3600 ) / 60;
+	second     = second - hour * 3600 - min * 60;
+
+	std::string s = str(boost::format("%02d:%02d:%02d")%hour%min%second);
+
+	Label *runtime = new Label(x+width-110,y+20,100,20);
+	runtime->Set_Label_Type(Label::LA_NONE);
+	runtime->Set_Font_Size(16);
+	runtime->Set_Text(s.c_str());
+	runtime->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	runtime->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	runtime->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	runtime->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	runtime->Drawme(g,false);
+
+	Show_Help_System(g,x,y+50);
+
+	while( key!= KEY_ENTER && key!= KEY_ESC && key!= KEY_F1 )
+	{
+		key = lo->Get_Key();
+
+		if ( key == KEY_F5 )
+			lo->Screen_Shoot(g);
+
+		m_gp->Time_now  = boost::posix_time::second_clock::universal_time();
+		time_elapse = m_gp->Time_now - m_gp->Time_start;
+
+		second = time_elapse.total_seconds();
+		hour   = second / 3600;
+		min    = ( second - hour * 3600 ) / 60;
+		second     = second - hour * 3600 - min * 60;
+		s = str(boost::format("%02d:%02d:%02d")%hour%min%second);
+		runtime->Set_Text(s.c_str());
+		runtime->Drawme(g,true);
+
+		alg->MDelay(70);	
+	}
+	button->Set_Focus(true);
+	button->Drawme(g);
+	alg->MDelay(100);
+	delete button;
+	button = NULL;
+
+	delete runtime;
+	runtime = NULL;
+
+	g.Restore_Disp_Area(0,0,639,479,mem);
+	delete[] mem;
+	mem = NULL;
+}
+
+int IView::Key_Enter_Fun(Graphic& g){;}
+int IView::Key_F2_Fun(Graphic& g){;}
+int IView::Key_F3_Fun(Graphic& g){;}
+int IView::Key_F4_Fun(Graphic& g){;}
+int IView::Key_F5_Fun(Graphic& g){;}
+int IView::Key_F6_Fun(Graphic& g){;}
+int IView::Key_F7_Fun(Graphic& g){;}
+
+int IView::Key_NL1_Fun(Graphic& g,int sub){;}
+int IView::Key_NR1_Fun(Graphic& g,int sub){;}
+int IView::Key_NL2_Fun(Graphic& g,int sub){;}
+int IView::Key_NR2_Fun(Graphic& g,int sub){;}
+int IView::Key_NL3_Fun(Graphic& g,int sub){;}
+int IView::Key_NR3_Fun(Graphic& g,int sub){;}
+int IView::Key_NL4_Fun(Graphic& g,int sub){;}
+int IView::Key_NR4_Fun(Graphic& g,int sub){;}
+int IView::Key_NL5_Fun(Graphic& g,int sub){;}
+int IView::Key_NR5_Fun(Graphic& g,int sub){;}
+int IView::Key_NL6_Fun(Graphic& g,int sub){;}
+int IView::Key_NR6_Fun(Graphic& g,int sub){;}
+
+void IView::Lock_View(Graphic&){;}
+void IView::UnLock_View(Graphic&){;}
+void IView::Set_Panel_Type(int type) {;}
+void IView::Switch_View() {;}
+void IView::Load_View_Object(IView* obj) {;}
diff --git a/src/EVA11/base/IView.h b/src/EVA11/base/IView.h
new file mode 100644
index 0000000..b75d310
--- /dev/null
+++ b/src/EVA11/base/IView.h
@@ -0,0 +1,83 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  IView.h
+ *
+ *    Description:  Interface of many kindd View
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 14时24分38秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _IVIEW_INC
+#define  _IVIEW_INC
+
+class Graphic;
+class Device;
+class Global;
+class Object;
+
+class IView : public Object
+{
+	public:
+		IView(int x,int y,int width,int heigh);
+		virtual ~IView() 		 	= 0;
+
+		virtual void Init_View(Graphic&) 	= 0;
+		virtual void Release_View() 	 	= 0;
+		virtual int  Loop_View(Graphic&) 	= 0;
+		virtual void Drawme (Graphic&)   	= 0;
+
+		virtual void Lock_View(Graphic&);
+		virtual void UnLock_View(Graphic&);
+
+		virtual void Set_Panel_Type(int);
+
+		int Do_Key_Event(int key,Graphic& g);
+
+		typedef enum {
+			CO_OK       = 1,
+			CO_NONE     = 999
+		} COMMAND;					/* ----------  end of enum COMMAND  ---------- */
+
+		virtual int Key_F1_Fun(Graphic& g); 
+		virtual int Key_F2_Fun(Graphic& g); 
+		virtual int Key_F3_Fun(Graphic& g); 
+		virtual int Key_F4_Fun(Graphic& g); 
+		virtual int Key_F5_Fun(Graphic& g); 
+		virtual int Key_F6_Fun(Graphic& g); 
+		virtual int Key_F7_Fun(Graphic& g); 
+
+		virtual int Key_Enter_Fun(Graphic& g); 
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y) ;
+		virtual void Switch_View(); 
+
+		virtual void Load_View_Object(IView* obj);
+	protected:
+
+	protected:
+		Global				     *m_gp;
+		Device				     *m_device;
+};
+#endif   /* ----- #ifndef iview_INC  ----- */
diff --git a/src/EVA11/base/Iconbutton.cpp b/src/EVA11/base/Iconbutton.cpp
new file mode 100644
index 0000000..e34c151
--- /dev/null
+++ b/src/EVA11/base/Iconbutton.cpp
@@ -0,0 +1,168 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Iconbutton.cpp
+ *
+ *    Description:  implementation of Icon button class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月20日 14时39分05秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	"Object.h"
+#include 	"Iconbutton.h"
+#include 	"Graphic.h"
+#include 	"Label.h"
+#include 	"Resource.h"
+
+#define      SHADOW	  2
+Iconbutton::Iconbutton (int x,int y,int width,int height)
+	: Object(x,y,width,height)
+{
+	m_Focus 	= false;
+	m_ResourceIndex = 0xffff;
+}
+
+Iconbutton::~Iconbutton ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init GUI function 
+ * =====================================================================================
+ */
+void Iconbutton::Init_GUI()
+{
+	m_labText = NULL;
+	m_labText = new Label(m_X+3,m_Y+m_Heigh-28,m_Width-6,20);
+	m_labText->Set_Text(" ");
+	m_labText->Set_Label_Type(Label::LA_NONE);
+
+	m_labText->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGNoColor);
+	m_labText->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGNoColor);
+
+	m_labText->Set_Label_Color(Label::LA_BGFO_COLOR,m_FGFoColor);
+	m_labText->Set_Label_Color(Label::LA_FGFO_COLOR,m_BGFoColor);
+
+	m_labText->Set_Font_Size(16);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  
+ * =====================================================================================
+ */
+void Iconbutton::Destroy_GUI()
+{
+	if 	( m_labText != NULL )
+	{
+		delete m_labText;
+		m_labText = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the iconbutton class
+ * =====================================================================================
+ */
+void Iconbutton::Drawme(Graphic& g)
+{
+	COLORTYPE txcolor,bgcolor;
+	COLORTYPE hicolor,locolor;
+
+	m_LightColor  = g.RGB24_16(0xffffff); 
+	m_ShadowColor = g.RGB24_16(0x000000); 
+
+	if ( m_Focus == true )
+	{
+		txcolor = m_FGFoColor;
+		bgcolor = m_FGFoColor;
+		hicolor = m_LightColor;
+		locolor = m_ShadowColor; 
+
+		m_labText->Set_Focus(true);
+	}
+	else
+	{
+		txcolor = m_FGNoColor;
+		bgcolor = m_BGNoColor;
+		hicolor = m_ShadowColor;
+		locolor = m_LightColor;
+
+		m_labText->Set_Focus(false);
+	}
+
+	g.DrawFillRect(m_X,m_Y,m_Width+SHADOW,m_Heigh+SHADOW,hicolor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
+	g.DrawFillRect(m_X+SHADOW,m_Y+SHADOW,m_Width-SHADOW,m_Heigh-SHADOW,bgcolor);
+
+	m_labText->Drawme(g);
+
+	if ( m_ResourceIndex != 0xffff )
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Jpeg(g,m_ResourceIndex,0,0,m_X+27,m_Y+15,320,240);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Text
+ *  Description:  Set the Text of iconbutton 
+ * =====================================================================================
+ */
+void Iconbutton::Set_Text(const char* text)
+{
+	m_labText->Set_Text(text);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Resource_Index
+ *  Description:  Set the resource index for Iconbutton class 
+ * =====================================================================================
+ */
+void Iconbutton::Set_Resource_Index(int index)
+{
+	m_ResourceIndex = index;
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_IconColor
+ *  Description:  The color of Icon 
+ * =====================================================================================
+ */
+void Iconbutton::Set_IconColor(ICONCOLOR type,short color)
+{
+	switch ( type ) 
+	{
+		case BGFO_COLOR:
+			m_BGFoColor = color;
+			break;
+
+		case BGNO_COLOR:
+			m_BGNoColor = color;
+			break;
+
+		case FGFO_COLOR:
+			m_FGFoColor = color;
+			break;
+
+		case FGNO_COLOR:
+			m_FGNoColor = color;
+			break;
+
+	}				/* -----  end switch  ----- */
+}
diff --git a/src/EVA11/base/Iconbutton.h b/src/EVA11/base/Iconbutton.h
new file mode 100644
index 0000000..057409a
--- /dev/null
+++ b/src/EVA11/base/Iconbutton.h
@@ -0,0 +1,65 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Iconbutton.h
+ *
+ *    Description:  Manage the Icon button class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月20日 14时37分33秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ICONBUTTON_INC
+#define  _ICONBUTTON_INC
+
+class Object;
+class Graphic;
+class Label;
+
+class Iconbutton : public Object
+{
+	public:
+		enum ICONCOLOR 
+		{
+			BGFO_COLOR,
+			BGNO_COLOR,
+			FGFO_COLOR,
+			FGNO_COLOR,
+		};
+		typedef enum ICONCOLOR ICONCOLOR;
+		Iconbutton (int x,int y,int width,int height);
+		~Iconbutton ();
+		void Set_IconColor(ICONCOLOR,short);
+
+		void Drawme(Graphic& g);
+		void Init_GUI();
+		void Destroy_GUI();
+
+		void Set_Text(const char*);
+		void Set_Resource_Index(int index);
+
+	public:
+		bool			m_Focus;
+	protected:
+
+	private:
+		Label			*m_labText;
+		int			m_ResourceIndex;
+
+		short 			m_FGFoColor;
+		short 			m_BGFoColor;
+
+		short 			m_FGNoColor;
+		short 			m_BGNoColor;
+
+		short 			m_LightColor;
+		short			m_ShadowColor;
+}; /* -----  end of class Iconbutton  ----- */
+#endif   /* ----- #ifndef _ICONBUTTON_INC  ----- */
diff --git a/src/EVA11/base/Initfacade.cpp b/src/EVA11/base/Initfacade.cpp
new file mode 100644
index 0000000..e2d2e86
--- /dev/null
+++ b/src/EVA11/base/Initfacade.cpp
@@ -0,0 +1,201 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Initfacade.cpp
+ *
+ *    Description:  implementation of Initfacade class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月23日 14时54分56秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<stdlib.h>
+#include 	<unistd.h>
+#include 	<sys/ioctl.h>
+#include 	<fcntl.h>
+#include 	<sys/stat.h>
+#include 	<sys/mman.h>
+
+#include 	"main.h"
+
+#include 	"Graphic.h"
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Splashscreen.h"
+#include	"Global.h"	
+#include	"Logic.h"
+#include 	"Language.h"
+#include 	"Algorithm.h"
+#include 	"DataRepo.h"
+#include 	"Initfacade.h"
+#include 	"FreeType.h"
+#include 	"MixingManage.h"
+
+Initfacade::Initfacade ()
+{
+}
+
+Initfacade::~Initfacade ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  System_Init
+ *  Description:  System Init Process 
+ * =====================================================================================
+ */
+bool Initfacade::Standard_ET_System_Init()
+{
+	Create_Inside_Directoies();
+	Graphic *g = Graphic::Instance(); 
+	if 	( g->Initgraph() == false ) 
+	{
+		perror("Error! Can't init the environment");
+		return false;
+	}
+	ft = FreeType::Instance();
+	if ( ft->Init_FreeType(*g,FONT_FILE_PATH) == false )
+	{
+		perror("Error! Can't init the FreeType");
+		g->Closegraph();
+		return false;
+	}
+	ft->Set_Transparce(false);
+
+	Splashscreen *splash = new Splashscreen(150,110,340,260);
+	splash->Drawme(*g);
+	splash->Show_Info(*g,"Starting the EVA-11 System");
+
+	lo = Logic::Instance();
+	lo->Init_Hardware(*g);
+
+	gp = Global::Instance();
+	pl = Language::Instance();
+
+	gp->Init_Global_Variables();
+
+	splash->Show_Info(*g,"Load System Parameters    ");
+
+	      /* Load par.nam */
+	gp->Load_Global_Variables(PAR_FILE_PATH);
+	      /* Load par.nam */
+
+	lo->Set_Global_Variables_Into_PCB();
+	alg = Algorithm::Instance();
+
+	for ( int i=0;i<Global::CHANCOUNT;i++ )
+		alg->Reset_MAX_Value(i,gp->DFilter[i]);
+
+	mixm = MixingManage::Instance();
+	mixm->Init_Object();
+	mixm->Sync_Mixing_Para(false);
+
+	alg->Calculate_Gain_Ratio(gp->GainRatio);
+
+	splash->Show_Info(*g,"Init Hardware and D-Buffer");
+	dpo = DataRepo::Instance();
+	lo->Set_Global_Variables_Into_System();
+
+	delete splash;
+	splash = NULL;
+
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  System_Destroy
+ *  Description:  System Destroy Process 
+ * =====================================================================================
+ */
+void Initfacade::Standard_ET_System_Destroy()
+{
+	      /* Save par.nam */
+	gp->Save_Global_Variables(PAR_FILE_PATH);
+	      /* Save par.nam */
+	gp->bTickStop = true;
+
+	lo->Release_Hardware();
+
+	mixm->Destroy_Object();
+
+	ft->Destroy_FreeType();
+
+	Graphic *g = Graphic::Instance(); 
+	g->Closegraph();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Standard_TCP_System_Init
+ *  Description:  Standard TCP System Init process 
+ * =====================================================================================
+ */
+bool Initfacade::Standard_TCP_System_Init()
+{
+	Graphic *g = Graphic::Instance(); 
+	if 	( g->Initgraph() == false ) 
+	{
+		perror("Error! Can't init the environment");
+		return false;
+	}
+
+	ft = FreeType::Instance();
+	if ( ft->Init_FreeType(*g,"/tmp/wqy-zenhei.ttc") == false )
+	{
+		perror("Error! Can't init the FreeType");
+		return false;
+	}
+
+	lo = Logic::Instance();
+	lo->Init_Hardware(*g);
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Standard_TCP_System_Destroy
+ *  Description:  Standard TCP system Destroy Process 
+ * =====================================================================================
+ */
+void Initfacade::Standard_TCP_System_Destroy()
+{
+	ft->Destroy_FreeType();
+	lo->Release_Hardware();
+
+	Graphic *g = Graphic::Instance(); 
+	g->Closegraph();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Create_Inside_Directories
+ *  Description:  Create the inside directories 
+ * =====================================================================================
+ */
+void Initfacade::Create_Inside_Directoies()
+{
+	if ( access(PBM_PATH,0) != 0 )
+		mkdir(PBM_PATH,0755);
+	if ( access(HELP_PATH,0) != 0 )
+		mkdir(HELP_PATH,0755);
+	if ( access(DATA_PATH,0) != 0 )
+		mkdir(DATA_PATH,0755);
+	if ( access(PARA_PATH,0) != 0 )
+		mkdir(PARA_PATH,0755);
+	if ( access(PIC_PATH,0) != 0 )
+		mkdir(PIC_PATH,0755);
+	if ( access(LOG_PATH,0) != 0 )
+		mkdir(LOG_PATH,0755);
+	if ( access(DB_PATH,0) != 0 )
+		mkdir(DB_PATH,0755);
+}
diff --git a/src/EVA11/base/Initfacade.h b/src/EVA11/base/Initfacade.h
new file mode 100644
index 0000000..306733e
--- /dev/null
+++ b/src/EVA11/base/Initfacade.h
@@ -0,0 +1,56 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Initfacade.h
+ *
+ *    Description:  Manage Init process
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月23日 14时49分43秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  INITFACADE_INC
+#define  INITFACADE_INC
+
+class Resource;
+class Logic;
+class Global;
+class Language;
+class Algorithm;
+class DataRepo;
+class MixingManage;
+class FreeType;
+
+class Initfacade
+{
+	public:
+		Initfacade ();
+		~Initfacade ();
+
+		bool Standard_ET_System_Init();
+		void Standard_ET_System_Destroy();
+
+		bool Standard_TCP_System_Init();
+		void Standard_TCP_System_Destroy();
+	protected:
+
+	private:
+		void Create_Inside_Directoies();
+	private:
+		Resource*			res;
+		Logic*				lo;
+		Global*				gp;
+		Language*			pl;
+		Algorithm*			alg;
+		DataRepo*			dpo;
+		FreeType*			ft;
+		MixingManage*			mixm;
+};
+#endif
diff --git a/src/EVA11/base/JPGS/backscreen.png b/src/EVA11/base/JPGS/backscreen.png
new file mode 100644
index 0000000000000000000000000000000000000000..3b59c08c5a15ee61e0f0ce38e1b29264916c0113
GIT binary patch
literal 4742
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
I>A5}qKdu`HlmGw#

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/colorspot.jpg b/src/EVA11/base/JPGS/colorspot.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..18881797dff9796b0ebf58be3dc719ee79c96558
GIT binary patch
literal 9817
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

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/czkscreen.jpg b/src/EVA11/base/JPGS/czkscreen.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..4ffb92c47d7e88e0b4a801b14ee4bc24af79514e
GIT binary patch
literal 10830
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
MUjP<&*Ym=E0doDMhX4Qo

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/dzkscreen.jpg b/src/EVA11/base/JPGS/dzkscreen.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..7942be71900a338cdf833e58ac206690dd379389
GIT binary patch
literal 12032
zcmbuF<x?Bn6Yqn&1b0htD8(TJibK%i!6mqBi<GudG!WdixVyK|77tbm#kIJ*7Fv3r
z-+giafxG9`&V2W?XU@#ovpaMCE&TfhAlFcZsRA%CFaYZREx^BJfYSfG|1bL=<o^rs
zzu<r006=_z86Xe~g9CsG#J~b#{2KtU0st78c>nG8{~10W0RRgd2bYit^M3+aasUQ4
z1{M|uE)EtZCeeQ~Yz#~+99%qnAO$5m6@Y-610+lX77<mTrPCu+<W%D3ky6t)G_v){
znENlB5d(mU^<Vb?hX>%`VqxRq|6jH=5P*q^iGhiYjfG8s^FPUdXlxuH1ui=Pk5ZV5
zLqU%kWGkZR(?la?=NA@U)O!vV^-XU6w*(-@`VS1m0s>wDdYlKXI(E!g;&5lQB}aFE
zd<ZZ%a?{Eg!)YJzX%=?f7Y(|QeDM;inEbs0_<iL|nLv+EwILsdQq!Vp9D_HWuUdYf
z$;kIR#ttc3^EFzHyH_>R_y_23ziDlYAoRp~t_QRB<0P4S^__6Y9B)34@4Xc6N0QyI
z-Ig<+IVG<{>V^;Q_#2F*ZsfMaH_MBWpUqkxmU5~`do;#yYwPN(S-E25-Hv`S;A7(3
zZqhlkN72z!c_fzl)~?*1KhvcsuJBn#b#%5q*H}V+>T#NhBVuF(#l<}T)_@Jo@YNBU
z=CbL-7xUH8x*TRAPCi3eM!&p7P=fU*vd8y)CAb?slmsnK%}LX1)Pd7Q;rZoABh-?e
zgD2;lisE|}pm|O9A%R<+dx7VztCVAk#@Dz>In50k`!EKEzU`I=;358_O0Q0)E8t?*
zUcncs(eHr%-rumBR%;nP&N)Hi8!K>Ei(I1{#v`RoDx)gGiXBV}(p7*-Psc>EA%5(&
zLbAOaQ*7wv@;7D$hs%I?&)&S<ZyT|1a{o%pVGfnL&Z2Wgyu_@hzuA|K)opJK_|Z2A
zdm-317y2lm<?Fh3nr_js^R5yyRJmJ%@C*D0h`SgKkd{(0+S@Ty<0kr5=e2I5l~xjv
z`by!w03oa_vkKBJRg5Cm<h4&RoEM0~C`yoa%n4#zD2}Y*FI?I<5(#3TCUDz~Jgsvf
zKpecVx`C#@x)@{x>T9CRJId)zrhheyeyYx9eD{L9Z8(~c?bRvIJjwE-g><NH=<$1r
zx2sC-!YH>)ww$3B$aJsI9<zy9;0Wf+Nm0!3-ZHaD8l`)uS@{ZMwR7hfFeA*4C$<?s
zPsTQy)i3_!CtY>(w6;Qb=g&M%*^!Hyqrf9fnnKpjjN|H6vA%k{vg#&@TIXSpA$ikd
z3JQC73`)COIe(<M@kOQQv7}91aQ$A}Un4r?`h)Kb8R;PkdXd)fXjRpBv6r@2RbB9N
z@pJx4KOtDAY(-4H88(xAG*r|Sci9FEHcu}x8k^oWQZX{zS5a0|t+(y{?ePBKG5m&h
zOjoKz5XYkM<@RM;grB&hC_^@uU2FSP4ST}O6!hS`1KCiJQT0+z$jffdUlCtM$E;d`
zV~oiIA}rW%y4!(iL+U!}@_<(%KW<8AmZ6oJC!c>J(*4EmO-rnn4+e2w4sX-*+;OgN
zew5$f%F6b>SE};Jn@o_#ezuC4qh!`wO9Z$nVVI#8cRW~-J;g!Vr3DRkzJgbUBiMD_
zaU_aNA>Ktv@p5x!fXP8sR#p@yBF6pMeWePPEk9{oHrIiq`KQt8S5N7mbLW4NpVaQR
zWuv(|4)H4;V$+Rv1vW#1w44<px?(o*-&sueFs}IJ)ook8J$`L-i9T9+`o)AS<Ku6e
zd}(o7-foDp*cqk%@046?^5%-gA$hfS{JG*^B8&3-ehlwAwL#N8#{AcYEi<uPU%iV*
zN^!qYoOh}t2`NZXJUyINu=>dw8_TK3ENc#m9`3g~HQW;t8X)kMbeTo%n%4EiB$>p9
z(mgTIB8#PV_y_S_EVnaMWp&??y5W_H$7LSW#Q1Dz5!V$mMIP58XMV>wq^NvDvxpLu
z<(Zu!KXs#*?btGY%%X^Cj7&+rBB8rv{<xZ?pa2g8Cj$%ZI1z?MT%L$t@1M2Y_zD-5
z#qSmCzBh?TnXR$;h>(qz@_bn-IqFdO{Aj0ATfOpjOHi=37Neo2u5K<=U9Ruj&w~5^
z3TwoOBe*}FOC66&c;OPpeiDxFkREJSWpVWEem&myCsuWC19C{}*@sVQmI|}mY1#Vw
z%{8%&_OJG<l?HgX<Sj<`lIUK_&mKpz5@teE4+yZmVP3VM``Bx%4(l6jllWSaXTJx7
zC4s3HLfDW!b_k%6WTv#mjwx;9Vk*yrsuT3a|C#$08nK^+;1Hpn@?zv%*RZQS_@Y%Z
zZ1l|S>$R5VKR|orKfqp3ME<c8q_84~(kW$MTS{;y(5ptJDv<%VP~XFe#>Qj2F+o6n
zMQ)UcZUIWD)!Zp<L8PW+{-ZIVBYXT|^~<-Z!R%V|7K(1Y1>1qt%B8P>z8I;dG#>|D
z!OsXLXEvBRM^GS=&Qu`Lx0#nI>kVV;YN@6`(`mG~-Wb!HL2&RvrB(=2bF(C$Y__i8
zVXT8)g8@))f356PxS<mI;lTNWrjq#F`HHfiafqDFji*L84LxDM*o?roc1ZFdyNUQ7
zOIi`8To{<NC3qHjHP4Zz7+4^r&nLc>@j@@q4>d)d{3FRIEgT=uCgqJsZ_Q#t*-^F`
z-1AzqbI9E#ZkBMxd#p}$u=RXSFXM!fEh_QlA4pE^f<w08Zo-f111BG&e*n^i@j!iN
zBO)SQf6*UiK!<|&eRlmd$2E8qsW^WB05sjwPVMCq)Zy>+>GUPUsNK|4{MK$i5RYo^
zB&l93o>m_^);R-2T+2%iNsBE^+-Pc>Ti9lpas?+o*3=~u{NRS^;VOA*&xq?&!47R^
z`Cfi+Jcg%0MR{-`6zxrR^&Y8KofF6fqfE2GCR=b_$mmJ2sYx|*mSw=u?m=JAq;;<=
z*m9Bxc~dS^4S5H>55BvS#^;%-qOj7WEivb;DH&l;kl{3p&Az*$c}Aa|`!)XZ(!9?8
z8)tz73WRCpn_#XCP69u$&fH<&oo%>w^tQ4Q1@}Jx^Yg;?r<t7wfAO%3n?iQ91L|W(
zgOVJXT2gcfdE-b@q`0#OMe`S1R_cqgO65!zbRD;2&SCMcKEoTax%4~AXdUs${A|!H
zEy1=bIVhr8SELUbH(J9US$Qy$gHfF0ytS-&S#h!0^xNs{eHh0zKY5F6wtq2>VE-m(
zavBAiQ5n<l)xxn8_8bHKc)`a%1BCQ>k8EpQqO9$YfAN-ED9)gei#yck8b%etQOCX4
zR7>YJCw-S3afW_ywDeWaq@Qwv;{)8Nv6{l15S3^xuk5Ab-v_~L!^5)|f^?UTH%TfT
zW^nX#nkJjb{FJtHHy{!?(aGWrCYP+-k4a}Bu=1|ad0-eiWA!@=mOV-J&P5sfkIuM<
zGW@L4dgEFNMK<`yl=4XjxpCY14)L>0ZRuz>5XttF@G0Xzzx)F)9uq*b)9I<9-OBUA
z@l)_O!|B)&r8z;?Og?S($)~Cu9m}OhRl&&}Rcv1B0K;1=tQafS#?UXJ$4!g+a+Z)W
zKI0TR6*xG;q;^`Msi8^+9xlCRV2{(pvSir@3Y_JD&u+cC(Tb}*8LqCZ_iSir$@y08
z_n}EWda%$+OIYG%p0>Q*%%p=cPj57{>}LWA8PoJ5L4T!r5F>PIXGtmDB?uB{g6Y73
zR^lulH{}^L+**zOm5MzA%1$YE5-G_AlbP@{A!q$EB>Bzq>fSn(F0QVnt;<11r_~va
zzNK(b%Jp)^f3m$e&S9q!0eyy-Uc*ErsQuRd0U~elP-sDa{DCp8>v@48(dyjX;4BV;
zuvL?{N?b!;@j;ncvt`VN<g-7r9UL_#9qfrIU;zCA0o}AMD<1L`^(VbK=Q3PN$U|~-
z4g1*u^;R1=iWq<H=8FtAaI-E(S&&in`^~PdF##QqZypjNr7xdC58U*!(Fl(H?F*8?
zs_e{Q)H6x2UkE5yS25PRk8lY?SJm*3H$Wmr6OKNnv~aY)ZybwSBAtdEl!q&9yOpG;
zG+lrXryd0!THYQPUeezkILXPHFmZsO*TvOcBa_5BWrfo4cjaa-;|77PGgd+Qaie#Q
zg}mRYrek_E_x`j&lHolAwiYiO3N^e|Q=dZQ{tE0(mTg6<I3<)B8g~V59Q=GGd(P;H
zXlI1J{y0Fgk8v!wJa@M~X#MxE+<L{I7uKPnP}<xkOj?BwP26<Q(nO83bEI<k`318e
zXKA?lU2vp(Qsy#yt)E<}7lY#%rCz^O^7JF=3s!K|SPrJL?-zBFdOsL>qkvLY&a#5l
zCVPg)BR+*=A{ga9MZ-&d`<&2Rh72qz<y~y*u^OoY`X=MN#71y@<Ti_&Q$Cgg@^Ubl
zi4?V!64xaGJ1>JAA}^J%{{eJu!#7WdwY|!(&&j!z1$6y(Wbp~qa&`%L$jK|-v=gd(
zGaGK;K4V-^r)MRez-&S?m>cL-3Q&G0ycmP-Q|6&e)m^}G@3*bm^YHtg2c&RJwAopG
zGQdha%%%3;FsnBa5`^mTO%4oOrO{VmC+UZu4X`Rgx}pQ^Q&!qRu9wr@?6DcnTgvNN
zjCeOh7|JOo9DDaB(7u7Ii>5z5hep)WCft1M&D<F`{Gl;lgb!C)i_u;UqOL!R$7xv*
z!u}1pWyvn(x#rjl)uYWd31I)*_N#@ojD}NfHsBCuS81+@xCs(|FjQ(gk`^mygRy%b
zHsY;ShiuG2*ZvaS^hsx%u*a%|9XY(OP=+U==d!W&2RX#z#;!vI-hMFT2?)3vLu4X;
zeuB3gbG+n^*OnYwTU5;#Vq#qBtpgxoA2$Z7n<o5AhKX{a?d(nG1_}@u@lWLo7$pdt
zoVAUU{`tdjO4A+440J5$6T~D~Uo^DKYd*MMqA_9ae=7e&7bjWPLjmf`;~-%77W}87
zj0aB5P4jc*tCn?ov8cdYbXRAT|DGDB)r%jy@3eg-My}q<ydK|$sEJdX_9u7OhH502
zn~lZT%%tKZ*}gIbf84&@Nfi0=kWt@rvt#HaNlhZpYMKNeex8zmzpe=1^u7dtN0gy1
zT7y>%w3=5uZ#CV_!nS}}Lk3m_AGn9Sh||WpIhGRYF%B!on_77Xmf*2OY2HrmK&{fW
z{fPJB*$iEaS_t4F($G*yFG%M~Pwz!FJ)i%@f#nrPjkIqK<&Lk<*i@A}fK#zq6qAaX
zitnAvd&tYz$7=Iu%d2iHA)#OUJJ;?Wy#BniCUrY~AoRPP1&E)M`$TyX=|>X7Z4cSP
zxqtq}PoT4nO-P>1Ftti<LhV@eKz;Z8+osPA)ce`0NFU|dM|FzOd|vLbj)wG7ct6ls
zG|U)5(g2~Rnv;rg0#0eMC(Xqigawm{?#aszhR9DydKLc;c*~n=U<dfc@VRgu=o*lp
zMXR@xAM4C>eNvP21-VNrkB)53>jE?Bt8qZ~h&6LI>GoQ_+&L|6{+60Cl{jg=%oXMU
zGRdmUy#vz&lUl#^5RU@0ga%06ofhUl4#1ek2)J;Q(Zge8(B56ij8Mc3Ga_}u_F~Gk
z%-#_0=pOZqhKuk=FJG&~9%`nx3D}%xirdRpNJwuH&~-K@rcQ5(Ak<1GTSQTX*DD;W
zed+n~_m3D|fN`VK{p=L{H<kE2{TEq;g+Q`!5>jxm(S#bIvYbF=?^(yetLU2`qs}0n
zK{wUZL(eivl=)a5V9nY~IC*sQfqJy~oA9H+5go(m?fz0nd#SXDQ4UoiE`{l!a9>?o
zzmg4+hh_@QQG|jdYcLT}VCgTZcRc~klScX&Wvq6VN2-iw5OFA09-Ec6sD6}Y;}_|$
z3k+NDCFW$LF3!^k(?pl~k1k`#JPmz2yT1Dib;0R=m5k^X+%Oc5IVf7?+C1h<QOLPX
zhJH%T?6;xPuL;zTkC$H)(An#Gt}eio3Vo@=(Nylk$I~qf(W`sOu4BE9FzO*9^sPKK
zpPD}F(AD4w<hrYz(LOxAImvJ8`JB5VlM|C#8gG2~*1mGv-@6NF5MgNedTf+Gy)wZ#
z@dc24NZJFBs%s0uur-+0NW@tMGMkm2AoUpu4h&8!R&^hnDWg!Dty~MQuVZ?iZsmNT
zJgE8sL}jJy%U1?ZQ0wH|?ii=L@Z7<vEHN#oKK@q2Fvg(?HuzSitjQkhkj@qMn&CNW
zGx&(gY06pBR;%|$>P-k^A@!&aL9?r`SKsGw1$R~*k6@I6hmJd$Zge5WCIimTwS|o5
z+)=hU_qtx8N6fqZoP9?GhTO1cG!hHB@V=5s(D8R8gALm%qJIGFwj(B8u4gQ@2&rJ@
z8I{P3Va?)9x|yK#0PQt#72EiwA$MALP63qo2V&xu;ElAMl&%b6@t-lnz19>kjEMNT
zrc#K?P)muh{bvtm|2yL_y*zjK<`%!h<2at_T-o?Yz+r5Gzyz1LUr}&PmJ(V=MmEcq
zMX+mZL|s20P)D8F^yTFkQ&iwL;{+Y@1*G#Z&uZ5gaSaF7;HdP-bm#RxL(j`qSX>V5
zDo8*Xo__NSZGbjTBy!kEA+VJYvO7ZviVnVN<s}h_B&as?cRBoH5kDq^1u88nEgcjP
zKEJp;n}`y15Br3gT2qLVpTc&&A0$pv72PiryrdN`-PUyBR*FiXa<7^$$}fL1pY+u+
z_|d-s{BLYuyx9AccU>XN6d>eM#XK>KktB^{2p7v35G{Z9B@pcp<1-A_&9GM=f|HSQ
zUGAkon&H`0(;0M0BGQg60$RtSSL9E}1;Ma?fWGf~FNB8AXRV><w}I!UDHrLsWhVnk
zqrD$^!NS<W3yU&%oowNyD2iBF7q{kzFhX?qW`+ceBRzyvZ!|I)nLIdeyXB2Y*H?DH
zwc6*Y6LeVqT$4mF;`vidyv7pzJ`o`#c3VY(&081d?wB8(jh~(%aKI8%DakW<tM1J}
zyM5=gS@!9TlNb%!x=+#pxv>#R=R%f8Igmn~d`jcX-b|`c8WW?+biXtv`7xlSlCc?u
zG+veKh7C<$i@zy-GTESU>+>P}y#s`v=T!%7r7JwO@S*uUN_avlw9dIRd^ThWAozKF
z>i2mINCu-wTlJ~&4D9zsQ#}YR=!DzCGqc;hk0Vy_X=BvV=XAa)4FcZDr)|GJ-4U=5
zMa_VQw5Lk9=yka{M%*aE!=dTcT_0u_CuA%E+x)74)?_6nn(2r`4}CPPNN#xL!ndY=
zJdYG+7|@Q-L1o{kDoD+qpk4R}2T!Yt8c3^&a7{W>v+eOgq=9(2Qdc7(u;;he4RpL-
zeT<wZCYdCk%(G1Oe|>|b^V&>$`_+L1d2q(lG8ew9n65BY$Mt?;_I}>dUaax$vmn4h
zuuUL)TGgILvFT;vv%EadME&PshyRr?Q3NGxN6!dWQ~AiU5%*yD&}dCpDVJ)Tx{fB`
zLo$1`@=V>cdfG)REw9Gj+Sh3k!?WcABs4G7Tq*3;48jS{7o$_gL+czm?@}4cY5Lf~
zynC44rdX9UjTep-?U))OrYR6xuX0s}6|RIdLC6SYR-j31^^t545G=ug4<w;i4EDut
z!<rBorb?VE2>u69_Vf?<Gd2<5HPeNELHQFsYf;&f*{6PeZ09F-I$>ewCHuiqZ&vEc
zMbJp%xwP5+_?vlOs_OZ-(m&7i@F04=s9)Aq_org2SNJQ{Blm)kV4&&fO`GXtx?R`G
zmh@X2QWaeTJ?*%~m$51roHSU+N2eP$w>a_oQ4~sXdX$uAA@u@IK@m$|ToV1*oe>z=
zJ{2CZUmA_h24{b>Fiz|0{{_x=zcqbf@<IsztHV}R59yn%Vkh?kg2=Z>zkb+xK{+e`
zZ?EPW^I>REi1cNG>OmM_YTjqqT);oHV>RZXu;PMynDkvkhmH6R>)86x#rlEFX?gr9
zZ5ON3*Q$AIA(y70Kis8q5VIlfgM-(slO`sS!ClL=+jQTl>u?!VOFcUDum$3(ny&I~
z{X$^UH&Q!6i-HbYvEQ0ws=l*mn(-l#^FYrzb?wG*1t+PxM%rb?^?<c1SDGY``#*^~
zqVZ!CEsb;92Bi{OYLH3q%5hvRkUZJ;ysb0~pY5fJRJ=3VNBNtKg|55(n-R&D5!>9z
zl{rh4QqtIGtq#@<x2l8bgk|r?$fzY6Wf0mS7ADt-&$gir_KHpEjzID(Y~tsD;hU*^
zhpZC8PGwgTji!WM*{8Ex;5v;u?s}TO*exQ?c$5=Zjn9{*AdFMN!|R(&Hst06O4=fZ
ztklKUf!OPdnHh06-OhV?{zWhTI8Mq-^kVpw`b*j>pG2wRQz~j!-;tQJJ<?#tX0PAU
zjd9#Ra-7{;8kC^O%@^>7?2Hz=I_Mta>iG8Hjy7X)q#~QE({(mo@Mb`&t~AVT=o6e!
zzT8yJoY%Jfr-A#SZuIUAsJXB8;c_9~g@YWLh?+W)AQ~4SgDc7A*_-m{=hav_^qAr2
zeg2q4MQ+|)+YQ6>tfd1ED^vQ>Cxy@Wwkpa~f3xL?l;M-@YzY^W`y}%aIJ+Kvz<O8p
z`N`t?^_^sAf<YN_ouM$>r?2be>h?)`=dGcUvKrAvDKq7p>5J*LAp1~@*V(r!siPNr
z!%qjdJE2JCqtB>A&)*ah4UD-fx)V2$^cPi&g*-h%${RqFLi{}L@$LX$p{9QT@QMN}
z{v3a@%nIM@>^>oi&@QXA9fLo9GcjM5Jl-9izw@L02O#>D7*{7aK7$iyN4dI^V0bEg
zp}1W@w@Vz0=a+7AUy}a=tS={*O+yP~kTwO!TfeS#H`(bGxct5Wi&sbcdta(=ihm$f
zS{ae?^4}aJu1}}dcapU~G<vPSn0I|Vd~G^x*!}j7;Ia?7y{kiQ(pOz^H5{P>^ku|t
zMIW7fjLld7=2p95Jh?*EJM3;Zy5`{9?FJ~aPlokd^hHa(R$M4z@O=^~)@i-~pv$?u
zaYwMlY;*Tzq!^Fk)sN{c1jFKSbc<EN)6f7e^B;2}tlA*H3yTz~*q<ZqwWm}x>iRCN
zAXt_uCZ}S4S&RZX#S7&oZASPaC^<#Ba#zUj&kaXKK{;O=x^j=ZEwmKl6NW(Kq0QVg
z_Q|m1ff@Y!&(1d5UOvnVu2A0yUvY$j77`}}O&6hQ=%wPmqQrW_(Llg=nU6M@q!3En
zyVtRNg6Ihe_pruiC4|K-^whzFVAP-+dGjLm_53#z2UsTO+t#ClTM0&MrA($^mOmL1
z^Jn}W<YZ6Jlt>;)<=;->@=Y8L%Bq2jkmk>i3xsv8MEN@zPmWBG>P#3F2rRk3R6H7<
zBOEs}{)hgBx0*lJq})t)?^P;ZysjXa)Gg%itG?I(s-&xj+7itC19Wx&N#^s8FC2T@
zpwXb4aeg-2CvMVLrTv+kgR(=%&hDzUhve}N`mXncGHv7FZm$qpA*k}`hi=__@~*e_
zf)-SNwJroE)vG+@TlkDw&J-|CnpF^PCp6pyepw;AxP$xyylX&WExg0{(+v#VM7+1j
zvN4q{O5d``v{$i9U=Dd=Ojh)BB3)^j;BpSDZmQwq%cWa4Kro%FE+QG=IQF`_Eg41c
z3mtr3YO5r5>4^onNjuxFy;seF%~T{cAo=ZwZ8^f9*KSdn<}jyWjj^+Rs(xN(v7W>w
z6GO%p&>n!hd2?Ckay}_)%kdR7?zRe5Q4zz#)JnzGEGVMKBA{?C=8)cu;!+ZMIF5g0
zuJy&kzs+*+QD1tWWl}6er(aOt%s@K{o?g-i`=ER+rfGa;$mc1PCuo_TsRF`Ve=M7O
zp$7$*Sz6aBsO#&XkwzTy(N_-e!-X4TdwlFMKHqfJjg;?*OE^8`Ee69%(NC#&{TJ(a
zhhtd<P&sMtoQW|KTXDsROwp`YC0ug-3!(_eGHGNSI;U9aaOij8<aXyyvj5Y}f325a
z*^7cQ>%AKezR$73rLxUZ{)Nr|UH*5!W8UeC_)Q)>25neA%~&~=WX=)BQtGWIZH%lR
zslcNSwhsBbbeUy&zSivQP<O*(50<%O5PvhOFV-##%2|Mc$!~nOAMbZiIzi{VUaPD-
zPlzGbv%3e@iuEV2g9a}$y+#6?LXUMq2E&|DZLe83{F<dYgED{xk-RDx9f`;nD<Osz
ze^Z`nI}TTja<3jN5c5O+ctJ#6Qm#@#dwc3AcRrHj#-CIuA>ZLZHJ0^=)6b+QlA_=y
zOXkw|Nnuqc`bMOC5G!<f@MT=bkMfcJMj;mMZ>}k3kviANff!nCF_mO7$?x#S)+qA*
zve>Kf{bFC~%WoEz3g5S`Zy%^QJry$+zS|-k#O|}{HoFLL@Df@Dd=@`CDa+~D%cYzT
z+3S?$<FobRra5J@>A<t`D1*8ergm`=bKzs!eM!k*B=Ae@c;rX*X@?dZn54MI>&<ku
zFF`nlZzjv`({{pkhS-82VM}1PNMX5l8Pe^`N0NgVuxkD*v+)SC<|cQI`gP`3c8{HW
zj#`SQ*_P!=;R;=u9T*|gG|q<^Ef{H@w^Ed%J(EhJgV>k{OS2?>G~UqJegkrruwo2n
zB8)q}(`PONYeegQt%3POf%9Xmxmf9cy`JCUPKwAcD(74G%ZRNg84-3Qdi9>Z!;`>d
zw_Yk@OR<9lprFrq7f}Dm{r);aLMrNvkFts?;o$fMZ$SOu&wrtA20ccZk3U!Mv?}AD
zcJIjgjU6SQuC89llD>|7Jg<)FuI4wQ)(efi75FQ11qt9c?|aDbjazf#AN@L9$k$x~
zExxRpY?A4*ce<<jd}GqX{CC2Wof?=|k*_oUG@8<8a=$|jgf{SOtNiaVvZUmIaT5;x
zHz7zXpNU3pa4B0e36VY-0inNjsv7=Uk)7H-yt93`cd(H=Tp_Sp9%{c=t@BQp73#0j
zA9S=6sEd!Rj=fdZg|6~XvS9`JmGCIq#UuKIguyB(4#~Re?w;BlX*~k+G}IYgyP`R8
z(v`oCRQ*x-^0(Acy1_xkdigVhyUxe+ykfuM^c^6O>w5UmZWBiRHk^BUD@|3Hax&B+
zuZ^Lb<KAck%Hap%>*VXVK>=GHUZ1Rx`ztW_PGPfBD2XL$q$&@B<4?>Lq8Fl!ahT~S
z>Jw@cB9mv+vlx#mCqO-d;7f~``<(lv*KN0;w#m4xiFza~CLFHE$kd{k61C_5N+UVZ
ztD`?hB|uADmy1&@HSLjS!B9lXfq_1%fx^_BKe=>Z+TDo@Ki!;Bn?AJ%=AJ~7DBR>f
z*1v6Cp7$4gal`QsKpAvdUGOGQ<>`&J@VMQTaC^;=4<sZnlcPgKuiAP4aHO@pnUn1d
z0&wg1AE4w@A}TXhqAZAaPq5CA3oWwk4Vn;%DO!pDjvWl|_0&hhxvBoP+f-ulc)TxV
z)b(txJ;O1uGEGh{+$8EH_9}Vaz&OAamxCMayHtn@;zGr>L@OG+(v+-TZlJjM2Qcg*
z-aBgRuILjC)Sb&a&xZ|P%nm=MCc7BFGgh0^krquHSLqW{Uge9OsncQZPd1x5IKSmL
z0-~+Y5VT+WMMCigFCR2(5#X|=f~Z(8g-~N{qd{9Yn5_uP*1}gF?pNxo{4{eRqLU3A
zoza1O*irv$%RkS}f7JEx&K|y}#@7&P(Jh&NS-<l}+9I#|zVz^hEk(jaEd~N1KO9{b
zX>L9iX=Dp0&2mO1JmFPg^D^Il43|NX%YAL|+S=moO#W#X7$2XTi6W_UPta$mo>%ff
zI5u`<a%;IT59ovFdY)yNQjhLcw?l)m$S}Q$$y+0mQ@f~81=JfS;KI3C-)8t4a#wvs
z?>K`SBF(U0INkd9PVVdUr=UDB90})QV{T<XAki{^PW~FCOdaGlYf!-9+L4$|V^~Ed
zzpk%CLCX;eehf~bEue8w{s-9T=7!$yWkTR3go%uR-qQRmV56~%l@1uVzT;gAEGd>r
z#P(PdHIJJ0J%?G<^U<x6Re=2vJ~M{|2z!s3;Pf8D0QNBUFUAYhmIl1u(hgo4m9D$(
z&dD|7h#L-J+KR}%>l$j>NHtJ;{cSSC<PSAb-=4IsD_{fBA;*rM(NW)d!{w}sVQ>Xs
zqM`qQ`d^#T#AJ(t=!lbQzX7G|-)8~ba)BEL5y}Uu#l;fJFk1HlR&FA!pa<B7tQJ#f
zxw19SI?-s5^__Ul3HNE@<v)P%ub{uW%ln~sPyYZ1H|MtnXEK-y%lp&lX*@bh|5-+!
zh9VE`JUer|2#*T|%-}dIn;>;VeH~4hy-Flme;)5tn+848cEsVXlN<jr*Z47Ek~1S!
zL~lhPf=+<2k1eiHePM&KtdwGEM|BwNm15F&J2sXiy--kiBoT3d%SLMY!6C;fcg0O7
zD8(*dDK>6#bHHq?OBJgmjk*he!#W-`K6K*5viXJ4*_@4111G|V{2(GfS?cdAm--v(
zIm{1oK%y4h&EL>+EzQx^297kd4^2TEa_HYrOcs<|9*XQauwVFH+#sH7BW}HnQ~oQ@
zoxq1jQAPxx&S+ZD_(}F2?>!wo5i&c+8?!q?vk!a5l{v1<kykp}dccW^YG0|Hr3?H3
zD-P6Uc*U)xA@lld-FdaVXvb8gO*-S%D``}t>2nk60E(@wdLhnwc`Ud7_jne_`!q)Z
zyI7(y_-<H>ra&X^vJAa?fo%Ht<nuX7-9eu^)mL2JqDR!EO0sp#C?Ch<G%bsEO7L-I
zS71JYb;>7Rs|QE*si;yGyV(*GfvMy99l=g;QPxI66&~Xc-(QP5I@;cEef&6mzPuD8
zgnU3BGm}t!Yjm!4!7S91cqc}o5vrVm4ha=|+jF;}UUA2MB4br2$=hY=I(Fp~DknqJ
z?PzDy$Y^Hx`&BVP-XY6JHRCa8!MUk(fqEh<Rh5mx;+*&h#@y?~9O)=c5g|X5&kS*l
zgCct7pO&AC5`VwLiGdN6*L*7NC>j=lrX>!vI%+*y_%x}hS&8S-hR-p-eC(V_E))#1
zlkMwSFkSNrN%HjOA0OlIBBpN~eIC(<t~*vG%@A$FS3ksg-_I2j+&PG3&$gzd1F0oQ
znG>oGwK46oVPv^QWU+H9*~)6eaHEt3)$x~p&y@Pn&ItU1vrvr*nW5Q-h@UE9*@^q{
z0abFi9o5qsPgyGkMLO~nv^#nOF8)0|H(&iW5{%?(aO~pHfRZm!Ng)MK+l9oNUJr<N
zX@!t#PWw;kRmnD;T-=HF@~S{!Tr#+2FnuC<%<Z*9l0*`k+k>3^hjF5=Hk(LmN1>1F
z5&Liz4X^C@+hfi9>+Vmz9lly-N$vabQIk3v{1h4jxwu2jT<Rom9o;XK4Z9|6`zHuB
zG0Er<^v~yltVl_9p3;Im4LvtsQ|dcvC(#;O#qalJ!nG&TZgvD?bEa{^lbA}oU1ol%
zF^ST^S4v~CL6h^uS_s4aLq0ez3zq9q4hfE7(G>QNDCe|dYTA0RS#k<Es@0B!Sd{y{
zgc4O5zA%OOPX)?Fw3ThZdKUca^WgeO($*2fL8YW2rMRK_3MAZTcISZRv)J3#R>wAv
zZS+N_LynDM)qA1h<FaCuhOb@?XwD?L<W+`h&}$G8JH`+1N=y%b+MBzxEhCSukc``w
zwuyIx*HMw##;;8({X2W%Gq;O^<)R*1q3Kor!wLZ|IH)#{8MTF0?m00Ai=gYRUZ{$0
z(wGZnwTtjSK)_JCvs{o$uF>YN5wB=N_-?FlPG&0nJyB7Sh=~#0AXUlQ*5=K3m$t-u
z3W9>ZaEK=-6Nha6vIS5SwS1)9Rm^40#ToC+vDxfEa36L*nr&W?W43kHe&boLA5X47
zVzxu?1h(DFtcD{(oNb3IvAMq3Iv)&W@NN}ItJM<HgYq*~7eyT9q!@NJmMKPMo5l4`
z#8L>=z*jI(Edug&oWB$5YX9(k@b|M{-e*3`KxCAR;A?85lWZGxVtaT{sf(eDu7r`1
zCC+3^iY|*e$ci9`VT>34k+8mLNKYa%kH#AY&XAb`eajDjZ1JaD^PE7e7Ho`<yNvzp
z#=|J98)yx0om*W<OhDz&=NuG@ABfKl!Ik2}1RX-32_`<k#zY9L?FJZBxwY>EA3HQW
zbKyo?kHeqpXQ4;|{o<jvg_bN9WkdMP&QEF!qsI19Q<LZv^54a^fL@ebS?m2qM@A4X
zKh9Xev3If0U+dKbRz>COtTejv@Ig{RJ%RMjZDHz!-Qjd5!!QT~dJBByW`K{tQ60C;
z52FB;i)Es>&avtK0m$4jNw8cKLd)!wu=UCUa?JEHGT1<LGsN3`#ifPDFWeLLOe`h+
zI?2DsDsj#~+1s{s_%z<MT_n_*W6{W=EM9Ts2fx&urWSy@QsgzO>&XAH=1Mo@mvvB}
zS4C}+=+}0}`;B43M2%OPQx5Izb7P>uS@K{THX{Iu@7;nxy6sa|T?S(QQx#{uSMBTj
z0#2k|HjSiGlo8x?Z;#24-r$*Ac?$m+y9lp4VI_g^KHtT0Q2JDgqGgsn@Qntx^xEb>
zz$@b0C2Lijxg&v*S+aqV#7Uet0Y#)V68jaQRaf>f6&XHHHeSbK=@05hra0{YIwwgc
z^l*95F{S9Z&}-Sx<8ROSN1pN64YmIRSW<J=os>l?8{N`*D(d}GGcz^7{WbyKf(aP+
zB~eO8YKyY6Q*>?nP6$MhKvU4ahd4HE%R^QU)Uu8O$0guk-<r*|zMZt<Qq+VGHVk~l
zzY~&IQ?u)o+qRv!^=5R;+(kGm_NB>y{|#M+IWw#N)(9W5M|Acw2x5^`+l03z05#$w
z0s5&iC~T?F>PyMwyaK<`RK@+Pf~A)LviVEqD|6`fnbr4p{&u5tiJ9SJBF}e>30k^n
zN|EmmPvJuezDl*o-bMBRKYQ;rVr^6&1(~3utkOB*=%z!X`P~8}*#2I~Z#TBkP<!w#
zn<;hEmYzMB;zV;iTF(ZVw=Cm&Rm@Fk-_|~paifYD#x%F%6Nv^_6~9-|)?14+Q>J~{
zq1Q>X*H4xw$r7h(`_a>yIEdeQqqXmNrv;h+EXUPY1;N9v?r#ewd8U99L;#A8HPy35
zZ8d5A=J;5K`rB-G<nU79opaY1wDKVrQ^-BFG-;ZCQfm->30BkElMQ(D!t^(ai=Xrk
zvbLHlYIB}Z(b!pQ`OYkaF2`U3q?{ze4-;zuU2GCbjsn$K>7yLY$#*Wv=ktpin6{M&
ztDnaLEZJV;EUP)CvRK~qygFYn9Wu{9W#yU{_7tL`fdX3}sR^6QNTK9-eC2Hs+jqtv
zcA~eZW5p=sG9ZKk@^4;6!FUO2K}--oUg$PsK=&|cY`b}ej&5A)jj9_hTHL#qeepZ%
z{SXS^v-DQ9b_2@h3&0DI5hP9<cmE9oK)wrr1pT)t2OZ{^T^cg!hj*~33N=k=aW!1`
zqEU6_?4BMuKZrLn7y|zLO*ba%mL-y<NiWSjVm4pAfy*2tFHPQ$-0~i<Gz=(Hp=P%C
zNwt7-&68pf+f*)whj;g5M3@49DAOy)qnEKSn{KYWGI|0{(N@D&ZQ=r&Fvm&lU%T0h
z=QCxmQedtyP)3dto4{VopH?DP>X&}t6m<quj^t5AqBgUg#J^CrFF(#cd#ztHF#NPI
z+yI1y8|)tVWi4(St1iN4OlB+(Zm6ySdSx-wD<hVOvPE8cCb2nxQ8UwpC`YMcq7Y48
zfHqfae9Dk)8p<3AsdErzsX?W;QmY|m)BSCPi+;|{t^HbHj$93-{!nU*OEM8zmOWQY
zhV2c{w)5c}78^|Z4O*7pZ*t6|1=<%E4Lwuj+h|IoLf?-j@_#Z4qh5kBbqRg}r(5#Q
jf1oS%N9sI_Ll3B{bHsa1De9!Fj&Q##x_u1%xA=bmiSlI?

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/eddysunlogo.png b/src/EVA11/base/JPGS/eddysunlogo.png
new file mode 100644
index 0000000000000000000000000000000000000000..10ba45dc48e6e92c4013c12197e414abcf256617
GIT binary patch
literal 2930
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

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/ozkscreen.jpg b/src/EVA11/base/JPGS/ozkscreen.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..79cc3a546d82106254c0bec7f3615f6257b9ab47
GIT binary patch
literal 11629
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

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/run.png b/src/EVA11/base/JPGS/run.png
new file mode 100644
index 0000000000000000000000000000000000000000..ea1f2565f526985b61af4fac6716f67416c31dcb
GIT binary patch
literal 1821
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
LNkvXXu0mjfF8F4C

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/splash.gif b/src/EVA11/base/JPGS/splash.gif
new file mode 100644
index 0000000000000000000000000000000000000000..d8a79b09a6196800de359a9e035fff7f467d748b
GIT binary patch
literal 159882
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
JAP~U%{{dF}FCzc|

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/startup.jpg b/src/EVA11/base/JPGS/startup.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..156492fb4b80505f55ddc6d0db14f1f2dc170e12
GIT binary patch
literal 20820
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
Kh-PaB>;Kt20n&N^

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/stop.png b/src/EVA11/base/JPGS/stop.png
new file mode 100644
index 0000000000000000000000000000000000000000..4127e8a1433c49722e31c96231dd05f5d67f5cb9
GIT binary patch
literal 1484
zcmV;-1vC1IP)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv00001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyz?
z1tKhBu1jP900m4*L_t(Y$BmY6Y*qCc$3M^cbN`+DkJ2?)ED$w?NC?GtCJhm$OQSJ1
z!kcN_$o9s>gc*1@ASKacWAd_bi_zc~Uu<Fw6Jki!K!DgNi!_z8I{(lPO6}l6+Y9aO
zz2}~D?|Js(*H)(1?Ma^GoRi=0`F@}0e1FgL6TW3ffM<X<;25-I!C@IwU>YhNaO*>0
z+xM)IJ710iI~JZVz@9ZdJuf(IZTW>*-vx*wY9D|6#b@Ww|N0R)`)}YhuyZ+pMf)eb
z*|vN4)6UMF7S6H>7?9ans=dAb`Hw#O&BO4A?_}^Y@EEWjcpp}-OQrt2wzv05dGt}G
zRufVEVF1fQQYj4&9+WSS9{ug7aPXH<I|XzD_Itn|fp?*!WA*B{R_)#UQ@gVh$>l`u
zz8i`~2m)v{pkDvRYc)tFk^AmLZ`=@j^Jel*O+RTK9&T%?*U$V4s{dFl(Ex03->~6u
zy0`a7;(4m;)*<WH3zh}5voJ7V0A!(}jRrI~Lsu6#4um0`JEz>bCDGNZOz+=6dahjF
zu^m2>v(UNufd>Y2d-tLuX5-eai0h)NhzL|FaOMom&l`Y30Umk?L{LCPi00>!4?ciK
zL#14n8!x^%GjjFn2FrKd&Rlyt1c6GmN;E!BZD4?Ut%iu8s*p;-wr${f(Ao-Hwt!_V
z1rKiCBs_T%Zr?^K6~S@TYiVgJLBWYsQ}{kqtD>sdfc4c^_)}Bp6HnlJo?)HIKzFw(
ziES@s=YRb*_Sv(zm5L$cILNE7iZwV$1Q{o?ETh9}6^SBKXWJ%GEaD$Oj@8qHoy!@v
z@%Vo!D43jt{(js>1C1h>nnK=q1Fl@b7Qt4{S~1lOK>*dNQAQ9TL4efjB(7hle(acG
z`z?7kN+tB@Q4*?Xv51^H1&0sA^fY)LmgC@xWE~q~M3D(@Szz0sirO|3ixKPY{$Bmt
z`8-Zn7kc0TGBpL|vf1l-5QZj$C`#GSiS(>ar@P2xAc~AP8b~?~J9Z#z))@98sP7||
z1tR8KYb#>gFg$EZyGU?B|6{e<hxRU!?W=Cyd{9S5kg+kibO~ZH*tHApxd&9u=D9gI
zbO^b889F+?ITM>U!CiO3(2yY~f-Vra;`@Jh)OBsrX~c0**F`pNguXtsP++M|gdzIU
zOUUFTIx%4c@%-~kGS$Z)NAA5B_Uu7RC3ALSF_@c6SXYAJ`X$RE@;sGflG^AfwV|OU
z=31%1zI{lk1T8H{p@0kzqp!STS_VK6FmvJr^)N&{k0_JT&wZcE<?^Kc2sBHj@>G~e
zNYkoSxXC1X`ZOAbh-D#teWn~MS3){%equ`tOit3cc#$xfr26{nq=$xZ@_8Dm6rYcd
z%D=|O7*p-DM`64TV%c(eOKE;yoA1A0+*}U1b`6Gyk!%+7dB|qXVN0jcWD;4i0;$*0
z!9n8nI=1H##^ZXSzn__j3HcNbz6^h{ry=Zzlba!ItyZ_*o}RXIn>OKOGRTS*Xf})F
zat0umgG>hTJV+#vSPVOrLR^<x6!FE8BQk&OT5t;XzW~3Rhq}F}>-S+`EquAAQrY5<
zjb-C)Z5nTHH!b^4FBD9PnwpjX=SD_!{I%C)x>%e%0nZ+SKP@-W<QMSZe%F0Fsk+w5
z=hYGsEXyck!F6GVsw$DHhBGrV8w3--ho8LzpWHcOWtl;>`a(YcxBT2(r$8i&2WufH
zCa?hjs{|K+Y{vQc4-S0*?dU*;h9Dkq{%cdy&mG%Nl1LzqV`S<3sPCKB;`@YQSlekX
mBSrq#tzsGbf7Yljv+zH4lRu;wRW!T+0000<MNUMnLSTYRzrMWy

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/video.jpg b/src/EVA11/base/JPGS/video.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..c0df1e3e6bdd670403df0911de7f48867de8627c
GIT binary patch
literal 8184
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
IQ+%BNUyxg6hyVZp

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JPGS/zkscreen.jpg b/src/EVA11/base/JPGS/zkscreen.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..2448cfc680a9f2f978295d0397c6c81d02c0c624
GIT binary patch
literal 10580
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
YJ}mTQZ$JuURmTeHaW1tIY4$YtKTBxi4FCWD

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/JpegOper.cpp b/src/EVA11/base/JpegOper.cpp
new file mode 100644
index 0000000..764a73f
--- /dev/null
+++ b/src/EVA11/base/JpegOper.cpp
@@ -0,0 +1,393 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  JpegOper.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年02月27日 15时06分24秒
+ *       Revision:  none
+ *       Compiler:  arm-g++
+ *
+ *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include	"JpegOper.h" 
+
+JpegOper::JpegOper()
+{
+	fb_ptr		= NULL;
+	Jpeg_buf	= NULL;
+	filePath	= NULL;
+	fb_bpp		= 0;
+	fb_width	= 0;
+	fb_height	= 0;
+}
+
+JpegOper::~JpegOper()
+{
+	if 	( filePath != NULL )
+	{
+		delete[] filePath;
+		filePath = NULL;
+	}
+	JpegDeleteJpegBuf();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegGetFrameBufferInfo
+ *  Description:  Confiurature screen infomation for screen shot 
+ * =====================================================================================
+ */
+void JpegOper::JpegGetFrameBufferInfo(unsigned char *ptr,int bpp,int width,int height)
+{
+	fb_ptr	  = ptr;
+	fb_bpp    = bpp;
+	fb_width  = width;
+	fb_height = height;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegCreateJpeg
+ *  Description:  Create the JPEG file from screen  
+ * =====================================================================================
+ */
+void JpegOper::JpegCreateJpeg(const char *filename,int quality)
+{
+	struct jpeg_compress_struct cinfo;
+	struct jpeg_error_mgr jerr;
+	FILE *outfile;
+	JSAMPROW row_pointer[1];
+	int row_stride;
+	uint16_t *ptr = (uint16_t *)fb_ptr;
+	uint8_t *imagebuf = new uint8_t [(fb_width<<1) + fb_width];
+
+	/* Step 1: allocate and initialize JPEG compression object */
+	cinfo.err = jpeg_std_error(&jerr);
+	jpeg_create_compress(&cinfo);
+
+	/* Step 2: specify data destination */
+	outfile = fopen(filename,"wb");
+	if( NULL == outfile )
+	{
+		fprintf(stderr,"can't open %s\n",filename);
+		exit(1);
+	}
+	jpeg_stdio_dest(&cinfo,outfile);
+
+	/* Step 3: set parameters for compression */
+	cinfo.image_width = fb_width;
+	cinfo.image_height = fb_height;
+	cinfo.input_components = 3;
+	cinfo.in_color_space = JCS_RGB;
+	jpeg_set_defaults(&cinfo);
+	jpeg_set_quality(&cinfo,quality,TRUE);
+
+	/* Step 4: Start compressor */
+	jpeg_start_compress(&cinfo,true);
+
+	/* Step 5: while() */
+	row_stride = fb_width * 3;
+	while(cinfo.next_scanline < cinfo.image_height)
+	{
+		ptr = (uint16_t *)&fb_ptr[cinfo.next_scanline*fb_width<<1];
+		for(int i=0;i<fb_width;i++)
+		{
+			imagebuf[3*i]	= (uint8_t)((ptr[i] & 0xF800)>>8);	//(value>>11)<<3
+			imagebuf[3*i+1]	= (uint8_t)((ptr[i] & 0x07E0)>>3);	//(value>>5)<<2
+			imagebuf[3*i+2]	= (uint8_t)((ptr[i] & 0x001F)<<3);	//value<<3
+		}
+		row_pointer[0] = imagebuf;
+		(void)jpeg_write_scanlines(&cinfo,row_pointer,1);
+	}
+
+	/* Step 6: Finish compression */
+	jpeg_finish_compress(&cinfo);
+	fclose(outfile);
+	delete []imagebuf;
+
+	/* Step 7: Release JPEG	compression object */
+	jpeg_destroy_compress(&cinfo);
+	sync();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegSetJpegPara
+ *  Description:  As the title showing 
+ * =====================================================================================
+ */
+void JpegOper::JpegSetJpegPara(const char *filename,int zoom,int narrow,J_COLOR_SPACE color_space)
+{
+	if(filePath != NULL)
+	{
+		delete[] filePath;
+		filePath = NULL;
+	}
+
+	filePath = new char[strlen(filename)+1];
+	strcpy(filePath,filename);
+
+	scale_num     = zoom;
+	scale_denom   = narrow;
+	j_color_space = color_space;
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegReadJpegFile2
+ *  Description:  Version2 of read jpeg file  
+ * =====================================================================================
+ */
+void JpegOper::JpegReadJpegFile2(unsigned long long offset)
+{
+	struct jpeg_decompress_struct cinfo;
+	struct my_error_mgr jerr;
+	/* More stuff */
+	FILE * infile;		/* source file */
+	JSAMPARRAY buffer;	/* Output row buffer */
+	int row_stride;		/* physical row width in output buffer */
+
+	if ((infile = fopen(filePath, "rb")) == NULL) {
+		printf("can't open %s\n", filePath);
+		exit(1);
+	}
+
+	fseek(infile,offset,SEEK_SET);
+
+	/* Step 1: allocate and initialize JPEG decompression object */
+	cinfo.err = jpeg_std_error(&jerr.pub);
+	jerr.pub.error_exit = my_error_exit;
+	if (setjmp(jerr.setjmp_buffer)) {
+		jpeg_destroy_decompress(&cinfo);
+		fclose(infile);
+		exit(1);
+	}
+	jpeg_create_decompress(&cinfo);
+
+	/* Step 2: specify data source (eg, a file) */
+	jpeg_stdio_src(&cinfo, infile);
+
+	/* Step 3: read file parameters with jpeg_read_header() */
+	(void) jpeg_read_header(&cinfo, TRUE);
+
+	/* Step 4: set parameters for decompression */
+	cinfo.scale_num = scale_num;
+	cinfo.scale_denom = scale_denom;
+	cinfo.out_color_space = j_color_space;
+
+
+	/* Step 5: Start decompressor */
+	(void) jpeg_start_decompress(&cinfo);
+	Jpeg_width = cinfo.output_width;
+	Jpeg_height = cinfo.output_height;
+	Jpeg_components = cinfo.output_components;
+	Jpeg_length = Jpeg_width * Jpeg_components;
+	
+	/* Make a one-row-high sample array that will go away when done with image */
+	buffer = (*cinfo.mem->alloc_sarray)
+		((j_common_ptr) &cinfo, JPOOL_IMAGE, Jpeg_length, 1);
+
+	JpegDeleteJpegBuf();
+	JpegNewJpegBuf();
+	
+	/* Step 6: while (scan lines remain to be read) */
+	while( cinfo.output_scanline < cinfo.output_height)
+	{
+		(void) jpeg_read_scanlines(&cinfo, buffer, 1);
+		/* Assume put_scanline_someplace wants a pointer and sample count. */
+		JpegCopyToJpegBuf(buffer[0],cinfo.output_scanline-1,Jpeg_length);
+	}
+	
+	/* Step 7: Finish decompression */
+	(void) jpeg_finish_decompress(&cinfo);
+
+	/* Step 8: Release JPEG decompression object */
+	jpeg_destroy_decompress(&cinfo);
+
+	fclose(infile);
+	return;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegReadJpeg
+ *  Description:  Show JPEG file on screen 
+ * =====================================================================================
+ */
+void JpegOper::JpegReadJpegFile()
+{
+	struct jpeg_decompress_struct cinfo;
+	struct my_error_mgr jerr;
+	/* More stuff */
+	FILE * infile;		/* source file */
+	JSAMPARRAY buffer;	/* Output row buffer */
+	int row_stride;		/* physical row width in output buffer */
+
+	if ((infile = fopen(filePath, "rb")) == NULL) 
+	{
+		printf("can't open %s\n", filePath);
+		exit(1);
+	}
+	/* Step 1: allocate and initialize JPEG decompression object */
+	cinfo.err = jpeg_std_error(&jerr.pub);
+	jerr.pub.error_exit = my_error_exit;
+	if (setjmp(jerr.setjmp_buffer)) 
+	{
+		jpeg_destroy_decompress(&cinfo);
+		fclose(infile);
+		exit(1);
+	}
+	jpeg_create_decompress(&cinfo);
+
+	/* Step 2: specify data source (eg, a file) */
+	jpeg_stdio_src(&cinfo, infile);
+
+	/* Step 3: read file parameters with jpeg_read_header() */
+	(void) jpeg_read_header(&cinfo, TRUE);
+
+	/* Step 4: set parameters for decompression */
+	cinfo.scale_num = scale_num;
+	cinfo.scale_denom = scale_denom;
+	cinfo.out_color_space = j_color_space;
+
+	/* Step 5: Start decompressor */
+	(void) jpeg_start_decompress(&cinfo);
+	Jpeg_width = cinfo.output_width;
+	Jpeg_height = cinfo.output_height;
+	Jpeg_components = cinfo.output_components;
+	Jpeg_length = Jpeg_width * Jpeg_components;
+	
+	/* Make a one-row-high sample array that will go away when done with image */
+	buffer = (*cinfo.mem->alloc_sarray)
+		((j_common_ptr) &cinfo, JPOOL_IMAGE, Jpeg_length, 1);
+
+	JpegDeleteJpegBuf();
+	JpegNewJpegBuf();
+	
+	/* Step 6: while (scan lines remain to be read) */
+	while( cinfo.output_scanline < cinfo.output_height)
+	{
+		(void) jpeg_read_scanlines(&cinfo, buffer, 1);
+		/* Assume put_scanline_someplace wants a pointer and sample count. */
+		JpegCopyToJpegBuf(buffer[0],cinfo.output_scanline-1,Jpeg_length);
+	}
+	
+	/* Step 7: Finish decompression */
+	(void) jpeg_finish_decompress(&cinfo);
+
+	/* Step 8: Release JPEG decompression object */
+	jpeg_destroy_decompress(&cinfo);
+
+	fclose(infile);
+	return;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegDeleteJpegBuf
+ *  Description:  
+ * =====================================================================================
+ */
+void JpegOper::JpegDeleteJpegBuf()
+{
+	if( Jpeg_buf != NULL )
+	{
+		for(int i=0;i<Jpeg_height;i++)
+		{
+			if(Jpeg_buf[i] != NULL)
+			{
+				delete []Jpeg_buf[i];
+			}
+		}
+		delete []Jpeg_buf;
+		Jpeg_buf = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegNewJpegBuf
+ *  Description:  
+ * =====================================================================================
+ */
+void JpegOper::JpegNewJpegBuf()
+{
+	Jpeg_buf = new unsigned char *[Jpeg_height];
+	for(int i=0;i<Jpeg_height;i++)
+	{
+		Jpeg_buf[i] = new unsigned char [Jpeg_length];
+		memset(Jpeg_buf[i],0,Jpeg_length);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegCopyToJpegBuf
+ *  Description:  
+ * =====================================================================================
+ */
+void JpegOper::JpegCopyToJpegBuf(unsigned char *Src, int line, int length)
+{
+	if( Jpeg_buf[line] )
+		memcpy(Jpeg_buf[line],Src,length);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  JpegPlayJpeg
+ *  Description:  
+ * =====================================================================================
+ */
+void JpegOper::JpegPlayJpeg(int Jpeg_x,int Jpeg_y,int fb_x,int fb_y,int Play_width,int Play_height)
+{
+	int i,j;
+	uint16_t pixel;
+	uint16_t *ptr;
+	if(Jpeg_x>Jpeg_width || Jpeg_y>Jpeg_height || fb_x>fb_width || fb_y>fb_height)
+		return;
+
+	switch( Jpeg_components )
+	{
+		case 1:
+			for(i=Jpeg_y; (i<Jpeg_height)&&((i-Jpeg_y)<Play_height)&&(fb_y<fb_height); fb_y++,i++)
+			{
+				ptr = (uint16_t *)(fb_ptr + (fb_x + fb_y*fb_width)*2);
+				
+				for(j=Jpeg_x; (j<Jpeg_width)&&((j-Jpeg_x)<Play_width)&&((fb_x+j-Jpeg_x)<fb_width); j++)
+				{
+					pixel = ( ((Jpeg_buf[i][j]>>3)<<11) | 
+							((Jpeg_buf[i][j+1]>>2)<<5) |
+							((Jpeg_buf[i][j+2]>>3)) );
+
+					*ptr = pixel;
+					ptr ++;
+				}
+			}
+			break;
+		case 3:
+			for(i=Jpeg_y; (i<Jpeg_height)&&((i-Jpeg_y)<Play_height)&&(fb_y<fb_height); fb_y++,i++)
+			{
+				ptr = (uint16_t *)(fb_ptr + (fb_x + fb_y*fb_width)*2);
+				
+				for(j=Jpeg_x; (j<Jpeg_width)&&((j-Jpeg_x)<Play_width)&&((fb_x+j-Jpeg_x)<fb_width); j++)
+				{
+					pixel = ( ((Jpeg_buf[i][j*3]>>3)<<11) | 
+							((Jpeg_buf[i][j*3+1]>>2)<<5) |
+							((Jpeg_buf[i][j*3+2]>>3)) );
+
+					*ptr = pixel;
+					ptr ++;
+				}
+			}
+
+			break;
+		default:
+			break;
+	}
+}
diff --git a/src/EVA11/base/JpegOper.h b/src/EVA11/base/JpegOper.h
new file mode 100644
index 0000000..9c9d0ef
--- /dev/null
+++ b/src/EVA11/base/JpegOper.h
@@ -0,0 +1,90 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  JpegOper.h
+ *
+ *    Description:  This class operator Jpeg class
+ *
+ *        Version:  1.0
+ *        Created:  2012年02月27日 14时56分24秒
+ *       Revision:  none
+ *       Compiler:  arm-g++
+ *
+ *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef  _JPEGOPER_INC
+#define  _JPEGOPER_INC
+
+#include 	<cstdio>
+#include 	<cstdlib>
+#include 	<unistd.h>
+#include 	<stdint.h>
+#include	<cstring>
+#include 	<setjmp.h>
+
+#include	<jpeglib.h>
+
+/*
+ * =====================================================================================
+ *        Class:  JpegOper
+ *  Description:  Manage jpeg operation 
+ * =====================================================================================
+ */
+/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/
+struct my_error_mgr {
+	struct jpeg_error_mgr pub;	/* "public" fields */
+	jmp_buf setjmp_buffer;		/* for return to caller */
+};
+typedef struct my_error_mgr * my_error_ptr;
+
+/* Here's the routine that will replace the standard error_exit method */
+METHODDEF(void) my_error_exit (j_common_ptr cinfo)
+{
+	my_error_ptr myerr = (my_error_ptr) cinfo->err;
+	(*cinfo->err->output_message) (cinfo);
+	longjmp(myerr->setjmp_buffer, 1);
+}
+
+class JpegOper
+{
+	public:
+		/* ====================  LIFECYCLE     ======================================= */
+		JpegOper ();                             	/* constructor */
+		~JpegOper ();                            	/* destructor */
+		void JpegCreateJpeg(const char *filename,int quality);
+		void JpegGetFrameBufferInfo(unsigned char *ptr,int bpp,int width,int height);
+		void JpegSetJpegPara(const char *filename,int zoom,int narrow,J_COLOR_SPACE color_space);
+		void JpegReadJpegFile();
+		void JpegReadJpegFile2(unsigned long long offset);
+		void JpegDeleteJpegBuf();
+		void JpegNewJpegBuf();
+		void JpegCopyToJpegBuf(unsigned char *Src, int line, int length);
+		void JpegPlayJpeg(int Jpeg_x,int Jpeg_y,int fb_x,int fb_y,int Play_width,int Play_height);
+	protected:
+
+	private:
+		/* framebuffer information */
+		unsigned char* 		fb_ptr;
+		int 			fb_bpp;
+		int 			fb_width;
+		int 			fb_height;
+
+		/* Set Para into Jpeg */
+		char*			filePath;
+		int 			scale_num;
+		int 			scale_denom;
+		J_COLOR_SPACE 		j_color_space;
+
+		/* Play information */
+		unsigned char **	Jpeg_buf;
+
+		/* JPEG file information */
+		int 			Jpeg_width;
+		int 			Jpeg_height;
+		int 			Jpeg_components;
+		int 			Jpeg_length;
+}; /* -----  end of class JpegOper  ----- */
+#endif   /* ----- #ifndef _JPEGOPER_INC  ----- */
diff --git a/src/EVA11/base/KFInterface.cpp b/src/EVA11/base/KFInterface.cpp
new file mode 100644
index 0000000..a23f5f3
--- /dev/null
+++ b/src/EVA11/base/KFInterface.cpp
@@ -0,0 +1,96 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  KFInterface.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月12日 10时24分18秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"KFInterface.h"
+
+BaseKFInterface::BaseKFInterface()
+{
+}
+BaseKFInterface::~BaseKFInterface()
+{
+}
+
+int BaseKFInterface::Key_Enter_Fun(Graphic& g){;}
+int BaseKFInterface::Key_ESC_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F1_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F2_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F3_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F4_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F5_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F6_Fun(Graphic& g){;}
+int BaseKFInterface::Key_F7_Fun(Graphic& g){;}
+                                           
+DetectKFInterface::DetectKFInterface()
+{
+}
+DetectKFInterface::~DetectKFInterface()
+{
+}
+
+int DetectKFInterface::Key_NL1_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR1_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NL2_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR2_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NL3_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR3_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NL4_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR4_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NL5_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR5_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NL6_Fun(Graphic& g,int sub){;}
+int DetectKFInterface::Key_NR6_Fun(Graphic& g,int sub){;}
+
+AlarmKFInterface::AlarmKFInterface()
+{
+}
+AlarmKFInterface::~AlarmKFInterface()
+{
+}
+
+int AlarmKFInterface::Alarm_NL1_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR1_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NL2_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR2_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NL3_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR3_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NL4_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR4_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NL5_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR5_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NL6_Fun(Graphic& g,int sub){;}
+int AlarmKFInterface::Alarm_NR6_Fun(Graphic& g,int sub){;}
+
+ParaKFInterface::ParaKFInterface()
+{
+}
+ParaKFInterface::~ParaKFInterface()
+{
+}
+
+int ParaKFInterface::Para_NL1_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR1_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NL2_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR2_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NL3_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR3_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NL4_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR4_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NL5_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR5_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NL6_Fun(Graphic& g,int sub){;}
+int ParaKFInterface::Para_NR6_Fun(Graphic& g,int sub){;}
diff --git a/src/EVA11/base/KFInterface.h b/src/EVA11/base/KFInterface.h
new file mode 100644
index 0000000..5ee6c55
--- /dev/null
+++ b/src/EVA11/base/KFInterface.h
@@ -0,0 +1,100 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  KFInterface.h
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月12日 10时22分48秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _KFINTERFACE_INC
+#define  _KFINTERFACE_INC
+
+class Graphic;
+class BaseKFInterface
+{
+	public:
+		BaseKFInterface ();
+		virtual ~BaseKFInterface ();
+
+		virtual int Key_Enter_Fun(Graphic& g);
+		virtual int Key_ESC_Fun(Graphic& g);
+		virtual int Key_F1_Fun(Graphic& g);
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F5_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+		virtual int Key_F7_Fun(Graphic& g);
+};
+
+class DetectKFInterface
+{
+	public:
+		DetectKFInterface ();
+		virtual ~DetectKFInterface ();
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+};
+
+class AlarmKFInterface
+{
+	public:
+		AlarmKFInterface ();
+		virtual ~AlarmKFInterface ();
+
+		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
+};
+
+class ParaKFInterface
+{
+	public:
+		ParaKFInterface ();
+		virtual ~ParaKFInterface ();
+
+		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR6_Fun(Graphic& g,int sub=1);
+};
+
+#endif
diff --git a/src/EVA11/base/Label.cpp b/src/EVA11/base/Label.cpp
new file mode 100644
index 0000000..fef040d
--- /dev/null
+++ b/src/EVA11/base/Label.cpp
@@ -0,0 +1,464 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Label.cpp
+ *
+ *    Description:  Implementation of Label class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月20日 08时51分34秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"ColorObj.h"
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"Language.h"
+#include 	"FreeType.h"
+#include 	"Gradual.h"
+
+struct Label::PImpl
+{
+	static const int	SHADOW  = 2;
+	static const int	RSHADOW = 1;
+	short 			m_BGFO_Color;
+	short 			m_FGFO_Color;
+	short 			m_BGNO_Color;
+	short 			m_FGNO_Color;
+
+	ColorObj::ColorV*	m_BGF_PColor;
+	ColorObj::ColorV*       m_FGF_PColor;
+	ColorObj::ColorV*       m_BGN_PColor;
+	ColorObj::ColorV*       m_FGN_PColor;
+	ColorObj::ColorV*	m_HI_PColor;
+	ColorObj::ColorV*       m_LO_PColor;
+
+	int			m_Font_Size;
+
+	bool			m_Focus;
+	LABELTYPE       	m_Type;
+	LADISPTYPE		m_Display_Type;
+	std::string		m_strText;
+	std::string		m_strContent1;
+	std::string		m_strContent2;
+
+	FreeType*		m_ft;
+	int			m_radius;
+};
+
+Label::Label (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh) , m_Imple(new struct PImpl)
+{
+	Language *lan      	= Language::Instance();
+	m_Imple->m_strText 	= lan->GetText(NONE);
+	m_Imple->m_Type    	= Label::LA_NONE;
+	m_Imple->m_Focus   	= false;
+	m_Imple->m_ft 	   	= FreeType::Instance();
+	m_Imple->m_Font_Size 	= 16;
+	m_Imple->m_radius       = 12;
+	m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
+	m_Imple->m_Display_Type = Label::LA_DT_CENTER;
+	m_Imple->m_strContent1  = lan->GetText(NONE);
+	m_Imple->m_strContent2  = lan->GetText(NONE);
+}
+
+Label::~Label ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the screen object on screen 
+ * =====================================================================================
+ */
+void Label::Drawme(Graphic &g,bool bufdraw)
+{
+	if ( bufdraw == true )
+		g.Switch_Screen();
+
+	short bgcolor,fgcolor;
+	short hicolor,locolor;
+	if 	( m_Imple->m_Focus == true )
+	{
+		bgcolor = m_Imple->m_BGFO_Color;
+		fgcolor = m_Imple->m_FGFO_Color;
+		hicolor = g_LIGHT_CO;
+		locolor = g_SHADOW_CO;
+	}
+	else
+	{
+		bgcolor = m_Imple->m_BGNO_Color;
+		fgcolor = m_Imple->m_FGNO_Color;
+		hicolor = g_SHADOW_CO;
+		locolor = g_LIGHT_CO;
+	}
+
+	ColorObj::ColorV* pbgcolor;
+	ColorObj::ColorV* pfgcolor;
+	ColorObj::ColorV* phicolor;
+	ColorObj::ColorV* plocolor;
+	if 	( m_Imple->m_Focus == true )
+	{
+		pbgcolor = m_Imple->m_BGF_PColor;
+		pfgcolor = m_Imple->m_FGF_PColor;
+		phicolor = m_Imple->m_HI_PColor;
+		plocolor = m_Imple->m_LO_PColor;
+	}
+	else
+	{
+		pbgcolor = m_Imple->m_BGN_PColor;
+		pfgcolor = m_Imple->m_FGN_PColor;
+		phicolor = m_Imple->m_LO_PColor;
+		plocolor = m_Imple->m_HI_PColor;
+	}
+
+	if 	( m_Imple->m_Type == Label::LA_NONE || m_Imple->m_Type == Label::LA_THIN )
+	{
+		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,bgcolor);
+
+		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
+		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
+		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
+		m_Imple->m_ft->Set_Transparce(true);
+
+		int xoffset; 
+		int yoffset;
+		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_LEFT )
+		{
+			xoffset =  m_X+(m_Width>>4);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_RIGHT )
+		{
+			xoffset =  m_X+m_Width-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(2))*m_Imple->m_Font_Size)-3;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_SPEC )
+		{
+			xoffset =  m_X+7;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_DOUBLE )
+		{
+			xoffset =  m_X+m_Width-(m_Imple->m_strContent1.size()>>1)*m_Imple->m_Font_Size-(m_Width>>4)-10;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
+			xoffset =  m_X+(m_Width>>4);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-4;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)-8;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
+			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
+		}
+		if 	( m_Imple->m_Type == Label::LA_THIN )
+		{
+			g.DrawRect(m_X,m_Y,m_Width,m_Heigh,fgcolor);
+		}
+	}
+	else if ( m_Imple->m_Type == Label::LA_ROUND || m_Imple->m_Type == Label::LA_HALFROUND || m_Imple->m_Type == Label::LA_QUAT )
+	{
+		if 	( m_Imple->m_Type == Label::LA_ROUND )
+		{
+			g.FillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
+			g.FillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
+			g.FillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
+		}
+		else if ( m_Imple->m_Type == Label::LA_HALFROUND )
+		{
+			g.HalfFillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
+			g.HalfFillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
+			g.HalfFillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
+		}
+		else if ( m_Imple->m_Type == Label::LA_QUAT )
+		{
+			g.QuatFillBox(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_radius,phicolor->color32);
+			g.QuatFillBox(m_X+m_Imple->RSHADOW,m_Y+m_Imple->RSHADOW,m_Width-2*m_Imple->RSHADOW,m_Heigh-2*m_Imple->RSHADOW,m_Imple->m_radius,plocolor->color32);
+			g.QuatFillBox(m_X+2*m_Imple->RSHADOW,m_Y+2*m_Imple->RSHADOW,m_Width-4*m_Imple->RSHADOW,m_Heigh-4*m_Imple->RSHADOW,m_Imple->m_radius,pbgcolor->color32);
+		}
+
+		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
+		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
+		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
+		m_Imple->m_ft->Set_Transparce(true);
+
+		int xoffset;
+		int yoffset;
+		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size)+1;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-2;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)-8;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
+			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_SM )
+		{
+			m_Imple->m_ft->Set_Font_Size(15);
+			m_Imple->m_ft->Set_Transparce(true);
+
+			xoffset =  m_X+4;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset-8,m_Imple->m_strText.c_str());
+			m_Imple->m_ft->Set_Font_Size(17);
+			m_Imple->m_ft->Text(xoffset+9,yoffset+4,m_Imple->m_strContent1.c_str());
+		}
+	}
+	else if ( m_Imple->m_Type == Label::LA_3D )
+	{
+		g.DrawFillRect(m_X,m_Y,m_Width+m_Imple->SHADOW,m_Heigh+m_Imple->SHADOW,hicolor);
+		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
+		g.DrawFillRect(m_X+m_Imple->SHADOW,m_Y+m_Imple->SHADOW,m_Width-m_Imple->SHADOW,m_Heigh-m_Imple->SHADOW,bgcolor);
+
+		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
+		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
+		m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size);
+		m_Imple->m_ft->Set_Transparce(true);
+
+		int xoffset;
+		int yoffset;
+		if 	( m_Imple->m_Display_Type == LA_DT_CENTER )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_LEFT )
+		{
+			xoffset =  m_X+(m_Width>>4);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_RIGHT )
+		{
+			xoffset =  m_X+m_Width-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(2))*m_Imple->m_Font_Size)-3;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_SPEC )
+		{
+			xoffset =  m_X+7;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_DOUBLE )
+		{
+			xoffset =  m_X+m_Width-(m_Imple->m_strContent1.size()>>1)*m_Imple->m_Font_Size-(m_Width>>4)-10;
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
+			xoffset =  m_X+(m_Width>>4);
+			yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+		}
+		else if ( m_Imple->m_Display_Type == LA_DT_DLINE )
+		{
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strText.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)-8;
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strText.c_str());
+
+			xoffset =  m_X+(m_Width>>1)-static_cast<int>((m_Imple->m_strContent1.size()/static_cast<double>(4))*m_Imple->m_Font_Size);
+			yoffset =  m_Y+(m_Heigh>>1)+m_Imple->m_Font_Size+2;
+			m_Imple->m_ft->Set_Font_Size(m_Imple->m_Font_Size-2);
+			m_Imple->m_ft->Text(xoffset,yoffset,m_Imple->m_strContent1.c_str());
+		}
+	}
+	else if ( m_Imple->m_Type == Label::LA_SM )
+	{
+		g.DrawFillRect(m_X,m_Y,m_Width+m_Imple->SHADOW,m_Heigh+m_Imple->SHADOW,hicolor);
+		g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,locolor);
+		g.DrawFillRect(m_X+m_Imple->SHADOW,m_Y+m_Imple->SHADOW,m_Width-m_Imple->SHADOW,m_Heigh-m_Imple->SHADOW,bgcolor);
+
+		m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,fgcolor);
+		m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,bgcolor);
+		m_Imple->m_ft->Set_Font_Size(15);
+		m_Imple->m_ft->Set_Transparce(true);
+
+		int xoffset; 
+		int yoffset;
+		xoffset =  m_X+4;
+		yoffset =  m_Y+(m_Heigh>>1)+(m_Imple->m_Font_Size>>1)-3;
+		m_Imple->m_ft->Text(xoffset,yoffset-8,m_Imple->m_strText.c_str());
+		m_Imple->m_ft->Set_Font_Size(17);
+		m_Imple->m_ft->Text(xoffset+9,yoffset+4,m_Imple->m_strContent1.c_str());
+	}
+
+	if 	( bufdraw == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-2,m_Y+m_Heigh-2,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Text
+ *  Description:  Set the Text of object 
+ * =====================================================================================
+ */
+void Label::Set_Text(const char* str,int index)
+{
+	if 	( index == 0 )
+	{
+		m_Imple->m_strText.clear();
+		m_Imple->m_strText.assign(str);
+	}
+	else if ( index == 1 )
+	{
+		m_Imple->m_strContent1.clear();
+		m_Imple->m_strContent1.assign(str);
+	}
+	else if ( index == 2 )
+	{
+		m_Imple->m_strContent2.clear();
+		m_Imple->m_strContent2.assign(str);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Content
+ *  Description:  Set the text of label 
+ * =====================================================================================
+ */
+void Label::Set_Content(const char *str)
+{
+	Set_Text(str,1);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Focus
+ *  Description:  Set the Focus of label 
+ * =====================================================================================
+ */
+void Label::Set_Focus(bool value)
+{
+	m_Imple->m_Focus = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Label_Color
+ *  Description:  Set the Label color include bkcolor and fgcolor
+ * =====================================================================================
+ */
+void Label::Set_Label_Color(LABCOLOR type,short color)
+{
+	switch ( type ) 
+	{
+        	case LA_BGFO_COLOR:	
+			m_Imple->m_BGFO_Color = color;
+			break;
+		case LA_FGNO_COLOR:	
+			m_Imple->m_FGNO_Color = color;
+			break;
+		case LA_BGNO_COLOR:	
+			m_Imple->m_BGNO_Color = color;
+			break;
+		case LA_FGFO_COLOR:	
+			m_Imple->m_FGFO_Color = color;
+			break;
+	}
+}
+void Label::Set_Label_Color(LABCOLOR type,ColorObj::ColorV* pcolor)
+{
+	switch ( type ) 
+	{
+        	case LA_BGFO_COLOR:	
+			m_Imple->m_BGF_PColor = pcolor;
+			break;
+		case LA_FGNO_COLOR:    
+			m_Imple->m_FGN_PColor = pcolor;
+			break;
+		case LA_BGNO_COLOR:    
+			m_Imple->m_BGN_PColor = pcolor;
+			break;
+		case LA_FGFO_COLOR:    
+			m_Imple->m_FGF_PColor = pcolor;
+			break;
+		case LA_HI_COLOR:    
+			m_Imple->m_HI_PColor = pcolor;
+			break;
+		case LA_LO_COLOR:    
+			m_Imple->m_LO_PColor = pcolor;
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Font_Size
+ *  Description:  Set the size of Font
+ * =====================================================================================
+ */
+void Label::Set_Font_Size(int size)
+{
+	m_Imple->m_Font_Size = size;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Display_Type
+ *  Description:  Set the display type 
+ * =====================================================================================
+ */
+void Label::Set_Display_Type(LADISPTYPE type)
+{
+	m_Imple->m_Display_Type = type;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Label_Type
+ *  Description:  Set the label type 
+ * =====================================================================================
+ */
+void Label::Set_Label_Type(LABELTYPE type)
+{
+	m_Imple->m_Type = type;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Radius
+ *  Description:  Set the radius of label 
+ * =====================================================================================
+ */
+void Label::Set_Radius(int radius)
+{
+	m_Imple->m_radius = radius;
+}
diff --git a/src/EVA11/base/Label.h b/src/EVA11/base/Label.h
new file mode 100644
index 0000000..98ba609
--- /dev/null
+++ b/src/EVA11/base/Label.h
@@ -0,0 +1,80 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Label.h
+ *
+ *    Description:  New label class which take place old lable lcass
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月20日 08时48分47秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  LABEL_INC
+#define  LABEL_INC
+
+#include 	<string>
+#include 	<memory>	
+
+#include 	"ColorObj.h"
+class Graphic;
+class Label : public Object
+{
+	public:
+		typedef enum 
+		{
+			LA_3D,
+			LA_NONE,
+			LA_SM,
+			LA_THIN,
+			LA_ROUND,
+			LA_HALFROUND,
+			LA_QUAT,
+		} LABELTYPE;
+		typedef enum 
+		{
+			LA_BGFO_COLOR,
+			LA_BGNO_COLOR,
+			LA_FGFO_COLOR,
+			LA_FGNO_COLOR,
+			LA_HI_COLOR,
+			LA_LO_COLOR,
+		} LABCOLOR;
+		typedef enum 
+		{
+			LA_DT_CENTER,
+			LA_DT_LEFT,
+			LA_DT_RIGHT,
+			LA_DT_DOUBLE,
+			LA_DT_DLINE,
+			LA_DT_SPEC,
+			LA_DT_SM,
+		}LADISPTYPE;
+
+		Label (int x,int y,int width,int heigh);
+		~Label ();
+
+		void Drawme(Graphic &g,bool bufdraw=false);
+		void Set_Text(const char*,int index=0);
+		void Set_Content(const char *);
+		void Set_Focus(bool value);
+		void Set_Label_Color(LABCOLOR,short color);
+		void Set_Label_Color(LABCOLOR,ColorObj::ColorV* pcolor);
+		void Set_Font_Size(int);
+		void Set_Display_Type(LADISPTYPE);
+		void Set_Label_Type(LABELTYPE);
+		void Set_Radius(int);
+	protected:
+
+	private:
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif   /* ----- #ifndef LABEL_INC  ----- */
diff --git a/src/EVA11/base/Language.cpp b/src/EVA11/base/Language.cpp
new file mode 100644
index 0000000..8d54594
--- /dev/null
+++ b/src/EVA11/base/Language.cpp
@@ -0,0 +1,846 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Language.cpp
+ *
+ *    Description:  Implementation of Language class
+ *
+ *        Version:  1.0
+ *        Created:  2011年02月10日 13时39分58秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdio>
+
+#include 	"Language.h"
+
+std::auto_ptr<Language> Language::m_Instance;
+
+Language::Language ()
+{
+	m_Langue = 0;                           /* 0: Chinese  1:English */
+}
+
+Language::~Language ()
+{
+}
+
+char const *Language::GetText(int index)
+{
+	if      ( m_Langue == 0 ) return Get_CN_Text(index);
+	else if ( m_Langue == 1 ) return Get_EN_Text(index);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only used the function to init language class 
+ * =====================================================================================
+ */
+Language* Language::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Language() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_EN_Text
+ *  Description:  Get English Text 
+ * =====================================================================================
+ */
+char const *Language::Get_EN_Text(int index)
+{
+	switch ( index ) 
+	{
+		case MAINTITLE:
+			return MAINTITLE_EN;
+		case DETECT:
+			return DETECT_EN;
+		case PARAM:
+			return PARAM_EN;
+		case DEBUG:
+			return DEBUG_EN;
+		case ALARM:
+			return ALARM_EN;
+		case ANALYZE:
+			return ANALYZE_EN;
+		case LAYOUT:
+			return LAYOUT_EN;
+		case OTHERS:
+			return OTHERS_EN;
+		case PREVIOUSE:
+			return PREVIOUSE_EN;
+		case NEXT:
+			return NEXT_EN;
+		case LEFTC:
+			return LEFTC_EN;
+		case RIGHTC:
+			return RIGHTC_EN;
+		case COMFIRM:
+			return COMFIRM_EN;
+		case BACKOUT:
+			return BACKOUT_EN;
+		case MAINBUTTON:
+			return MAINBUTTON_EN;
+		case RESERVE:
+			return RESERVE_EN;
+		case SUBTITLE:
+			return SUBTITLE_EN;
+		case CANCEL:
+			return CANCEL_EN;
+		case COMFIRMEXIT:
+			return COMFIRMEXIT_EN;
+		case INFORMESG08:
+			return INFORMESG08_EN;
+		case INFORMESG09:
+			return INFORMESG09_EN;
+		case SCREEN:
+			return SCREEN_EN;
+		case CHANNEL:
+			return CHANNEL_EN;
+		case HDGAIN:
+			return HDGAIN_EN;
+		case FREQUENCEVALUE:
+			return FREQUENCEVALUE_EN;
+		case DRIVER:
+			return DRIVER_EN;
+		case OFFSET:
+			return OFFSET_EN;
+		case PROBE:
+			return PROBE_EN;
+		case FREQUENCE:               
+			return FREQUENCE_EN;
+		case DIFILTER:
+			return DIFILTER_EN;
+		case GAIN:                 
+			return GAIN_EN;
+		case PHASE:
+     			return PHASE_EN;
+		case HIFILTER:           
+			return HIFILTER_EN;
+		case LOFILTER:          
+			return LOFILTER_EN;
+		case CRAFTPARA:
+			return CRAFTPARA_EN;
+		case SAVEPARAM:
+			return SAVEPARAM_EN;
+		case LOADPARAM:
+			return LOADPARAM_EN;
+		case DELPARAM:
+			return DELPARAM_EN;
+		case SUB_TITLE2:
+			return SUB_TITLE2_EN;
+		case EXCUTE:
+			return EXCUTE_EN;
+		case LOADEMPTYDOC:
+			return LOADEMPTYDOC_EN;
+		case DELEMPTYDOC:
+			return DELEMPTYDOC_EN;
+		case OVERWRITECHECK:
+			return OVERWRITECHECK_EN;
+		case INFO_PASSWORD:
+			return INFO_PASSWORD_EN;
+		case INFO_PD_INVAIL:
+			return INFO_PD_INVAIL_EN;
+		case CLOSED:
+			return CLOSED_EN;
+		case HELPTITLE1:
+			return HELPTITLE1_EN;
+		case HELPTITLE2: 
+			return HELPTITLE2_EN;
+		case HELPB1F1:   
+			return HELPB1F1_EN;
+		case HELPB1F2:   
+			return HELPB1F2_EN;
+		case HELPB1F3:  
+			return HELPB1F3_EN;
+		case HELPB1F3_O:  
+			return HELPB1F3_O_EN;
+		case HELPB1F5:  
+			return HELPB1F5_EN;
+		case HELPB1F4:   
+			return HELPB1F4_EN;
+		case HELPB1F6:  
+			return HELPB1F6_EN;
+		case HELPB1F7:  
+			return HELPB1F7_EN;
+		case HELPB1ESC:  
+			return HELPB1ESC_EN;
+		case HELPB1ENTER:
+			return HELPB1ENTER_EN;
+		case GRAPHICFILE:
+			return GRAPHICFILE_EN;
+		case GRAPHICSAVE:
+			return GRAPHICSAVE_EN;
+		case INFORMESG10:
+			return INFORMESG10_EN;
+		case VIDEODISPLAY:
+			return VIDEODISPLAY_EN;
+		case COLORDISPLAY:
+			return COLORDISPLAY_EN;
+		case SIGZKDISPLAY:
+			return SIGZKDISPLAY_EN;
+		case INFORMESG22:
+			return INFORMESG22_EN;
+		case LOADDATA:
+			return LOADDATA_EN;
+		case SAVEDATA:
+			return SAVEDATA_EN;
+		case DELEDATA:
+			return DELEDATA_EN;
+		case SUB_TITLE3:
+			return SUB_TITLE3_EN;
+		case UPDATEPRO:
+		       return UPDATEPRO_EN;	
+		case UPDATECOMFIRM:
+		       return UPDATECOMFIRM_EN;
+		case TRANINFO1:
+		       return TRANINFO1_EN;
+		case ALLGAIN:
+		       return ALLGAIN_EN;
+		case VIDEOOPEN:
+		       return VIDEOOPEN_EN;
+		case VIDEOCLOSE:
+		       return VIDEOCLOSE_EN;
+		case ADJRES:
+		       return ADJRES_EN;
+		case AUTODI:
+		       return AUTODI_EN;
+		case PAGE5:
+		       return PAGE5_EN;
+		case CHCOL:
+		       return CHCOL_EN;
+		case PGUP:
+		       return PGUP_EN;
+		case PGDN:
+		       return PGDN_EN;
+		case DATAFILE:
+		       return DATAFILE_EN;
+		case LOADDATA1:
+		       return LOADDATA1_EN;
+		case SAVEDATA1:
+		       return SAVEDATA1_EN;
+		case LANGUAGE:
+		       return LANGUAGE_EN;
+		case LAN_VALUE:
+			return LAN_VALUE_EN;
+		case DZKDISPLAY:
+			return DZKDISPLAY_EN;
+		case DATE:
+			return DATE_EN;
+		case TIME:
+			return TIME_EN;
+		case VERSION:
+			return VERSION_EN;
+		case ABOUTMSG1: 
+			return ABOUTMSG1_EN;
+		case ABOUTMSG2:
+			return ABOUTMSG2_EN;
+		case ABOUTMSG21:
+			return ABOUTMSG21_EN;
+		case ABOUTMSG22:
+			return ABOUTMSG22_EN;
+		case ABOUTMSG3:
+			return ABOUTMSG3_EN;
+		case ABOUTMSG4: 
+			return ABOUTMSG4_EN;
+		case ABOUTMSG5: 
+			return ABOUTMSG5_EN;
+		case ABOUTMSG7: 		
+			return ABOUTMSG7_EN;
+		case ABOUTMSG6: 
+			return ABOUTMSG6_EN;
+		case ABOUTMSG8: 
+			return ABOUTMSG8_EN;
+		case SAMPLETYPE:
+			return SAMPLETYPE_EN;
+		case INSIDESAMP:
+			return INSIDESAMP_EN;
+		case OUTSIDESAMP:
+			return OUTSIDESAMP_EN;
+		case STIMEINTER:
+			return STIMEINTER_EN;
+		case SAMPPLUS:
+			return SAMPPLUS_EN;
+		case COLORSPOTDM:
+			return COLORSPOTDM_EN;
+		case DISPMOD_3D:
+			return DISPMOD_3D_EN;
+		case DISPMOD_2D:
+			return DISPMOD_2D_EN;
+		case SCANSPEED:
+			return SCANSPEED_EN;
+		case EDDYNETWORK:
+			return EDDYNETWORK_EN;
+		case IPMESG:
+			return IPMESG_EN;
+		case ERRORMSG1:
+			return ERRORMSG1_EN;
+		case INFORMESG07:
+			return INFORMESG07_EN;
+		case INFORMESG06:
+			return INFORMESG06_EN;
+		case SYSTEMDATE:
+			return SYSTEMDATE_EN;
+		case SYSTEMTIME:
+			return SYSTEMTIME_EN;
+		case INFORMESG21:
+			return INFORMESG21_EN;
+		case DELETE:
+			return DELETE_EN;
+		case DELETEHELP:
+			return DELETEHELP_EN;
+		case PICMANAGE:
+			return PICMANAGE_EN;
+		case PREVIEW:
+			return PREVIEW_EN;
+		case PREPIC:
+			return PREPIC_EN;
+		case PICFILE:
+			return PICFILE_EN;
+		case PREVIEWPIC:
+			return PREVIEWPIC_EN;
+		case DELPICFILE:
+			return DELPICFILE_EN;
+		case ALARMTYPE:
+			return ALARMTYPE_EN;
+		case ALARMACOUNT:           
+			return ALARMACOUNT_EN;
+		case ALARMBEEP:               
+			return ALARMBEEP_EN;
+		case ALARMOUT:
+			return ALARMOUT_EN;
+		case ALARMDISP:       
+			return ALARMDISP_EN;
+		case ALARMWINS:
+			return ALARMWINS_EN;
+		case LEFTLIMIT:
+			return LEFTLIMIT_EN;
+		case RIGHTLIMIT:
+			return RIGHTLIMIT_EN;
+		case UPLIMIT:
+			return UPLIMIT_EN;
+		case DOWNLIMIT:
+			return DOWNLIMIT_EN;
+		case DEGREE1:
+			return DEGREE1_EN;
+		case DEGREE2:
+			return DEGREE2_EN;
+		case XHALF:
+			return XHALF_EN;
+		case YHALF:
+			return YHALF_EN;
+		case RECTALARM:
+			return RECTALARM_EN;
+		case AMPALARM:
+			return AMPALARM_EN;
+		case HAMPALARM:
+			return HAMPALARM_EN;
+		case ALARMWINMENU:
+			return ALARMWINMENU_EN;
+		case OPEN:
+			return OPEN_EN;
+		case DEFAULT:
+			return DEFAULT_EN;
+		case RESTORE:
+			return RESTORE_EN;
+		case RESTOREDEFAULT:
+			return RESTOREDEFAULT_EN;
+		case REBOOTMSG:
+			return REBOOTMSG_EN;
+		case CLEANBUF:
+			return CLEANBUF_EN;
+		case RUNTIME:
+			return RUNTIME_EN;
+		case KEYBEEP:
+			return KEYBEEP_EN;
+		case SHUTDOWNMSG1:
+			return SHUTDOWNMSG1_EN;
+		case SHUTDOWNMSG2:
+			return SHUTDOWNMSG2_EN;
+		case TIMESCALE:
+			return TIMESCALE_EN;
+		case TIMESCALESPEED:
+			return TIMESCALESPEED_EN;
+		case MIXINGINFO1:
+			return MIXINGINFO1_EN;
+		case PRIFREQ:
+			return PRIFREQ_EN;
+		case SECFREQ:
+			return SECFREQ_EN;
+		case MIXFACTOR:
+			return MIXFACTOR_EN;
+		case MIXFACTORCOMFIRM:
+			return MIXFACTORCOMFIRM_EN;
+		case SAVEMIXCOMFIRM:
+			return SAVEMIXCOMFIRM_EN;
+		case X1POINT:
+			return X1POINT_EN;
+		case Y1POINT:
+			return Y1POINT_EN;
+		case X2POINT:
+			return X2POINT_EN;
+		case Y2POINT:
+			return Y2POINT_EN;
+		case GAINRATIO:
+			return GAINRATIO_EN;
+		case CLEANPHOTO:
+			return CLEANPHOTO_EN;
+		case OZKDISPLAY:
+			return OZKDISPLAY_EN;
+		case XNPOINT:
+			return XNPOINT_EN;
+		case YNPOINT:
+			return YNPOINT_EN;
+		case SCOPE:
+			return SCOPE_EN;
+		case WHOLE:
+			return WHOLE_EN;
+		case CROSSCHAN:
+			return CROSSCHAN_EN;
+		case ALARMLIMIT:
+			return ALARMLIMIT_EN;
+		case COMBINING:
+			return COMBINING_EN;
+		case ASCANCHAN:
+			return ASCANCHAN_EN;
+		case EMSGAIN:
+			return EMSGAIN_EN;
+		case ASCANSPEED:
+			return ASCANSPEED_EN;
+		case PARASYNC:
+			return PARASYNC_EN;
+		case PARASYNCCOMFIRM:
+			return PARASYNCCOMFIRM_EN;
+		case RESBALACE:
+			return RESBALACE_EN;
+		case ADRIVE: 		
+			return ADRIVE_EN;
+		case BDRIVE: 		
+			return BDRIVE_EN;
+		case APICK: 		
+			return APICK_EN;
+		case BPICK: 		
+			return BPICK_EN;
+		case RFFILTER:
+			return RFFILTER_EN;
+		case PRECISION:
+			return PRECISION_EN;
+		case PREHIGH:
+			return PREHIGH_EN;
+		case PREMED:
+			return PREMED_EN;
+		case PRELOW:
+			return PRELOW_EN;
+		case OPERATION:
+			return OPERATION_EN;
+		default:
+			return NONE_EN;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_CN_Text
+ *  Description:  Get Chinese Text 
+ * =====================================================================================
+ */
+char const *Language::Get_CN_Text(int index)
+{
+	switch ( index ) {
+		case MAINTITLE:
+			return MAINTITLE_CN;
+		case DETECT:
+			return DETECT_CN;
+		case PARAM:
+			return PARAM_CN;
+		case DEBUG:
+			return DEBUG_CN;
+		case ALARM:
+			return ALARM_CN;
+		case ANALYZE:
+			return ANALYZE_CN;
+		case LAYOUT:
+			return LAYOUT_CN;
+		case OTHERS:
+			return OTHERS_CN;
+		case PREVIOUSE:
+			return PREVIOUSE_CN;
+		case NEXT:
+			return NEXT_CN;
+		case LEFTC:
+			return LEFTC_CN;
+		case RIGHTC:
+			return RIGHTC_CN;
+		case COMFIRM:
+			return COMFIRM_CN;
+		case BACKOUT:
+			return BACKOUT_CN;
+		case MAINBUTTON:
+			return MAINBUTTON_CN;
+		case RESERVE:
+			return RESERVE_CN;
+		case SUBTITLE:
+			return SUBTITLE_CN;
+		case CANCEL:
+			return CANCEL_CN;
+		case COMFIRMEXIT:
+			return COMFIRMEXIT_CN;
+		case INFORMESG08:
+			return INFORMESG08_CN;
+		case INFORMESG09:
+			return INFORMESG09_CN;
+		case SCREEN:
+			return SCREEN_CN;
+		case CHANNEL:
+			return CHANNEL_CN;
+		case HDGAIN:
+			return HDGAIN_CN;
+		case FREQUENCEVALUE:
+			return FREQUENCEVALUE_CN;
+		case DRIVER:
+			return DRIVER_CN;
+		case OFFSET:
+			return OFFSET_CN;
+		case PROBE:
+			return PROBE_CN;
+		case FREQUENCE:               
+			return FREQUENCE_CN;
+		case DIFILTER:
+			return DIFILTER_CN;
+		case GAIN:                 
+			return GAIN_CN;
+		case PHASE:
+     			return PHASE_CN;
+		case HIFILTER:           
+			return HIFILTER_CN;
+		case LOFILTER:          
+			return LOFILTER_CN;
+		case CRAFTPARA:
+			return CRAFTPARA_CN;
+		case SAVEPARAM:
+			return SAVEPARAM_CN;
+		case LOADPARAM:
+			return LOADPARAM_CN;
+		case DELPARAM:
+			return DELPARAM_CN;
+		case SUB_TITLE2:
+			return SUB_TITLE2_CN;
+		case EXCUTE:
+			return EXCUTE_CN;
+		case LOADEMPTYDOC:
+			return LOADEMPTYDOC_CN;
+		case DELEMPTYDOC:
+			return DELEMPTYDOC_CN;
+		case OVERWRITECHECK:
+			return OVERWRITECHECK_CN;
+		case INFO_PASSWORD:
+			return INFO_PASSWORD_CN;
+		case INFO_PD_INVAIL:
+			return INFO_PD_INVAIL_CN;
+		case CLOSED:
+			return CLOSED_CN;
+		case HELPTITLE1:
+			return HELPTITLE1_CN;
+		case HELPTITLE2: 
+			return HELPTITLE2_CN;
+		case HELPB1F1:   
+			return HELPB1F1_CN;
+		case HELPB1F2:   
+			return HELPB1F2_CN;
+		case HELPB1F3:  
+			return HELPB1F3_CN;
+		case HELPB1F3_O:  
+			return HELPB1F3_O_CN;
+		case HELPB1F5:  
+			return HELPB1F5_CN;
+		case HELPB1F4:   
+			return HELPB1F4_CN;
+		case HELPB1F6:  
+			return HELPB1F6_CN;
+		case HELPB1F7:  
+			return HELPB1F7_CN;
+		case HELPB1ESC:  
+			return HELPB1ESC_CN;
+		case HELPB1ENTER:
+			return HELPB1ENTER_CN;
+		case GRAPHICFILE:
+			return GRAPHICFILE_CN;
+		case GRAPHICSAVE:
+			return GRAPHICSAVE_CN;
+		case INFORMESG10:
+			return INFORMESG10_CN;
+		case VIDEODISPLAY:
+			return VIDEODISPLAY_CN;
+		case COLORDISPLAY:
+			return COLORDISPLAY_CN;
+		case SIGZKDISPLAY:
+			return SIGZKDISPLAY_CN;
+		case INFORMESG22:
+			return INFORMESG22_CN;
+		case LOADDATA:
+			return LOADDATA_CN;
+		case SAVEDATA:
+			return SAVEDATA_CN;
+		case DELEDATA:
+			return DELEDATA_CN;
+		case SUB_TITLE3:
+			return SUB_TITLE3_CN;
+		case UPDATEPRO:
+		       return UPDATEPRO_CN;
+		case UPDATECOMFIRM:
+		       return UPDATECOMFIRM_CN;
+		case TRANINFO1:
+		       return TRANINFO1_CN;
+		case ALLGAIN:
+		       return ALLGAIN_CN;
+		case VIDEOOPEN:
+		       return VIDEOOPEN_CN;
+		case VIDEOCLOSE:
+		       return VIDEOCLOSE_CN;
+		case ADJRES:
+		       return ADJRES_CN;
+		case AUTODI:
+		       return AUTODI_CN;
+		case PAGE5:
+		       return PAGE5_CN;
+		case CHCOL:
+		       return CHCOL_CN;
+		case PGUP:
+		       return PGUP_CN;
+		case PGDN:
+		       return PGDN_CN;
+		case DATAFILE:
+		       return DATAFILE_CN;
+		case LOADDATA1:
+		       return LOADDATA1_CN;
+		case SAVEDATA1:
+		       return SAVEDATA1_CN;
+		case LANGUAGE:
+		       return LANGUAGE_CN;
+		case LAN_VALUE:
+			return LAN_VALUE_CN;
+		case DZKDISPLAY:
+			return DZKDISPLAY_CN;
+		case DATE:
+			return DATE_CN;
+		case TIME:
+			return TIME_CN;
+		case VERSION:
+			return VERSION_CN;
+		case ABOUTMSG1: 
+			return ABOUTMSG1_CN;
+		case ABOUTMSG2:
+			return ABOUTMSG2_CN;
+		case ABOUTMSG21:
+			return ABOUTMSG21_CN;
+		case ABOUTMSG22:
+			return ABOUTMSG22_CN;
+		case ABOUTMSG3:
+			return ABOUTMSG3_CN;
+		case ABOUTMSG4: 
+			return ABOUTMSG4_CN;
+		case ABOUTMSG5: 
+			return ABOUTMSG5_CN;
+		case ABOUTMSG7: 	       
+			return ABOUTMSG7_CN;
+		case ABOUTMSG6: 
+			return ABOUTMSG6_CN;
+		case ABOUTMSG8: 
+			return ABOUTMSG8_CN;
+		case SAMPLETYPE:
+			return SAMPLETYPE_CN;
+		case INSIDESAMP:
+			return INSIDESAMP_CN;
+		case OUTSIDESAMP:
+			return OUTSIDESAMP_CN;
+		case STIMEINTER:
+			return STIMEINTER_CN;
+		case SAMPPLUS:
+			return SAMPPLUS_CN;
+		case COLORSPOTDM:
+			return COLORSPOTDM_CN;
+		case DISPMOD_3D:
+			return DISPMOD_3D_CN;
+		case DISPMOD_2D:
+			return DISPMOD_2D_CN;
+		case SCANSPEED:
+			return SCANSPEED_CN;
+		case EDDYNETWORK:
+			return EDDYNETWORK_CN;
+		case IPMESG:
+			return IPMESG_CN;
+		case ERRORMSG1:
+			return ERRORMSG1_CN;
+		case INFORMESG07:
+			return INFORMESG07_CN;
+		case INFORMESG06:
+			return INFORMESG06_CN;
+		case SYSTEMDATE:
+			return SYSTEMDATE_CN;
+		case SYSTEMTIME:
+			return SYSTEMTIME_CN;
+		case INFORMESG21:
+			return INFORMESG21_CN;
+		case DELETE:
+			return DELETE_CN;
+		case DELETEHELP:
+			return DELETEHELP_CN;
+		case PICMANAGE:
+			return PICMANAGE_CN;
+		case PREVIEW:
+			return PREVIEW_CN;
+		case PREPIC:
+			return PREPIC_CN;
+		case PICFILE:
+			return PICFILE_CN;
+		case PREVIEWPIC:
+			return PREVIEWPIC_CN;
+		case DELPICFILE:
+			return DELPICFILE_CN;
+		case ALARMTYPE:
+			return ALARMTYPE_CN;
+		case ALARMACOUNT:           
+			return ALARMACOUNT_CN;
+		case ALARMBEEP:               
+			return ALARMBEEP_CN;
+		case ALARMOUT:
+			return ALARMOUT_CN;
+		case ALARMDISP:       
+			return ALARMDISP_CN;
+		case ALARMWINS:
+			return ALARMWINS_CN;
+		case LEFTLIMIT:
+			return LEFTLIMIT_CN;
+		case RIGHTLIMIT:
+			return RIGHTLIMIT_CN;
+		case UPLIMIT:
+			return UPLIMIT_CN;
+		case DOWNLIMIT:
+			return DOWNLIMIT_CN;
+		case DEGREE1:
+			return DEGREE1_CN;
+		case DEGREE2:
+			return DEGREE2_CN;
+		case XHALF:
+			return XHALF_CN;
+		case YHALF:
+			return YHALF_CN;
+		case RECTALARM:
+			return RECTALARM_CN;
+		case AMPALARM:
+			return AMPALARM_CN;
+		case HAMPALARM:
+			return HAMPALARM_CN;
+		case ALARMWINMENU:
+			return ALARMWINMENU_CN;
+		case OPEN:
+			return OPEN_CN;
+		case DEFAULT:
+			return DEFAULT_CN;
+		case RESTORE:
+			return RESTORE_CN;
+		case RESTOREDEFAULT:
+			return RESTOREDEFAULT_CN;
+		case REBOOTMSG:
+			return REBOOTMSG_CN;
+		case CLEANBUF:
+			return CLEANBUF_CN;
+		case RUNTIME:
+			return RUNTIME_CN;
+		case KEYBEEP:
+			return KEYBEEP_CN;
+		case SHUTDOWNMSG1:
+			return SHUTDOWNMSG1_CN;
+		case SHUTDOWNMSG2:
+			return SHUTDOWNMSG2_CN;
+		case TIMESCALE:
+			return TIMESCALE_CN;
+		case TIMESCALESPEED:
+			return TIMESCALESPEED_CN;
+		case MIXINGINFO1:
+			return MIXINGINFO1_CN;
+		case PRIFREQ:
+			return PRIFREQ_CN;
+		case SECFREQ:
+			return SECFREQ_CN;
+		case MIXFACTOR:
+			return MIXFACTOR_CN;
+		case MIXFACTORCOMFIRM:
+			return MIXFACTORCOMFIRM_CN;
+		case SAVEMIXCOMFIRM:
+			return SAVEMIXCOMFIRM_CN;
+		case X1POINT:
+			return X1POINT_CN;
+		case Y1POINT:
+			return Y1POINT_CN;
+		case X2POINT:
+			return X2POINT_CN;
+		case Y2POINT:
+			return Y2POINT_CN;
+		case GAINRATIO:
+			return GAINRATIO_CN;
+		case CLEANPHOTO:
+			return CLEANPHOTO_CN;
+		case OZKDISPLAY:
+			return OZKDISPLAY_CN;
+		case XNPOINT:
+			return XNPOINT_CN;
+		case YNPOINT:
+			return YNPOINT_CN;
+		case SCOPE:
+			return SCOPE_CN;
+		case WHOLE:
+			return WHOLE_CN;
+		case CROSSCHAN:
+			return CROSSCHAN_CN;
+		case ALARMLIMIT:
+			return ALARMLIMIT_CN;
+		case COMBINING:
+			return COMBINING_CN;
+		case ASCANCHAN:
+			return ASCANCHAN_CN;
+		case EMSGAIN:
+			return EMSGAIN_CN;
+		case ASCANSPEED:
+			return ASCANSPEED_CN;
+		case PARASYNC:
+			return PARASYNC_CN;
+		case PARASYNCCOMFIRM:
+			return PARASYNCCOMFIRM_CN;
+		case RESBALACE:
+			return RESBALACE_CN;
+		case ADRIVE: 		
+			return ADRIVE_CN;
+		case BDRIVE: 		
+			return BDRIVE_CN;
+		case APICK: 		
+			return APICK_CN;
+		case BPICK: 		
+			return BPICK_CN;
+		case RFFILTER:
+			return RFFILTER_CN;
+		case PRECISION:
+			return PRECISION_CN;
+		case PREHIGH:
+			return PREHIGH_CN;
+		case PREMED:
+			return PREMED_CN;
+		case PRELOW:
+			return PRELOW_CN;
+		case OPERATION:
+			return OPERATION_CN;
+		default:
+			return NONE_CN;
+	}
+}
diff --git a/src/EVA11/base/Language.h b/src/EVA11/base/Language.h
new file mode 100644
index 0000000..978c54f
--- /dev/null
+++ b/src/EVA11/base/Language.h
@@ -0,0 +1,48 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Language.h
+ *
+ *    Description:  Manage the Language string
+ *
+ *        Version:  1.0
+ *        Created:  2011年02月10日 13时35分52秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _LANGUAGE_INC
+#define  _LANGUAGE_INC
+
+#include 	<memory>
+#include 	"ProjectGBText.h"
+
+class Language
+{
+	public:
+		static Language* Instance();             /* only used this function to visit variables   */
+
+		char const *GetText(int index);
+		inline int GetLang(){ return m_Langue;}
+		inline void SetLang(int value) { m_Langue = value;}
+	protected:
+	private:
+		Language ();
+		~Language ();
+		Language (const Language&);
+		Language& operator = (const Language&);
+	private:
+		char const *Get_EN_Text(int index);
+		char const *Get_CN_Text(int index);
+	private:
+		friend class std::auto_ptr<Language>;
+		static std::auto_ptr<Language>		m_Instance;
+		int              			m_Langue;
+}; /* -----  end of class Language  ----- */
+
+#endif   /* ----- #ifndef language_INC  ----- */
diff --git a/src/EVA11/base/LimitManage.cpp b/src/EVA11/base/LimitManage.cpp
new file mode 100644
index 0000000..afafb83
--- /dev/null
+++ b/src/EVA11/base/LimitManage.cpp
@@ -0,0 +1,137 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  LimitManage.cpp
+ *
+ *    Description:  implementation of LimitManage class 
+ *
+ *        Version:  1.0
+ *        Created:  2013年04月07日 10时18分47秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Global.h"
+#include 	"LimitManage.h"
+#include 	"Basescreen.h"
+#include 	"AlarmRegion.h"
+
+LimitManage::LimitManage (int x,int y,int width,int heigh)
+	: Object(x,y,width,heigh)
+{
+}
+
+LimitManage::~LimitManage ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Alarm_Sets
+ *  Description:  Init the Alarm parameters 
+ * =====================================================================================
+ */
+void LimitManage::Init_Alarm_Sets(Graphic&)
+{
+	m_Alarm = new(std::nothrow) SLimitAlarm(m_X,m_Y,m_Width,m_Heigh);
+	m_Alarm->Set_Color(Basescreen::LA_FG_COLOR,g_BUTXNO_CO);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_Alarm_Sets
+ *  Description:  Destroy the Alarm Sets 
+ * =====================================================================================
+ */
+void LimitManage::Destroy_Alarm_Sets()
+{
+	delete m_Alarm;
+	m_Alarm = NULL;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm window parameters into Object 
+ * =====================================================================================
+ */
+void LimitManage::Load_Alarm_Para(int gpalarm)
+{
+	m_Alarm->Set_4Para(gpalarm,
+				       0,
+				       0,
+				       0);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Alarm_Para
+ *  Description:  Save Alarm window parameters into Object 
+ * =====================================================================================
+ */
+void LimitManage::Save_Alarm_Para(int& gpalarm)
+{
+	Global *gp = Global::Instance();
+	gpalarm = m_Alarm->Get_P1();
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Alarm_Sets
+ *  Description:  Draw all class manage alarm on screen 
+ * =====================================================================================
+ */
+void LimitManage::Draw_Alarm_Sets(Graphic& g,bool bufflag)
+{
+	Global *gp = Global::Instance();
+//	if 	( m_AlarmType == 3 ) return;
+
+	if ( bufflag == true )
+		g.Switch_Screen();
+
+	m_Alarm->Drawme(g,false);
+
+	if ( bufflag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Adj_P1
+ *  Description:  Adjust the 1 parameters of device 
+ * =====================================================================================
+ */
+void LimitManage::Adj_P1(int v,int& gpalarm)
+{
+	Global *gp = Global::Instance();
+
+	m_Alarm->Adj_P1(v);
+
+	Save_Alarm_Para(gpalarm);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Is_In_Alarm
+ *  Description:  Judge the signal whether in Alarm 
+ * =====================================================================================
+ */
+int LimitManage::Is_In_Alarm(const int& x,const int& y)
+{
+	Global *gp = Global::Instance();
+
+	if ( m_Alarm->Is_In_Region(x,y) )
+		return 0;
+	else
+		return 0xff;
+}
diff --git a/src/EVA11/base/LimitManage.h b/src/EVA11/base/LimitManage.h
new file mode 100644
index 0000000..06c6ff7
--- /dev/null
+++ b/src/EVA11/base/LimitManage.h
@@ -0,0 +1,47 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  LimitManage.h
+ *
+ *    Description:  Something like the AlarmManage class 
+ *
+ *        Version:  1.0
+ *        Created:  2013年04月07日 10时14分13秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  LIMITMANAGE_INC
+#define  LIMITMANAGE_INC
+
+class Object;
+class IAlarm;
+class LimitManage : public Object
+{
+	public:
+		LimitManage (int x,int y,int width,int heigh);
+		virtual ~LimitManage();
+
+		void Init_Alarm_Sets(Graphic&);
+		void Destroy_Alarm_Sets();
+
+		void Load_Alarm_Para(int gpalarm);
+		void Save_Alarm_Para(int& gpalarm);
+
+		void Draw_Alarm_Sets(Graphic& g,bool bufflag=false);
+
+		void Adj_P1(int,int& gpalarm); 
+
+		int Is_In_Alarm(const int& x,const int& y); 
+	protected:
+
+	private:
+		IAlarm*			m_Alarm;
+};
+
+#endif   /* ----- #ifndef LIMITMANAGE_INC  ----- */
diff --git a/src/EVA11/base/Loadwin.cpp b/src/EVA11/base/Loadwin.cpp
new file mode 100644
index 0000000..db04d6b
--- /dev/null
+++ b/src/EVA11/base/Loadwin.cpp
@@ -0,0 +1,605 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Loadwin.cpp
+ *
+ *    Description:  Implementation of Loadwin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 14时39分24秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<typeinfo>
+#include 	<fstream>
+
+#include 	<boost/format.hpp>
+
+#include 	"Basewin.h"
+#include	"Loadwin.h"
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Logic.h"
+#include	"Label.h"
+#include	"Language.h"
+#include	"Global.h"
+#include	"Msgbox.h"
+#include	"Battery.h"
+#include 	"Parawin.h"
+#include 	"Algorithm.h"
+
+#include 	"FreeType.h"
+#include 	"Png.h"
+
+#include 	"Resource.h"
+
+Loadwin::Loadwin (Graphic&g,LOADTYPE type)
+{
+	m_Type = type;
+}
+
+Loadwin::~Loadwin ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object of screen 
+ * =====================================================================================
+ */
+void Loadwin::Init_GUI(Graphic& g)
+{
+        m_Title = new Label(90,12,460,30);
+	m_Title->Set_Label_Type(Label::LA_NONE);
+	m_Title->Set_Text(m_pl->GetText(MAINTITLE));
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+
+	Sub_Init_GUI(g);
+
+	m_NorLable[26] = new Label(3+424,53+39*9,210,38);
+	m_NorLable[26]->Set_Label_Type(Label::LA_3D);
+	m_NorLable[26]->Set_Text(m_pl->GetText(MAINBUTTON));
+	m_NorLable[26]->Set_Font_Size(18);
+	m_NorLable[26]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_NorLable[26]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	m_NorLable[26]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	m_NorLable[26]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+	m_BottomFocus = 1;
+	m_NormalFocus = 27;
+	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+	m_BomButton[m_BottomFocus-1]->Set_Focus(true);
+
+	for ( int i=0;i<3;i++ )	
+	{
+		m_BlankLable[i] = new Label(3+424,53+39*(i+6),210,38);
+		m_BlankLable[i]->Set_Text(m_pl->GetText(RESERVE));
+		m_BlankLable[i]->Set_Label_Type(Label::LA_3D);
+		m_BlankLable[i]->Set_Font_Size(18);
+		m_BlankLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_BlankLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_BlankLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_BlankLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	}
+
+	std::string s = str(boost::format("Ver:%s")%PROVERSION);
+	m_Version = new Label(8+40,15,70,22);
+	m_Version->Set_Font_Size(16);
+	m_Version->Set_Text(s.c_str());
+	m_Version->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Version->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_Version->Set_Label_Type(Label::LA_NONE);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void Loadwin::Destroy_GUI()
+{
+	if ( m_Title != NULL )
+	{
+		delete m_Title;
+		m_Title = NULL;
+	}
+	if ( m_SubTitle != NULL )
+	{
+		delete m_SubTitle;
+		m_SubTitle = NULL;
+	}
+	if ( m_Version != NULL )
+	{
+		delete m_Version;
+		m_Version = NULL;
+	}
+	for ( int i=0;i<27;i++ )
+	{
+		if ( m_NorLable[i] != NULL ) 
+		{
+			delete m_NorLable[i];
+			m_NorLable[i] = NULL;
+		}
+	}
+	for ( int i=0;i<3;i++ )	
+	{
+		if ( m_BlankLable[i] != NULL ) 
+		{
+			delete m_BlankLable[i];
+			m_BlankLable[i] = NULL;
+		}
+	}
+	Basewin::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bom_Index
+ *  Description:  Return the Bom button text 
+ *        index: from 0 to 6
+ * =====================================================================================
+ */
+const char*Loadwin::Get_Bom_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0: 
+			return m_pl->GetText(PREVIOUSE);
+			break;
+		case 1: 
+			return m_pl->GetText(NEXT);
+			break;
+		case 2: 
+			return m_pl->GetText(LEFTC);
+			break;
+		case 3: 
+			return m_pl->GetText(RIGHTC);
+			break;
+		case 4: 
+			return m_pl->GetText(NONE);
+			break;
+		case 5: 
+			return m_pl->GetText(COMFIRM);
+			break;
+		case 6: 
+			return m_pl->GetText(BACKOUT);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_Title
+ *  Description:  Init the normal button title 
+ * =====================================================================================
+ */
+void Loadwin::Init_Normal_Title()
+{
+	char oc;
+	int num;
+
+	for ( int i = 0; i < TITLECOUNT ; i += 1 )
+	{
+		m_Text[i]	=	" ";
+	}
+
+	std::string strfilename = str(boost::format("%s%s")%RUN_PATH%"PAR.NAM");
+	std::fstream filestream;                /* used by save data */
+	filestream.open(strfilename.c_str(),std::ios::in|std::ios::out);
+
+	if (!filestream)
+		perror("Not Found The PAR.NAM File,Continue....\n");
+	else
+	{
+		int i=0;
+		int index=0;
+		while(!filestream.eof())        /* go through the whold file do preparation of the menu text*/
+		{
+			filestream.get(oc);
+			if (oc >= 'A' && oc <= 'Z' )
+			{
+				index = oc - 0x41;
+				filestream.get(oc);
+				if (oc == ' ')
+				{
+					if ( i != index ) i = index;
+					m_Text[i] = ""; /* reset the value of string */
+					filestream.get(oc);
+					do
+					{
+						m_Text[i] = m_Text[i] + oc;	
+						filestream.get(oc);
+					}while( oc!=0x0d && !filestream.eof() );
+					i = i + 1;
+				}
+			}
+		}
+		filestream.close();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ * =====================================================================================
+ */
+void Loadwin::Drawme (Graphic& g)
+{
+	Basewin::Drawme(g);
+	m_Title->Drawme(g);
+	m_SubTitle->Drawme(g);
+	m_Version->Drawme(g);
+
+	Resource *res = Resource::Instance();
+	res->Show_Resource_Png(g,7,5,5);
+
+	for ( int i=0;i<27;i++ )
+	{
+		m_NorLable[i]->Drawme(g);
+	}
+	for ( int i=0;i<3;i++ )
+	{
+		m_BlankLable[i]->Drawme(g);
+	}
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function 
+ *       return:  0: Exit program
+ *                1: goto Mainwin
+ * =====================================================================================
+ */
+int Loadwin::Loopwindow (Graphic &g)
+{
+	return SubLoopwindow(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Loadwin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+	return CO_NONE;
+}
+int Loadwin::Key_Bom2_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,2);
+	return CO_NONE;
+}
+int Loadwin::Key_Bom3_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,3);
+	return CO_NONE;
+}
+int Loadwin::Key_Bom4_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,4);
+	return CO_NONE;
+}
+int Loadwin::Key_Bom6_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,6);
+	return CO_OK;
+}
+int Loadwin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Loadwin::Key_Esc_Fun(Graphic& g)
+{
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(COMFIRMEXIT),Msgbox::MSG_OKCANCEL);	
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == true )
+	{
+		delete ms;
+		ms = NULL;
+		return CO_EXIT;
+	}
+	delete ms;
+	ms = NULL;
+	return CO_NONE;
+}
+int  Loadwin::Key_Enter_Fun(Graphic& g)
+{
+	return Key_Bom6_Fun(g);
+}
+
+int Loadwin::Key_F5_Fun(Graphic& g)
+{
+	Logic* lo = Logic::Instance();
+	lo->Screen_Shoot(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  As the input parameter index to set the bottoms button status  
+ * =====================================================================================
+ */
+void Loadwin::DrawBottomFocus(Graphic& g,int index)
+{
+	Basewin::DrawBottomFocus(g,index);
+	switch ( index ) 
+	{
+		case 1:                         /* previouse */
+			{
+				if ( m_NormalFocus == 1 )
+				{
+				        m_NormalFocus = 27;
+					m_NorLable[0]->Set_Focus(false);
+					m_NorLable[0]->Drawme(g);
+					m_NorLable[26]->Set_Focus(true);
+					m_NorLable[26]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus--;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+
+			}
+			break;
+		case 2:                         /* next */
+			{
+				if ( m_NormalFocus == 27 )
+				{
+				        m_NormalFocus = 1;
+					m_NorLable[26]->Set_Focus(false);
+					m_NorLable[26]->Drawme(g);
+					m_NorLable[0]->Set_Focus(true);
+					m_NorLable[0]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus++;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 3:                         /* left  */
+			{
+				if ( m_NormalFocus < 7 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 20;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus >= 7 && m_NormalFocus <= 9 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus == 10 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus = 27;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus == 27 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus = 20;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 4:                         /* right */
+			{
+				if ( m_NormalFocus > 20 && m_NormalFocus != 27 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 20;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus <= 19 && m_NormalFocus > 16 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus == 20 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus = 27;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus == 27 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus = 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SubLoopwindow
+ *  Description:  SubLoopwindow function for Loopwindow 
+ * =====================================================================================
+ */
+int Loadwin::SubLoopwindow(Graphic &g)
+{
+	int result = 0;
+	Init_Normal_Title();
+	Init_GUI(g);
+	Drawme(g);
+
+	while( 1 )
+	{
+		result = Command_Process(g);
+		if 	( result == CO_EXIT )
+			goto Exit;
+		else if ( result == CO_OK )
+		{
+			if  	( m_NormalFocus == 27 )
+			{
+				m_alg->MDelay(100);
+				goto Exit;
+			}
+			else
+			{
+				Parawin *paraw;
+				if 	( m_Type == LT_LOAD )
+					paraw = new Parawin(Parawin::PT_LOAD,'a'+m_NormalFocus-1);
+				else if ( m_Type == LT_SAVE )
+					paraw = new Parawin(Parawin::PT_SAVE,'a'+m_NormalFocus-1);
+				else if ( m_Type == LT_DELE )
+					paraw = new Parawin(Parawin::PT_DELE,'a'+m_NormalFocus-1);
+
+				else if ( m_Type == DA_LOAD )
+					paraw = new Parawin(Parawin::DA_LOAD,'a'+m_NormalFocus-1);
+				else if ( m_Type == DA_SAVE )
+					paraw = new Parawin(Parawin::DA_SAVE,'a'+m_NormalFocus-1);
+				else if ( m_Type == DA_DELE )
+					paraw = new Parawin(Parawin::DA_DELE,'a'+m_NormalFocus-1);
+
+				result = paraw->Loopwindow(g);
+				delete paraw;
+				paraw = NULL;
+				if 	( result == CO_LOADEXIT )
+					goto Exit;
+			}
+		}
+	}
+
+Exit:
+	Destroy_GUI();
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sub_Init_GUI
+ *  Description:  Subversion to init GUI 
+ * =====================================================================================
+ */
+void Loadwin::Sub_Init_GUI(Graphic &g)
+{
+	Basewin::Init_GUI(g);
+	/*-----------------------------------------------------------------------------
+	 *  Init the buttom line buttons
+	 *-----------------------------------------------------------------------------*/
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+	}	
+
+	m_BomSmall->Set_Text("X");
+
+	m_SubTitle = new Label(550,25,80,22);
+	m_SubTitle->Set_Label_Type(Label::LA_NONE);
+	m_SubTitle->Set_Text(m_pl->GetText(SUBTITLE));
+	m_SubTitle->Set_Font_Size(16);
+	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+
+	if 	( m_gp->Language == 1 )
+		m_Title->Set_Font_Size(16);
+	else if ( m_gp->Language == 0 )
+		m_Title->Set_Font_Size(26);
+
+	for ( int i=0;i<10;i++ )
+	{
+		m_NorLable[i] = new Label(3,53+39*i,210,38);
+		m_NorLable[i]->Set_Label_Type(Label::LA_3D);
+		m_NorLable[i]->Set_Text((char *)m_Text[i].c_str());
+		m_NorLable[i]->Set_Font_Size(18);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	}
+	for ( int i=0;i<10;i++ )
+	{
+		m_NorLable[10+i] = new Label(3+212,53+39*i,210,38);
+		m_NorLable[10+i]->Set_Label_Type(Label::LA_3D);
+		m_NorLable[10+i]->Set_Text((char *)m_Text[i+10].c_str());
+		m_NorLable[10+i]->Set_Font_Size(18);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	}
+	for ( int i=0;i<6;i++ )
+	{
+		m_NorLable[20+i] = new Label(3+424,53+39*i,210,38);
+		m_NorLable[20+i]->Set_Label_Type(Label::LA_3D);
+		m_NorLable[20+i]->Set_Text((char *)m_Text[i+10].c_str());
+		m_NorLable[20+i]->Set_Font_Size(18);
+		m_NorLable[20+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[20+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[20+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[20+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	}
+}
diff --git a/src/EVA11/base/Loadwin.h b/src/EVA11/base/Loadwin.h
new file mode 100644
index 0000000..a9e5adf
--- /dev/null
+++ b/src/EVA11/base/Loadwin.h
@@ -0,0 +1,79 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Loadwin.h
+ *
+ *    Description:  Manage the Parameters loading 
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 14时37分32秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _LOADWIN_INC
+#define  _LOADWIN_INC
+
+#include 	<string>
+class Loadwin : public Basewin
+{
+	public:
+		enum LOADTYPE 
+		{
+			LT_LOAD,
+			LT_SAVE,
+			LT_DELE,
+
+			DA_LOAD,	
+			DA_SAVE,
+			DA_DELE
+		};						                 /* ----------  end of enum LOADTYPE  ---------- */
+		typedef enum LOADTYPE LOADTYPE;
+
+		Loadwin (Graphic&g,LOADTYPE type);   		                 /* constructor */
+		virtual ~Loadwin ();                           	                 /* destructor */
+
+		void Drawme (Graphic& g);       		                 /* Any window coming from window class draw itself on screen */
+		int Loopwindow (Graphic &);        		                 /* deal with the command getting from key board  */
+
+	protected:
+		virtual int Key_Bom1_Fun(Graphic& g);
+		virtual int Key_Bom2_Fun(Graphic& g);
+		virtual int Key_Bom3_Fun(Graphic& g);
+		virtual int Key_Bom4_Fun(Graphic& g);
+		virtual int Key_Bom6_Fun(Graphic& g);
+		virtual int Key_Bom7_Fun(Graphic& g);
+
+		virtual int Key_Esc_Fun(Graphic& g);
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual int Key_F5_Fun(Graphic& g); 
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		void Init_Normal_Title();
+		const char*Get_Bom_Text(int);
+		void DrawBottomFocus(Graphic &g,int index);     		 /* change the bottom buttons status as the parameter index */
+
+		int SubLoopwindow(Graphic &);
+		void Sub_Init_GUI(Graphic &);
+
+	protected:
+		static const int		     TITLECOUNT = 26;
+
+		int                                  m_NormalFocus;
+		std::string 			     m_Text[TITLECOUNT];
+		LOADTYPE                             m_Type;
+		Label                               *m_Title;
+		Label                               *m_SubTitle;
+		Label                               *m_Version;
+		Label                               *m_NorLable[27];             /* Normal Lines A~Z and Normal detect */
+		Label                               *m_BlankLable[3];            /* Nothing function                   */
+}; /* -----  end of class Loadwin  ----- */
+#endif   /* ----- #ifndef _LOADWIN_INC  ----- */
diff --git a/src/EVA11/base/Log.cpp b/src/EVA11/base/Log.cpp
new file mode 100644
index 0000000..928a0a0
--- /dev/null
+++ b/src/EVA11/base/Log.cpp
@@ -0,0 +1,146 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Log.cpp
+ *
+ *    Description:  Implementation of Log class
+ *
+ *        Version:  1.0
+ *        Created:  2013年06月05日 15时05分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<unistd.h>
+#include 	<sys/types.h>
+#include 	<dirent.h>
+#include	<cstdio>
+
+#include 	<log4cplus/logger.h>
+#include 	<log4cplus/loggingmacros.h>
+#include 	<log4cplus/configurator.h>
+#include 	<log4cplus/fileappender.h>
+
+#include	"main.h"
+#include	"Log.h"
+
+std::auto_ptr<Log> Log::m_Instance;
+
+struct Log::PImpl
+{
+	log4cplus::Logger 		    m_log;
+	int				    m_Files_Amount;
+	char*				    m_Msg;
+};
+
+Log::Log() : m_Imple(new struct PImpl)
+{
+	log4cplus::BasicConfigurator config;
+	config.configure();
+
+	m_Imple->m_log = log4cplus::Logger::getInstance(LOG4CPLUS_TEXT("EVA11"));
+	m_Imple->m_log.setLogLevel(log4cplus::INFO_LOG_LEVEL);
+
+	Create_Log_Directory_File();
+
+	m_Imple->m_Msg = new char[200];
+}
+
+Log::~Log()
+{
+	delete[] m_Imple->m_Msg;
+	m_Imple->m_Msg = NULL;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Log* Log::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Log() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_Log
+ *  Description:  Write the Log into media
+ * =====================================================================================
+ */
+void Log::Write_Log(const char* log)
+{
+	struct tm *timenow;
+	time_t now;
+	time(&now);
+	timenow = localtime(&now);
+
+	sprintf(m_Imple->m_Msg,"%04d-%02d-%02d %02d:%02d:%02d V%s %s",
+			timenow->tm_year+1900,timenow->tm_mon+1,timenow->tm_mday,
+			timenow->tm_hour,timenow->tm_min,timenow->tm_sec,PROVERSION,log);
+
+	LOG4CPLUS_INFO(m_Imple->m_log,LOG4CPLUS_TEXT(m_Imple->m_Msg));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Create_Log_Directory
+ *  Description:  Create the Log directory and file 
+ * =====================================================================================
+ */
+void Log::Create_Log_Directory_File()
+{
+	char *file = new char[100];
+	if ( access(LOGDIRECTORY,0) != 0 )
+	{
+		sprintf(file,"mkdir -p %s",LOGDIRECTORY);
+		int re = system(static_cast<const char*>(file));
+		m_Imple->m_Files_Amount = 0;
+	}
+	struct tm *timenow;
+	time_t now;
+	time(&now);
+	timenow = localtime(&now);
+	sprintf(file,"%s/EVA11-P%03d-%04d-%02d-%02d-%02d-%02d-%02d.log",LOGDIRECTORY,m_Imple->m_Files_Amount+1,timenow->tm_year+1900,timenow->tm_mon+1,timenow->tm_mday,timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+	log4cplus::SharedAppenderPtr append(new log4cplus::FileAppender(file));
+	append->setName("EVA11 log File");
+	m_Imple->m_log.addAppender(append);
+	delete[] file;
+	file = NULL;
+	sync();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Scan_Files_Amount
+ *  Description:  Scan the Files of log directory amount 
+ * =====================================================================================
+ */
+void Log::Scan_Files_Amount()
+{
+	DIR *dp;
+	struct dirent *dirp;
+	m_Imple->m_Files_Amount = 0;
+
+	if ( ( dp = opendir(LOGDIRECTORY) ) == NULL )
+		printf ( "not open directory \n" );
+	else
+	{
+		while( ( dirp = readdir(dp) ) != NULL )
+		{
+			m_Imple->m_Files_Amount ++;
+		}
+
+		m_Imple->m_Files_Amount -= 2;		//directory:  .   ..
+		closedir(dp);
+	}
+}
diff --git a/src/EVA11/base/Log.h b/src/EVA11/base/Log.h
new file mode 100644
index 0000000..9a58289
--- /dev/null
+++ b/src/EVA11/base/Log.h
@@ -0,0 +1,46 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Log.h
+ *
+ *    Description:  manage the Log class,write Log messgae into file or 
+ *                  show them on screen
+ *
+ *        Version:  1.0
+ *        Created:  2013年06月05日 15时05分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  LOG_INC
+#define  LOG_INC
+
+#include 	<memory>	
+class Log
+{
+	public:
+		static Log* Instance();
+		void Write_Log(const char*);
+
+	private:
+		Log ();                             /* constructor */
+		~Log ();                            /* destructor  */
+		Log( const Log& );
+		Log& operator = (const Log&);
+
+		void Create_Log_Directory_File();
+		void Scan_Files_Amount();
+	private:
+		friend class std::auto_ptr<Log>;
+		static std::auto_ptr<Log>    	    m_Instance;
+
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	    m_Imple;
+};
+
+#endif
diff --git a/src/EVA11/base/Logic.cpp b/src/EVA11/base/Logic.cpp
new file mode 100644
index 0000000..a3d4626
--- /dev/null
+++ b/src/EVA11/base/Logic.cpp
@@ -0,0 +1,997 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Logic.cpp
+ *
+ *    Description:  Implementation of Logic class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 15时36分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdio>
+#include	<iostream>
+#include	<fstream>
+#include	<sys/vfs.h>
+#include 	<boost/bind.hpp>
+
+#include 	"Graphic.h"
+#include 	"Logic.h"
+#include	"Msgbox.h"
+#include 	"Device.h"
+#include 	"Language.h"
+#include 	"Algorithm.h"
+#include	"Global.h"
+#include 	"JpegOper.h"
+#include 	"DataRepo.h"
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"ManageMD5.h"
+#include 	"Gradual.h"
+#include 	"MixingManage.h"
+#include 	"FreeType.h"
+
+std::auto_ptr<Logic> Logic::m_Instance;
+
+Logic::Logic ()
+{
+	m_pl     	= Language::Instance();
+	m_alg    	= Algorithm::Instance();
+	m_device 	= Device::Instance();
+	m_gp     	= Global::Instance();
+	m_repo		= DataRepo::Instance();
+
+	m_SuffixJpeg    = ".jpeg"; 
+
+#ifdef X86
+#else
+	m_ADC_fd = open("/dev/ADC", O_RDWR);
+	if ( m_ADC_fd < 0 ) { perror("Unable to open the ADC file!"); }
+#endif
+}  /* -----  end of method Logic::Logic  (constructor)  ----- */
+
+Logic::~Logic ()
+{
+#ifdef X86
+#else
+	if ( m_ADC_fd != -1 )
+	{
+		close(m_ADC_fd);
+	}
+#endif
+}  /* -----  end of method Logic::~Logic  (destructor)  ----- */
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+Logic* Logic::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Logic() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Hardware
+ *  Description:  Init the FPGA work mode 
+ * =====================================================================================
+ */
+void Logic::Init_Hardware(Graphic& g)
+{
+	if 	( m_device->Init_ET_Board() == false )
+	{
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG09),Msgbox::MSG_OK);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g);
+		delete ms;
+		ms = NULL;
+		while(1);                                                /* Waiting shutdown 		  */
+	}
+	else
+	{
+		m_g = &g;
+		for ( int i = 0; i < 10; i += 1 ) 			/* Just clean unstable key status */
+			Get_Key();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ShutDownMsg
+ *  Description:  
+ * =====================================================================================
+ */
+void Logic::ShutDownMsg(const boost::system::error_code & e)
+{
+	printf ( "Shutdown Device!\n" );
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_Hardware
+ *  Description:  Release the Hardware source
+ * =====================================================================================
+ */
+void Logic::Release_Hardware()
+{
+	m_device->UnInit_ET_Board();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Global_Variables_Into_PCB
+ *  Description:  Set device all partial_sumrameters into FPGA  
+ *                call it, when set to default value or start the device 
+ * =====================================================================================
+ */
+void Logic::Set_Global_Variables_Into_PCB()
+{
+	m_device->Write_Para_Func(Device::NORMAL);
+	for ( int ch=0;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		m_device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		m_device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		m_device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+
+		m_device->Write_Para_DriverBal(ch,m_gp->DriverBal[ch]);
+		m_device->Write_Para_DriveA_ID(ch,m_gp->DriverA_ID[ch]);
+		m_device->Write_Para_DriveB_ID(ch,m_gp->DriverB_ID[ch]);
+		m_device->Write_Para_PickA_ID(ch,m_gp->PickA_ID[ch]);
+		m_device->Write_Para_PickB_ID(ch,m_gp->PickB_ID[ch]);
+	}
+
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		m_device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	m_device->Write_Para_Driver(m_gp->Driver);
+	m_device->Write_Para_Offset(m_gp->Offset);
+	m_device->Write_Para_SignalWave(0);
+
+	m_device->Transfer_ECT_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Global_Variables_Into_System
+ *  Description:  We need one function to calculate system variables into system 
+ * =====================================================================================
+ */
+void Logic::Set_Global_Variables_Into_System()
+{
+	m_gp->Calculate_Gain();
+	m_pl->SetLang(m_gp->Language);
+	Reset_Data_Repo();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_Data_Repo
+ *  Description:  Reset the Data of Repo 
+ *                when chang the display panel need call it to chang the each loop 
+ *                word cout
+ * =====================================================================================
+ */
+void Logic::Reset_Data_Repo()
+{
+	if 	( m_gp->PanelType == 2 )             // Single ZKScreen
+		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),1<<2);
+	else if ( m_gp->PanelType == 3 )             // Double ZKScreen
+		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),2<<2);
+	else if ( m_gp->PanelType == 4 )             // Oct ZKScreen
+		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),16<<2);
+	else if ( m_gp->PanelType == 5 )             // Composite ZKScreen
+		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),2<<2);
+	else 
+		m_repo->Reset_Data_Repo((m_gp->DataBufLength>>2),Global::CHANCOUNT<<2);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Key
+ *  Description:  Get the Key Value from device or keyboard 
+ * =====================================================================================
+ */
+int Logic::Get_Key()
+{
+	if 	( KEYSOURCE == 0 )
+	{
+		return Get_Key_From_Keyboard();
+	}
+	else if ( KEYSOURCE == 1 )
+	{
+		return Get_Key_From_FPGA(); 
+	}
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Key_From_FPGA
+ *  Description:  Get key value from FPGA 
+ * =====================================================================================
+ */
+int Logic::Get_Key_From_FPGA()
+{
+	if 	( !( m_device->Read_Port(0x0006) & 0x40) )
+	{
+		m_alg->MDelay(1500);
+		if	( !(m_device->Read_Port(0x0006) & 0x40) )
+		{
+			Shutdown();
+			while(1);
+		}
+	}
+
+	int key = m_device->Read_Port(0x002F);
+
+	if 	( key & 0x80 )
+	{
+		if ( m_gp->MultiKey < 30 ) m_gp->MultiKey ++;
+
+		if ( m_gp->KeyBeep == true )
+			Short_Beep();
+		return (key & 0x7f);
+	}
+	else if ( key == 0 )
+	{
+		m_gp->MultiKey = 0;
+		return key;
+	}
+	else
+	{
+		m_gp->MultiKey = 0;
+		if ( m_gp->KeyBeep == true )
+			Short_Beep();
+		return (key & 0x7f);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Key_From_Keyboard
+ *  Description:  Get the key value form keyboard 
+ * =====================================================================================
+ */
+int Logic::Get_Key_From_Keyboard()
+{
+	int key;                                			/* because the getchar function return int type  */
+	key = getchar();
+
+	if ( key == 27 )
+	{
+		key = getchar();
+		if ( key == -1 ) return KEY_ESC;
+		else if ( key == 91 )           			/* function key value */
+		{
+			key = getchar();
+			if ( key == 49 ) 
+			{
+				key = getchar();
+				if ( key == 55 )
+				{
+					key = getchar();
+					if ( key == 126 )
+					{
+						return KEY_F6; 		/* F6 key value */
+					}
+				}
+			}
+			else if ( key == 91 )
+			{
+				key = getchar();
+				if ( key == 65 ) return KEY_F1;
+				if ( key == 66 ) return KEY_F2;
+				if ( key == 67 ) return KEY_F3;
+				if ( key == 68 ) return KEY_F4;
+			}
+		}
+	}
+	else
+	{
+		if 	( key == 0xffffffff )
+			return 0;
+		else
+			return key;                    			/* Normal key return immediately */
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Shutdown
+ *  Description:  When user instruct, closed the power
+ * =====================================================================================
+ */
+void Logic::Shutdown()
+{
+	boost::asio::io_service io;
+	boost::asio::deadline_timer t(io,boost::posix_time::seconds(3));
+
+	t.async_wait(boost::bind(&Logic::ShutDownMsg,this,_1));
+
+	short m_BGColor = g_BUBGNO_CO;
+	short m_FGColor = g_BUTXNO_CO;
+
+	short x         = 180;
+	short y         = 160;
+	short basex     = x;
+	short basey     = y;
+	short width     = 310;
+	short heigh     = 68;
+	int   ft        = 16;
+	unsigned char *mem = new unsigned char[m_g->Get_Disp_Area_Bytes(x,y,x+width-1,y+heigh-1)];
+	m_g->Load_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
+	/*-----------------------------------------------------------------------------
+	 *  Draw the front color 
+	 *-----------------------------------------------------------------------------*/
+	m_g->DrawFillRect(x,y,width,heigh,m_BGColor);
+
+	m_g->Setcolor(m_FGColor);
+	m_g->DrawRect(x,y,width,heigh);
+	m_g->DrawRect(x+1,y+1,width-2,heigh-2);
+	m_g->Setcolor(m_g->RGB24_16(0x000000));
+	m_g->DrawRect(x+2,y+2,width-4,heigh-4);
+	m_g->DrawRect(x+3,y+3,width-6,heigh-6);
+	m_g->Setcolor(m_FGColor);
+	m_g->DrawRect(x+4,y+4,width-8,heigh-8);
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,m_FGColor);
+	font->Set_Color(FreeType::BGCOLOR,m_BGColor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(basex+90+21,basey+10+17,m_pl->GetText(SHUTDOWNMSG1));
+	font->Text(basex+14+21,basey+35+17,m_pl->GetText(SHUTDOWNMSG2));
+
+	Pre_Shutdown();
+
+	io.run();
+
+	sync();
+
+	m_g->Restore_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
+	delete[] mem;
+	mem = NULL;
+
+	m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)|0x80);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pre_Shutdown
+ *  Description:  Before shutdown we need to do some job 
+ * =====================================================================================
+ */
+void Logic::Pre_Shutdown()
+{
+	/*-----------------------------------------------------------------------------
+	 * Save parameters into flash 
+	 *-----------------------------------------------------------------------------*/
+	Global *pgp = Global::Instance();
+	pgp->Save_Global_Variables(PAR_FILE_PATH);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Alarm_Beep
+ *  Description:  Set the beep operation status
+ *                status: true set the beep and led 
+ * =====================================================================================
+ */
+void Logic::Alarm_Beep(bool status)
+{
+	if 	( status == true )                             /* set the status of led on detect object  */
+		m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)|0x40);
+	else
+		m_device->Write_Port(0x3E,m_device->Read_Port(0x3E)&0xBF);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Short_Beep
+ *  Description:  Alarm a short beep 
+ * =====================================================================================
+ */
+void Logic::Short_Beep()
+{
+	Alarm_Beep(true);
+	m_alg->MDelay(40);
+	Alarm_Beep(false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Frequence_2_Char
+ *  Description:  Convert frequence to char 
+ * =====================================================================================
+ */
+void Logic::Frequence_2_Char(int freqvalue,char* msg)
+{
+	if 	( freqvalue > 9999 && freqvalue <= 99999 )
+	{
+		sprintf(msg,"%.2fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
+	}
+	else if ( freqvalue > 99999 && freqvalue < 1000000 )
+	{
+		sprintf(msg,"%.1fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
+	}
+	else if ( freqvalue >= 1000000 )
+	{
+		sprintf(msg,"%.0fKHz",static_cast<double>(freqvalue)/static_cast<double>(1000));
+	}
+	else
+		sprintf(msg,"%d Hz",freqvalue);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Probe_Fun_2_Char
+ *  Description:  Convert Probe Fun 2 char
+ * =====================================================================================
+ */
+void Logic::Probe_Fun_2_Char(int chan,int probefun,int freq,char* msg)
+{
+	switch ( probefun ) 
+	{
+		case 1:	
+			sprintf(msg,"S%d(ET F%d)",chan,freq);
+			break;
+
+		case 2:	
+			sprintf(msg,"S%d(FET F%d)",chan,freq);
+			break;
+
+		case 3:	
+			sprintf(msg,"S%d(EMS F%d)",chan,freq);
+			break;
+
+		default:	
+			sprintf(msg,"S%d(-- F%d)",chan,freq);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Probe_Fun_2_Char_only
+ *  Description:  
+ * =====================================================================================
+ */
+void Logic::Probe_Fun_2_Char_Only(int probefun,char* msg)
+{
+	switch ( probefun ) 
+	{
+		case 1:	
+			sprintf(msg,"ET");
+			break;
+
+		case 2:	
+			sprintf(msg,"FET");
+			break;
+
+		case 3:	
+			sprintf(msg,"EMS");
+			break;
+
+		default:	
+			sprintf(msg,"ET");
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Convert_Hi_Low_Filterpass_2_Char
+ *  Description:  Convert Hight ot Low filterpass to char  
+ *       HiFlag:  true     HiFilter
+ *                false    LowFilter
+ * =====================================================================================
+ */
+void Logic::Convert_Hi_Low_Filterpass_2_Char(int value,bool HiFlag,char *msg)
+{
+	if 	( HiFlag == true )
+	{
+		if 	( value == 0 ) sprintf(msg,"%s",m_pl->GetText(CLOSED));
+		else if ( value == 100000 ) sprintf(msg,"%.dHz",10000);
+		else 
+			sprintf(msg,"%.1fHz",static_cast<float>(value)/static_cast<float>(10));
+	}
+	else
+	{
+		if 	( value == -1 ) sprintf(msg,"%s",m_pl->GetText(CLOSED));
+		else if ( value == 100000 ) sprintf(msg,"%.dHz",10000);
+		else sprintf(msg,"%.1fHz",static_cast<float>(value)/static_cast<float>(10));
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Check_Disk_Space
+ *  Description:  Check whether the disk space have enough space
+ *       return:  true:   There is enough space
+ *                false:  There is not enough space
+ *    needspace:  The space need to be save file
+ *  remainspace:  If return is false, it will save the remain space
+ *         Unit:  Bytes
+ * =====================================================================================
+ */
+bool Logic::Check_Disk_Space(const unsigned long long needspace,unsigned long long& remainspace)
+{
+	struct statfs diskinfo;
+	statfs(DATA_PATH,&diskinfo);
+	unsigned long long size = diskinfo.f_bsize*diskinfo.f_bfree;
+	if ( needspace > size )
+	{
+		remainspace = size;
+		return false;
+	}
+	else
+	{
+		remainspace = needspace;
+		return true;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Screen_Shoot
+ *  Description:  Save screen as JPEG formate 
+ * =====================================================================================
+ */
+void Logic::Screen_Shoot(Graphic& g)
+{
+	int index;
+	char *filename = new char[60];
+	JpegOper *jpeg = new JpegOper;
+	jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
+
+	/*-----------------------------------------------------------------------------
+	 *  Splash screen
+	 *-----------------------------------------------------------------------------*/
+	unsigned char* scr = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
+	g.Load_Disp_Area(0,0,639,479,scr);
+	g.DrawFillRect(0,0,640,480,0xffff);
+	m_alg->MDelay(20);
+	g.Restore_Disp_Area(0,0,639,479,scr);
+	delete[] scr;
+	scr = NULL;
+
+	if ( Check_Screen_Shoot_Available(index) == true )
+	{
+		char *data = new char[60];
+		sprintf(data,"%s%s%02d%s%s",m_pl->GetText(GRAPHICFILE),"pic",index,m_SuffixJpeg.c_str(),m_pl->GetText(GRAPHICSAVE));
+		Msgbox *ms = new Msgbox(180,170,300,100,data,Msgbox::MSG_OKCANCEL);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+
+		if ( ms->Showme(g) )
+		{
+			sprintf(filename,"%s%s%02d%s",PIC_PATH,"pic",index,m_SuffixJpeg.c_str());
+			jpeg->JpegCreateJpeg(filename,100);
+		}
+
+		delete ms;
+		ms = NULL;
+		delete[] data;
+		data = NULL;
+	}
+	else
+	{
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG10),Msgbox::MSG_OK);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g);
+		delete ms;
+		ms = NULL;
+	}
+
+	delete[] filename;
+	filename = NULL;
+	delete jpeg;
+	jpeg = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Check_Screen_Shoot_Available
+ *  Description:  Check the screen shoot number available 
+ * =====================================================================================
+ */
+bool Logic::Check_Screen_Shoot_Available(int &index)
+{
+	using namespace std;
+	bool result = false;
+	char *databuf = new char[60];
+	char *filename = new char[60];
+
+	for ( int i=0;i<m_MAXJpegCount;i++ )
+	{
+		sprintf(filename,"%s%s%02d%s",PIC_PATH,"pic",i,m_SuffixJpeg.c_str());
+		if ( access(filename,0) != 0 )
+		{
+			result = true;
+			index = i;
+			goto Exit;
+		}
+	}	
+	result = false;
+Exit:
+	delete[] databuf;
+	databuf = NULL;
+	delete[] filename;
+	filename = NULL;
+	return result; 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Update_Program
+ *  Description:  Update Program for device 
+ * =====================================================================================
+ */
+void Logic::Update_Program(Graphic& g)
+{
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(UPDATECOMFIRM),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == true )
+	{
+		delete ms;
+		ms = NULL;
+		Do_Update_Event(g);
+	}
+	delete ms;
+	ms = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Do_Update_Event
+ *  Description:  DO the Update Program Event 
+ * =====================================================================================
+ */
+void Logic::Do_Update_Event(Graphic& g)
+{
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
+	g.Load_Disp_Area(0,0,639,479,mem);
+	Label *lab = new Label(220,230,250,25);
+	lab->Set_Label_Type(Label::LA_THIN);
+	lab->Set_Text(m_pl->GetText(TRANINFO1));
+	lab->Set_Font_Size(16);
+	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	lab->Drawme(g);
+	delete lab;
+	lab = NULL;
+	Update_Command(g);
+	g.Restore_Disp_Area(0,0,639,479,mem);
+	delete[] mem;
+	mem = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Update_Command
+ *  Description:  Do update command 
+ * =====================================================================================
+ */
+void Logic::Update_Command(Graphic& g)
+{
+	ManageMD5* md5 = ManageMD5::Instance();
+	char* command = new char[100];
+	sprintf(command,"cp -p %smain %smain",RUN_PATH_RU,APP_READY_PATH);
+	Excute_Command(command,true);
+
+	m_alg->MDelay(2000);
+
+	sprintf(command,"%smain",APP_READY_PATH);
+	if 	( md5->Calculate_MD5(command) == true )
+	{
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG07),Msgbox::MSG_OK);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g);
+		delete ms;
+		ms = NULL;
+		/*-----------------------------------------------------------------------------
+		 *  When Update Programe Sccessful, Clean .Par File
+		 *-----------------------------------------------------------------------------*/
+		sprintf(command,"rm %s",PAR_FILE_PATH);
+		Excute_Command(command);
+	}
+	else
+	{
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(INFORMESG06),Msgbox::MSG_OK);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g);
+		delete ms;
+		ms = NULL;
+
+		sprintf(command,"rm %smain",APP_READY_PATH);
+		Excute_Command(command,true);
+	}
+Exit:
+	delete[] command;
+	command = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Excute_Command
+ *  Description:  Excute the command 
+ *      caution:  It is the async mode
+ * =====================================================================================
+ */
+void Logic::Excute_Command(const char* command,bool syncflag)
+{
+	pid_t pid;
+	pid = vfork();
+	if ( pid == 0 )
+	{
+		if ( execl("/bin/sh", "sh", "-c", command, (char *)0) == -1 )
+			perror("Excute Command Error");
+		else
+		{
+			if ( syncflag == true )
+				sync();
+		}
+		_exit(0);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  About_Box
+ *  Description:  Show the About Message on Screen 
+ * =====================================================================================
+ */
+void Logic::About_Box(Graphic& g,int x, int y)
+{
+	short m_BGColor = g_BUBGNO_CO;
+	short m_FGColor = g_BUTXNO_CO;
+
+	short basex     = x;
+	short basey     = y;
+	short width     = 312;
+	short heigh     = 250;
+	int   ft        = 16;
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(x,y,x+width-1,y+heigh-1)];
+	g.Load_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
+	/*-----------------------------------------------------------------------------
+	 *  Draw the front color 
+	 *-----------------------------------------------------------------------------*/
+	g.DrawFillRect(x,y,width,heigh,m_BGColor);
+
+	COLORTYPE co_sa;
+	co_sa = g.Getcolor();
+	g.Setcolor(m_FGColor);
+
+	Gradual *gd = new Gradual(x,y,width-2,20);
+	gd->Set_LColor(g.RGB24_16(0x789449));
+	gd->Set_RColor(g.RGB24_16(0x000000));
+	gd->Drawme(g);
+	delete gd;
+	gd = NULL;
+
+	g.DrawRect(x,y,width,heigh);
+	g.DrawRect(x+1,y+1,width-2,20);
+	g.DrawRect(x+1,y+20,width-2,heigh-21);
+	g.Setcolor(co_sa);
+
+	int cent_x      = x + ( width>>1 );
+	int cent_y      = y + ( heigh>>1 );
+
+	Label *button	= new Label(cent_x-2*ft-4,y+heigh-32,4*ft,ft+4+4);
+	button->Set_Font_Size(16);
+	button->Set_Text(m_pl->GetText(COMFIRM));
+	button->Set_Label_Type(Label::LA_3D);
+	button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+	char *databuf = new char[50];
+	float ver = (static_cast<float>(m_device->Get_Module_Version())/100);
+	INT32 fver = m_device->Get_FPGA_Version();
+	sprintf(databuf,"%s%s-%.2f-%x %s",m_pl->GetText(ABOUTMSG21),PROVERSION,ver,fver,m_pl->GetText(ABOUTMSG22));
+	
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,m_FGColor);
+	font->Set_Color(FreeType::BGCOLOR,m_BGColor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+	font->Text(basex+110,basey+45,m_pl->GetText(ABOUTMSG1));
+
+	if 	( m_gp->Language == 1 )
+		font->Text(basex+14,basey+35+20+15,m_pl->GetText(ABOUTMSG2));
+	else if ( m_gp->Language == 0 )
+		font->Text(basex+50,basey+35+20+15,m_pl->GetText(ABOUTMSG2));
+
+	font->Text(basex+14,basey+55+20+15,databuf);
+	font->Text(basex+14,basey+75+20+15,m_pl->GetText(ABOUTMSG3));
+	font->Text(basex+14,basey+95+20+15,m_pl->GetText(ABOUTMSG4));
+	font->Text(basex+14,basey+115+20+15,m_pl->GetText(ABOUTMSG5));
+	font->Text(basex+14,basey+135+20+15,m_pl->GetText(ABOUTMSG6));
+	font->Text(basex+14,basey+155+20+15,m_pl->GetText(ABOUTMSG7));
+	font->Text(basex+14,basey+175+20+15,m_pl->GetText(ABOUTMSG8));
+	delete[] databuf;
+	databuf = NULL;
+	button->Drawme(g);
+
+	int key = 0;
+	while(key!= KEY_ENTER && key!= KEY_ESC)
+	{
+		key = Get_Key();
+		if ( key == KEY_F5 )
+			Screen_Shoot(g);
+		m_alg->MDelay(100);
+	}
+
+	button->Set_Focus(true);
+	button->Drawme(g);
+
+	m_alg->MDelay(100);
+
+	delete button;
+	button = NULL;
+
+	g.Restore_Disp_Area(x,y,x+width-1,y+heigh-1,mem);
+	delete[] mem;
+	mem = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restore_Default_Value
+ *  Description:  Call this function to restore the default value 
+ * =====================================================================================
+ */
+void Logic::Restore_Default_Value(Graphic& g)
+{
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(RESTOREDEFAULT),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == true )
+	{
+		delete ms;
+		ms = NULL;
+
+		m_gp->Init_Global_Variables();
+		m_gp->Save_Global_Variables(PAR_FILE_PATH);
+
+		Msgbox *nms = new Msgbox(200,170,260,100,m_pl->GetText(REBOOTMSG),Msgbox::MSG_OK);
+		nms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		nms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		nms->Showme(g);
+		delete nms;
+		nms = NULL;
+	}
+	delete ms;
+	ms = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restore_Mix_Factor
+ *  Description:  Restore Mixing Factor 
+ * =====================================================================================
+ */
+void Logic::Restore_Mix_Factor(Graphic& g)
+{
+	Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(MIXFACTORCOMFIRM),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == true )
+	{
+		delete ms;
+		ms = NULL;
+
+		MixingManage *algm = MixingManage::Instance();
+		algm->Restore_Mix_Factor();
+		algm->Sync_Mixing_Para(true);
+	}
+	delete ms;
+	ms = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Data_Into_File
+ *  Description:  For test the Mixing Algorithm 
+ * =====================================================================================
+ */
+bool Logic::Save_Data_Into_File(const char* path,short *buf,int length)
+{
+	bool result = false;
+	std::ofstream oo;
+	oo.open(path,std::ofstream::binary|std::ofstream::trunc);
+	if ( !oo )
+	{
+		perror("can't save para file");
+		result = false;
+	}
+	else
+	{
+		for ( int i=0;i<length;i++ )
+		{
+			oo<<buf[i]<<' ';
+		}
+		result = true;
+		oo.flush();
+		oo.close();
+		sync();
+	}
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Data_Into_File
+ *  Description:  For test the Mixing Algorithm 
+ * =====================================================================================
+ */
+bool Logic::Load_Data_From_File(const char* path,short *buf,int length)
+{
+	bool result = false;
+	std::ifstream io;
+	io.open(path,std::ifstream::binary);
+	if ( !io.is_open() )
+	{
+		perror("can't load para file");
+		result = false;
+	}
+	else
+	{
+		for ( int i=0;i<length;i++ )
+		{
+			io>>buf[i];
+		}
+		result = true;
+		io.close();
+		sync();
+	}
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_ADC_Handle
+ *  Description:  Get the handle of ADC driver  
+ * =====================================================================================
+ */
+int Logic::Get_ADC_Handle()
+{
+#ifdef X86 
+	return 0;
+#else
+	return m_ADC_fd;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Mainwin_Point
+ *  Description:  Set the Mainwin Point 
+ * =====================================================================================
+ */
+void Logic::Set_Mainwin_Point(Mainwin* p)
+{
+	m_pMainwin = p;
+}
diff --git a/src/EVA11/base/Logic.h b/src/EVA11/base/Logic.h
new file mode 100644
index 0000000..8d9e3ae
--- /dev/null
+++ b/src/EVA11/base/Logic.h
@@ -0,0 +1,121 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Logic.h
+ *
+ *    Description:  Declear Logic class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 15时34分48秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _Logic_INC
+#define  _Logic_INC
+
+#include 	<string>
+#include 	<memory>
+#include 	<boost/asio.hpp>
+
+#include 	"main.h"
+
+class Graphic;
+class Language;
+class Algorithm;
+class Device;
+class Global;
+class DataRepo;
+class Mainwin;
+
+class Logic
+{
+	public:
+		static Logic* Instance();                /* only used this function to visit variables   */
+
+		int Get_Key();
+		void Init_Hardware(Graphic& g);
+		void Release_Hardware();
+		void Shutdown();
+		void Pre_Shutdown();
+		void Frequence_2_Char(int freqvalue,char* msg);
+		void Probe_Fun_2_Char(int chan,int probefun,int freq,char* msg);
+		void Probe_Fun_2_Char_Only(int probefun,char* msg);
+
+		void Set_Global_Variables_Into_PCB();
+		void Set_Global_Variables_Into_System();
+
+		void Convert_Hi_Low_Filterpass_2_Char(int value,bool HiFlag,char *msg);
+		bool Check_Disk_Space(const unsigned long long needspace,unsigned long long& remainspace);
+
+		void Screen_Shoot(Graphic& g);
+
+		void Update_Program(Graphic& g);
+
+		void About_Box(Graphic& g,int x,int y);
+		void Excute_Command(const char* command, bool syncflag=true);
+		void Restore_Default_Value(Graphic& g);
+
+		void Reset_Data_Repo();
+		void Restore_Mix_Factor(Graphic& g);
+
+		bool Save_Data_Into_File(const char*,short *,int);
+		bool Load_Data_From_File(const char*,short *,int);
+
+		int Get_ADC_Handle();
+		void Set_Mainwin_Point(Mainwin* p);
+	protected:
+	private:
+		Logic ();
+		~Logic ();
+		Logic (const Logic&);
+		Logic& operator = (const Logic&);
+
+		int Get_Key_From_Keyboard();
+		int Get_Key_From_FPGA();
+		void Alarm_Beep(bool status);
+		void Short_Beep();
+
+		bool Check_Screen_Shoot_Available(int &index);
+		void Do_Update_Event(Graphic& g);
+		void Update_Command(Graphic& g);
+
+		void ShutDownMsg(const boost::system::error_code & e);
+	private:
+		/*-----------------------------------------------------------------------------
+		 *  Battery Hand
+		 *-----------------------------------------------------------------------------*/
+		int m_ADC_fd;     	               /* ADC Handle */
+
+		friend class std::auto_ptr<Logic>;
+		static std::auto_ptr<Logic>		m_Instance;
+		static const int			m_MAXJpegCount = 100;
+		std::string				m_SuffixJpeg;
+		/*-----------------------------------------------------------------------------
+		* KEYSOURCE: 0 from keyboard
+		*            1 from device
+		*-----------------------------------------------------------------------------  */
+#ifdef		_KEY_PC_
+		static const int			KEYSOURCE      = 0;
+#endif
+#ifdef		_KEY_308_1_
+		static const int			KEYSOURCE      = 1;
+#endif
+#ifdef		_KEY_308_A_
+		static const int			KEYSOURCE      = 1;
+#endif
+
+		Language				*m_pl;
+		Algorithm                               *m_alg;
+		Device			                *m_device;
+		Global			                *m_gp;
+		DataRepo		                *m_repo;
+		Graphic					*m_g;
+		Mainwin					*m_pMainwin;
+}; /* -----  end of class Logic  ----- */
+#endif   /* ----- #ifndef _Logic_INC  ----- */
diff --git a/src/EVA11/base/MKlib.mk b/src/EVA11/base/MKlib.mk
new file mode 100644
index 0000000..ec3aa03
--- /dev/null
+++ b/src/EVA11/base/MKlib.mk
@@ -0,0 +1,186 @@
+##########################################################
+#
+#                    The EVA11 project lib configrature 
+#
+# Author:    kevin.wang
+# Company:   Eddysun     xiamen
+# Date:      2012.12.13
+# Comment:   Try to re-structure the Project Makefile
+#            
+#
+###########################################################
+
+
+########################################################### 
+# Configrature the third library with follow selection
+########################################################### 
+LIBINC_SDL      = yes
+LIBINC_SDL2     = no
+LIBINC_ETIO     = yes
+LIBINC_GIF      = yes
+LIBINC_GSL      = yes
+LIBINC_LOG4CPP  = yes
+LIBINC_Z        = yes
+LIBINC_JPEG     = yes
+LIBINC_MD       = no
+LIBINC_USB      = yes
+LIBINC_PNG      = yes
+LIBINC_FREETYPE = yes
+LIBINC_ICONV    = yes
+LIBINC_SQLITE3  = yes
+LIBINC_SSL      = yes
+LIBINC_SDLGFX   = yes
+LIBINC_SDLIMAGE = yes
+LIBINC_SDLNET   = no
+LIBINC_SDLTTF   = no
+LIBINC_SOCKETS  = no
+LIBINC_BOOST    = yes
+LIBINC_ZTHREAD  = yes
+LIBINC_DIRECTFB = yes
+
+THIRDLIB =
+SEARCH_LIBPATH =
+SEARCH_INCPATH = -I$(MYLIBS_DIR)/sp++/include/
+
+ifeq ($(LIBINC_ETIO),yes)
+THIRDLIB+=etio
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libetio/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libetio/include/
+endif
+
+ifeq ($(LIBINC_GIF),yes)
+THIRDLIB+=gif
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libgif/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libgif/include/
+endif
+
+ifeq ($(LIBINC_GSL),yes)
+THIRDLIB+=gsl
+THIRDLIB+=gslcblas
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libgsl/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libgsl/include/
+endif
+
+ifeq ($(LIBINC_LOG4CPP),yes)
+THIRDLIB+=log4cplus
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/liblog4cplus/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/liblog4cplus/include/
+endif
+
+ifeq ($(LIBINC_Z),yes)
+THIRDLIB+=z
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libz/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libz/include/
+endif
+
+ifeq ($(LIBINC_JPEG),yes)
+THIRDLIB+=jpeg
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libjpeg/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libjpeg/include/
+endif
+
+ifeq ($(LIBINC_MD),yes)
+THIRDLIB+=md
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libmd5/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libmd5/include/
+endif
+
+ifeq ($(LIBINC_USB),yes)
+THIRDLIB+=usb-1.0
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libusb/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libusb/include/libusb-1.0/
+endif
+
+ifeq ($(LIBINC_PNG),yes)
+THIRDLIB+=png15
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libpng/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libpng/include/
+endif
+
+ifeq ($(LIBINC_FREETYPE),yes)
+THIRDLIB+=freetype
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libfreetype/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libfreetype/include/freetype2/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libfreetype/include/
+endif
+
+ifeq ($(LIBINC_ICONV),yes)
+THIRDLIB+=iconv
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libiconv/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libiconv/include/
+endif
+
+ifeq ($(LIBINC_SQLITE3),yes)
+THIRDLIB+=sqlite3
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsqlite/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsqlite/include/
+endif
+
+ifeq ($(LIBINC_SSL),yes)
+THIRDLIB+=ssl crypto
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libopenssl/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libopenssl/include/
+endif
+
+ifeq ($(LIBINC_SDLGFX),yes)
+THIRDLIB+=SDL_gfx
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-gfx/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-gfx/include/
+endif
+
+ifeq ($(LIBINC_SDLIMAGE),yes)
+THIRDLIB+=SDL_image
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-image/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-image/include/
+endif
+
+ifeq ($(LIBINC_SDLNET),yes)
+THIRDLIB+=SDL_net
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-net/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-net/include/
+endif
+
+ifeq ($(LIBINC_SDLTTF),yes)
+THIRDLIB+=SDL_ttf
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl-ttf/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl-ttf/include/
+endif
+
+ifeq ($(LIBINC_SDL),yes)
+THIRDLIB+=SDL
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl/include/SDL/
+endif
+
+ifeq ($(LIBINC_SDL2),yes)
+THIRDLIB+=SDL2
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsdl2.0/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsdl2.0/include/
+endif
+
+ifeq ($(LIBINC_SOCKETS),yes)
+THIRDLIB+=Sockets
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libsocket/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libsocket/include/
+endif
+
+ifeq ($(LIBINC_BOOST),yes)
+THIRDLIB+=boost_system boost_filesystem
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libboost/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libboost/include/
+endif
+
+ifeq ($(LIBINC_ZTHREAD),yes)
+THIRDLIB+=ZThread
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libzthread/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libzthread/include/
+endif
+
+ifeq ($(LIBINC_DIRECTFB),yes)
+THIRDLIB+=directfb
+THIRDLIB+=direct
+THIRDLIB+=fusion
+THIRDLIB+=++dfb
+SEARCH_LIBPATH+=-L$(MYLIBS_DIR)/libdirectfb/lib/
+SEARCH_INCPATH+=-I$(MYLIBS_DIR)/libdirectfb/include/
+endif
diff --git a/src/EVA11/base/Mainwin.cpp b/src/EVA11/base/Mainwin.cpp
new file mode 100644
index 0000000..5ab7fe4
--- /dev/null
+++ b/src/EVA11/base/Mainwin.cpp
@@ -0,0 +1,3532 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Mainwin.cpp
+ *
+ *    Description:  Implemntation of Mainwin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月13日 15时19分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<unistd.h>
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Basewin.h"
+#include 	"Mainwin.h"
+#include 	"Graphic.h"
+#include	"Language.h"
+#include	"Global.h"
+#include	"Msgbox.h"
+#include	"Battery.h"
+#include	"Process.h"
+#include 	"Logic.h"
+
+#include 	"Basescreen.h"
+
+#include	"Label.h"
+
+#include 	"IView.h"
+#include 	"DetectView.h"
+#include 	"ParaView.h"
+#include	"DebugView.h"
+#include	"OtherView.h"
+#include	"PanelView.h"
+#include 	"AlarmView.h"
+#include 	"AnalyzeView.h"
+
+Mainwin::Mainwin ()
+{
+}
+
+Mainwin::~Mainwin ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void Mainwin::Drawme(Graphic &g)
+{
+	Basewin::Drawme(g);
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+		m_NorButton[i]->Drawme(g);
+
+	m_View[m_BottomFocus-1]->Switch_View();
+	m_View[m_BottomFocus-1]->Drawme(g);
+	Refresh_Small_Label(g);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Main loop in Mainwin class 
+ * =====================================================================================
+ */
+int Mainwin::Loopwindow(Graphic &g)
+{
+	int result = 0;
+	Init_Variables();
+	Init_GUI(g);
+	Init_View_Sets(g);
+	Drawme(g);
+	Init_Process_Sets();
+#ifdef CALSAMPLE
+	unsigned long long len = 0;
+	struct tm *timenow;
+	time_t now,old;
+	time(&old);
+#endif
+	while( 1 )
+	{
+		if 	( m_PauseFlag == false )
+			m_View[m_BottomFocus-1]->Loop_View(g);
+
+		result = Command_Process(g);
+
+		if 	( result == CO_EXIT )
+			goto Exit;
+
+		if	( m_BottomFocus == 7 && m_SubMenuNo[m_BottomFocus-1] == 4 )
+			DisplayTimeDate(g);
+
+#ifdef CALSAMPLE
+		len ++;
+		if ( len == 100000 )
+		{
+			time(&now);
+			now = now - old;
+			time(&old);
+			timenow = localtime(&now);
+			printf ( "100K sample cost %d second \n",timenow->tm_sec );
+			len = 0;
+		}
+#endif
+	}
+
+Exit:
+	Release_Process_Sets();
+	Release_View_Sets();
+	Destroy_GUI();
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Mainwin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+}
+int Mainwin::Key_Bom2_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,2);
+}
+int Mainwin::Key_Bom3_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,3);
+}
+int Mainwin::Key_Bom4_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,4);
+}
+int Mainwin::Key_Bom5_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,5);
+}
+int Mainwin::Key_Bom6_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,6);
+}
+int Mainwin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+}
+int Mainwin::Key_Esc_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false && m_BottomFocus == 1 )
+	{
+		m_PauseFlag = true;
+		m_View[m_BottomFocus-1]->Lock_View(g);
+		return CO_NONE;
+	}
+	else
+	{
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(COMFIRMEXIT),Msgbox::MSG_OKCANCEL);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		if ( ms->Showme(g) == true )
+		{
+			delete ms;
+			ms = NULL;
+			return CO_EXIT;
+		}
+		delete ms;
+		ms = NULL;
+		return CO_NONE;
+	}
+}
+int Mainwin::Key_Enter_Fun(Graphic& g)
+{
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],m_NormalFocus,IProcess::ENTER);
+
+	m_View[m_BottomFocus-1]->Key_Enter_Fun(g);
+
+	if ( m_PauseFlag == true && m_BottomFocus == 1 )
+	{
+		m_PauseFlag = false;
+		m_View[m_BottomFocus-1]->UnLock_View(g);
+		return CO_NONE;
+	}
+}
+int Mainwin::Key_NL1_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,1);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],1,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL1_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR1_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,1);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],1,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR1_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NL2_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,2);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],2,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL2_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR2_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,2);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],2,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR2_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NL3_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,3);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],3,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL3_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR3_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,3);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],3,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR3_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NL4_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,4);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],4,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL4_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR4_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,4);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],4,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR4_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NL5_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,5);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],5,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL5_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR5_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,5);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],5,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR5_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NL6_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,6);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],6,IProcess::LKEY);
+	m_View[m_BottomFocus-1]->Key_NL6_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_NR6_Fun(Graphic& g)
+{
+	DrawNormalFocus(g,6);
+	m_Process[m_BottomFocus-1]->Do_Event(g,m_SubMenuNo[m_BottomFocus-1],6,IProcess::RKEY);
+	m_View[m_BottomFocus-1]->Key_NR6_Fun(g,m_SubMenuNo[m_BottomFocus-1]);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+	return CO_NONE;
+}
+int Mainwin::Key_F1_Fun(Graphic& g)
+{
+	m_View[m_BottomFocus-1]->Key_F1_Fun(g);
+}
+int Mainwin::Key_F2_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false )
+		m_View[m_BottomFocus-1]->Key_F2_Fun(g);
+}
+int Mainwin::Key_F3_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false )
+		m_View[m_BottomFocus-1]->Key_F3_Fun(g);
+}
+int Mainwin::Key_F4_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false )
+		m_View[m_BottomFocus-1]->Key_F4_Fun(g);
+}
+int Mainwin::Key_F5_Fun(Graphic& g)
+{
+	m_View[m_BottomFocus-1]->Key_F5_Fun(g);
+	m_lo->Screen_Shoot(g);
+}
+int Mainwin::Key_F6_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false )
+		m_View[m_BottomFocus-1]->Key_F6_Fun(g);
+}
+int Mainwin::Key_F7_Fun(Graphic& g)
+{
+	if ( m_PauseFlag == false )
+		m_View[m_BottomFocus-1]->Key_F7_Fun(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Variables
+ *  Description:  Init the variables of device 
+ * =====================================================================================
+ */
+void Mainwin::Init_Variables()
+{
+	m_BottomFocus  	  = 1;
+	m_NormalFocus 	  = 1;
+
+	for (int i=0;i<MAXBOMCOUNT;i++)
+	{
+		m_SubMenuNo[i] 
+			  = 1;
+	}
+
+	m_SubMenuMaxNo[0] = 1;
+	m_SubMenuMaxNo[1] = 3;
+	m_SubMenuMaxNo[2] = 2;
+	m_SubMenuMaxNo[3] = 2;
+	m_SubMenuMaxNo[4] = 1;
+	m_SubMenuMaxNo[5] = 1;
+	m_SubMenuMaxNo[6] = 4;
+
+	m_PauseFlag       = false;
+
+	Logic* lo = Logic::Instance();
+	lo->Set_Mainwin_Point(this);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void Mainwin::Init_GUI(Graphic& g)
+{
+	Basewin::Init_GUI(g);
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+	}
+
+	ColorObj* colorobj = ColorObj::Instance();
+
+	m_BomButton[0]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_BomButton[1]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_BomButton[3]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_BomButton[4]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+
+	m_BomButton[0]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
+	m_BomButton[1]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
+	m_BomButton[3]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
+	m_BomButton[4]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(29));
+
+	m_BomButton[0]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_BomButton[1]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_BomButton[3]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_BomButton[4]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+
+	m_BomButton[0]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
+	m_BomButton[1]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
+	m_BomButton[3]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
+	m_BomButton[4]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(30));
+
+	for ( int i=0;i<MAXNORCOUNT;i++)
+	{
+		if ( i == MAXNORCOUNT-1 )
+			m_NorButton[i] = new Label(533,4+73*(MAXNORCOUNT-1),104,72);
+		else
+			m_NorButton[i] = new Label(533,4+73*i,104,71);
+
+		m_NorButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+		m_NorButton[i]->Set_Label_Color(Label::LA_BGNO_COLOR,colorobj->Get_ColorVP(17));
+		m_NorButton[i]->Set_Label_Color(Label::LA_FGNO_COLOR,colorobj->Get_ColorVP(16));
+		m_NorButton[i]->Set_Label_Color(Label::LA_BGFO_COLOR,colorobj->Get_ColorVP(18));
+		m_NorButton[i]->Set_Label_Color(Label::LA_FGFO_COLOR,colorobj->Get_ColorVP(19));
+		m_NorButton[i]->Set_Label_Color(Label::LA_HI_COLOR,colorobj->Get_ColorVP(31));
+		m_NorButton[i]->Set_Label_Color(Label::LA_LO_COLOR,colorobj->Get_ColorVP(30));
+
+		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,1));
+		m_NorButton[i]->Set_Label_Type(Label::LA_ROUND);
+		m_NorButton[i]->Set_Display_Type(Label::LA_DT_DLINE);
+		m_NorButton[i]->Set_Font_Size(18);
+		m_NorButton[i]->Set_Radius(15);
+		if 	( i == m_NormalFocus - 1 )
+			m_NorButton[i]->Set_Focus(true);
+		else
+			m_NorButton[i]->Set_Focus(false); 
+	}
+	m_BomSmall->Set_Display_Type(Label::LA_DT_SM);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void Mainwin::Destroy_GUI()
+{
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		if	( m_NorButton[i] != NULL )
+		{
+			delete m_NorButton[i];
+			m_NorButton[i] = NULL;
+		}
+	}
+	Basewin::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View_Sets
+ *  Description:  Init the sets of view 
+ * =====================================================================================
+ */
+void Mainwin::Init_View_Sets(Graphic& g)
+{
+	m_View[0] = new DetectView(2,2,530,442);
+	m_View[0]->Init_View(g);
+
+	m_View[1] = new ParaView(2,2,530,442);
+	m_View[1]->Init_View(g);
+	m_View[1]->Load_View_Object(m_View[0]);
+
+	m_View[2] = new DebugView(2,2,530,442);
+	m_View[2]->Init_View(g);
+
+	m_View[3] = new AlarmView(2,2,530,442);
+	m_View[3]->Init_View(g);
+	m_View[3]->Load_View_Object(m_View[0]);
+
+	m_View[4] = new AnalyzeView(2,2,530,442);
+	m_View[4]->Init_View(g);
+	m_View[4]->Load_View_Object(m_View[0]);
+
+	m_View[5] = new PanelView(2,2,530,442);
+	m_View[5]->Init_View(g);
+
+	m_View[6] = new OtherView(2,2,530,442);
+	m_View[6]->Init_View(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View_Sets
+ *  Description:  Release the view sets 
+ * =====================================================================================
+ */
+void Mainwin::Release_View_Sets()
+{
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_View[i]->Release_View();
+		delete m_View[i];
+		m_View[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  As the input parameter index to set the bottoms button status
+ *        index: From 1 to 7
+ * =====================================================================================
+ */
+void Mainwin::DrawBottomFocus(Graphic& g,int index)
+{
+	int savebomindex = m_BottomFocus;
+	Basewin::DrawBottomFocus(g,index);
+
+	int kt[7] = {256,1,1,1,1,1,1};
+	Basewin::Set_MAX_Get_Key_Interval(kt[index-1]);
+
+	if 	( index == 1 && savebomindex != 1 )
+	{
+		m_PauseFlag = false;
+	}
+
+	if 	( index != 1 )
+		m_PauseFlag = false;
+
+ 	if 	( index == savebomindex )
+	{
+		if 	( (m_SubMenuNo[index-1] == m_SubMenuMaxNo[index-1]) )
+			m_SubMenuNo[index-1] = 1;
+		else
+			m_SubMenuNo[index-1] += 1;
+	}
+	else
+	{
+		m_View[m_BottomFocus-1]->Switch_View();
+		m_View[m_BottomFocus-1]->Drawme(g);
+	}
+
+	Refresh_Small_Label(g);
+	Refresh_Normal_Label_Content(g);
+	Refresh_Normal_Label_Text(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawNormalFocus
+ *  Description:  
+ * =====================================================================================
+ */
+void Mainwin::DrawNormalFocus(Graphic& g,int index)
+{
+	if 	( index != m_NormalFocus )
+	{
+		m_NorButton[m_NormalFocus-1]->Set_Focus(false);
+		m_NorButton[index-1]->Set_Focus(true);
+		m_NormalFocus = index;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Small_Label
+ *  Description:  Refresh the small label of page 
+ * =====================================================================================
+ */
+void Mainwin::Refresh_Small_Label(Graphic& g)
+{
+	sprintf(m_Msg,"%d",m_SubMenuNo[m_BottomFocus-1]);
+	m_BomSmall->Set_Text(m_Msg,0);
+	sprintf(m_Msg,"%d",m_SubMenuMaxNo[m_BottomFocus-1]);
+	m_BomSmall->Set_Text(m_Msg,1);
+	m_BomSmall->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Bom_Label
+ *  Description:  Refresh the Bomttom Label 
+ * =====================================================================================
+ */
+void Mainwin::Refresh_Normal_Label_Text(Graphic& g)
+{
+	g.Switch_Screen();
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
+		m_NorButton[i]->Drawme(g,false);
+	}
+	g.Switch_Screen();
+	g.Screen_Copy(533,4,533+105-1,4+73*MAXNORCOUNT-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Normal_Label_Content
+ *  Description:  Display the Normal label content 
+ * =====================================================================================
+ */
+void Mainwin::Refresh_Normal_Label_Content(Graphic& g)
+{
+	int bom = m_BottomFocus;
+	int sub = m_SubMenuNo[m_BottomFocus-1];
+
+	switch ( bom )
+	{
+		case 1: 
+			Refresh_Normal_Label_Content_1(g,sub);
+			break;
+		case 2:	
+			Refresh_Normal_Label_Content_2(g,sub);
+			break;
+		case 3: 
+			Refresh_Normal_Label_Content_3(g,sub);
+			break;
+		case 4: 
+			Refresh_Normal_Label_Content_4(g,sub);
+			break;
+		case 5:	
+			Refresh_Normal_Label_Content_5(g,sub);
+			break;
+		case 6: 
+			Refresh_Normal_Label_Content_6(g,sub);
+			break;
+		case 7: 
+			Refresh_Normal_Label_Content_7(g,sub);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0:
+			Refresh_Normal_Label_Content_1_ColorPanel(g,sub);
+			break;
+
+		case 1:
+			Refresh_Normal_Label_Content_1_VideoPanel(g,sub);
+			break;
+
+		case 2:
+			Refresh_Normal_Label_Content_1_ZKPanel(g,sub);
+			break;
+
+		case 3:
+			Refresh_Normal_Label_Content_1_DZKPanel(g,sub);
+			break;
+
+		case 4:
+			Refresh_Normal_Label_Content_1_OZKPanel(g,sub);
+			break;
+
+		case 5:
+			Refresh_Normal_Label_Content_1_CZKPanel(g,sub);
+			break;
+	}
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1_ZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->SingleFocusSignal]/static_cast<float>(10));
+							break;
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->SingleFocusSignal]);
+							break;
+						case 3:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]],m_Msg);
+							break;
+						case 4:
+							if 	( m_gp->TimeScaleDisp == 1 )
+								sprintf(m_Msg,"S.Y");
+							else if ( m_gp->TimeScaleDisp == 0 )
+								sprintf(m_Msg,"S.X");
+							else
+								sprintf(m_Msg,"OFF");
+							break;
+						case 5:
+							sprintf(m_Msg,"%d",m_gp->TimeScaleSpeed);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1_DZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
+							break;
+						case 1:
+							{
+								if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								{
+									if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
+										sprintf(m_Msg,"S%d OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]+1);
+									else
+										m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[m_gp->ScrSigFocus]+1,m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]],m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]+1,m_Msg);
+								}
+								else
+								{
+									if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
+										  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
+									{
+										sprintf(m_Msg,"M%d:OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
+									}
+									else
+										sprintf(m_Msg,"M%d:S%d-S%d",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1);
+								}
+							}
+							break;
+						case 2:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]]/static_cast<float>(10));
+							else
+								sprintf(m_Msg,"%.1f dB",m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]/static_cast<float>(10));
+							break;
+						case 3:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]]);
+							else
+								sprintf(m_Msg,"%d DEG",m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]);
+							break;
+						case 4:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+							{
+								if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
+									sprintf(m_Msg,"OFF");
+								else
+									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]],m_Msg);
+							}
+							else
+							{
+								if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
+									  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
+										sprintf(m_Msg,"OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
+								else
+									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]],m_Msg);
+							}
+							break;
+						case 5:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+							{
+								sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							}
+							else
+							{
+								if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
+									  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
+										sprintf(m_Msg,"OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1);
+								else
+									m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]],m_Msg);
+							}
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+		
+void Mainwin::Refresh_Normal_Label_Content_1_OZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d %s",m_gp->ScopeChan+1,m_pl->GetText(CHANNEL));
+							break;
+
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->CrossGain[m_gp->ScopeChan]/static_cast<float>(10));
+							break;
+
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->CrossDegree[m_gp->ScopeChan]);
+							break;
+
+						case 3:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1_CZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
+							break;
+						case 1:
+							{
+								if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								{
+									if 	( m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]] == 0 )
+										sprintf(m_Msg,"S%d OFF",m_gp->ScrSigM[m_gp->ScrSigFocus]+1);
+									else
+										m_lo->Probe_Fun_2_Char(m_gp->ScrSigM[m_gp->ScrSigFocus]+1,m_gp->ProbeFun[m_gp->ScrSigM[m_gp->ScrSigFocus]],m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]+1,m_Msg);
+								}
+								else
+								{
+									if 	( m_gp->ProbeFun[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 ||  
+										  m_gp->ProbeFun[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]] == 0 )
+									{
+										sprintf(m_Msg,"%s","M%d:SX OFF");
+									}
+									else
+										sprintf(m_Msg,"M%d:S%d-S%d",m_gp->ScrSigM[m_gp->ScrSigFocus]-2+1,m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1, m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]+1);
+								}
+							}
+							break;
+						case 2:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]]/static_cast<float>(10));
+							else
+								sprintf(m_Msg,"%.1f dB",m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]/static_cast<float>(10));
+							break;
+						case 3:
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]]);
+							else
+								sprintf(m_Msg,"%d DEG",m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]);
+							break;
+						case 4:
+								sprintf(m_Msg,"S3-S4");
+							break;
+						case 5:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->AScanMapChan[0]]/static_cast<float>(10));  // always m_gp->AScanMapChan[0]
+																            //	   =  m_gp->AScanMapChan[1]
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1_VideoPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+						case 1:
+						case 2:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_1_ColorPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%.1f dB",m_gp->ColorGain/static_cast<float>(10));
+							break;
+						case 1:	
+							sprintf(m_Msg,"F%d",m_gp->ColorSpotFreqIndex+1);
+							break;
+						case 2:	
+							m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->ColorSpotFreqIndex],m_Msg);
+							break;
+						case 5:
+							sprintf (m_Msg,"%d",m_gp->ColorSpotScanSpeed);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0:
+			Refresh_Normal_Label_Content_2_ColorPanel(g,sub);
+			break;
+		case 1:
+			Refresh_Normal_Label_Content_2_VideoPanel(g,sub);
+			break;
+		case 2:
+			Refresh_Normal_Label_Content_2_ZKPanel(g,sub);
+			break;
+		case 3:
+			Refresh_Normal_Label_Content_2_DZKPanel(g,sub);
+			break;
+		case 4:
+			Refresh_Normal_Label_Content_2_OZKPanel(g,sub);
+			break;
+		case 5:
+			Refresh_Normal_Label_Content_2_CZKPanel(g,sub);
+			break;
+		default:
+			Refresh_Normal_Label_Content_2_ZKPanel(g,sub);
+			break;
+	}
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2_ColorPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ColorSpotSampleType == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(INSIDESAMP));
+							else if ( m_gp->ColorSpotSampleType == 1 )
+								sprintf(m_Msg,"%s",m_pl->GetText(OUTSIDESAMP));
+							break;
+						case 1:
+							if 	( m_gp->ColorSpotSampleType == 0 )
+								sprintf(m_Msg,"%d",m_gp->ColorSpotSampIntervalClock);
+							else if ( m_gp->ColorSpotSampleType == 1 )
+								sprintf(m_Msg,"%d",m_gp->ColorSPotSampOutPuls);
+							break;
+						case 5:
+							if 	( m_gp->ColorSpotDispMode == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(DISPMOD_2D));
+							else if ( m_gp->ColorSpotDispMode == 1 )
+								sprintf(m_Msg,"%s",m_pl->GetText(DISPMOD_3D));
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+			
+void Mainwin::Refresh_Normal_Label_Content_2_VideoPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+		case 2:
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+
+
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2_ZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
+							break;
+						case 1:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->SingleFocusSignal],m_Msg);
+							break;
+						case 2:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
+							break;
+						case 3:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]],m_Msg);
+							break;
+						case 4:
+							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->SingleFocusSignal]));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->SingleFocusSignal+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->SingleFocusSignal+1,m_gp->ProbeFun[m_gp->SingleFocusSignal],m_gp->FreqIndex[m_gp->SingleFocusSignal]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->SingleFocusSignal]/static_cast<float>(10));
+							break;
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->SingleFocusSignal]);
+							break;
+						case 3:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->SingleFocusSignal],true,m_Msg);
+							break;
+						case 4:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->SingleFocusSignal],false,m_Msg);
+							break;
+						case 5:
+							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->SingleCentX);
+							break;
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->SingleCentY);
+							break;
+						case 2:
+							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2_DZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->DParaChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->DParaChan+1,m_gp->ProbeFun[m_gp->DParaChan],m_gp->FreqIndex[m_gp->DParaChan]+1,m_Msg);
+							break;
+						case 1:
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->DParaChan],m_Msg);
+							break;
+						case 2:
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->DParaChan]+1);
+							break;
+						case 3:
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]],m_Msg);
+							break;
+						case 4:
+							if 	( m_gp->DFilter[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->DParaChan]));
+							break;
+						case 5:
+							sprintf(m_Msg,"%s",m_pl->GetText(RESTORE));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->DParaChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->DParaChan+1,m_gp->ProbeFun[m_gp->DParaChan],m_gp->FreqIndex[m_gp->DParaChan]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->DParaChan]/static_cast<float>(10));
+							break;
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->DParaChan]);
+							break;
+						case 3:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->DParaChan],true,m_Msg);
+							break;
+						case 4:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->DParaChan],false,m_Msg);
+							break;
+						case 5:
+							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->DoubleCentX1);
+							break;
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->DoubleCentY1);
+							break;
+						case 2:
+							sprintf(m_Msg,"%d",m_gp->DoubleCentX2);
+							break;
+						case 3:
+							sprintf(m_Msg,"%d",m_gp->DoubleCentY2);
+							break;
+						case 4:
+							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2_CZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->CompositeChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->CompositeChan+1,m_gp->ProbeFun[m_gp->CompositeChan],m_gp->FreqIndex[m_gp->CompositeChan]+1,m_Msg);
+							break;
+						case 1:
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->CompositeChan],m_Msg);
+							break;
+						case 2:
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->CompositeChan]+1);
+							break;
+						case 3:
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]],m_Msg);
+							break;
+						case 4:
+							if 	( m_gp->DFilter[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->CompositeChan]));
+							break;
+						case 5:
+							sprintf(m_Msg,"%d",20 - m_gp->AScanSpeed);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->CompositeChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->CompositeChan+1,m_gp->ProbeFun[m_gp->CompositeChan],m_gp->FreqIndex[m_gp->CompositeChan]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->CompositeChan]/static_cast<float>(10));
+							break;
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->CompositeChan]);
+							break;
+						case 3:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->CompositeChan],true,m_Msg);
+							break;
+						case 4:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->CompositeChan],false,m_Msg);
+							break;
+						case 5:
+							sprintf(m_Msg,"%d",m_gp->Auto_Disappear);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->CompositeCentX1);
+							break;
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->CompositeCentY1);
+							break;
+						case 2:
+							sprintf(m_Msg,"%d",m_gp->CompositeCentX2);
+							break;
+						case 3:
+							sprintf(m_Msg,"%d",m_gp->CompositeCentY2);
+							break;
+						case 4:
+							sprintf(m_Msg,"%.1f",static_cast<double>(m_gp->GainRatio)/10);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_2_OZKPanel(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->QuadChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->QuadChan+1,m_gp->ProbeFun[m_gp->QuadChan],m_gp->FreqIndex[m_gp->QuadChan]+1,m_Msg);
+							break;
+						case 1:
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Probe_Fun_2_Char_Only(m_gp->ProbeFun[m_gp->QuadChan],m_Msg);
+							break;
+						case 2:
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								sprintf(m_Msg,"F%d",m_gp->FreqIndex[m_gp->QuadChan]+1);
+							break;
+						case 3:
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"OFF");
+							else
+								m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]],m_Msg);
+							break;
+						case 4:
+							if 	( m_gp->DFilter[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",(1<<m_gp->DFilter[m_gp->QuadChan]));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->QuadChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->QuadChan+1,m_gp->ProbeFun[m_gp->QuadChan],m_gp->FreqIndex[m_gp->QuadChan]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%.1f dB",m_gp->Gain[m_gp->QuadChan]/static_cast<float>(10));
+							break;
+						case 2:
+							sprintf(m_Msg,"%d DEG",m_gp->Degree[m_gp->QuadChan]);
+							break;
+						case 3:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->HiFilter[m_gp->QuadChan],true,m_Msg);
+							break;
+						case 4:
+							m_lo->Convert_Hi_Low_Filterpass_2_Char(m_gp->LoFilter[m_gp->QuadChan],false,m_Msg);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->OCTCentX[0]);
+							break;
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->OCTCentY[0]);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+
+void Mainwin::Refresh_Normal_Label_Content_3(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->ProbeFun[m_gp->DebugChan] == 0 )
+								sprintf(m_Msg,"S%d OFF",m_gp->DebugChan+1);
+							else
+								m_lo->Probe_Fun_2_Char(m_gp->DebugChan+1,m_gp->ProbeFun[m_gp->DebugChan],m_gp->FreqIndex[m_gp->DebugChan]+1,m_Msg);
+							break;
+						case 1:
+							sprintf(m_Msg,"%d dB",m_gp->HDGain[m_gp->DebugChan]*5);
+							break;
+						case 2:
+							m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]],m_Msg);
+							break;
+						case 3:
+							if 	( m_gp->Driver == 4 )
+								sprintf(m_Msg,"%d V(*)",5);
+							else
+								sprintf(m_Msg,"%d V",m_gp->Driver+1);
+							break;
+						case 4:
+							sprintf(m_Msg,"%d",m_gp->Offset);
+							break;
+						case 5:
+							if 	( m_gp->bRFFilterEnable == true )
+								sprintf(m_Msg,"%s","On");
+							else
+								sprintf(m_Msg,"%s","Off");
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							{
+								if 	( m_gp->Precision == 16 )
+									sprintf(m_Msg,"%s",m_pl->GetText(PRELOW));
+								else if ( m_gp->Precision == 8 )
+									sprintf(m_Msg,"%s",m_pl->GetText(PREMED));
+								else if ( m_gp->Precision == 0 )
+									sprintf(m_Msg,"%s",m_pl->GetText(PREHIGH));
+							}
+							break;
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->DriverBal[m_gp->DebugChan]-8);
+							break;
+						case 2:
+							if ( m_gp->DriverA_ID[m_gp->DebugChan] >= 0 && m_gp->DriverA_ID[m_gp->DebugChan] <= 247 )
+								sprintf(m_Msg,"C%d",m_gp->DriverA_ID[m_gp->DebugChan]+1);
+							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 254 )
+								sprintf(m_Msg,"%s","GND");
+							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 255 )
+								sprintf(m_Msg,"%s","NULL");
+							break;
+						case 3:
+							if ( m_gp->DriverB_ID[m_gp->DebugChan] >= 0 && m_gp->DriverB_ID[m_gp->DebugChan] <= 247 )
+								sprintf(m_Msg,"C%d",m_gp->DriverB_ID[m_gp->DebugChan]+1);
+							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 254 )
+								sprintf(m_Msg,"%s","GND");
+							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 255 )
+								sprintf(m_Msg,"%s","NULL");
+							break;
+						case 4:
+							if ( m_gp->PickA_ID[m_gp->DebugChan] >= 0 && m_gp->PickA_ID[m_gp->DebugChan] <= 247 )
+								sprintf(m_Msg,"C%d",m_gp->PickA_ID[m_gp->DebugChan]+1);
+							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 254 )
+								sprintf(m_Msg,"%s","GND");
+							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 255 )
+								sprintf(m_Msg,"%s","NULL");
+							break;
+						case 5:
+							if ( m_gp->PickB_ID[m_gp->DebugChan] >= 0 && m_gp->PickB_ID[m_gp->DebugChan] <= 247 )
+								sprintf(m_Msg,"C%d",m_gp->PickB_ID[m_gp->DebugChan]+1);
+							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 254 )
+								sprintf(m_Msg,"%s","GND");
+							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 255 )
+								sprintf(m_Msg,"%s","NULL");
+							break;
+						default:
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_4(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 2:
+			Refresh_Normal_Label_Content_4_ZKPanel(g,sub);
+			break;
+		case 3:
+			Refresh_Normal_Label_Content_4_DZKPanel(g,sub);
+			break;
+		case 4:
+			Refresh_Normal_Label_Content_4_OZKPanel(g,sub);
+			break;
+		case 5:
+			Refresh_Normal_Label_Content_4_CZKPanel(g,sub);
+			break;
+		default:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}
+}
+
+void Mainwin::Refresh_Normal_Label_Content_4_ZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if 	( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else if ( m_gp->SAlarmType == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
+							else if ( m_gp->SAlarmType == 1 )
+								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
+							else if ( m_gp->SAlarmType == 2 )
+								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
+							break;
+						case 1:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",m_gp->SAlarmCount[m_gp->SAlarmType]+1);
+							break;
+						case 2:
+							if ( m_gp->AlarmBeep == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 3:
+							if ( m_gp->AlarmOutput == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 4:
+							if ( m_gp->AlarmDisplay == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%c",'A'+m_gp->SAlarmIndex[m_gp->SAlarmType]);
+							break;
+						case 1:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][0]);
+							break;
+						case 2:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][1]);
+							break;
+						case 3:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][2]);
+							break;
+						case 4:
+							if ( m_gp->SAlarmType == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->SAlarmPara[m_gp->SAlarmType][m_gp->SAlarmIndex[m_gp->SAlarmType]][3]);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_4_DZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
+							break;
+
+						case 1:
+							if 	( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
+							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 1 )
+								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
+							else if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
+								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
+							break;
+						case 2:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",m_gp->DAlarmCount[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]+1);
+							break;
+						case 3:
+							if ( m_gp->AlarmBeep == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 4:
+							if ( m_gp->AlarmOutput == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 5:
+							if ( m_gp->AlarmDisplay == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%c",'A'+m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]);
+							break;
+						case 1:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][0]);
+							break;
+						case 2:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][1]);
+							break;
+						case 3:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][2]);
+							break;
+						case 4:
+							if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->DAlarmPara[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]][m_gp->DAlarmIndex[m_gp->ScrSigFocus][m_gp->DAlarmType[m_gp->ScrSigFocus]]][3]);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_4_CZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%d",m_gp->ScrSigFocus+1);
+							break;
+
+						case 1:
+							if 	( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 0 )
+								sprintf(m_Msg,"%s",m_pl->GetText(AMPALARM));
+							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 1 )
+								sprintf(m_Msg,"%s",m_pl->GetText(HAMPALARM));
+							else if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
+								sprintf(m_Msg,"%s",m_pl->GetText(RECTALARM));
+							break;
+						case 2:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+								sprintf(m_Msg,"%d",m_gp->CAlarmCount[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]+1);
+							break;
+						case 3:
+							if ( m_gp->AlarmBeep == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 4:
+							if ( m_gp->AlarmOutput == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 5:
+							if ( m_gp->AlarmDisplay == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%c",'A'+m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]);
+							break;
+						case 1:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][0]);
+							break;
+						case 2:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][1]);
+							break;
+						case 3:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][2]);
+							break;
+						case 4:
+							if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 )
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							else
+							       	sprintf(m_Msg,"%d",
+								m_gp->CAlarmPara[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]][m_gp->CAlarmIndex[m_gp->ScrSigFocus][m_gp->CAlarmType[m_gp->ScrSigFocus]]][3]);
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+
+}
+			
+void Mainwin::Refresh_Normal_Label_Content_4_OZKPanel(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 1:
+							sprintf(m_Msg,"%d",m_gp->OAlarmPara[0]);
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		default:
+			for ( int i=0;i<MAXNORCOUNT;i++ )
+			{
+					switch ( i )
+					{
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+			}
+			break;
+	}
+}
+
+void Mainwin::Refresh_Normal_Label_Content_5(Graphic& g,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_6(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+						case 1:
+						case 2:
+						case 3:
+						case 4:
+						case 5:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						default:
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+void Mainwin::Refresh_Normal_Label_Content_7(Graphic& g,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+						case 1:
+						case 2:
+						case 3:
+						case 4:
+						case 5:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 2:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						case 1:
+							sprintf(m_Msg,"%s",m_pl->GetText(RESTORE));
+							break;
+						case 2:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						case 3:
+							if 	( m_gp->KeyBeep == true )
+								sprintf(m_Msg,"%s",m_pl->GetText(OPEN));
+							else
+								sprintf(m_Msg,"%s",m_pl->GetText(CLOSED));
+							break;
+						case 4:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						case 5:
+							sprintf(m_Msg,"%s",m_pl->GetText(LAN_VALUE));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 3:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+			}
+			break;
+		case 4:
+			{
+				for ( int i=0;i<MAXNORCOUNT;i++ )
+				{
+					switch ( i )
+					{
+						case 0:
+							{
+								struct tm *timenow;
+								time_t now;
+								time(&now);
+								timenow = localtime(&now);
+
+								timenow->tm_mon += 1;
+								timenow->tm_year -=100;
+								sprintf(m_Msg,"%02d/%02d/%02d",timenow->tm_year,timenow->tm_mon,timenow->tm_mday);
+							}
+							break;
+						case 1:
+							{
+								struct tm *timenow;
+								time_t now;
+								time(&now);
+								timenow = localtime(&now);
+
+								sprintf(m_Msg,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+							}
+							break;
+						case 2:
+							sprintf(m_Msg,"%s",m_pl->GetText(EXCUTE));
+							break;
+						default:	
+							sprintf(m_Msg,"%s",m_pl->GetText(NONE));
+							break;
+					}				/* -----  end switch  ----- */
+					m_NorButton[i]->Set_Content(m_Msg);
+				}
+
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bom_Text
+ *  Description:  Get the Bom button text  
+ * =====================================================================================
+ */
+const char*Mainwin::Get_Bom_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0:
+			m_pl->GetText(DETECT);
+			break;
+		case 1:
+			m_pl->GetText(PARAM);
+			break;
+		case 2:
+			m_pl->GetText(DEBUG);
+			break;
+		case 3:
+			m_pl->GetText(ALARM);
+			break;
+		case 4:
+			m_pl->GetText(ANALYZE);
+			break;
+		case 5:
+			m_pl->GetText(LAYOUT);
+			break;
+		case 6:
+			m_pl->GetText(OTHERS);
+			break;
+		default:	
+			m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Normal_Text
+ *  Description:  Get the Normal button text 
+ *
+ *                bom:    1-7
+ *                normal: 1-6
+ *                sub:    start from 1
+ * =====================================================================================
+ */
+const char*Mainwin::Get_Normal_Text(int bom,int normal,int sub)
+{
+	switch ( bom ) 
+	{
+		case 1:	
+			return Get_Normal_Text_1(normal,sub);
+			break;
+		case 2:	
+			return Get_Normal_Text_2(normal,sub);
+			break;
+		case 3:	
+			return Get_Normal_Text_3(normal,sub);
+			break;
+		case 4:	
+			return Get_Normal_Text_4(normal,sub);
+			break;
+		case 5:	
+			return Get_Normal_Text_5(normal,sub);
+			break;
+		case 6:	
+			return Get_Normal_Text_6(normal,sub);
+			break;
+		case 7:	
+			return Get_Normal_Text_7(normal,sub);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Normal_Text_1 2 3 4 5 6 7
+ *  Description:  Get the difference of Submenu text 
+ * =====================================================================================
+ */
+const char*Mainwin::Get_Normal_Text_1(int normal,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0: 
+			return Get_Normal_Text_1_ColorPanel(normal,sub);
+			break;
+
+		case 1: 
+			return Get_Normal_Text_1_VideoPanel(normal,sub);
+			break;
+
+		case 2:
+			return Get_Normal_Text_1_ZKPanel(normal,sub);
+			break;
+
+		case 3:
+			return Get_Normal_Text_1_DZKPanel(normal,sub);
+			break;
+
+		case 4:
+			return Get_Normal_Text_1_OZKPanel(normal,sub);
+			break;
+
+		case 5:
+			return Get_Normal_Text_1_CZKPanel(normal,sub);
+			break;
+
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_1_ColorPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0:
+						return m_pl->GetText(ALLGAIN);
+						break;
+					case 1:
+						return m_pl->GetText(FREQUENCE);
+						break;
+					case 2:
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 5:
+						return m_pl->GetText(SCANSPEED);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_1_VideoPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal )
+				{
+					case 0: 
+						return m_pl->GetText(VIDEOOPEN);
+						break;
+					case 1:	
+						return m_pl->GetText(VIDEOCLOSE);
+						break;
+					case 2:	
+						return m_pl->GetText(ADJRES);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_1_ZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 3:
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 4:
+						return m_pl->GetText(TIMESCALE);
+						break;
+					case 5:
+						return m_pl->GetText(TIMESCALESPEED);
+						break;
+					default:
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_1_DZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal )
+				{
+					case 0:
+						return m_pl->GetText(SCREEN);
+						break;
+					case 1: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 2:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 3:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 4:
+						if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+							return m_pl->GetText(FREQUENCEVALUE);
+						else
+						{
+							return m_pl->GetText(PRIFREQ);
+						}
+						break;
+					case 5:
+						if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+							return m_pl->GetText(NONE);
+						else
+						{
+							return m_pl->GetText(SECFREQ);
+						}
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+
+const char*Mainwin::Get_Normal_Text_1_OZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal )
+				{
+					case 0:
+						return m_pl->GetText(CROSSCHAN);
+						break;
+					case 1:
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:
+						return m_pl->GetText(PHASE);
+						break;
+					case 3:
+						return m_pl->GetText(PARASYNC);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+
+const char*Mainwin::Get_Normal_Text_1_CZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal )
+				{
+					case 0:
+						return m_pl->GetText(SCREEN);
+						break;
+					case 1: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 2:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 3:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 4:
+						return m_pl->GetText(ASCANCHAN);
+						break;
+					case 5:
+						return m_pl->GetText(EMSGAIN);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+
+const char*Mainwin::Get_Normal_Text_2(int normal,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0: 
+			return Get_Normal_Text_2_ColorPanel(normal,sub);
+			break;
+		case 1: 
+			return Get_Normal_Text_2_VideoPanel(normal,sub);
+			break;
+		case 2:
+			return Get_Normal_Text_2_ZKPanel(normal,sub);
+			break;
+		case 3:
+			return Get_Normal_Text_2_DZKPanel(normal,sub);
+			break;
+		case 4:
+			return Get_Normal_Text_2_OZKPanel(normal,sub);
+			break;
+		case 5:
+			return Get_Normal_Text_2_CZKPanel(normal,sub);
+			break;
+
+		default:
+			return Get_Normal_Text_2_ZKPanel(normal,sub);
+			break;
+	}
+}
+
+const char*Mainwin::Get_Normal_Text_2_VideoPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+		case 2:
+		case 3:
+			{
+				switch ( normal ) 
+				{
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_2_ColorPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(SAMPLETYPE);
+						break;
+					case 1:	
+						if 	( m_gp->ColorSpotSampleType == 0 )
+							return m_pl->GetText(STIMEINTER);
+						else if ( m_gp->ColorSpotSampleType == 1 )
+							return m_pl->GetText(SAMPPLUS);
+						break;
+					case 5:
+						return m_pl->GetText(COLORSPOTDM);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_2_ZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(PROBE);
+						break;
+					case 2:	
+						return m_pl->GetText(FREQUENCE);
+						break;
+					case 3: 
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 4:	
+						return m_pl->GetText(DIFILTER);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 3: 
+						return m_pl->GetText(HIFILTER);
+						break;
+					case 4:	
+						return m_pl->GetText(LOFILTER);
+						break;
+					case 5:
+						return m_pl->GetText(AUTODI);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 3:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(X1POINT);
+						break;
+					case 1:	
+						return m_pl->GetText(Y1POINT);
+						break;
+					case 2:
+						return m_pl->GetText(GAINRATIO);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_2_DZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(PROBE);
+						break;
+					case 2:	
+						return m_pl->GetText(FREQUENCE);
+						break;
+					case 3: 
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 4:	
+						return m_pl->GetText(DIFILTER);
+						break;
+					case 5:
+						return m_pl->GetText(MIXFACTOR);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 3: 
+						return m_pl->GetText(HIFILTER);
+						break;
+					case 4:	
+						return m_pl->GetText(LOFILTER);
+						break;
+					case 5:
+						return m_pl->GetText(AUTODI);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 3:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(X1POINT);
+						break;
+					case 1:	
+						return m_pl->GetText(Y1POINT);
+						break;
+					case 2:	
+						return m_pl->GetText(X2POINT);
+						break;
+					case 3:	
+						return m_pl->GetText(Y2POINT);
+						break;
+					case 4:
+						return m_pl->GetText(GAINRATIO);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_2_OZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(PROBE);
+						break;
+					case 2:	
+						return m_pl->GetText(FREQUENCE);
+						break;
+					case 3: 
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 4:	
+						return m_pl->GetText(DIFILTER);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 3: 
+						return m_pl->GetText(HIFILTER);
+						break;
+					case 4:	
+						return m_pl->GetText(LOFILTER);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+
+		case 3:
+			{
+				switch ( normal ) 
+				{
+					case 0:
+						return m_pl->GetText(XNPOINT);
+						break;
+					case 1:
+						return m_pl->GetText(YNPOINT);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_2_CZKPanel(int normal,int sub)
+{
+	switch ( sub )
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(PROBE);
+						break;
+					case 2:	
+						return m_pl->GetText(FREQUENCE);
+						break;
+					case 3: 
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 4:	
+						return m_pl->GetText(DIFILTER);
+						break;
+					case 5:
+						return m_pl->GetText(ASCANSPEED);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(GAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(PHASE);
+						break;
+					case 3: 
+						return m_pl->GetText(HIFILTER);
+						break;
+					case 4:	
+						return m_pl->GetText(LOFILTER);
+						break;
+					case 5:
+						return m_pl->GetText(AUTODI);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 3:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(X1POINT);
+						break;
+					case 1:	
+						return m_pl->GetText(Y1POINT);
+						break;
+					case 2:	
+						return m_pl->GetText(X2POINT);
+						break;
+					case 3:	
+						return m_pl->GetText(Y2POINT);
+						break;
+					case 4:
+						return m_pl->GetText(GAINRATIO);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+const char*Mainwin::Get_Normal_Text_3(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(CHANNEL);
+						break;
+					case 1:	
+						return m_pl->GetText(HDGAIN);
+						break;
+					case 2:	
+						return m_pl->GetText(FREQUENCEVALUE);
+						break;
+					case 3: 
+						return m_pl->GetText(DRIVER);
+						break;
+					case 4:	
+						return m_pl->GetText(OFFSET);
+						break;
+					case 5:
+						return m_pl->GetText(RFFILTER);
+						break;
+
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(PRECISION);
+						break;
+					case 1:	
+						return m_pl->GetText(RESBALACE);
+						break;
+					case 2:	
+						return m_pl->GetText(ADRIVE);
+						break;
+					case 3: 
+						return m_pl->GetText(BDRIVE);
+						break;
+					case 4:	
+						return m_pl->GetText(APICK);
+						break;
+					case 5:	
+						return m_pl->GetText(BPICK);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+const char*Mainwin::Get_Normal_Text_4(int normal,int sub)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 2: 
+			return Get_Normal_Text_4_ZKPanel(normal,sub);
+			break;
+		case 3: 
+			return Get_Normal_Text_4_DZKPanel(normal,sub);
+			break;
+		case 4:
+			return Get_Normal_Text_4_OZKPanel(normal,sub);
+			break;
+		case 5:
+			return Get_Normal_Text_4_CZKPanel(normal,sub);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_4_ZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(ALARMTYPE);
+						break;
+					case 1:	
+						return m_pl->GetText(ALARMACOUNT);
+						break;
+					case 2:	
+						return m_pl->GetText(ALARMBEEP);
+						break;
+					case 3: 
+						return m_pl->GetText(ALARMOUT);
+						break;
+					case 4:	
+						return m_pl->GetText(ALARMDISP);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(ALARMWINS);
+						break;
+					case 1:	
+						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
+							return m_pl->GetText(LEFTLIMIT);
+						else
+							return m_pl->GetText(DEGREE1);
+						break;
+					case 2:	
+						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
+							return m_pl->GetText(UPLIMIT);
+						else
+							return m_pl->GetText(DEGREE2);
+						break;
+					case 3: 
+						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
+							return m_pl->GetText(RIGHTLIMIT);
+						else
+							return m_pl->GetText(XHALF);
+						break;
+					case 4:	
+						if ( m_gp->SAlarmType == 3 || m_gp->SAlarmType == 2 )
+							return m_pl->GetText(DOWNLIMIT);
+						else
+							return m_pl->GetText(YHALF);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+const char*Mainwin::Get_Normal_Text_4_DZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0:
+						return m_pl->GetText(SCREEN);
+						break;
+					case 1: 
+						return m_pl->GetText(ALARMTYPE);
+						break;
+					case 2:	
+						return m_pl->GetText(ALARMACOUNT);
+						break;
+					case 3:	
+						return m_pl->GetText(ALARMBEEP);
+						break;
+					case 4: 
+						return m_pl->GetText(ALARMOUT);
+						break;
+					case 5:	
+						return m_pl->GetText(ALARMDISP);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(ALARMWINS);
+						break;
+					case 1:	
+						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(LEFTLIMIT);
+						else
+							return m_pl->GetText(DEGREE1);
+						break;
+					case 2:	
+						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(UPLIMIT);
+						else
+							return m_pl->GetText(DEGREE2);
+						break;
+					case 3: 
+						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(RIGHTLIMIT);
+						else
+							return m_pl->GetText(XHALF);
+						break;
+					case 4:	
+						if ( m_gp->DAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->DAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(DOWNLIMIT);
+						else
+							return m_pl->GetText(YHALF);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+const char*Mainwin::Get_Normal_Text_4_CZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 0:
+						return m_pl->GetText(SCREEN);
+						break;
+					case 1: 
+						return m_pl->GetText(ALARMTYPE);
+						break;
+					case 2:	
+						return m_pl->GetText(ALARMACOUNT);
+						break;
+					case 3:	
+						return m_pl->GetText(ALARMBEEP);
+						break;
+					case 4: 
+						return m_pl->GetText(ALARMOUT);
+						break;
+					case 5:	
+						return m_pl->GetText(ALARMDISP);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		case 2:
+			{
+				switch ( normal ) 
+				{
+					case 0: 
+						return m_pl->GetText(ALARMWINS);
+						break;
+					case 1:	
+						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(LEFTLIMIT);
+						else
+							return m_pl->GetText(DEGREE1);
+						break;
+					case 2:	
+						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(UPLIMIT);
+						else
+							return m_pl->GetText(DEGREE2);
+						break;
+					case 3: 
+						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(RIGHTLIMIT);
+						else
+							return m_pl->GetText(XHALF);
+						break;
+					case 4:	
+						if ( m_gp->CAlarmType[m_gp->ScrSigFocus] == 3 || m_gp->CAlarmType[m_gp->ScrSigFocus] == 2 )
+							return m_pl->GetText(DOWNLIMIT);
+						else
+							return m_pl->GetText(YHALF);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+const char*Mainwin::Get_Normal_Text_4_OZKPanel(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			{
+				switch ( normal ) 
+				{
+					case 1: 
+						return m_pl->GetText(ALARMLIMIT);
+						break;
+					default:	
+						return m_pl->GetText(NONE);
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}
+}
+const char*Mainwin::Get_Normal_Text_5(int normal,int sub)
+{
+	return m_pl->GetText(NONE);
+}
+const char*Mainwin::Get_Normal_Text_6(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( normal ) 
+			{
+				case 0:
+					return m_pl->GetText(COMBINING);
+					break;
+				case 1:
+					return m_pl->GetText(OZKDISPLAY);
+					break;
+				case 2:
+					return m_pl->GetText(DZKDISPLAY);
+					break;
+
+				case 3: 
+					return m_pl->GetText(SIGZKDISPLAY);
+					break;
+
+				case 4: 
+					return m_pl->GetText(COLORDISPLAY);
+					break;
+
+				case 5: 
+					return m_pl->GetText(VIDEODISPLAY);
+					break;
+
+				default:	
+					return m_pl->GetText(NONE);
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+	return m_pl->GetText(NONE);
+}
+const char*Mainwin::Get_Normal_Text_7(int normal,int sub)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( normal ) 
+			{
+				case 0: 
+					return m_pl->GetText(SAVEPARAM);
+					break;
+
+				case 1: 
+					return m_pl->GetText(LOADPARAM);
+					break;
+
+				case 2: 
+					return m_pl->GetText(DELPARAM);
+					break;
+
+				case 3: 
+					return m_pl->GetText(SAVEDATA);
+					break;
+
+				case 4: 
+					return m_pl->GetText(LOADDATA);
+					break;
+
+				case 5: 
+					return m_pl->GetText(DELEDATA);
+					break;
+
+				default:	
+					return m_pl->GetText(NONE);
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+
+		case 2:
+			switch ( normal ) 
+			{
+				case 0: 
+					return m_pl->GetText(UPDATEPRO);
+					break;
+
+				case 1:
+					return m_pl->GetText(DEFAULT);
+					break;
+
+				case 2:
+					return m_pl->GetText(PICMANAGE);
+					break;
+
+				case 3:
+					return m_pl->GetText(KEYBEEP);
+					break;
+
+				case 4:
+					return m_pl->GetText(OPERATION);
+					break;
+
+				case 5:
+					return m_pl->GetText(LANGUAGE);
+					break;
+
+				default:	
+					return m_pl->GetText(NONE);
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+		case 4:
+			switch ( normal ) 
+			{
+				case 0:
+					return m_pl->GetText(SYSTEMDATE);
+					break;
+				case 1:
+					return m_pl->GetText(SYSTEMTIME);
+					break;
+				case 2:
+					return m_pl->GetText(VERSION);
+					break;
+				default:	
+					return m_pl->GetText(NONE);
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+	return m_pl->GetText(NONE);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Process_Sets
+ *  Description:  Init process sets 
+ * =====================================================================================
+ */
+void Mainwin::Init_Process_Sets()
+{
+	m_Process[0]	 = 	new DetectProcess(this);
+	m_Process[1]	 = 	new ParameterProcess(this);
+	m_Process[2]	 = 	new DebugProcess(this);
+	m_Process[3]	 = 	new AlarmProcess(this);
+	m_Process[4]	 = 	new AnalyzeProcess(this);
+	m_Process[5]	 = 	new DisplayProcess(this);
+	m_Process[6]	 = 	new OthersProcess(this);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_Process_Sets
+ *  Description:  Release Process Sets 
+ * =====================================================================================
+ */
+void Mainwin::Release_Process_Sets()
+{
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		delete m_Process[i];
+		m_Process[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Language
+ *  Description:  When switch language call it
+ * =====================================================================================
+ */
+void Mainwin::Switch_Language(Graphic& g)
+{
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+		if 	( m_gp->Language == 0 )
+			m_BomButton[i]->Set_Font_Size(24);
+		else
+			m_BomButton[i]->Set_Font_Size(16);
+	}
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
+	}
+	Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DisplayTimeDate
+ *  Description:  Display time and date on screen
+ * =====================================================================================
+ */
+void Mainwin::DisplayTimeDate(Graphic& g)
+{
+	struct tm *timenow;
+	time_t now;
+	time(&now);
+	timenow = localtime(&now);
+
+	if ( m_ssecond == timenow->tm_sec )
+		return;
+
+	m_ssecond = timenow->tm_sec;
+
+	sprintf(m_Msg,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+	m_NorButton[1]->Set_Content(m_Msg);
+	m_NorButton[1]->Drawme(g,true);
+
+	timenow->tm_mon += 1;
+	timenow->tm_year -=100;
+	sprintf(m_Msg,"%02d/%02d/%02d",timenow->tm_year,timenow->tm_mon,timenow->tm_mday);
+	m_NorButton[0]->Set_Content(m_Msg);
+	m_NorButton[0]->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Update_Time
+ *  Description:  Update time on button 
+ * =====================================================================================
+ */
+void Mainwin::Update_Time(Graphic& g,const char* timebuf)
+{
+	m_NorButton[1]->Set_Content(timebuf);
+	m_NorButton[1]->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Update_Date
+ *  Description:  Update date on button 
+ * =====================================================================================
+ */
+void Mainwin::Update_Date(Graphic& g,const char* timebuf)
+{
+	m_NorButton[0]->Set_Content(timebuf);
+	m_NorButton[0]->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sync_Cross_Chan_Parameters
+ *  Description: Sync the Cross Channel Parameters to other parameters  
+ * =====================================================================================
+ */
+void Mainwin::Sync_Cross_Chan_Parameters(Graphic& g)
+{
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		m_NorButton[i]->Set_Text(Get_Normal_Text(m_BottomFocus,i,m_SubMenuNo[m_BottomFocus-1]));
+		m_NorButton[i]->Drawme(g,false);
+	}
+
+	Msgbox *ms = new Msgbox(120,170,420,100,m_pl->GetText(PARASYNCCOMFIRM),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == true )
+	{
+		for ( int i=0;i<8;i++ )
+		{
+			m_gp->CrossDegree[i] = m_gp->CrossDegree[m_gp->ScopeChan];
+			m_gp->CrossGain[i] = m_gp->CrossGain[m_gp->ScopeChan];
+		}
+		m_gp->Calculate_Gain();
+	}
+
+	delete ms;
+	ms = NULL;
+}
diff --git a/src/EVA11/base/Mainwin.h b/src/EVA11/base/Mainwin.h
new file mode 100644
index 0000000..d1ad86e
--- /dev/null
+++ b/src/EVA11/base/Mainwin.h
@@ -0,0 +1,175 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Mainwin.h
+ *
+ *    Description:  Important class, in the Ruby project 
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月13日 15时15分28秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _MAINWIN_INC
+#define  _MAINWIN_INC
+
+class Basewin;
+class IView;
+class IProcess;
+class OthersProcess;
+class Graphic;
+
+#include 	<time.h>
+#include 	<sys/time.h>
+
+class Mainwin : public Basewin
+{
+	public:
+		Mainwin ();
+		virtual ~Mainwin ();
+		void Drawme (Graphic&);
+		int Loopwindow(Graphic &);
+
+	protected:
+		void Init_GUI(Graphic& g);
+		void Init_Variables();
+		void Destroy_GUI();
+
+		void Init_Process_Sets();
+		void Release_Process_Sets();
+
+		void Init_View_Sets(Graphic& g);
+		void Release_View_Sets();
+
+		virtual int Key_Bom1_Fun(Graphic& g);
+		virtual int Key_Bom2_Fun(Graphic& g);
+		virtual int Key_Bom3_Fun(Graphic& g);
+		virtual int Key_Bom4_Fun(Graphic& g);
+		virtual int Key_Bom5_Fun(Graphic& g);
+		virtual int Key_Bom6_Fun(Graphic& g);
+		virtual int Key_Bom7_Fun(Graphic& g);
+
+		virtual int Key_Esc_Fun(Graphic& g);
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual int Key_NL1_Fun(Graphic& g);
+		virtual int Key_NR1_Fun(Graphic& g);
+		virtual int Key_NL2_Fun(Graphic& g);
+		virtual int Key_NR2_Fun(Graphic& g);
+		virtual int Key_NL3_Fun(Graphic& g);
+		virtual int Key_NR3_Fun(Graphic& g);
+		virtual int Key_NL4_Fun(Graphic& g);
+		virtual int Key_NR4_Fun(Graphic& g);
+		virtual int Key_NL5_Fun(Graphic& g);
+		virtual int Key_NR5_Fun(Graphic& g);
+		virtual int Key_NL6_Fun(Graphic& g);
+		virtual int Key_NR6_Fun(Graphic& g);
+
+		virtual int Key_F1_Fun(Graphic& g);
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F5_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+		virtual int Key_F7_Fun(Graphic& g);
+	private:
+		const char*Get_Bom_Text(int index);
+		const char*Get_Normal_Text(int bom,int normal,int sub);
+
+		const char*Get_Normal_Text_1(int normal,int sub);
+		const char*Get_Normal_Text_2(int normal,int sub);
+		const char*Get_Normal_Text_3(int normal,int sub);
+		const char*Get_Normal_Text_4(int normal,int sub);
+		const char*Get_Normal_Text_5(int normal,int sub);
+		const char*Get_Normal_Text_6(int normal,int sub);
+		const char*Get_Normal_Text_7(int normal,int sub);
+
+		const char*Get_Normal_Text_1_ColorPanel(int normal,int sub);
+		const char*Get_Normal_Text_1_VideoPanel(int normal,int sub);
+		const char*Get_Normal_Text_1_ZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_1_DZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_1_OZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_1_CZKPanel(int normal,int sub);
+
+		const char*Get_Normal_Text_2_VideoPanel(int normal,int sub);
+		const char*Get_Normal_Text_2_ColorPanel(int normal,int sub);
+		const char*Get_Normal_Text_2_ZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_2_DZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_2_OZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_2_CZKPanel(int normal,int sub);
+
+		const char*Get_Normal_Text_4_ZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_4_DZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_4_OZKPanel(int normal,int sub);
+		const char*Get_Normal_Text_4_CZKPanel(int normal,int sub);
+
+		void DrawBottomFocus(Graphic& g,int index);
+		void DrawNormalFocus(Graphic& g,int index);
+
+		void Refresh_Small_Label(Graphic& g);
+
+		void Refresh_Normal_Label_Text(Graphic& g);
+		void Refresh_Normal_Label_Content(Graphic& g);
+
+		void Refresh_Normal_Label_Content_1(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_3(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_4(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_5(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_6(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_7(Graphic& g,int sub);
+
+		void Refresh_Normal_Label_Content_1_VideoPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_1_ColorPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_1_ZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_1_DZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_1_OZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_1_CZKPanel(Graphic& g,int sub);
+
+		void Refresh_Normal_Label_Content_2_VideoPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2_ColorPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2_ZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2_DZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2_OZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_2_CZKPanel(Graphic& g,int sub);
+
+		void Refresh_Normal_Label_Content_4_ZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_4_DZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_4_OZKPanel(Graphic& g,int sub);
+		void Refresh_Normal_Label_Content_4_CZKPanel(Graphic& g,int sub);
+
+		void Switch_Language(Graphic& g);
+
+		void DisplayTimeDate(Graphic& g);
+		void Update_Time(Graphic& g,const char *);
+		void Update_Date(Graphic& g,const char *);
+		void Sync_Cross_Chan_Parameters(Graphic& g);
+	private:
+		friend class 			     OthersProcess;
+		friend class 			     ParameterProcess;
+		friend class 			     DetectProcess;
+
+		static const int  		     MAXNORCOUNT = 6;
+
+		/*-----------------------------------------------------------------------------
+		 * Bottom buttons
+		 *---------------------------------------------------------------------------- */
+		int               		     m_NormalFocus;
+		int 				     m_SubMenuNo[MAXBOMCOUNT];    
+		int 				     m_SubMenuMaxNo[MAXBOMCOUNT]; 
+
+		Label				     *m_NorButton[MAXNORCOUNT];
+		IProcess			     *m_Process[MAXBOMCOUNT];
+		IView				     *m_View[MAXBOMCOUNT];
+
+		bool				     m_PauseFlag;
+		int				     m_ssecond;
+		
+}; /* -----  end of class Mainwin  ----- */
+#endif   /* ----- #ifndef _MAINWIN_INC  ----- */
diff --git a/src/EVA11/base/Makefile b/src/EVA11/base/Makefile
new file mode 100644
index 0000000..311190e
--- /dev/null
+++ b/src/EVA11/base/Makefile
@@ -0,0 +1,118 @@
+##########################################################
+#
+#                    The EVA11 project Makefile
+#
+# Author:    kevin.wang
+# Company:   Eddysun     xiamen
+# Date:      2012.12.13
+# Comment:   Try to re-structure the Project Makefile
+#            
+#
+###########################################################
+include MKlib.mk 
+
+ifeq ($(CMOD),dynamic)
+DYNAMICLIBS=$(THIRDLIB) $(LIBS)
+else
+DYNAMICLIBS:=$(LIBS) 
+STATICLIBS=$(THIRDLIB)
+endif
+
+TXTOBJS:=OBJS
+TXTDEPS:=DEPS
+TXTJPGS:=JPGS
+TXTASMS:=ASMS
+OBJS_DIR:=./$(TXTOBJS)/
+DEPS_DIR:=./$(TXTDEPS)/
+
+ifeq ($(COMPILE),arm9)
+SRCS:=$(wildcard *.cpp *.c $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif $(TXTASMS)/*.s)
+else
+SRCS:=$(wildcard *.cpp *.c $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif)
+endif
+
+OBJS:=$(SRCS:=.o)
+DEPS:=$(SRCS:=.dep)
+
+OBJS:=$(addprefix $(OBJS_DIR),$(OBJS))
+DEPS:=$(addprefix $(DEPS_DIR),$(DEPS))
+
+ifeq ($(DEBUG),yes)
+COMPILE_FLAG = -g2
+else
+
+ifeq ($(COMPILE),arm9)
+COMPILE_FLAG = -O2 -march=armv4t
+else 
+COMPILE_FLAG = -O2
+endif
+
+endif
+
+
+all: $(DEPS) $(EXEC)
+
+$(DEPS_DIR)%.cpp.dep: %.cpp
+	@set -e; \
+	$(RM) -rf $@.tmp; \
+	gcc -E -MM $^ > $@.tmp; \
+	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.cpp.o:,g' < $@.tmp > $@; \
+	$(RM) $@.tmp
+
+$(DEPS_DIR)%.c.dep: %.c
+	@set -e; \
+	$(RM) -rf $@.tmp; \
+	gcc -E -MM $^ > $@.tmp; \
+	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.c.o:,g' < $@.tmp > $@; \
+	$(RM) $@.tmp
+
+$(DEPS_DIR)$(TXTASMS)/%.s.dep: $(TXTASMS)/%.s
+	@set -e;
+
+$(DEPS_DIR)$(TXTJPGS)/%.jpg.dep: $(TXTJPGS)/%.jpg
+	@set -e;
+
+$(DEPS_DIR)$(TXTJPGS)/%.png.dep: $(TXTJPGS)/%.png
+	@set -e;
+
+$(DEPS_DIR)$(TXTJPGS)/%.gif.dep: $(TXTJPGS)/%.gif
+	@set -e;
+
+-include $(DEPS)
+
+$(EXEC): $(OBJS)
+	$(CPP) $(FLAG) -o $@ $^ -Wl,-Bdynamic $(addprefix -l,$(DYNAMICLIBS)) -Wl,-Bstatic $(addprefix -l,$(STATICLIBS)) $(SEARCH_LIBPATH) -Wl,-Bdynamic
+
+$(addprefix $(OBJS_DIR),%.s.o): %.s
+	$(AS) $< -o $@
+
+$(addprefix $(OBJS_DIR),%.c.o): %.c
+	$(CC) $(C_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
+
+$(addprefix $(OBJS_DIR),%.cpp.o): %.cpp
+	$(CPP) $(CPP_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
+
+$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.jpg.o): $(TXTJPGS)/%.jpg
+ifeq ($(COMPILE),arm9)
+	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
+else
+	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
+endif
+
+$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.png.o): $(TXTJPGS)/%.png
+ifeq ($(COMPILE),arm9)
+	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
+else
+	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
+endif
+
+$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.gif.o): $(TXTJPGS)/%.gif
+ifeq ($(COMPILE),arm9)
+	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
+else
+	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
+endif
+
+.PHONY: clean
+clean:
+	$(RM) -rf $(addprefix $(OBJS_DIR),*.o) $(addprefix $(OBJS_DIR),$(TXTJPGS)/*.o) $(addprefix $(DEPS_DIR),*.dep) $(EXEC) 
diff --git a/src/EVA11/base/ManageMD5.cpp b/src/EVA11/base/ManageMD5.cpp
new file mode 100644
index 0000000..ff5a7b5
--- /dev/null
+++ b/src/EVA11/base/ManageMD5.cpp
@@ -0,0 +1,132 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ManageMD5.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月12日 16时44分40秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<new>
+#include 	<cstring>
+#include        <cstdio>
+#include 	<unistd.h>
+#include 	<fstream>
+#include 	<ostream>
+
+#include 	<openssl/md5.h>
+
+#include 	"ManageMD5.h"
+std::auto_ptr<ManageMD5> ManageMD5::m_Instance;
+
+static unsigned char shash[MD5_DIGEST_LENGTH] = {0};
+
+ManageMD5::ManageMD5 ()
+{
+}
+
+ManageMD5::~ManageMD5 ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+ManageMD5* ManageMD5::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new ManageMD5() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_MD5
+ *  Description:  Calculate the MD5 value 
+ *         path:  Complete path of file which need to calculate MD5
+ * =====================================================================================
+ */
+bool ManageMD5::Calculate_MD5(const char* path)
+{
+	using namespace std;
+	bool result = false;
+	if 	( access(path,0) == -1 )
+	{
+		perror("access file");
+		return false;
+	}
+	std::fstream filestream;
+	filestream.open(path,ios::binary|ios::in);
+	if 	( !filestream )
+	{
+		perror("can't open the input data file\n");
+		return false;
+	}
+	filestream.seekp(0,ios::end);
+	unsigned int length = filestream.tellp();
+
+	if ( length <= 16 )
+	{
+		printf ( "length less 16 bytes\n" );
+		return false;
+	}
+
+	unsigned char *buf  = new(std::nothrow) unsigned char[length];
+
+	if ( buf == NULL )
+	{
+		perror("Can't Allocate Memory for Programe");
+		return false;
+	}
+
+	filestream.seekp(0,ios::beg);
+	filestream.read((char*)buf,length);
+	filestream.close();
+
+	MD5_CTX ctx;
+	memset(&ctx,0,sizeof(MD5_CTX));
+	MD5_Init(&ctx);
+	MD5_Update(&ctx,buf,length-16);
+	MD5_Final(shash,&ctx);
+
+	for ( int i=0;i<16;i++ )
+	{
+		if ( buf[length-16+i] != shash[i] )
+		{
+			result = false;
+			goto Exit;
+		}
+	}
+
+ 	result = true;
+Exit:
+	delete[] buf;
+	buf = NULL;
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Hash_Value
+ *  Description:  Get the Hash table value 
+ *      caution:  Get the Hash value after Calculate_MD5
+ * =====================================================================================
+ */
+unsigned char* ManageMD5::Get_Hash_Value()
+{
+	return shash;
+}
diff --git a/src/EVA11/base/ManageMD5.h b/src/EVA11/base/ManageMD5.h
new file mode 100644
index 0000000..c45428a
--- /dev/null
+++ b/src/EVA11/base/ManageMD5.h
@@ -0,0 +1,41 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ManageMD5.h
+ *
+ *    Description:  Deal with md5 function
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月12日 16时39分52秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  ManageMD5_INC
+#define  ManageMD5_INC
+
+#include 	<memory>
+class ManageMD5
+{
+	public:
+		static ManageMD5* Instance();
+		bool Calculate_MD5(const char* path);
+		unsigned char* Get_Hash_Value();
+	protected:
+
+	private:
+		ManageMD5();
+		~ManageMD5();
+		ManageMD5( const ManageMD5& );
+		ManageMD5& operator = (const ManageMD5&);
+	private:
+		friend class std::auto_ptr<ManageMD5>;
+		static std::auto_ptr<ManageMD5>		m_Instance;
+};
+
+#endif   /* ----- #ifndef ManageMD5_INC  ----- */
diff --git a/src/EVA11/base/MixingManage.cpp b/src/EVA11/base/MixingManage.cpp
new file mode 100644
index 0000000..c270130
--- /dev/null
+++ b/src/EVA11/base/MixingManage.cpp
@@ -0,0 +1,200 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  MixingManage.cpp
+ *
+ *    Description:  Implementation of MixingManage class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月28日 11时25分57秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	"MixingManage.h"
+#include 	"AlgMixing.h"
+#include 	"Global.h"
+
+std::auto_ptr<MixingManage> MixingManage::m_Instance;
+
+struct MixingManage::PImpl
+{
+	const static int	UnitCount = Global::MIXCOUNT;
+	AlgMixing*		AlgMixUnit[UnitCount];
+};
+
+MixingManage::MixingManage ()
+	: m_Imple(new struct PImpl)
+{
+}
+
+MixingManage::~MixingManage ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  Only use this function to init logic class 
+ * =====================================================================================
+ */
+MixingManage* MixingManage::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new MixingManage() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Object
+ *  Description:  Init the Object of MixingManage class 
+ * =====================================================================================
+ */
+bool MixingManage::Init_Object()
+{
+	for ( int i=0;i<m_Imple->UnitCount;i++ )
+	{
+		m_Imple->AlgMixUnit[i] = new AlgMixing;
+		m_Imple->AlgMixUnit[i]->Init_Object();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy
+ *  Description:  Destroy the object of class 
+ * =====================================================================================
+ */
+void MixingManage::Destroy_Object()
+{
+	for ( int i=0;i<m_Imple->UnitCount;i++ )
+	{
+		delete m_Imple->AlgMixUnit[i];
+		m_Imple->AlgMixUnit[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Data_Into_Buffer
+ *  Description:  Load Data into Buffer of object 
+ * =====================================================================================
+ */
+void MixingManage::Load_Data_Into_Buffer(int index,ETDATA *data)
+{
+	m_Imple->AlgMixUnit[index]->Load_Data_Into_Buffer(data);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_Data_From_Buffer
+ *  Description:  Clean Data from Buffer 
+ * =====================================================================================
+ */
+void MixingManage::Clean_Data_From_Buffer(int index)
+{
+	m_Imple->AlgMixUnit[index]->Clean_Data_From_Buffer();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Mix_Para
+ *  Description:  Calculate the mixing parameters
+ * =====================================================================================
+ */
+void MixingManage::Calculate_Mix_Para(int index)
+{
+	m_Imple->AlgMixUnit[index]->Calculate_Mix_Para();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mixing
+ *  Description:  Mixing the Signal value 
+ * =====================================================================================
+ */
+void MixingManage::Mixing(int index,const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA & y)
+{
+	m_Imple->AlgMixUnit[index]->Mixing(xb,yb,x,y);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_MixUnit_Count
+ *  Description:  Get the Mixing Unit Count 
+ * =====================================================================================
+ */
+int MixingManage::Get_MixUnit_Count()
+{
+	return m_Imple->UnitCount;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sync_Mixing_Para
+ *  Description:  Sync Mixing para with Mixing Unit and Global 
+ *
+ *         flag:  true    	MixingUnit -> Global
+ *                false 	Global->MixingUnit
+ * =====================================================================================
+ */
+void MixingManage::Sync_Mixing_Para(bool flag)
+{
+	Global *gp = Global::Instance();
+	if 	( flag == false )
+	{
+		for ( int i=0;i<Global::MIXCOUNT;i++ )
+		{
+			m_Imple->AlgMixUnit[i]->Set_Sx(gp->Sx[i]);
+			m_Imple->AlgMixUnit[i]->Set_Sy(gp->Sy[i]);
+			m_Imple->AlgMixUnit[i]->Set_Cos(gp->Cos[i]);
+			m_Imple->AlgMixUnit[i]->Set_Sin(gp->Sin[i]);
+
+			m_Imple->AlgMixUnit[i]->Set_a(gp->a[i]);
+			m_Imple->AlgMixUnit[i]->Set_b(gp->b[i]);
+			m_Imple->AlgMixUnit[i]->Set_c(gp->c[i]);
+			m_Imple->AlgMixUnit[i]->Set_d(gp->d[i]);
+
+			m_Imple->AlgMixUnit[i]->Set_AlgMix_Version(gp->MixAlgVersion[i]);
+		}
+	}
+	else
+	{
+		for ( int i=0;i<Global::MIXCOUNT;i++ )
+		{
+			gp->Sx[i]  = m_Imple->AlgMixUnit[i]->Get_Sx();
+			gp->Sy[i]  = m_Imple->AlgMixUnit[i]->Get_Sy();
+			gp->Cos[i] = m_Imple->AlgMixUnit[i]->Get_Cos();
+			gp->Sin[i] = m_Imple->AlgMixUnit[i]->Get_Sin();
+
+			gp->a[i] = m_Imple->AlgMixUnit[i]->Get_a();
+			gp->b[i] = m_Imple->AlgMixUnit[i]->Get_b();
+			gp->c[i] = m_Imple->AlgMixUnit[i]->Get_c();
+			gp->d[i] = m_Imple->AlgMixUnit[i]->Get_d();
+
+			gp->MixAlgVersion[i]
+				 = m_Imple->AlgMixUnit[i]->Get_AlgMix_Version();
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restore_Mix_Factor
+ *  Description:  Restore Mult-Freq Factor 
+ * =====================================================================================
+ */
+void MixingManage::Restore_Mix_Factor()
+{
+	for ( int i=0;i<Global::MIXCOUNT;i++ )
+	{
+		m_Imple->AlgMixUnit[i]->Init_Object();
+	}
+}
diff --git a/src/EVA11/base/MixingManage.h b/src/EVA11/base/MixingManage.h
new file mode 100644
index 0000000..527eb2d
--- /dev/null
+++ b/src/EVA11/base/MixingManage.h
@@ -0,0 +1,54 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  MixingManage.h
+ *
+ *    Description:  Manage the Mixing unit
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月28日 11时23分45秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  MIXINGMANAGE_INC
+#define  MIXINGMANAGE_INC
+
+#include 	<memory>
+#include 	"main.h"
+
+class MixingManage
+{
+	public:
+		static MixingManage* Instance();
+
+		bool Init_Object();
+		void Destroy_Object();
+		void Load_Data_Into_Buffer(int index,ETDATA *data);
+		void Clean_Data_From_Buffer(int index);
+		void Calculate_Mix_Para(int index);
+		void Mixing(int index,const ETDATA xb,const ETDATA yb,ETDATA &x,ETDATA &y);
+		int Get_MixUnit_Count();
+
+		void Sync_Mixing_Para(bool);
+		void Restore_Mix_Factor();
+	protected:
+
+	private:
+		MixingManage ();
+		~MixingManage ();
+		MixingManage (const MixingManage&);
+		MixingManage& operator = (const MixingManage&);
+	private:
+		friend class std::auto_ptr<MixingManage>;
+		static std::auto_ptr<MixingManage>		m_Instance;
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif   /* ----- #ifndef MIXINGMANAGE_INC  ----- */
diff --git a/src/EVA11/base/Modifywin.cpp b/src/EVA11/base/Modifywin.cpp
new file mode 100644
index 0000000..feea6ab
--- /dev/null
+++ b/src/EVA11/base/Modifywin.cpp
@@ -0,0 +1,277 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Modifywin.cpp
+ *
+ *    Description:  Implementation of Modifywin class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月04日 16时45分27秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Basewin.h"
+#include	"Loadwin.h"
+#include	"Modifywin.h" 
+#include 	"Graphic.h"
+#include 	"Logic.h"
+#include	"Label.h"
+#include	"Language.h"
+#include	"Global.h"
+#include	"Msgbox.h"
+#include	"Battery.h"
+#include 	"Parawin.h"
+
+Modifywin::Modifywin (Graphic&g,LOADTYPE type) :
+	Loadwin(g,type)
+{
+}
+
+Modifywin::~Modifywin ()
+{
+}
+
+void Modifywin::Drawme (Graphic& g)
+{
+	Basewin::Drawme(g);
+	m_Title->Drawme(g);
+
+	if ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE )
+		m_SubTitle->Drawme(g);
+
+	for ( int i=0;i<26;i++ )
+	{
+		m_NorLable[i]->Drawme(g);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object of screen 
+ * =====================================================================================
+ */
+void Modifywin::Init_GUI(Graphic& g)
+{
+	if 	( m_Type == LT_SAVE )
+	{
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(SAVEPARAM));
+	}
+	else if	( m_Type == LT_LOAD )
+	{
+	       	m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(LOADPARAM));
+	}
+	else if	( m_Type == LT_DELE )
+	{ 
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(DELPARAM));
+	}
+	else if	( m_Type == DA_SAVE )
+	{ 
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
+	}
+	else if	( m_Type == DA_LOAD )
+	{
+	       	m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(LOADDATA));
+	}
+	else if	( m_Type == DA_DELE ) 
+	{
+		m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(DELEDATA));
+	}
+	m_Title->Set_Label_Type(Label::LA_NONE);
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+
+	Sub_Init_GUI(g);
+
+	m_BottomFocus = 1;
+	m_NormalFocus = 1;
+	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+	m_BomButton[m_BottomFocus-1]->Set_Focus(true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void Modifywin::Destroy_GUI()
+{
+	if ( m_Title != NULL )
+	{
+		delete m_Title;
+		m_Title = NULL;
+	}
+	if ( m_SubTitle != NULL )
+	{
+		delete m_SubTitle;
+		m_SubTitle = NULL;
+	}
+	for ( int i=0;i<26;i++ )
+	{
+		if ( m_NorLable[i] != NULL )
+		{
+			delete m_NorLable[i];
+			m_NorLable[i] = NULL;
+		}
+	}
+	Basewin::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  Switch the bottom focus status 
+ * =====================================================================================
+ */
+void Modifywin::DrawBottomFocus(Graphic &g,int index)
+{
+	Basewin::DrawBottomFocus(g,index);
+	switch ( index ) 
+	{
+		case 1:                         /* previouse */
+			{
+				if ( m_NormalFocus == 1 )
+				{
+				        m_NormalFocus = 26;
+					m_NorLable[0]->Set_Focus(false);
+					m_NorLable[0]->Drawme(g);
+					m_NorLable[25]->Set_Focus(true);
+					m_NorLable[25]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus--;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+		case 2:                         /* next */
+			{
+				if ( m_NormalFocus == 26 )
+				{
+				        m_NormalFocus = 1;
+					m_NorLable[25]->Set_Focus(false);
+					m_NorLable[25]->Drawme(g);
+					m_NorLable[0]->Set_Focus(true);
+					m_NorLable[0]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus++;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 3:                         /* left  */
+			{
+				if ( m_NormalFocus < 7 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 20;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus >= 7 && m_NormalFocus <= 10 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 4:                         /* right */
+			{
+				if ( m_NormalFocus > 20 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 20;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else if ( m_NormalFocus <= 20 && m_NormalFocus > 16 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function 
+ *       return:  0: Exit program
+ *                1: goto Mainwin
+ * =====================================================================================
+ */
+int Modifywin::Loopwindow (Graphic &g)
+{
+	Save_Screen_Into_Memory(g);
+	int result = SubLoopwindow(g);
+	Restore_Screen_From_Memory(g);
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Modifywin::Key_Esc_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Modifywin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
diff --git a/src/EVA11/base/Modifywin.h b/src/EVA11/base/Modifywin.h
new file mode 100644
index 0000000..679239a
--- /dev/null
+++ b/src/EVA11/base/Modifywin.h
@@ -0,0 +1,41 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Modifywin.h
+ *
+ *    Description:  Load parameters level 1 class   
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月04日 16时43分31秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _MODIFYWIN_INC
+#define  _MODIFYWIN_INC
+
+class Loadwin;
+class Modifywin : public Loadwin
+{
+	public:
+		Modifywin (Graphic&g,LOADTYPE type);
+		virtual ~Modifywin ();
+
+		void Drawme (Graphic& g);       		                 /* Any window coming from window class draw itself on screen */
+		int Loopwindow (Graphic &);        		                 /* deal with the command getting from key board  */
+	protected:
+		virtual int Key_Esc_Fun(Graphic& g);
+		virtual int Key_Bom7_Fun(Graphic& g);
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+		void DrawBottomFocus(Graphic &g,int index);     		 /* change the bottom buttons status as the parameter index */
+	private:
+}; /* -----  end of class Modifywin  ----- */
+
+#endif   /* ----- #ifndef modifywin_INC  ----- */
diff --git a/src/EVA11/base/Msgbox.cpp b/src/EVA11/base/Msgbox.cpp
new file mode 100644
index 0000000..cf70950
--- /dev/null
+++ b/src/EVA11/base/Msgbox.cpp
@@ -0,0 +1,480 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Msgbox.cpp
+ *
+ *    Description:  implementation of Msgbox class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 16时38分13秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include	<string.h>
+#include 	<stdio.h>
+#include 	<unistd.h>
+#include 	<sys/time.h>
+
+#include 	"Object.h"
+#include 	"Msgbox.h"
+#include	"Graphic.h"
+#include 	"Label.h"
+#include	"Language.h"
+#include 	"Algorithm.h"
+#include 	"Logic.h"
+
+Msgbox::Msgbox (int x,int y,int width,int heigh,const char *text,MSGBOXTYPE type)
+{
+	m_Type     = type;
+	m_X        = x;
+	m_Y        = y;
+	m_Width    = width;
+	m_Heigh    = heigh;
+	m_FontType = 16;
+
+	m_Text     = NULL;
+	m_Text     = new char[strlen(text)+1];
+	strcpy(m_Text,text);
+
+	m_Content  = NULL;
+	m_Content  = new char[strlen("--")+1];
+	strcpy(m_Content,"--");
+	
+	m_Transparece = 255;
+
+}  /* -----  end of method Msgbox::Msgbox  (constructor)  ----- */
+
+Msgbox::~Msgbox ()
+{
+	if ( m_Text == NULL )
+	{
+		delete[] m_Text;
+		m_Text = NULL;
+	}
+	if ( m_Content == NULL )
+	{
+		delete[] m_Content;
+		m_Content = NULL;
+	}
+}  /* -----  end of method Msgbox::Msgbox  (destructor)  ----- */
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Text
+ *  Description:  Set the Msgbox showing text 
+ * =====================================================================================
+ */
+void Msgbox::Set_Text(const char *text)
+{
+	if ( strlen(text) == 0 ) return;
+	delete[] m_Text;
+	m_Text = new char[strlen(text)+1];
+	strcpy(m_Text,text);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Content
+ *  Description:  Set the Content message 
+ * =====================================================================================
+ */
+void Msgbox::Set_Content(const char *text)
+{
+	if ( strlen(text) == 0 ) return;
+	delete[] m_Content;
+	m_Content = new char[strlen(text)+1];
+	strcpy(m_Content,text);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Color
+ *  Description:  Set the Msgbox's color 
+ * =====================================================================================
+ */
+void Msgbox::Set_Color(MSG_COLORTYPE ct,short color)
+{
+	if 	( ct == MSG_COLORTYPE_FG )
+		m_FGColor = color;
+	else if ( ct == MSG_COLORTYPE_BG )
+		m_BGColor = color;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_FontType
+ *  Description:  Set the font type 
+ * =====================================================================================
+ */
+void Msgbox::Set_FontType(int value)
+{
+	m_FontType = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Showme
+ *  Description:  Very important function, draw msgbox and deal with the key event 
+ * =====================================================================================
+ */
+bool Msgbox::Showme(Graphic &g)
+{
+	bool revalue = false;
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1)];
+	g.Load_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,mem); 	   /* save the screen graphic buffer */
+
+	g.Switch_Screen();
+
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
+	COLORTYPE co_sa;
+	co_sa = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
+	g.Setcolor(g.RGB24_16(0x000000));
+	g.DrawRect(m_X+2,m_Y+2,m_Width-4,m_Heigh-4);
+	g.DrawRect(m_X+3,m_Y+3,m_Width-6,m_Heigh-6);
+	g.Setcolor(m_FGColor);
+	g.DrawRect(m_X+4,m_Y+4,m_Width-8,m_Heigh-8);
+	g.Setcolor(co_sa);
+
+	g.Switch_Screen();
+	int t = g.Get_Transparce();
+	g.Set_Transparce(m_Transparece);
+	g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	g.Set_Transparce(t);
+
+	revalue = Loopwindow(g);
+Exit:
+	g.Restore_Disp_Area(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,mem); /* restore the graphic buffer */
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+	delete[] mem;                                                 /* release the buffer */
+	mem = NULL;
+	return revalue;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function, do anthing for this class 
+ * =====================================================================================
+ */
+bool Msgbox::Loopwindow(Graphic& g)
+{
+	bool revalue = false;
+	Language* pl = Language::Instance();
+	Algorithm* alg = Algorithm::Instance();
+	Logic* lo       = Logic::Instance();
+	int cent_x   = m_X + ( m_Width>>1 );
+	int cent_y   = m_Y + ( m_Heigh>>1 );
+	int ft       = m_FontType;
+	int key      = 0;
+
+	if 	( m_Type == MSG_OK )
+	{
+		Label *button	= new Label(cent_x-2*ft-4,cent_y+(ft>>1)-2,4*ft,ft+8);
+		button->Set_Text(pl->GetText(COMFIRM));
+		button->Set_Font_Size(16);
+		button->Set_Label_Type(Label::LA_3D);
+		button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
+		lab->Set_Label_Type(Label::LA_NONE);
+		lab->Set_Text(m_Text);
+		lab->Set_Font_Size(18);
+		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
+		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
+		lab->Drawme(g);
+		button->Drawme(g);
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		while(key!= KEY_ENTER && key!= KEY_ESC)                    /*there may be much start method */
+		{
+			key = lo->Get_Key();
+		}
+		button->Set_Focus(true);
+		button->Drawme(g);
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		alg->MDelay(100);
+
+		delete button;
+		button = NULL;
+		delete lab;
+		lab = NULL;
+		revalue = true;
+	}
+	else if ( m_Type == MSG_OKCANCEL )
+	{
+		g.Switch_Screen();
+
+		Label *button1	= new Label(cent_x-(ft<<2)-(ft<<1),cent_y+(ft>>1)-2,4*ft,ft+8);
+		Label *button2	= new Label(cent_x+(ft<<1),cent_y+(ft>>1)-2,4*ft,ft+8);
+		button1->Set_Label_Type(Label::LA_3D);
+		button2->Set_Label_Type(Label::LA_3D);
+		button1->Set_Font_Size(16);
+		button2->Set_Font_Size(16);
+		button2->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		button2->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		button2->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		button2->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		button1->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		button1->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		button1->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		button1->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+		button1->Set_Text(pl->GetText(COMFIRM));
+		button2->Set_Text(pl->GetText(CANCEL));
+
+		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
+		lab->Set_Label_Type(Label::LA_NONE);
+		lab->Set_Text(m_Text);
+		lab->Set_Font_Size(18);
+		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
+		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
+		lab->Drawme(g);
+		button1->Drawme(g);
+		button2->Drawme(g);
+	
+		g.Switch_Screen();
+		int t = g.Get_Transparce();
+		g.Set_Transparce(m_Transparece);
+		g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+		g.Set_Transparce(t);
+
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		while(key!= KEY_ENTER && key!= KEY_ESC)               	   /*there may be much start method */
+		{
+			key = lo->Get_Key();
+		}
+
+		g.Switch_Screen();
+
+		if ( key == KEY_ENTER )  { button1->Set_Focus(true); button1->Drawme(g); revalue = true;}
+		else if ( key == KEY_ESC ) { button2->Set_Focus(true); button2->Drawme(g); revalue = false;}
+
+		g.Switch_Screen();
+		t = g.Get_Transparce();
+		g.Set_Transparce(m_Transparece);
+		g.Screen_Copy_Alpha(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+		g.Set_Transparce(t);
+
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		alg->MDelay(100);
+
+		delete button1;
+		button1 = NULL;
+		delete button2;
+		button2 = NULL;
+		delete lab;
+		lab = NULL;
+	}
+	else if ( m_Type == MSG_AUTO )			 	           /* auto close the windows  */
+	{
+		int tick = 0;
+		Label *button	= new Label(cent_x-2*ft-4,cent_y+(ft>>1)-2,4*ft,ft+8);
+		button->Set_Text(pl->GetText(COMFIRM));
+		button->Set_Font_Size(16);
+		button->Set_Label_Type(Label::LA_3D);
+		button->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		button->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		button->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		button->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+		Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-12,ft*(strlen(m_Text)>>1)+4,ft+4);
+		lab->Set_Label_Type(Label::LA_NONE);
+		lab->Set_Text(m_Text);
+		lab->Set_Font_Size(16);
+		lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
+		lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
+
+		lab->Drawme(g);
+		button->Drawme(g);
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		while( key!= KEY_ENTER && key!= KEY_ESC && tick<50 )   /*there may be much start method */
+		{
+			key = lo->Get_Key();
+			alg->MDelay(100);
+			tick ++;
+		}
+		button->Set_Focus(true);
+		button->Drawme(g);
+#ifdef X86
+		g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+		alg->MDelay(100);
+		delete button;
+		button = NULL;
+		delete lab;
+		lab = NULL;
+		revalue = true;
+	}
+	return revalue;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Transparce
+ *  Description:  
+ * =====================================================================================
+ */
+void Msgbox::Set_Transparce(int v)
+{
+	m_Transparece = v;
+}
+
+PasswdMsgbox::PasswdMsgbox (int x,int y,int width,int heigh,const char *text) :
+	Msgbox(x,y,width,heigh,text,MSG_OK) 
+{
+	m_Status = PWCANCEL;
+}
+
+PasswdMsgbox::~PasswdMsgbox()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Main loop function,very important function 
+ * =====================================================================================
+ */
+bool PasswdMsgbox::Loopwindow(Graphic &g)
+{
+	bool revalue    = false;
+	Language* pl    = Language::Instance();
+	Algorithm* alg  = Algorithm::Instance();
+	Logic* lo       = Logic::Instance();
+	int cent_x      = m_X + ( m_Width>>1 );
+	int cent_y      = m_Y + ( m_Heigh>>1 );
+	int ft          = m_FontType;
+	int key         = 0;
+
+	char pa[4];
+	int index       = 0;
+
+	Label *button1	= new Label(cent_x-(ft<<2)-(ft<<1),cent_y+(ft>>1)+10,4*ft,ft+8);
+	Label *button2	= new Label(cent_x+(ft<<1),cent_y+(ft>>1)+10,4*ft,ft+8);
+
+	button1->Set_Text(pl->GetText(COMFIRM));
+	button2->Set_Text(pl->GetText(CANCEL));
+
+	button1->Set_Label_Type(Label::LA_3D);
+	button2->Set_Label_Type(Label::LA_3D);
+	button1->Set_Font_Size(16);
+	button2->Set_Font_Size(16);
+
+	button2->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	button2->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	button2->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	button2->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	button1->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	button1->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	button1->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	button1->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+
+	Label *lab = new Label(cent_x-(strlen(m_Text)>>1)*(ft>>1)-4,cent_y-(ft)-20,ft*(strlen(m_Text)>>1)+4,ft+4);
+	lab->Set_Text(m_Text);
+	lab->Set_Label_Type(Label::LA_NONE);
+
+	lab->Set_Font_Size(18);
+	lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
+	lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
+	lab->Drawme(g);
+	button1->Drawme(g);
+	button2->Drawme(g);
+
+#ifdef X86
+	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+	while( key!= KEY_ENTER && key!= KEY_ESC )
+	{
+		if ( index == 5 ) { revalue = false; m_Status = PWFAILTURE; goto Exit; }
+
+		if ( key != 0 && key!= KEY_ENTER && key!= KEY_ESC ) 
+		{
+			pa[index] = key;
+			index ++;
+			Show_Each_Password(g,index);
+		}
+
+		key = lo->Get_Key();
+		alg->MDelay(50);
+	}
+
+	if      ( key == KEY_ENTER )
+	{
+		button1->Set_Focus(true); 
+		button1->Drawme(g); 
+		if ( pa[0] == KEY_F2 && pa[1] == KEY_F5 && pa[2] == KEY_F4 && pa[3] == KEY_F3 )
+		{
+			m_Status = PWSUCCESS;
+			revalue = true;
+		}
+		else 
+		{
+			m_Status = PWFAILTURE;
+			revalue = false;
+		}
+	}
+	else if ( key == KEY_ESC   ) { button2->Set_Focus(true); button2->Drawme(g); m_Status = PWCANCEL; revalue = false;}
+
+#ifdef X86
+	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+Exit:		
+	alg->MDelay(100);
+	delete button1;
+	button1 = NULL;
+	delete button2;
+	button2 = NULL;
+	delete lab;
+	lab = NULL;
+	return revalue;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Each_Password
+ *  Description:  Show Each passowrd key 
+ *                MAX Count is 4
+ * =====================================================================================
+ */
+void PasswdMsgbox::Show_Each_Password(Graphic &g,int index)
+{
+	int cent_x = m_X + ( m_Width>>1 );
+	int cent_y = m_Y + ( m_Heigh>>1 );
+	Label *lab = new Label(cent_x-60+index*20,cent_y-8,20,18);
+
+	lab->Set_Text("*");
+	lab->Set_Label_Type(Label::LA_NONE);
+
+	lab->Set_Font_Size(16);
+	lab->Set_Label_Color(Label::LA_BGNO_COLOR,m_BGColor);
+	lab->Set_Label_Color(Label::LA_FGNO_COLOR,m_FGColor);
+	lab->Drawme(g);
+	delete lab;
+	lab = NULL;
+#ifdef X86
+	g.Update_Rect(m_X,m_Y,m_Width,m_Heigh);
+#endif
+}
diff --git a/src/EVA11/base/Msgbox.h b/src/EVA11/base/Msgbox.h
new file mode 100644
index 0000000..72c7866
--- /dev/null
+++ b/src/EVA11/base/Msgbox.h
@@ -0,0 +1,92 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Msgbox.h
+ *
+ *    Description:  Declear of Msgbox class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月06日 16时25分54秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _MSGBOX_INC
+#define  _MSGBOX_INC
+
+class Graphic;
+class Msgbox
+{
+	public:
+		enum MSGBOXTYPE 
+		{
+			MSG_OK,
+			MSG_OKCANCEL,
+			MSG_AUTO,
+		};
+		typedef enum MSGBOXTYPE MSGBOXTYPE;
+
+		enum MSG_COLORTYPE
+		{
+			MSG_COLORTYPE_FG,
+			MSG_COLORTYPE_BG,
+		};
+		typedef enum MSG_COLORTYPE MSG_COLORTYPE;
+
+		Msgbox (int x,int y,int width,int heigh,const char *text,MSGBOXTYPE type);
+		~Msgbox ();
+		
+		bool Showme(Graphic &);
+
+		void Set_Text(const char*);
+		void Set_Content(const char *text);
+		void Set_Color(MSG_COLORTYPE ct,short color);
+		void Set_FontType(int value);
+
+		void Set_Transparce(int);
+	protected:
+		virtual bool Loopwindow(Graphic &);
+	protected:
+		MSGBOXTYPE  			m_Type;
+		short       			m_X;
+		short       			m_Y;
+		short       			m_Width;
+		short       			m_Heigh;
+		int         			m_FontType;
+
+		char       		       *m_Text;
+		char       		       *m_Content;
+		short   			m_BGColor;
+		short				m_FGColor;
+		int				m_Transparece;
+	private:
+};
+
+class PasswdMsgbox : public Msgbox
+{
+	public:
+		enum STATUS 
+		{
+			PWSUCCESS ,
+			PWFAILTURE,
+			PWCANCEL  , 
+		};
+		typedef enum STATUS STATUS;
+
+		PasswdMsgbox (int x,int y,int width,int heigh,const char *text);
+		~PasswdMsgbox ();
+
+		inline STATUS Get_Status() { return m_Status; }
+	protected:
+		virtual bool Loopwindow(Graphic &);
+
+	private:
+		void Show_Each_Password(Graphic &,int index);
+		STATUS 			  	m_Status;
+};
+#endif
diff --git a/src/EVA11/base/Netclient.cpp b/src/EVA11/base/Netclient.cpp
new file mode 100644
index 0000000..11ef954
--- /dev/null
+++ b/src/EVA11/base/Netclient.cpp
@@ -0,0 +1,317 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Netclient.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2011年10月19日 15时17分13秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#include	"Netclient.h"
+
+Netclient::Netclient ()
+{
+	m_Port = 5300;
+	m_ServerIP = new CHAR[100];
+	m_ClientIP = new CHAR[100];
+
+	sprintf ( m_ServerIP,"%s","192.168.1.1" );
+	Getip(m_ClientIP);
+	printf ( "%s\n",m_ClientIP );
+
+	m_tv.tv_sec  = 0;
+	m_tv.tv_usec = 1;
+}
+
+Netclient::~Netclient ()
+{
+	delete[] m_ServerIP;
+	m_ServerIP = NULL;
+	delete[] m_ClientIP;
+	m_ClientIP = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Open_Client
+ *  Description:  
+ * =====================================================================================
+ */
+BOOL Netclient::Open_Socket()
+{
+	m_Socketfd = socket(AF_INET,SOCK_STREAM,0);
+	if ( m_Socketfd == -1 ) { perror("Can't Init a socket!"); return false; }
+
+	bzero(&m_Locale,sizeof(m_Locale));
+	m_Locale.sin_family = AF_INET;           /* IPV4 version */
+	m_Locale.sin_port = htons(m_Port);
+	if ( inet_aton(m_ClientIP,(struct in_addr *)&m_Locale.sin_addr.s_addr) == 0 )
+	{
+		perror("Can't Init a local socket!"); 
+		close(m_Socketfd);	
+		return false;
+	}
+
+	bzero(&m_Remote,sizeof(m_Remote));
+	m_Remote.sin_family = AF_INET;
+	m_Remote.sin_port = htons(m_Port);       /* Remote port */
+	if ( inet_aton(m_ServerIP,(struct in_addr *)&m_Remote.sin_addr.s_addr) == 0 )
+	{
+		perror("Can't Init a remote socket!"); 
+		close(m_Socketfd);	
+		return false;
+	}
+
+	INT32 on = 1;                            /* Enable the Port can't be reused */
+	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on)) == -1 )
+	{
+		perror("Set Sockopt error");
+		close(m_Socketfd);
+		return false;
+	}
+
+	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_RCVTIMEO,(CHAR *)&m_tv,sizeof(struct timeval)) == -1 )
+	{
+		perror("Set Sockopt error 1");
+		close(m_Socketfd);
+		return false;
+	}
+
+	int rcvbuf = 1024*128;
+	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_RCVBUF,(const char *)&rcvbuf,sizeof(int) ) == -1 ) 
+	{
+		perror("Set Sockopt error 2");
+		close(m_Socketfd);
+		return false;
+	}
+
+	int sndbuf = 1024*128;
+	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_SNDBUF,(const char *)&sndbuf,sizeof(int) ) == -1 ) 
+	{
+		perror("Set Sockopt error 3");
+		close(m_Socketfd);
+		return false;
+	}
+
+	int flags;
+	flags = fcntl(m_Socketfd,F_GETFL,0);
+	fcntl(m_Socketfd,F_SETFL,flags|O_NONBLOCK);
+
+//	if ( setsockopt(m_Socketfd,SOL_SOCKET,SO_SNDTIMEO,(CHAR *)&m_tv,sizeof(struct timeval)) == -1 )
+//	{
+//		perror("Set Sockopt error 2");
+//		close(m_Socketfd);
+//		return false;
+//	}
+
+//	if ( bind(m_Socketfd,(struct sockaddr *)&m_Locale,sizeof(struct sockaddr) ) == -1 )
+//	{
+//		perror("Can't bind");
+//		close(m_Socketfd);
+//		return false;
+//	}
+
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Close_Socket
+ *  Description:  
+ * =====================================================================================
+ */
+void Netclient::Close_Socket()
+{
+	close(m_Socketfd);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Connect_Server
+ *  Description:   
+ * =====================================================================================
+ */
+BOOL Netclient::Connect_Server()
+{
+	BOOL flag = false;
+	if ( connect(m_Socketfd,(struct sockaddr*)&m_Remote,sizeof(m_Remote)) != 0 )
+	{
+		flag = false;
+	}
+	else
+	{
+		flag = true;
+	}
+	return flag;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Remote_IP
+ *  Description:  
+ * =====================================================================================
+ */
+const CHAR* Netclient::Get_Remote_IP()
+{
+	return inet_ntoa(m_Remote.sin_addr);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Poll_Socket_Status
+ *  Description:  
+ * =====================================================================================
+ */
+Netclient::NETSTA Netclient::Poll_Socket_Status()
+{
+	FD_ZERO(&m_RDfd);
+	FD_SET(m_Socketfd,&m_RDfd);
+
+	if ( select(m_Socketfd+1,&m_RDfd,NULL,NULL,&m_tv) <= 0 )
+		return Netclient::NETNONE;
+	else
+	{
+		if ( !FD_ISSET(m_Socketfd,&m_RDfd) )
+		{
+			return Netclient::NETNONE;
+		}
+		else
+		{
+			return Netclient::DATAIN;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  Get the Data from socket 
+ * =====================================================================================
+ */
+INT32 Netclient::Get_Data(CHAR* data,INT32 len)
+{
+	return recv(m_Socketfd,data,len,0);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Send_Data
+ *  Description:  Send Data into Net port 
+ * =====================================================================================
+ */
+bool Netclient::Send_Data(CHAR* data,INT32 len)
+{
+	FD_ZERO(&m_WRfd);
+	FD_SET(m_Socketfd,&m_WRfd);
+
+	if ( select(m_Socketfd+1,NULL,&m_WRfd,NULL,&m_tv) <= 0 )
+		return false; 
+	else
+	{
+		if ( !FD_ISSET(m_Socketfd,&m_WRfd) )
+		{
+			printf ( "test\n" );
+			return false; 
+		}
+		else
+		{
+			if ( send(m_Socketfd,data,len,0) != len )
+			{
+				printf ( "send data length != wanted send data length\n" );
+				return false;
+			}
+			else
+				return true;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Getip
+ *  Description:  
+ * =====================================================================================
+ */
+void Netclient::Getip(char *ip)
+{
+	int fd;
+	struct ifreq ifr;
+	struct sockaddr_in *sin;
+	fd = socket(AF_INET,SOCK_DGRAM,0);
+	memset(&ifr,0,sizeof(ifr));
+	strcpy(ifr.ifr_name,ETH_NAME);
+	ioctl(fd,SIOCGIFADDR,&ifr);
+	sin = (struct sockaddr_in*)&ifr.ifr_addr;
+	strcpy((char *)ip,(char *)inet_ntoa(sin->sin_addr));
+	close(fd);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Getmac
+ *  Description:  
+ * =====================================================================================
+ */
+void Netclient::Getmac(char *mac)
+{
+	int i;
+	int fd;
+	unsigned char addr[6];
+	struct ifreq ifr;
+	struct sockaddr_in *sin;
+	
+	fd = socket(AF_INET,SOCK_DGRAM,0);
+	memset(&ifr,0,sizeof(ifr));
+	strcpy(ifr.ifr_name,ETH_NAME);
+	ioctl(fd,SIOCGIFHWADDR,&ifr);
+	sin = (struct sockaddr_in*)&ifr.ifr_addr;
+	memset(addr,0,6);
+	memcpy(addr,ifr.ifr_hwaddr.sa_data,6);
+	sprintf((char *)mac,"%02x:%02x:%02x:%02x:%02x:%02x",
+			addr[0],addr[1],addr[2],addr[3],addr[4],addr[5]);
+	close(fd);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Test_Ether_Connect
+ *  Description:  Test the Ether Connect is OK
+ * =====================================================================================
+ */
+bool Netclient::Test_Ether_Connect()
+{
+	int fd = -1,err = 0;
+	struct ifreq ifr;
+	memset(&ifr, 0, sizeof(ifr));  
+	strcpy(ifr.ifr_name, ETH_NAME);  
+
+	fd = socket(AF_INET, SOCK_DGRAM, 0);  
+	if 	( fd < 0 )
+	{
+		perror("Cannot get control socket");  
+		return false;  
+	}
+
+	if 	( ioctl(fd, SIOCGIFFLAGS, &ifr) < 0 )
+	{
+		perror("Cannot get socket flags");  
+		return false;
+	}
+
+	if	( ifr.ifr_flags & IFF_RUNNING )
+		return true;
+	else 
+	{
+		perror("socket not running status");  
+		return false;
+	}
+}
diff --git a/src/EVA11/base/Netclient.h b/src/EVA11/base/Netclient.h
new file mode 100644
index 0000000..1e62da4
--- /dev/null
+++ b/src/EVA11/base/Netclient.h
@@ -0,0 +1,84 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Netclient.h
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2011年10月19日 15时14分10秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _NETCLIENT_INC
+#define  _NETCLIENT_INC
+
+/*
+ * =====================================================================================
+ *        Class:  Netclient
+ *  Description:  
+ * =====================================================================================
+ */
+/*-----------------------------------------------------------------------------
+ *  Net program used head file
+ *-----------------------------------------------------------------------------*/
+#include 	<sys/ioctl.h>
+#include 	<unistd.h>
+#include 	<fcntl.h>
+#include 	<sys/stat.h>
+#include 	<sys/mman.h>
+#include        <stdio.h>
+#include        <errno.h>
+#include        <strings.h>
+#include        <stdlib.h>
+#include	<cstdlib>
+#include	<cstdio>
+#include 	<sys/types.h>
+#include        <sys/socket.h>
+#include        <netinet/in.h>
+#include        <arpa/inet.h>
+#include        <signal.h>
+#include 	<string.h>
+#include 	<net/if.h>
+
+#include 	"main.h"
+
+#define 	ETH_NAME "eth0"
+class Netclient
+{
+	public:
+		enum NETSTA { NETNONE  = 0,
+			      DATAIN   = 1 };
+		Netclient ();                             /* constructor */
+		~Netclient ();                            /* destructor */
+		BOOL Open_Socket();
+		void Close_Socket();
+		BOOL Connect_Server();
+		const CHAR* Get_Remote_IP();
+		NETSTA Poll_Socket_Status();
+		INT32 Get_Data(CHAR* data,INT32 len);
+		bool Send_Data(CHAR* data,INT32 len);
+		void Getip(char *ip);
+		void Getmac(char *mac);
+
+		bool Test_Ether_Connect();
+	protected:
+
+	private:
+		INT32			m_Port;
+		CHAR*			m_ServerIP;
+		CHAR*			m_ClientIP;
+		INT32			m_Socketfd;
+		struct sockaddr_in	m_Remote;
+		struct sockaddr_in	m_Locale;
+		struct timeval          m_tv;
+		fd_set			m_WRfd;
+		fd_set			m_RDfd;
+}; /* -----  end of class Netclient  ----- */
+#endif   /* ----- #ifndef _NETCLIENT_INC  ----- */
diff --git a/src/EVA11/base/OBJS/ASMS/Asm_Fun_Sets.s.o b/src/EVA11/base/OBJS/ASMS/Asm_Fun_Sets.s.o
new file mode 100644
index 0000000000000000000000000000000000000000..28bcebcef3f8de47c9d1bafc6ffe609b38c56a01
GIT binary patch
literal 1108
zcma)5&ubG=5T3W2w(F1L){BD0rcfbb^K5HC^cISSVpD=YKtZsZWTC+%E4#0tCwuVV
zQM`-&6Z``__$Tz}MMzTudJ{qLR=?SOv&Jgugvs~K%=hMPW+%^Ytlv~hk(i<q{fdYh
zSx~5?f)bq|kETED?$gKe7ezY*@&^YgZoT<@{_yg?)LtoP;1G02@`ZQnLvOD>^owst
z<iCdRj85*|8j6mukshL*rMXe)?;iZ2t*x$JFP2(ylq4pKy5)^pd0Ai8D;J9ueMPTO
z^$fZNVbJW5ng*Sy+@(p!Q>2q;Jrgv6CeCn6SR8h>37;C$?Z5=2n@K{t74>>yAGv;H
zLS5UqS58dOdQ7@{yRHLc;!bnhgb6?Vf7%>$JlaXC=lQ<0oS|U(Ip8tN85U6}*&Lr|
zod>@F=h%g_z0V;3&R!$YC1hCtFWnL}a)z65zj-Fsq;?Ila4vnabpffZA%Q!eNS<|P
zB>;+U23($v%irM-m{=1Xqa#V6heKb1$F1{Rd^pc;yx$K5%gBjIKZ*Z_ZvJ#x)%~p_
z_b(h#sPw%&%$upSzBv}>6vWN9Aj`TmF<wS}3ZKko0jJUJ6p%U3kYnC--XY!%j^}|q
z1NIsEcF6fnxYTJOpoKP7lis6hJHz^RH;o%n2djRk6*o+rCf52LgQMwPe4clM@xDd=
LoeutAFKql1i>iu(

literal 0
HcmV?d00001

diff --git a/src/EVA11/base/OBJS/ASMS/README b/src/EVA11/base/OBJS/ASMS/README
new file mode 100644
index 0000000..e69de29
diff --git a/src/EVA11/base/OBJS/JPGS/README b/src/EVA11/base/OBJS/JPGS/README
new file mode 100644
index 0000000..e69de29
diff --git a/src/EVA11/base/OBJS/README b/src/EVA11/base/OBJS/README
new file mode 100644
index 0000000..e69de29
diff --git a/src/EVA11/base/OZKPanel.cpp b/src/EVA11/base/OZKPanel.cpp
new file mode 100644
index 0000000..9a15c8c
--- /dev/null
+++ b/src/EVA11/base/OZKPanel.cpp
@@ -0,0 +1,603 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  OZKPanel.cpp
+ *
+ *    Description:  implementation of Octo-Panel
+ *
+ *        Version:  1.0
+ *        Created:  2013年03月13日 15时15分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	"Object.h"
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Global.h"
+
+#include 	"DataRepo.h"
+#include 	"Bufferbar.h"
+#include 	"Device.h"
+
+#include 	"BasePanel.h"
+#include 	"OZKPanel.h"
+
+#include 	"Label.h"
+
+#include 	"Basescreen.h"
+#include 	"ZScreen.h"
+
+#include 	"FreeType.h"
+
+#include 	"LimitManage.h"
+
+OZKPanel::OZKPanel (int x,int y,int width,int heigh)
+	: BasePanel(x,y,width,heigh)
+{
+}
+
+OZKPanel::~OZKPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void OZKPanel::Init_GUI(Graphic& g)
+{
+	Global *gp = Global::Instance();
+	int width  = 132;
+	int height = 150 + 10 + 15 + 5 + 2;
+
+	m_Zscreen[0] = new Zscreen(2,43,width,height);
+	m_LimitManage[0] = new(std::nothrow) LimitManage(2,43,width,height);
+
+	m_Zscreen[1] = new Zscreen(2+width,43,width,height);
+	m_LimitManage[1] = new(std::nothrow) LimitManage(2+width,43,width,height);
+
+	m_Zscreen[2] = new Zscreen(2+2*width,43,width,height);
+	m_LimitManage[2] = new(std::nothrow) LimitManage(2+2*width,43,width,height);
+
+	m_Zscreen[3] = new Zscreen(2+3*width,43,width,height);
+	m_LimitManage[3] = new(std::nothrow) LimitManage(2+3*width,43,width,height);
+
+	m_Zscreen[4] = new Zscreen(2,44+217,width,height);
+	m_LimitManage[4] = new(std::nothrow) LimitManage(2,44+217,width,height);
+
+	m_Zscreen[5] = new Zscreen(2+width,44+217,width,height);
+	m_LimitManage[5] = new(std::nothrow) LimitManage(2+width,44+217,width,height);
+
+	m_Zscreen[6] = new Zscreen(2+2*width,44+217,width,height);
+	m_LimitManage[6] = new(std::nothrow) LimitManage(2+2*width,44+217,width,height);
+
+	m_Zscreen[7] = new Zscreen(2+3*width,44+217,width,height);
+	m_LimitManage[7] = new(std::nothrow) LimitManage(2+3*width,44+217,width,height);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_LimitManage[i]->Init_Alarm_Sets(g);
+
+	for (int i=0;i<8;i++ )
+		m_Zscreen[i]->Set_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+		m_Zscreen[i]->Set_ID(i+1);
+
+		if 	( gp->ODrawMode == 0 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
+		else if ( gp->ODrawMode == 1 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
+		else if ( gp->ODrawMode == 2 )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::SPEC);
+	}
+
+	m_labMsg[0] = new Label(1,8,width,18);
+	m_labMsg[1] = new Label(1+width,8,width,18);
+	m_labMsg[2] = new Label(1+2*width,8,width,18);
+	m_labMsg[3] = new Label(1+3*width,8,width,18);
+
+	m_labValue[0] = new Label(1,25,width,18);
+	m_labValue[1] = new Label(1+width,25,width,18);
+	m_labValue[2] = new Label(1+2*width,25,width,18);
+	m_labValue[3] = new Label(1+3*width,25,width,18);
+
+	int laby = 226;
+	m_labMsg[4] = new Label(1,laby,width,18);
+	m_labMsg[5] = new Label(1+width,laby,width,18);
+	m_labMsg[6] = new Label(1+2*width,laby,width,18);
+	m_labMsg[7] = new Label(1+3*width,laby,width,18);
+
+	m_labValue[4] = new Label(1,laby+17,width,18);
+	m_labValue[5] = new Label(1+width,laby+17,width,18);
+	m_labValue[6] = new Label(1+2*width,laby+17,width,18);
+	m_labValue[7] = new Label(1+3*width,laby+17,width,18);
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_labMsg[i]->Set_Label_Type(Label::LA_THIN);
+		m_labValue[i]->Set_Label_Type(Label::LA_THIN);
+		m_labMsg[i]->Set_Font_Size(14);
+		m_labValue[i]->Set_Font_Size(16);
+		m_labMsg[i]->Set_Text(" ");
+		m_labValue[i]->Set_Text(" ");
+
+		m_labMsg[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_labMsg[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+
+		m_labValue[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+		m_labValue[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+		m_labValue[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_labValue[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_labValue[i]->Set_Focus(true);
+	}
+
+	m_Bufbar = new Bufferbar(2,2,532,6);
+	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
+	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
+	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
+
+	m_DataProcess = new OZKDataProcess;
+
+	gp->bONeedResetAlarmArea = true;
+	Load_Alarm_Para();
+
+	m_gp->bQuadSrcPause = false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void OZKPanel::Destroy_GUI()
+{
+	if ( m_DataProcess != NULL )
+	{
+		delete m_DataProcess;
+		m_DataProcess = NULL;
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		if 	( m_Zscreen[i] != NULL )
+		{
+			delete m_Zscreen[i];
+			m_Zscreen[i] = NULL;
+		}
+
+		if 	( m_labMsg[i] != NULL )
+		{
+			delete m_labMsg[i];
+			m_labMsg[i] = NULL;
+		}
+
+		if 	( m_labValue[i] != NULL )
+		{
+			delete m_labValue[i];
+			m_labValue[i] = NULL;
+		}
+	}
+
+	if ( m_Bufbar != NULL )
+	{
+		delete m_Bufbar;
+		m_Bufbar = NULL;
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_LimitManage[i]->Destroy_Alarm_Sets();
+		if ( m_LimitManage[i] != NULL )
+		{
+			delete m_LimitManage[i];
+			m_LimitManage[i] = NULL;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void OZKPanel::Drawme(Graphic& g,bool flag)
+{
+	DataRepo *datarepo = DataRepo::Instance();
+
+	if 	( flag == true )
+		g.Switch_Screen();
+	Refresh_Gain_Rotation();
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Drawme(g,false);
+		m_labMsg[i]->Drawme(g,false);
+		m_labValue[i]->Drawme(g,false);
+		m_LimitManage[i]->Draw_Alarm_Sets(g,false);
+	}
+
+	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
+
+	if 	( flag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  important function, deal with data
+ * =====================================================================================
+ */
+int OZKPanel::Loop_Panel(Graphic& g)
+{
+	if 	( m_gp->bQuadSrcPause == true )
+		return 0;
+
+	m_DataProcess->Data_Process();
+	m_DataProcess->Get_Data(m_RawBuf);
+
+	int x,y;
+
+	if 	( m_gp->ODrawMode == 2 )
+	{
+		for ( int i=0;i<8;i++ )
+		{
+			x = m_RawBuf[i<<1];
+			y = m_RawBuf[(i<<1)+1];
+
+			m_Zscreen[i]->Map_XY_To_Scr(x,y);
+
+			if ( m_LimitManage[i]->Is_In_Alarm(x,y) != 0xff )
+				m_Zscreen[i]->Set_Alarm_Status(true);
+			else 
+				m_Zscreen[i]->Set_Alarm_Status(false);
+
+			m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[i<<1],m_RawBuf[(i<<1)+1]);
+		}
+	}
+	else
+	{
+		for ( int i=0;i<8;i++ )
+		{
+			m_Zscreen[i]->Draw_ET_Point(g,m_RawBuf[i<<1],m_RawBuf[(i<<1)+1]);
+			m_Zscreen[i]->Get_SX_SY(x,y);
+			
+			if ( i == 0 && m_LimitManage[i]->Is_In_Alarm(x,y) != 0xff ) 
+			{
+	//			printf ( "%d\n",i );
+			}
+		}
+	}
+
+
+	m_Bufbar->Save_Bytes_Number(g,8<<2);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void OZKPanel::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+	font->Text(x+30,y+110,pl->GetText(HELPB1F3_O));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Panel
+ *  Description:  Switch panel call this function 
+ * =====================================================================================
+ */
+void OZKPanel::Switch_Panel()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+
+	for ( int ch=0;ch<16;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 1;			// ECT
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int ch=16;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 0;		       // CLOSE
+		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	device->Write_Para_Driver(m_gp->Driver);
+	device->Write_Para_Offset(m_gp->Offset);
+	device->Write_Para_SignalWave(0);
+
+	device->Transfer_ECT_Parameters();
+
+	m_DataProcess->Trigger_Balacne_Process();       // very Important
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_ZKScreen
+ *  Description:  Clean the ZKScreen 
+ * =====================================================================================
+ */
+void OZKPanel::Clean_ZKScreen(Graphic& g)
+{
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Drawme(g,true);
+		m_LimitManage[i]->Draw_Alarm_Sets(g,true);
+		m_labMsg[i]->Drawme(g,true);
+		m_labValue[i]->Drawme(g,true);
+	}
+}
+
+int OZKPanel::Key_NL2_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
+}
+
+int OZKPanel::Key_NR2_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
+}
+
+int OZKPanel::Key_NL3_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
+}
+
+int OZKPanel::Key_NR3_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	m_labMsg[m_gp->ScopeChan]->Drawme(g,true);
+}
+int OZKPanel::Key_NL4_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_labMsg[i]->Drawme(g,true);
+}
+
+int OZKPanel::Key_NR4_Fun(Graphic& g,int sub)
+{
+	Refresh_Gain_Rotation();
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_labMsg[i]->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_FX_Fun
+ *  Description:  Shot Functions 
+ * =====================================================================================
+ */
+int OZKPanel::Key_F2_Fun(Graphic& g)
+{
+	if 	( m_gp->bQuadSrcPause == false )
+		Clean_ZKScreen(g);
+}
+
+int OZKPanel::Key_F3_Fun(Graphic& g)
+{
+	if 	( m_gp->ODrawMode == 0 )
+	{
+		m_gp->ODrawMode = 1;
+
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::LINE);
+	}
+	else if ( m_gp->ODrawMode == 1 )
+	{
+		m_gp->ODrawMode = 2;
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::SPEC);
+	}
+	else if ( m_gp->ODrawMode == 2 )
+	{
+		m_gp->ODrawMode = 0;
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+			m_Zscreen[i]->Set_Draw_Mode(Zscreen::POINT);
+	}
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+		m_Zscreen[i]->Reset_Trace();
+}
+
+int OZKPanel::Key_F4_Fun(Graphic& g)
+{
+	if 	( m_gp->bQuadSrcPause == false )
+		m_DataProcess->Trigger_Balacne_Process();
+}
+
+int OZKPanel::Key_Enter_Fun(Graphic& g)
+{
+	m_gp->bQuadSrcPause = false;
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		m_Zscreen[i]->Drawme(g,true);
+		m_LimitManage[i]->Draw_Alarm_Sets(g,true);
+	}
+}
+
+/* --------------------------------------------------------------------- */
+/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
+/* --------------------------------------------------------------------- */
+
+int OZKPanel::Para_NL1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::LEFT,3);
+			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
+		}
+	}
+}
+int OZKPanel::Para_NR1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
+		}
+	}
+}
+int OZKPanel::Para_NL2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::UP,3);
+			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
+		}
+	}
+}
+int OZKPanel::Para_NR2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+		{
+			m_Zscreen[i]->Adjust_Center_Point(g,Zscreen::DOWN,3);
+			m_Zscreen[i]->Get_Center_Point(m_gp->OCTCentX[i],m_gp->OCTCentY[i]);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm Parameters from Global 
+ *                When Load Para from device call this function
+ * =====================================================================================
+ */
+void OZKPanel::Load_Alarm_Para()
+{
+	Global* gp = Global::Instance();
+	if 	( gp->bONeedResetAlarmArea == true )
+	{
+		for ( int i=0;i<m_cMAXScreenCount;i++ )
+			m_LimitManage[i]->Load_Alarm_Para(gp->OAlarmPara[i]);
+		gp->bONeedResetAlarmArea = false;
+	}
+}
+
+/* --------------------------------------------------------------------- */
+/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
+/* --------------------------------------------------------------------- */
+
+int OZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		for (int i=0;i<m_cMAXScreenCount;i++ )
+			m_LimitManage[i]->Adj_P1(-(m_gp->MultiKey*2 + 5),gp->OAlarmPara[i]);
+
+		Drawme(g,true);
+		gp->bONeedResetAlarmArea = true;
+	}
+}
+int OZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		for (int i=0;i<m_cMAXScreenCount;i++ )
+			m_LimitManage[i]->Adj_P1((m_gp->MultiKey*2 + 5),gp->OAlarmPara[i]);
+
+		Drawme(g,true);
+		gp->bONeedResetAlarmArea = true;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Gain_Rotation
+ *  Description:  Refresh the Gain and ROtation's value 
+ * =====================================================================================
+ */
+void OZKPanel::Refresh_Gain_Rotation()
+{
+	char *msg = new char[100];
+	Global *gp = Global::Instance();
+
+	for ( int i=0;i<m_cMAXScreenCount;i++ )
+	{
+		sprintf(msg,"C%d %.1f dB %d DEG",i+1,gp->CrossGain[i]/static_cast<float>(10),m_gp->CrossDegree[i]);
+		m_labMsg[i]->Set_Text(msg);
+	}
+
+	delete[] msg;
+	msg = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Calculate_Value
+ *  Description:  display the Calculate on Msg Label 
+ * =====================================================================================
+ */
+void OZKPanel::Refresh_Calculate_Value(Graphic& g,int index,double value)
+{
+	char *msg = new char[100];
+	sprintf ( msg,"%f\n",value );
+	m_labValue[index]->Set_Text(msg);
+	m_labValue[index]->Drawme(g,true);
+	delete[] msg;
+	msg = NULL;
+}
diff --git a/src/EVA11/base/OZKPanel.h b/src/EVA11/base/OZKPanel.h
new file mode 100644
index 0000000..27152b9
--- /dev/null
+++ b/src/EVA11/base/OZKPanel.h
@@ -0,0 +1,85 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  OZKPanel.h
+ *
+ *    Description:  Manage Octo-ZK screen
+ *
+ *        Version:  1.0
+ *        Created:  2013年03月13日 15时13分35秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _OZKPANEL_INC
+#define  _OZKPANEL_INC
+
+class BasePanel;
+class Zscreen;
+class Label;
+class OZKDataProcess;
+class LimitManage;
+
+class OZKPanel : public BasePanel
+{
+	public:
+		OZKPanel (int x,int y,int width,int heigh);
+		~OZKPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
+
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+		virtual void Switch_Panel();
+
+		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
+
+		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
+
+	protected:
+
+	private:
+		void Clean_ZKScreen(Graphic& g);
+		void Load_Alarm_Para();
+		void Refresh_Gain_Rotation();
+		void Refresh_Calculate_Value(Graphic& g,int index,double value);
+
+	private:
+		const static int			m_cMAXScreenCount = 8;
+		Zscreen*				m_Zscreen[m_cMAXScreenCount];
+
+		Label*					m_labMsg[m_cMAXScreenCount];
+		Label*					m_labValue[m_cMAXScreenCount];
+		Bufferbar*				m_Bufbar;
+
+		OZKDataProcess*				m_DataProcess;
+		LimitManage*				m_LimitManage[m_cMAXScreenCount];
+
+}; /* -----  end of class OZKPanel  ----- */
+
+#endif   /* ----- #ifndef _OZKPANEL_INC  ----- */
diff --git a/src/EVA11/base/Object.cpp b/src/EVA11/base/Object.cpp
new file mode 100644
index 0000000..2dcf9fd
--- /dev/null
+++ b/src/EVA11/base/Object.cpp
@@ -0,0 +1,39 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Object.cpp
+ *
+ *    Description:  Implemntation of Object class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 15时13分35秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+
+Object::Object (int x,int y,int width,int heigh)
+{
+	m_X          = x;
+	m_Y          = y;
+	m_Width      = width;
+	m_Heigh      = heigh;
+
+	m_Center_X   = x + ( m_Width >> 1 );
+	m_Center_Y   = y + ( m_Heigh >> 1 );
+
+	m_Left       = m_X;                                              /* On the frame */
+	m_Right      = m_X + m_Width-1 ;                                 /* On the frame */
+	m_Up         = m_Y;                                              /* On the frame */
+	m_Down       = m_Y + m_Heigh-1;                                  /* On the frame */
+}
+
+Object::~Object ()
+{
+}
diff --git a/src/EVA11/base/Object.h b/src/EVA11/base/Object.h
new file mode 100644
index 0000000..cfa35fd
--- /dev/null
+++ b/src/EVA11/base/Object.h
@@ -0,0 +1,44 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Object.h
+ *
+ *    Description:  The most basic class of all screen class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 15时10分06秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  OBJECT_INC
+#define  OBJECT_INC
+
+class Object
+{
+	public:
+		Object (int x,int y,int width,int height);
+		virtual ~Object ();
+
+	private:
+
+	protected:
+		short 			m_X;
+		short 			m_Y;
+		short 			m_Width;
+		short 			m_Heigh;
+		short 			m_Center_X;
+		short 			m_Center_Y;
+
+		short 			m_Left;
+		short 			m_Right;
+		short 			m_Up;
+		short 			m_Down;
+};
+
+#endif
diff --git a/src/EVA11/base/Operationwin.cpp b/src/EVA11/base/Operationwin.cpp
new file mode 100644
index 0000000..86458ae
--- /dev/null
+++ b/src/EVA11/base/Operationwin.cpp
@@ -0,0 +1,248 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Operationwin.cpp
+ *
+ *    Description: Implemention of Operationwin class 
+ *
+ *        Version:  1.0
+ *        Created:  2013年11月29日 15时17分32秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<sys/stat.h>
+#include	<fstream>
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"Basewin.h"
+#include 	"Operationwin.h"
+#include 	"Graphic.h"
+#include	"Label.h"
+#include	"Language.h"
+#include	"Global.h"
+#include 	"Log.h"
+
+#include 	"SQLLiteWrapper.h"
+
+#define DBNAME 	"OperationDB.db"
+
+Operationwin::Operationwin ()
+{
+	m_db = new SQLiteDB;
+}
+
+Operationwin::~Operationwin ()
+{
+	delete m_db;
+	m_db = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object
+ * =====================================================================================
+ */
+void Operationwin::Init_GUI(Graphic& g)
+{
+	Basewin::Init_GUI(g);
+
+	m_Title = new Label(250,12,140,30);
+		m_Title->Set_Text(m_pl->GetText(OPERATION));
+	m_Title->Set_Label_Type(Label::LA_NONE);
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	if 	( m_gp->Language == 1 )
+		m_Title->Set_Font_Size(16);
+	else if ( m_gp->Language == 0 )
+		m_Title->Set_Font_Size(26);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy thr GUI object
+ * =====================================================================================
+ */
+void Operationwin::Destroy_GUI()
+{
+	Basewin::Destroy_GUI();
+	if 	( m_Title    != NULL ) delete m_Title;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ * Description:  Evey Windows class ues this function to draw himself on screen
+ * =====================================================================================
+ */
+void Operationwin::Drawme(Graphic &g)
+{
+	Basewin::Drawme(g);
+
+	m_Title->Drawme(g);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function
+ * =====================================================================================
+ */
+int  Operationwin::Loopwindow(Graphic &g)
+{
+	Save_Screen_Into_Memory(g);
+	int result    = 0;
+
+	Init_GUI(g);
+	Drawme(g);
+	Init_DB();
+
+	while( 1 )
+	{
+		result = Command_Process(g);
+		if 	( result == CO_EXIT )
+			goto Exit;
+		else if ( result == CO_OK )
+		{
+			result = CO_OK;
+			goto Exit;
+		}
+	}
+
+Exit:
+	Close_DB();
+	Destroy_GUI();
+	Restore_Screen_From_Memory(g);
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Operationwin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom2_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,2);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom3_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,3);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom4_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,4);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom5_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,5);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom6_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,6);
+	return CO_NONE;
+}
+int Operationwin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Operationwin::Key_Enter_Fun(Graphic& g)
+{
+	return Key_Bom6_Fun(g);
+}
+int Operationwin::Key_Esc_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBottomFocus
+ *  Description:  As the input parameter index to set the bottoms button status  
+ * =====================================================================================
+ */
+void Operationwin::DrawBottomFocus(Graphic& g,int index)
+{
+	Basewin::DrawBottomFocus(g,index);
+
+	switch ( index ) {
+		case 1:                         /* previouse */
+			{
+			}
+			break;
+		case 2:                         /* next */
+			{
+			}
+			break;
+
+		case 3:                         /* left  */
+			{
+			}
+
+			break;
+
+		case 4:                         /* right */
+			{
+			}
+			break;
+		case 5:
+			{
+			}
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_DB
+ *  Description:  Init the Data Base 
+ * =====================================================================================
+ */
+bool Operationwin::Init_DB()
+{
+	Log *log = Log::Instance();
+	if	(!m_db->OpenConnection(DBNAME,DB_PATH))
+	{
+		std::cout<<"Connecting To DB Failed :"<<m_db->GetLastError().c_str();
+		Log *log = Log::Instance();
+		log->Write_Log("Connecting To DB Failed");
+		return false;
+	}
+	else 
+	{
+		log->Write_Log("Connecting To DB Successfully");
+		return true;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Close_DB
+ *  Description:  Close the Data Base connection 
+ * =====================================================================================
+ */
+void Operationwin::Close_DB()
+{
+	Log *log = Log::Instance();
+	log->Write_Log("Closing DB Successfully");
+	m_db->CloseConnection();
+}
diff --git a/src/EVA11/base/Operationwin.h b/src/EVA11/base/Operationwin.h
new file mode 100644
index 0000000..b66c51b
--- /dev/null
+++ b/src/EVA11/base/Operationwin.h
@@ -0,0 +1,58 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Operationwin.h
+ *
+ *    Description: Manage Device Operation 
+ *
+ *        Version:  1.0
+ *        Created:  2013年11月29日 15时14分19秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  OPERATIONWIN_INC
+#define  OPERATIONWIN_INC
+
+#include 	<string>
+
+class SQLiteDB;
+class Operationwin : public Basewin
+{
+	public:
+		Operationwin ();                             /* constructor */
+		virtual ~Operationwin();
+
+		virtual int  Loopwindow(Graphic &g);
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+		void Drawme(Graphic &g);
+
+		bool Init_DB();
+		void Close_DB();
+
+		virtual int Key_Bom1_Fun(Graphic& g) ;
+		virtual int Key_Bom2_Fun(Graphic& g) ;
+		virtual int Key_Bom3_Fun(Graphic& g) ;
+		virtual int Key_Bom4_Fun(Graphic& g) ;
+		virtual int Key_Bom5_Fun(Graphic& g) ;
+		virtual int Key_Bom6_Fun(Graphic& g) ;
+		virtual int Key_Bom7_Fun(Graphic& g) ;
+
+		virtual int Key_Esc_Fun(Graphic& g)  ;
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual void DrawBottomFocus(Graphic& g,int index);
+	private:
+		Label  				    *m_Title;
+		int 				     m_BottomFocus;
+		SQLiteDB			    *m_db;
+
+}; /* -----  end of class Operationwin  ----- */
+#endif   /* ----- #ifndef OPERATIONwin_INC  ----- */
diff --git a/src/EVA11/base/OtherView.cpp b/src/EVA11/base/OtherView.cpp
new file mode 100644
index 0000000..1826647
--- /dev/null
+++ b/src/EVA11/base/OtherView.cpp
@@ -0,0 +1,166 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  OtherView.cpp
+ *
+ *    Description:  Implementation of OtherView class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 10时37分10秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Sinscreen.h"
+
+#include 	"IView.h"
+#include 	"OtherView.h"
+#include 	"Graphic.h"
+#include 	"Resource.h"
+#include 	"Language.h"
+#include 	"Device.h"
+
+#include 	"FreeType.h"
+
+OtherView::OtherView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+}
+
+OtherView::~OtherView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  
+ * =====================================================================================
+ */
+void OtherView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  
+ * =====================================================================================
+ */
+void OtherView::Release_View()
+{
+	Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  
+ * =====================================================================================
+ */
+int OtherView::Loop_View(Graphic& g)
+{
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  
+ * =====================================================================================
+ */
+void OtherView::Drawme(Graphic& g)
+{
+	g.Switch_Screen();
+	m_Zscreen->Drawme(g,false);
+	Show_BackGround_Pic(g);
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  
+ * =====================================================================================
+ */
+void OtherView::Init_GUI(Graphic& g)
+{
+	m_Zscreen = new Sinscreen(m_X,m_Y,m_Width,m_Heigh);
+	m_Zscreen->Set_Color(Sinscreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Zscreen->Set_Color(Sinscreen::LA_BG_COLOR,g_SCBG_CO);
+	m_Zscreen->Set_Color(Sinscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Zscreen->Set_Color(Sinscreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Zscreen->Set_Color(Sinscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+	m_Zscreen->Set_Back_Coordinate(Sinscreen::BKNONE);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void OtherView::Destroy_GUI()
+{
+	delete m_Zscreen;
+	m_Zscreen = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_BackGound_Pic
+ *  Description:  Show the Backgound picture on screen 
+ * =====================================================================================
+ */
+void OtherView::Show_BackGround_Pic(Graphic& g)
+{
+	Resource *res = Resource::Instance();
+	res->Show_Resource_Png(g,1,132,109);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void OtherView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_View
+ *  Description:  When Swtich view call this function
+ *  		 Very important function
+ * =====================================================================================
+ */
+void OtherView::Switch_View()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+}
diff --git a/src/EVA11/base/OtherView.h b/src/EVA11/base/OtherView.h
new file mode 100644
index 0000000..f44142b
--- /dev/null
+++ b/src/EVA11/base/OtherView.h
@@ -0,0 +1,49 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  OtherView.h
+ *
+ *    Description:  Display other functions
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月11日 10时30分33秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _OTHERVIEW_INC
+#define  _OTHERVIEW_INC
+
+class Sinscreen;
+class IView;
+class Graphic;
+class OtherView : public IView
+{
+	public:
+		OtherView (int x,int y,int width,int heigh);
+		~OtherView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+		virtual void Switch_View();
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		/* -----  Enter the DebugView call the sets function to init the view  ----- */
+
+		virtual void Drawme (Graphic&);
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		void Show_BackGround_Pic(Graphic& g);
+	private:
+		Sinscreen				     *m_Zscreen;
+};
+#endif
diff --git a/src/EVA11/base/PICwin.cpp b/src/EVA11/base/PICwin.cpp
new file mode 100644
index 0000000..c4e4c63
--- /dev/null
+++ b/src/EVA11/base/PICwin.cpp
@@ -0,0 +1,337 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  PICwin.cpp
+ *
+ *    Description:  Manage of Pictrue of device
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月28日 09时47分50秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include	<fstream>
+
+#include 	"Object.h"
+#include 	"Basewin.h"
+#include 	"Datawin.h"
+#include 	"PICwin.h"
+#include	"JpegOper.h"
+#include 	"Logic.h"
+#include 	"Graphic.h"
+#include	"Language.h"
+#include 	"Label.h"
+#include 	"Msgbox.h"
+
+#include 	"main.h"
+
+PICwin::PICwin ()
+	: Datawin(Datawin::DA_LOAD,'A',0)
+{
+	m_Preview_Status = false;
+}
+
+PICwin::~PICwin ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object of screen 
+ * =====================================================================================
+ */
+void PICwin::Init_GUI(Graphic& g)
+{
+	Datawin::Init_GUI(g);
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+	}
+	m_Title->Set_Text(m_pl->GetText(PREPIC));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI object of screen 
+ * =====================================================================================
+ */
+void PICwin::Destroy_GUI()
+{
+	Datawin::Destroy_GUI();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ * =====================================================================================
+ */
+void PICwin::Drawme(Graphic& g)
+{
+	Datawin::Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Loopwindow of class
+ * =====================================================================================
+ */
+int PICwin::Loopwindow(Graphic &g)
+{
+	return	Datawin::Loopwindow(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bom_Text
+ *  Description:  Get the help screen buttons text
+ * =====================================================================================
+ */
+const char*  PICwin::Get_Bom_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0: 
+			return m_pl->GetText(PREVIOUSE);
+			break;
+		case 1: 
+			return m_pl->GetText(NEXT);
+			break;
+		case 2: 
+			return m_pl->GetText(DELETE);
+			break;
+		case 3: 
+			return m_pl->GetText(PGUP);
+			break;
+		case 4: 
+			return m_pl->GetText(PGDN);
+			break;
+		case 5: 
+			return m_pl->GetText(PREVIEW);
+			break;
+		case 6: 
+			return m_pl->GetText(BACKOUT);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_One_Line
+ *  Description:  Init one Line value 
+ * =====================================================================================
+ */
+void PICwin::Init_Normal_One_Line(int i)
+{
+	std::fstream m_filestream;
+	char *databuf = new char[60];
+	char *filename = new char[60];
+
+	sprintf(filename,"%s%s%02d.jpeg",PIC_PATH,"pic",i+m_CurrentPage*m_cMAXItem);
+	m_filestream.open(filename,std::ios::binary|std::ios::in);
+	if 	( !m_filestream )
+	{
+		m_Itemtime[i].flag = false;
+		sprintf(databuf,"%s %s%02d.jpeg         %s",m_pl->GetText(PICFILE),"pic",i+m_CurrentPage*m_cMAXItem,m_pl->GetText(BLANK));
+		m_NorLable[i]->Set_Text(databuf);
+	}
+	else
+	{
+		struct stat info;
+		time_t seconds;
+		struct tm *p;
+		stat(filename,&info);
+		seconds             = info.st_mtime;
+		p                   = localtime(&seconds);
+		m_Itemtime[i].year  = p->tm_year + 1900;
+		m_Itemtime[i].month = p->tm_mon + 1;
+		m_Itemtime[i].day   = p->tm_mday;
+		m_Itemtime[i].flag  = true;
+		m_filestream.close();
+		sprintf(databuf,"%s %s%02d.jpeg    %d/%d/%d",m_pl->GetText(PICFILE),"pic",i+m_CurrentPage*m_cMAXItem,m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
+		m_NorLable[i]->Set_Text(databuf);
+	}
+
+	delete[] databuf;
+	databuf = NULL;
+	delete[] filename;
+	filename = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Preview_PIcture
+ *  Description:  Preview screen shot file 
+ * =====================================================================================
+ */
+void PICwin::Preview_Picture(Graphic& g)
+{
+	sprintf(m_Msg,"%s%s%02d.jpeg",PIC_PATH,"pic",m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
+	if ( access(m_Msg,0) != 0 )
+	{
+		Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g); 
+		delete ms;
+		ms = NULL;
+	}
+	else
+	{
+		unsigned char *buf = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)]; /* save the screen */
+		g.Load_Disp_Area(0,0,639,479,buf);
+
+		JpegOper *m_Jpeg     = new JpegOper;
+		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
+
+		m_Jpeg->JpegSetJpegPara(m_Msg,5,5,JCS_RGB);
+		m_Jpeg->JpegReadJpegFile();
+		m_Jpeg->JpegPlayJpeg(0,0,0,0,640,480);
+
+		delete m_Jpeg;
+		m_Jpeg = NULL;
+
+		Label *lab = new Label(2,2,220,25);
+		lab->Set_Label_Type(Label::LA_THIN);
+		lab->Set_Text(m_pl->GetText(PREVIEWPIC));
+		lab->Set_Font_Size(18);
+		lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUBGNO_CO);
+		lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUTXNO_CO);
+		lab->Set_Display_Type(Label::LA_DT_LEFT);
+		lab->Drawme(g);
+		delete lab;
+		lab = NULL;
+
+		m_Preview_Status = true;
+
+		int result = 0;
+		while( result != CO_EXIT )
+		{
+			result = Command_Process(g);
+		}
+
+		m_Preview_Status = false;
+		g.Restore_Disp_Area(0,0,639,479,buf);
+		delete[] buf;
+		buf = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Delete_Picture
+ *  Description:  Delete picture of screen-shot 
+ * =====================================================================================
+ */
+void PICwin::Delete_Picture(Graphic& g)
+{
+	sprintf(m_Msg,"%s%s%02d.jpeg",PIC_PATH,"pic",m_NormalFocus-1+m_CurrentPage*m_cMAXItem);
+	if ( access(m_Msg,0) != 0 )
+	{
+		Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		ms->Showme(g); 
+		delete ms;
+		ms = NULL;
+	}
+	else
+	{
+		if ( Password_Confirm(g) == 1 )
+		{
+			if ( remove(m_Msg) == 0 )
+			{
+				Msgbox *ms = new Msgbox(200,170,300,80,m_pl->GetText(DELPICFILE),Msgbox::MSG_OK);	
+				ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+				ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+				ms->Showme(g); 
+				delete ms;
+				ms = NULL;
+				Init_Normal_Lines();
+				Drawme(g);
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int PICwin::Key_Bom1_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,1);
+	return CO_NONE;
+}
+int PICwin::Key_Bom2_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,2);
+	return CO_NONE;
+}
+int PICwin::Key_Bom3_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+	{
+		Basewin::DrawBottomFocus(g,3);
+		Delete_Picture(g);
+	}
+	return CO_NONE;
+}
+int PICwin::Key_Bom4_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,4);
+	return CO_NONE;
+}
+int PICwin::Key_Bom5_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,5);
+	return CO_NONE;
+}
+int PICwin::Key_Bom6_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+	{
+		DrawBottomFocus(g,6);
+		Preview_Picture(g);
+	}
+	return CO_NONE;
+}
+int PICwin::Key_Bom7_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int PICwin::Key_Enter_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+	{
+		DrawBottomFocus(g,6);
+		Preview_Picture(g);
+	}
+	return CO_NONE;
+}
+int PICwin::Key_Esc_Fun(Graphic& g)
+{
+	if ( m_Preview_Status == false )
+		DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
diff --git a/src/EVA11/base/PICwin.h b/src/EVA11/base/PICwin.h
new file mode 100644
index 0000000..8f8075a
--- /dev/null
+++ b/src/EVA11/base/PICwin.h
@@ -0,0 +1,55 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  PICwin.h
+ *
+ *    Description:  Manage the Picture file of device
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月28日 09时46分08秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PICWIN_INC
+#define  _PICWIN_INC
+
+class PICwin : public Datawin
+{
+	public:
+		PICwin ();
+		virtual ~PICwin ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g);
+
+		virtual int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
+		virtual const char*  Get_Bom_Text(int);
+
+		virtual int Key_Bom1_Fun(Graphic& g) ;
+		virtual int Key_Bom2_Fun(Graphic& g) ;
+		virtual int Key_Bom3_Fun(Graphic& g) ;
+		virtual int Key_Bom4_Fun(Graphic& g) ;
+		virtual int Key_Bom5_Fun(Graphic& g) ;
+		virtual int Key_Bom6_Fun(Graphic& g) ;
+		virtual int Key_Bom7_Fun(Graphic& g) ;
+
+		virtual int Key_Esc_Fun(Graphic& g)  ;
+		virtual int Key_Enter_Fun(Graphic& g);
+	protected:
+		virtual void Init_Normal_One_Line(int i);
+	private:
+		void Preview_Picture(Graphic& g);
+		void Delete_Picture(Graphic& g);
+	private:
+		bool 		m_Preview_Status;
+
+};
+
+#endif
diff --git a/src/EVA11/base/PanelView.cpp b/src/EVA11/base/PanelView.cpp
new file mode 100644
index 0000000..bf1ec41
--- /dev/null
+++ b/src/EVA11/base/PanelView.cpp
@@ -0,0 +1,255 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  PanelView.cpp
+ *
+ *    Description:  implementation of PanelView class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月19日 17时37分19秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"Language.h"
+#include 	"Global.h"
+#include 	"Language.h"
+
+#include 	"Object.h"
+#include 	"Iconbutton.h"
+#include 	"IView.h"
+#include 	"PanelView.h"
+
+#include 	"FreeType.h"
+
+PanelView::PanelView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+}
+
+PanelView::~PanelView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view
+ * =====================================================================================
+ */
+void PanelView::Init_View(Graphic& g)
+{
+	for ( int i=0;i<3;i++ )
+	{
+		m_Iconbut[i] =  new Iconbutton(5+i*175,5,174,145);
+
+		m_Iconbut[i]->Set_IconColor(Iconbutton::BGFO_COLOR,g_BUTXFO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::BGNO_COLOR,g_BUBGNO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::FGFO_COLOR,g_BUBGFO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::FGNO_COLOR,g_BUTXNO_CO);
+
+		m_Iconbut[i]->Init_GUI();
+		m_Iconbut[i]->m_Focus = false;
+	}
+
+	for ( int i=3;i<m_cMAXIconCount;i++ )
+	{
+		m_Iconbut[i] =  new Iconbutton(5+(i-3)*175,5+145,174,145);
+
+		m_Iconbut[i]->Set_IconColor(Iconbutton::BGFO_COLOR,g_BUTXFO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::BGNO_COLOR,g_BUBGNO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::FGFO_COLOR,g_BUBGFO_CO);
+		m_Iconbut[i]->Set_IconColor(Iconbutton::FGNO_COLOR,g_BUTXNO_CO);
+
+		m_Iconbut[i]->Init_GUI();
+		m_Iconbut[i]->m_Focus = false;
+	}
+
+	Language	*pl = Language::Instance();
+	m_Iconbut[0]->Set_Text(pl->GetText(COLORDISPLAY));
+	m_Iconbut[0]->Set_Resource_Index(4);
+	m_Iconbut[1]->Set_Text(pl->GetText(VIDEODISPLAY));
+	m_Iconbut[1]->Set_Resource_Index(3);
+	m_Iconbut[2]->Set_Text(pl->GetText(SIGZKDISPLAY));
+	m_Iconbut[2]->Set_Resource_Index(5);
+	m_Iconbut[3]->Set_Text(pl->GetText(DZKDISPLAY));
+	m_Iconbut[3]->Set_Resource_Index(6);
+	m_Iconbut[4]->Set_Text(pl->GetText(OZKDISPLAY));
+	m_Iconbut[4]->Set_Resource_Index(10);
+	m_Iconbut[5]->Set_Text(pl->GetText(COMBINING));
+	m_Iconbut[5]->Set_Resource_Index(11);
+	Global *gp =  Global::Instance();
+	m_Iconbut[gp->PanelType]->m_Focus = true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  
+ * =====================================================================================
+ */
+void PanelView::Release_View()
+{
+	for ( int i=0;i<m_cMAXIconCount;i++ )
+	{
+		m_Iconbut[i]->Destroy_GUI();
+		delete m_Iconbut[i];
+		m_Iconbut[i] = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  
+ * =====================================================================================
+ */
+int PanelView::Loop_View(Graphic& g)
+{
+;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the Videw GUI object 
+ * =====================================================================================
+ */
+void PanelView::Drawme(Graphic& g)
+{
+	g.Switch_Screen();
+
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0x000000));
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
+	g.Setcolor(g.RGB24_16(0xFFFFFF));
+	g.Setcolor(co);
+
+	Language	*pl = Language::Instance();
+	m_Iconbut[0]->Set_Text(pl->GetText(COLORDISPLAY));
+	m_Iconbut[1]->Set_Text(pl->GetText(VIDEODISPLAY));
+	m_Iconbut[2]->Set_Text(pl->GetText(SIGZKDISPLAY));
+	m_Iconbut[3]->Set_Text(pl->GetText(DZKDISPLAY));
+	m_Iconbut[4]->Set_Text(pl->GetText(OZKDISPLAY));
+	m_Iconbut[5]->Set_Text(pl->GetText(COMBINING));
+
+	for ( int i=0;i<m_cMAXIconCount;i++ )
+	{
+		m_Iconbut[i]->Drawme(g);
+	}
+
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void PanelView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Chang_Panel_Focus
+ *  Description:  Chang the panel focus 
+ * =====================================================================================
+ */
+void PanelView::Chang_Panel_Focus(Graphic& g)
+{
+	Global *gp = Global::Instance();
+	for ( int i=0;i<m_cMAXIconCount;i++ )
+	{
+		if 	( m_Iconbut[i]->m_Focus == true )
+		{
+			if ( i != gp->PanelType )
+			{
+				m_Iconbut[i]->m_Focus = false;
+				m_Iconbut[i]->Drawme(g);
+			}
+		}
+		else
+		{
+			if ( i == gp->PanelType )
+			{
+				m_Iconbut[i]->m_Focus = true;
+				m_Iconbut[i]->Drawme(g);
+			}
+		}
+	}
+}
+
+int PanelView::Key_NL1_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR1_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NL2_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR2_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NL3_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR3_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NL4_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR4_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NL5_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR5_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NL6_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
+int PanelView::Key_NR6_Fun(Graphic& g,int sub)
+{
+	Chang_Panel_Focus(g);
+}
diff --git a/src/EVA11/base/PanelView.h b/src/EVA11/base/PanelView.h
new file mode 100644
index 0000000..6e69b4f
--- /dev/null
+++ b/src/EVA11/base/PanelView.h
@@ -0,0 +1,59 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  PanelView.h
+ *
+ *    Description:  Select which Panel
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月19日 17时33分02秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PANELVIEW_INC
+#define  _PANELVIEW_INC
+
+class IView;
+class Iconbutton;
+
+class PanelView : public IView
+{
+	public:
+		PanelView (int x,int y,int width,int heigh);
+		~PanelView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		/* -----  Enter the DebugView call the sets function to init the view  ----- */
+
+		virtual void Drawme (Graphic&);
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+	protected:
+		void Chang_Panel_Focus(Graphic& g);
+	private:
+		static const int	m_cMAXIconCount = 6;
+		Iconbutton 		*m_Iconbut[m_cMAXIconCount];
+};
+#endif
diff --git a/src/EVA11/base/ParaView.cpp b/src/EVA11/base/ParaView.cpp
new file mode 100644
index 0000000..bfab372
--- /dev/null
+++ b/src/EVA11/base/ParaView.cpp
@@ -0,0 +1,210 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ParaView.cpp
+ *
+ *    Description:  Implementation of ParaView class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月12日 11时03分46秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdlib>
+#include 	<cstdio>
+
+#include 	"Graphic.h"
+#include	"Global.h"
+#include 	"Device.h"
+#include 	"Language.h"
+
+#include 	"Object.h"
+
+#include 	"BasePanel.h"
+#include 	"IView.h"
+#include	"DetectView.h"
+#include 	"ParaView.h"
+
+#include 	"FreeType.h"
+
+ParaView::ParaView (int x,int y,int width,int heigh)
+	: IView(x,y,width,heigh)
+{
+	m_DetectView = NULL;
+}
+
+ParaView::~ParaView ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_View
+ *  Description:  Init the view sets 
+ * =====================================================================================
+ */
+void ParaView::Init_View(Graphic& g)
+{
+	Init_GUI(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_View
+ *  Description:  
+ * =====================================================================================
+ */
+void ParaView::Release_View()
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_View
+ *  Description:  Loop View
+ * =====================================================================================
+ */
+int ParaView::Loop_View(Graphic& g)
+{
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_DetectView_Object
+ *  Description:  For Alarm view draw GUI on screen 
+ * =====================================================================================
+ */
+void ParaView::Load_View_Object(IView* obj)
+{
+	m_DetectView = dynamic_cast<DetectView *>(obj);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message system
+ * =====================================================================================
+ */
+void ParaView::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI Object 
+ * =====================================================================================
+ */
+void ParaView::Init_GUI(Graphic& g)
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void ParaView::Destroy_GUI()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ * =====================================================================================
+ */
+void ParaView::Drawme(Graphic& g)
+{
+	if ( m_DetectView != NULL )
+		m_DetectView->Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Swtich_View
+ *  Description:  when chang the view called it
+ * =====================================================================================
+ */
+void ParaView::Switch_View()
+{
+	if ( m_DetectView != NULL )
+		m_DetectView->Switch_View();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fn_Fun
+ *  Description:  Key Function 
+ * =====================================================================================
+ */
+int ParaView::Key_NL1_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL1_Fun(g,sub);
+}
+int ParaView::Key_NR1_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR1_Fun(g,sub);
+}
+int ParaView::Key_NL2_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL2_Fun(g,sub);
+}
+int ParaView::Key_NR2_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR2_Fun(g,sub);
+}
+int ParaView::Key_NL3_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL3_Fun(g,sub);
+}
+int ParaView::Key_NR3_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR3_Fun(g,sub);
+}
+int ParaView::Key_NL4_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL4_Fun(g,sub);
+}
+int ParaView::Key_NR4_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR4_Fun(g,sub);
+}
+int ParaView::Key_NL5_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL5_Fun(g,sub);
+}
+int ParaView::Key_NR5_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR5_Fun(g,sub);
+}
+int ParaView::Key_NL6_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NL6_Fun(g,sub);
+}
+int ParaView::Key_NR6_Fun(Graphic& g,int sub)
+{
+	m_DetectView->m_Panel[m_DetectView->m_PanelType]->Para_NR6_Fun(g,sub);
+}
diff --git a/src/EVA11/base/ParaView.h b/src/EVA11/base/ParaView.h
new file mode 100644
index 0000000..845ab21
--- /dev/null
+++ b/src/EVA11/base/ParaView.h
@@ -0,0 +1,60 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ParaView.h
+ *
+ *    Description:  Parameters view Object
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月12日 10时59分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PARAVIEW_INC
+#define  _PARAVIEW_INC
+
+class IView;
+class DetectView;
+class ParaView : public IView
+{
+	public:
+		ParaView (int x,int y,int width,int heigh);
+		~ParaView ();
+
+		virtual void Init_View(Graphic&);
+		virtual void Release_View();
+		virtual int  Loop_View(Graphic&);
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+		virtual void Drawme(Graphic&);
+
+		void Load_View_Object(IView* obj);
+		void Switch_View();
+
+		virtual int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Key_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Key_NR6_Fun(Graphic& g,int sub=1);
+	protected:
+
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		DetectView*		m_DetectView;
+	private:
+};
+
+#endif   /* ----- #ifndef _PARAVIEW_INC  ----- */
diff --git a/src/EVA11/base/Parawin.cpp b/src/EVA11/base/Parawin.cpp
new file mode 100644
index 0000000..e5dee8a
--- /dev/null
+++ b/src/EVA11/base/Parawin.cpp
@@ -0,0 +1,707 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Parawin.cpp
+ *
+ *    Description:  Body of Parawin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月29日 14时56分36秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<unistd.h>
+#include 	<fstream>
+
+#include 	"Object.h"
+#include 	"Basewin.h"
+#include 	"Parawin.h"
+#include 	"Graphic.h"
+#include 	"Logic.h"
+#include	"Label.h"
+#include	"Language.h"
+#include	"Global.h"
+#include	"Battery.h"
+#include 	"Datawin.h"
+#include	"Msgbox.h"
+#include 	"Helpwin.h"
+#include 	"Algorithm.h"
+#include 	"MixingManage.h"
+
+Parawin::Parawin (PARATYPE type,char flag)
+{
+	m_pl   = Language::Instance();
+	m_gp   = Global::Instance();
+	m_Type = type;
+	m_flag = flag;
+}  /* -----  end of method Parawin::Parawin  (constructor)  ----- */
+Parawin::~Parawin ()
+{
+}  /* -----  end of method Parawin::Parawin  (destructor)  ----- */
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI Object on screen 
+ * =====================================================================================
+ */
+void Parawin::Drawme(Graphic& g)
+{
+	Basewin::Drawme(g);
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		m_NorLable[i]->Drawme(g);
+	}
+	m_Title->Drawme(g);
+	m_SubTitle->Drawme(g);
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Very important function 
+ *       return:  0: Exit program
+ *                1: goto Mainwin
+ * =====================================================================================
+ */
+int Parawin::Loopwindow(Graphic& g)
+{
+	Save_Screen_Into_Memory(g);
+	int result    = 0;
+	m_BottomFocus = 1;
+	m_NormalFocus = 1;
+	Init_Normal_Title();
+	Init_Normal_Lines();
+	Init_GUI(g);
+	Drawme(g);
+
+	while( 1 )
+	{
+		result = Command_Process(g);
+		if 	( result == CO_EXIT )
+			goto Exit;
+		else if ( result == CO_OK )
+		{
+			result = CO_OK;
+			goto Exit;
+		}
+		else if ( result == CO_LOADEXIT )
+		{
+			result = CO_LOADEXIT;
+			goto Exit;
+		}
+	}
+
+Exit:
+	Destroy_GUI();
+	Restore_Screen_From_Memory(g);
+
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+	return result;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object of screen 
+ * =====================================================================================
+ */
+void Parawin::Init_GUI(Graphic& g)
+{
+	Basewin::Init_GUI(g);
+	/*-----------------------------------------------------------------------------
+	 *  Init the buttom line buttons
+	 *-----------------------------------------------------------------------------*/
+	for ( int i=0;i<MAXBOMCOUNT;i++ )
+	{
+		m_BomButton[i]->Set_Text(Get_Bom_Text(i));
+	}	
+	m_BomButton[0]->Set_Focus(true);
+	m_BomSmall->Set_Text("X");
+
+	char *itembuf = new char[100];
+	for ( int i=0;i<10;i++ )
+	{
+		if 	( m_Itemtime[i].flag == true && ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE ) )
+		{
+			sprintf(itembuf,"%s",const_cast<char *>(m_Text[i].c_str()));
+			m_NorLable[i] = new Label(4,53+39*i,315,38);
+			m_NorLable[i]->Set_Text(itembuf);
+			sprintf(itembuf,"%d/%02d/%02d",m_Itemtime[i].year,m_Itemtime[i].month,m_Itemtime[i].day);
+			m_NorLable[i]->Set_Text(itembuf,1);
+			m_NorLable[i]->Set_Label_Type(Label::LA_3D);
+		}
+		else
+		{
+			m_NorLable[i] = new Label(4,53+39*i,315,38);
+			m_NorLable[i]->Set_Text(const_cast<char *>(m_Text[i].c_str()));
+			m_NorLable[i]->Set_Label_Type(Label::LA_3D);
+		}
+		m_NorLable[i]->Set_Font_Size(18);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_NorLable[i]->Set_Display_Type(Label::LA_DT_DOUBLE);
+	}
+	for ( int i=0;i<10;i++ )
+	{
+		if 	( m_Itemtime[i+10].flag == true && ( m_Type != DA_SAVE && m_Type != DA_LOAD && m_Type != DA_DELE ) )
+		{
+			sprintf(itembuf,"%s",const_cast<char *>(m_Text[i+10].c_str()));
+			m_NorLable[i+10] = new Label(7+315,53+39*i,315,38);
+			m_NorLable[i+10]->Set_Text(itembuf);
+			sprintf(itembuf,"%d/%02d/%02d",m_Itemtime[i+10].year,m_Itemtime[i+10].month,m_Itemtime[i+10].day);
+			m_NorLable[i+10]->Set_Text(itembuf,1);
+			m_NorLable[i+10]->Set_Label_Type(Label::LA_3D);
+		}
+		else
+		{
+			m_NorLable[i+10] = new Label(7+315,53+39*i,315,38);
+			m_NorLable[i+10]->Set_Text(const_cast<char *>(m_Text[i+10].c_str()));
+			m_NorLable[i+10]->Set_Label_Type(Label::LA_3D);
+		}
+		m_NorLable[10+i]->Set_Font_Size(18);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+		m_NorLable[10+i]->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+		m_NorLable[10+i]->Set_Display_Type(Label::LA_DT_DOUBLE);
+	}
+
+	m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+
+	delete[] itembuf;
+	itembuf = NULL;
+
+	m_Title = new Label(250,12,140,30);
+	if 	( m_Type == PT_SAVE ) 
+		m_Title->Set_Text(m_pl->GetText(SAVEPARAM));
+	else if	( m_Type == PT_LOAD )
+		m_Title->Set_Text(m_pl->GetText(LOADPARAM));
+	else if	( m_Type == PT_DELE )
+		m_Title->Set_Text(m_pl->GetText(DELPARAM));
+	else if	( m_Type == DA_SAVE )
+		m_Title->Set_Text(m_pl->GetText(SAVEDATA));
+	else if	( m_Type == DA_LOAD )
+		m_Title->Set_Text(m_pl->GetText(LOADDATA));
+	else if	( m_Type == DA_DELE ) 
+		m_Title->Set_Text(m_pl->GetText(DELEDATA));
+	m_Title->Set_Label_Type(Label::LA_NONE);
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	if 	( m_gp->Language == 1 )
+		m_Title->Set_Font_Size(16);
+	else if ( m_gp->Language == 0 )
+		m_Title->Set_Font_Size(26);
+
+	m_SubTitle = new Label(550,25,80,22);
+	m_SubTitle->Set_Text(m_pl->GetText(SUB_TITLE2));
+	m_SubTitle->Set_Label_Type(Label::LA_NONE);
+	m_SubTitle->Set_Font_Size(16);
+	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object
+ * =====================================================================================
+ */
+void Parawin::Destroy_GUI()
+{
+	Basewin::Destroy_GUI();
+	if 	( m_Title    != NULL ) delete m_Title;
+	if 	( m_SubTitle != NULL ) delete m_SubTitle;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Bom_Text
+ *  Description:  Return the Bom button text 
+ *        index: from 0 to 6
+ * =====================================================================================
+ */
+const char*Parawin::Get_Bom_Text(int index)
+{
+	switch ( index ) 
+	{
+		case 0: 
+			return m_pl->GetText(PREVIOUSE);
+			break;
+		case 1: 
+			return m_pl->GetText(NEXT);
+			break;
+		case 2: 
+			return m_pl->GetText(LEFTC);
+			break;
+		case 3: 
+			return m_pl->GetText(RIGHTC);
+			break;
+		case 4: 
+			return m_pl->GetText(NONE);
+			break;
+		case 5: 
+			return m_pl->GetText(COMFIRM);
+			break;
+		case 6: 
+			return m_pl->GetText(BACKOUT);
+			break;
+		default:	
+			return m_pl->GetText(NONE);
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_Title
+ *  Description:  Init the normal button title 
+ * =====================================================================================
+ */
+void Parawin::Init_Normal_Title()
+{
+	char oc;
+	int num;
+
+	for ( int i = 0; i < MAXNORCOUNT; i += 1 ) 
+	{
+		m_Text[i] = m_pl->GetText(CRAFTPARA);
+	}
+
+	sprintf(m_Msg,"%s%s",RUN_PATH,"PAR.NAM");
+
+	std::fstream filestream;
+	filestream.open(m_Msg,std::ios::in|std::ios::out);
+	if (!filestream)
+	{
+		perror("Can't open the par.nam file\n");
+	}
+	else
+	{
+		int i=0;
+		int index=0;
+		while(!filestream.eof())
+		{
+			filestream.get(oc);
+			if (oc == m_flag-0x20)
+			{
+				filestream.get(oc);
+				if ((oc == '0') || (oc == '1'))
+				{
+					if      ( oc == '0' ) index = 0;
+					else if ( oc == '1' ) index = 10;
+					filestream.get(oc);
+					if ((oc >= 0x30) && (oc < 0x30+10))
+					{
+						index = index + oc - 0x30;
+						if ( index >= 0 && index < 20 )
+						{
+							filestream.get(oc);
+							if ((oc == ' '))
+							{
+								if ( i != index ) i = index;
+								m_Text[i] = "";
+								filestream.get(oc);
+								do
+								{
+									m_Text[i] = m_Text[i] + oc;	
+									filestream.get(oc);
+								}while( oc!=0x0d && !filestream.eof() );
+								i = i + 1;
+							}
+						}
+					}
+				}
+			}
+		}
+		filestream.close();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Normal_Lines
+ *  Description:  according the currentpage paramter initial the normal lines of screen 
+ * =====================================================================================
+ */
+void Parawin::Init_Normal_Lines()
+{
+	for ( int i=0;i<MAXNORCOUNT;i++ )
+	{
+		sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,i);
+		if ( access(m_Msg,0) != 0 )
+		{
+			m_Itemtime[i].flag = false;
+		}
+		else
+		{
+			struct stat info;
+			time_t seconds;
+			struct tm *p;
+			stat(m_Msg,&info);
+			seconds = info.st_mtime;
+			p = localtime(&seconds);
+			m_Itemtime[i].year = p->tm_year + 1900;
+			m_Itemtime[i].month = p->tm_mon + 1;
+			m_Itemtime[i].day = p->tm_mday;
+			m_Itemtime[i].flag = true;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBomttomFocus
+ *  Description:  As the input parameter index to set the bottoms button status  
+ * =====================================================================================
+ */
+void Parawin::DrawBottomFocus(Graphic& g,int index)
+{
+	Basewin::DrawBottomFocus(g,index);
+
+	switch ( index ) {
+		case 1:                         /* previouse */
+			{
+				if 	( m_NormalFocus == 1 )
+				{
+				        m_NormalFocus = MAXNORCOUNT;
+					m_NorLable[0]->Set_Focus(false);
+					m_NorLable[0]->Drawme(g);
+					m_NorLable[19]->Set_Focus(true);
+					m_NorLable[19]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus--;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+
+			}
+			break;
+		case 2:                         /* next */
+			{
+				if ( m_NormalFocus == MAXNORCOUNT )
+				{
+				        m_NormalFocus = 1;
+					m_NorLable[19]->Set_Focus(false);
+					m_NorLable[19]->Drawme(g);
+					m_NorLable[0]->Set_Focus(true);
+					m_NorLable[0]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus++;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+
+		case 3:                         /* left  */
+			{
+				if ( m_NormalFocus < 11 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+
+			break;
+
+		case 4:                         /* right */
+			{
+				if ( m_NormalFocus > 10 )
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus -= 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+				else
+				{
+					m_NorLable[m_NormalFocus-1]->Set_Focus(false);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+					m_NormalFocus += 10;
+					m_NorLable[m_NormalFocus-1]->Set_Focus(true);
+					m_NorLable[m_NormalFocus-1]->Drawme(g);
+				}
+			}
+			break;
+	}				/* -----  end switch  ----- */
+#ifdef X86
+	g.Update_Rect(0,0,640,480);
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Item_Refresh_Item
+ *  Description:  Save the parameters into flash and refresh GUI item 
+ * =====================================================================================
+ */
+void Parawin::Save_Item_Refresh_Item(Graphic& g)
+{
+	int result = Password_Confirm(g);
+	if 	( result == 1 )
+	{
+		sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
+		m_gp->Save_Global_Variables(m_Msg);
+		if 	( access(m_Msg,0) == 0 )
+		{
+			struct stat info;
+			time_t seconds;
+			struct tm *p;
+			stat(m_Msg,&info);
+			seconds = info.st_mtime;
+			p = localtime(&seconds);
+			m_Itemtime[m_NormalFocus-1].year  = p->tm_year + 1900;
+			m_Itemtime[m_NormalFocus-1].month = p->tm_mon + 1;
+			m_Itemtime[m_NormalFocus-1].day   = p->tm_mday;
+			m_Itemtime[m_NormalFocus-1].flag  = true;
+
+			sprintf(m_Msg,"%s",const_cast<char *>(m_Text[m_NormalFocus-1].c_str()));
+			m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg);
+			sprintf(m_Msg,"%d/%02d/%02d",m_Itemtime[m_NormalFocus-1].year,m_Itemtime[m_NormalFocus-1].month,m_Itemtime[m_NormalFocus-1].day);
+			m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg,1);
+			m_NorLable[m_NormalFocus-1]->Drawme(g);
+		}
+	}
+	else if ( result == 0 )
+	{
+		Msgbox *mps = new Msgbox(150,170,350,100,m_pl->GetText(INFO_PD_INVAIL),Msgbox::MSG_OK);	
+		mps->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		mps->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		mps->Showme(g);
+		delete mps;
+		mps = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int Parawin::Key_Bom1_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,1);
+	return CO_NONE;
+}
+int Parawin::Key_Bom2_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,2);
+	return CO_NONE;
+}
+int Parawin::Key_Bom3_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,3);
+	return CO_NONE;
+}
+int Parawin::Key_Bom4_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,4);
+	return CO_NONE;
+}
+int Parawin::Key_Bom6_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,6);
+	switch ( m_Type )
+	{
+		case PT_LOAD:
+			{
+				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
+				{
+					sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
+					m_gp->Load_Global_Variables(m_Msg);
+
+					/*-----------------------------------------------------------------------------
+					 * When load parameters from nand flash we need let to device  
+					 *-----------------------------------------------------------------------------*/
+					m_gp->bSNeedResetAlarmArea = true;
+					m_gp->bDNeedResetAlarmArea = true;
+					m_gp->bONeedResetAlarmArea = true;
+
+					m_lo->Set_Global_Variables_Into_PCB();
+
+					for ( int i=0;i<Global::CHANCOUNT;i++ )
+						m_alg->Reset_MAX_Value(i,m_gp->DFilter[i]);
+
+					MixingManage *mixm = MixingManage::Instance();
+					mixm->Init_Object();
+					mixm->Sync_Mixing_Para(false);
+
+					m_lo->Set_Global_Variables_Into_System();
+
+					m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+
+					return CO_LOADEXIT;
+				}
+				else
+				{       Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(LOADEMPTYDOC),Msgbox::MSG_OK);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					ms->Showme(g);
+					delete ms;
+					ms = NULL;
+				}
+			}
+			break;
+
+		case PT_SAVE:
+			{
+				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
+				{
+					Msgbox *ms = new Msgbox(200,170,280,100,m_pl->GetText(OVERWRITECHECK),Msgbox::MSG_OKCANCEL);	
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					if ( ms->Showme(g) == false )
+					{
+						delete ms;
+						ms = NULL;
+					}
+					else
+					{
+						delete ms;
+						ms = NULL;
+						Save_Item_Refresh_Item(g);
+					}
+				}
+				else
+				{
+					Save_Item_Refresh_Item(g);
+				}
+			}
+			break;
+
+		case PT_DELE:
+			{
+				if 	( m_Itemtime[m_NormalFocus-1].flag == true )
+				{
+					if ( Password_Confirm(g) == 1 )
+					{
+						sprintf(m_Msg,"%s%c%02d.par",PARA_PATH,m_flag,m_NormalFocus-1);
+						if 	( remove(m_Msg) == 0 )
+						{
+							m_Itemtime[m_NormalFocus-1].flag = false;
+							sprintf(m_Msg,"%s",const_cast<char *>(m_Text[m_NormalFocus-1].c_str()));
+							m_NorLable[m_NormalFocus-1]->Set_Text(m_Msg);
+							m_NorLable[m_NormalFocus-1]->Set_Text(" ",1);
+							m_NorLable[m_NormalFocus-1]->Drawme(g);
+						}
+					}
+					else
+					{
+						Msgbox *mps = new Msgbox(150,170,350,100,m_pl->GetText(INFO_PD_INVAIL),Msgbox::MSG_OK);	
+						mps->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+						mps->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+						mps->Showme(g);
+						delete mps;
+						mps = NULL;
+					}
+				}
+				else
+				{       Msgbox *ms = new Msgbox(200,170,300,100,m_pl->GetText(DELEMPTYDOC),Msgbox::MSG_OK);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+					ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+					ms->Showme(g);
+					delete ms;
+					ms = NULL;
+				}
+			}
+			break;
+		case DA_SAVE:
+			{
+				Datawin *dataw;
+				dataw = new Datawin(Datawin::DA_SAVE,m_flag,m_NormalFocus-1);
+				dataw->Loopwindow(g);
+				delete dataw;
+				dataw = NULL;
+			}
+			break;
+		case DA_LOAD:
+			{
+				Datawin *dataw;
+				dataw = new Datawin(Datawin::DA_LOAD,m_flag,m_NormalFocus-1);
+				dataw->Loopwindow(g);
+				delete dataw;
+				dataw = NULL;
+			}
+			break;
+		case DA_DELE:
+			{
+				Datawin *dataw;
+				dataw = new Datawin(Datawin::DA_DELE,m_flag,m_NormalFocus-1);
+				dataw->Loopwindow(g);
+				delete dataw;
+				dataw = NULL;
+			}
+			break;
+
+	}
+	return CO_NONE;
+}
+int Parawin::Key_Bom7_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Parawin::Key_Enter_Fun(Graphic& g)
+{
+	return Key_Bom6_Fun(g);
+}
+int Parawin::Key_Esc_Fun(Graphic& g)
+{
+	DrawBottomFocus(g,7);
+	return CO_EXIT;
+}
+int Parawin::Key_F1_Fun(Graphic& g)
+{
+	Show_Device_Help_Message(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Device_Help_Message
+ *  Description:  When Enter the Device show this message to users 
+ * =====================================================================================
+ */
+void Parawin::Show_Device_Help_Message(Graphic& g)
+{
+	Helpwin* helpw = new Helpwin();
+	helpw->Set_Flag(m_flag);
+	helpw->Set_Index(m_NormalFocus-1);
+	helpw->Loopwindow(g);
+	delete helpw;
+	helpw = NULL;
+}
diff --git a/src/EVA11/base/Parawin.h b/src/EVA11/base/Parawin.h
new file mode 100644
index 0000000..61d4ad8
--- /dev/null
+++ b/src/EVA11/base/Parawin.h
@@ -0,0 +1,91 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Parawin.h
+ *
+ *    Description:  implementation of parameters managment
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月29日 14时52分55秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef  _PARAWIN_INC
+#define  _PARAWIN_INC
+
+#include 	<cstring>
+class Parawin : public Basewin
+{
+	public:
+		enum PARATYPE
+		{
+			PT_LOAD,
+			PT_SAVE,
+			PT_DELE,
+			DA_LOAD,
+			DA_SAVE,
+			DA_DELE
+		};				/* ----------  end of enum PARATYPE  ---------- */
+		typedef enum PARATYPE PARATYPE;
+
+		struct ITEMTIME 
+		{
+			bool flag;
+			short year;
+			short month;
+			short day;
+		};				/* ----------  end of struct ITEMTIME  ---------- */
+		typedef struct ITEMTIME ITEMTIME;
+
+		Parawin (PARATYPE type,char flag);      	/* constructor */
+		virtual ~Parawin ();              		/* destructor  */
+
+		void Drawme (Graphic& g);       		/* Any window coming from window class draw itself on screen */
+		int Loopwindow (Graphic &);        		/* deal with the command getting from key board              */
+
+	protected:
+		virtual int Key_Bom1_Fun(Graphic& g) ;
+		virtual int Key_Bom2_Fun(Graphic& g) ;
+		virtual int Key_Bom3_Fun(Graphic& g) ;
+		virtual int Key_Bom4_Fun(Graphic& g) ;
+		virtual int Key_Bom6_Fun(Graphic& g) ;
+		virtual int Key_Bom7_Fun(Graphic& g) ;
+
+		virtual int Key_Esc_Fun(Graphic& g)  ;
+		virtual int Key_Enter_Fun(Graphic& g);
+		virtual int Key_F1_Fun(Graphic& g);
+
+		virtual void DrawBottomFocus(Graphic& g,int index);
+
+	private:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+
+		void Init_Normal_Title();
+		void Init_Normal_Lines();
+		const char*Get_Bom_Text(int);
+
+		void Save_Item_Refresh_Item(Graphic& g);
+		void Show_Device_Help_Message(Graphic& g);
+	private:
+		static const int		     MAXNORCOUNT = 20;
+		int 				     m_NormalFocus;
+
+		Label  				    *m_Title;
+		Label  				    *m_SubTitle;
+
+		Language			    *m_pl;
+		Global				    *m_gp;
+		PARATYPE			     m_Type;
+		char				     m_flag;		
+
+		Label				    *m_NorLable[MAXNORCOUNT];
+		std::string 			     m_Text[MAXNORCOUNT];
+		ITEMTIME 			     m_Itemtime[MAXNORCOUNT];
+}; /* -----  end of class Parawin  ----- */
+#endif   /* ----- #ifndef _PARAWIN_INC  ----- */
diff --git a/src/EVA11/base/Png.cpp b/src/EVA11/base/Png.cpp
new file mode 100644
index 0000000..cf8f7b8
--- /dev/null
+++ b/src/EVA11/base/Png.cpp
@@ -0,0 +1,179 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Png.cpp
+ *
+ *    Description:  Manage of Png class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月01日 10时18分15秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Png.h"
+#include 	"Graphic.h"
+
+Png::Png ()
+{
+}
+
+Png::~Png ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Read_PNG_File
+ *  Description:  Read the png file and display it on screen  
+ * =====================================================================================
+ */
+void Png::Read_PNG_File(Graphic& g,const char* path,const int& x,const int& y)
+{
+	FILE *file = fopen(path,"rb");
+	if ( file == NULL )
+	{
+		perror("can't open the png file");
+		return;
+	}
+
+	png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);
+	png_infop info_ptr = png_create_info_struct(png_ptr);
+	png_init_io(png_ptr,file);
+	png_read_png(png_ptr,info_ptr,PNG_TRANSFORM_EXPAND,0);
+
+	int m_width = png_get_image_width(png_ptr,info_ptr);
+	int m_height = png_get_image_height(png_ptr,info_ptr);
+	int color_type = png_get_color_type(png_ptr,info_ptr);
+	int bit_depth = png_get_bit_depth(png_ptr,info_ptr);
+
+	switch ( color_type ) 
+	{
+		case PNG_COLOR_TYPE_RGB:
+			{
+				png_bytep* row_pointers = png_get_rows(png_ptr, info_ptr);
+
+				int color;
+				for( int i = 0; i < m_height; i++ )
+				{
+					for( int j = 0; j < m_width; j += 1 )
+					{
+						color = ( row_pointers[i][(j + (j << 1)) + 0]<< 16 ) + ( row_pointers[i][(j + (j << 1)) + 1] << 8 ) + \
+							( row_pointers[i][(j + (j << 1)) + 2] );
+						g.Setpixel(x+j,y+i,g.RGB24_16(color));
+					}
+				}
+			}
+			break;
+
+		case PNG_COLOR_TYPE_RGBA:
+			{
+				png_bytep* row_pointers = png_get_rows(png_ptr, info_ptr);
+
+				for( int i = 0; i < m_height; i++ )
+				{
+					for( int j = 0; j < m_width; j += 1 )
+					{
+						if 	( row_pointers[i][((j << 2))+3] != 0 )
+						{
+							g.Setpixel(x+j,y+i,g.RGB24_16(Alpha_Color((uint8_t *)&row_pointers[i][((j << 2))],g.Getpixel(x+j,y+i))));
+						}
+					}
+				}
+			}
+			break;
+
+		default:
+			printf ( "not support such png formate \n" );
+			break;
+	}
+
+	png_destroy_read_struct(&png_ptr, &info_ptr, 0);
+	fclose(file);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Write_PNG_File
+ *  Description:  Write screen picture into png file 
+ * =====================================================================================
+ */
+void Png::Write_PNG_File(Graphic& g,const char* path,const int& width,const int& height)
+{
+	FILE *file = fopen(path,"wb");
+	if ( file == NULL )
+	{
+		perror("can't open the png file");
+		return;
+	}
+
+	unsigned short *src = (unsigned short *)g.Get_Screen_Ptr();
+	int	      srcw  = g.Get_Screen_Width();
+	int	      srch  = g.Get_Screen_Height();
+
+	png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,0,0,0);
+	png_infop info_ptr = png_create_info_struct(png_ptr);
+	png_init_io(png_ptr,file);
+
+	png_set_IHDR(png_ptr, info_ptr, width,height,  
+			8,PNG_COLOR_TYPE_RGB_ALPHA,PNG_INTERLACE_NONE,
+			PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+	png_write_info(png_ptr, info_ptr);  
+
+	png_bytep *row_pointers = new png_bytep[height*sizeof(png_bytep)]; 
+
+	for ( int i=0;i<height;i++ )
+	{
+		row_pointers[i] =  new unsigned char[4*width];
+		for ( int j=0;j<width;j++ )
+		{
+			row_pointers[i][j*4+0] = ((src[i*srcw+j]>>11)&0x1f)<<3;
+			row_pointers[i][j*4+1] = ((src[i*srcw+j]>>5)&0x3f)<<2;
+			row_pointers[i][j*4+2] = ((src[i*srcw+j])&0x1f)<<3;
+			row_pointers[i][j*4+3] = 0xff;
+		}
+	}
+
+	png_write_image(png_ptr,row_pointers);
+	png_write_end(png_ptr,NULL);
+
+	for ( int i=0;i<height;i++ )
+	{
+		delete row_pointers[i];
+		row_pointers[i] = NULL;
+	}
+
+	delete[]  row_pointers;
+	row_pointers = NULL;
+
+	fclose(file);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Alpha_Color
+ *  Description:  Alpha Color calculate,only called in Alpha parameters exist
+ * =====================================================================================
+ */
+int Png::Alpha_Color(uint8_t *row,short color)
+{
+	int nr    = row[0];
+	int ng    = row[1];
+	int nb    = row[2];
+	int alpha = row[3];
+
+	int oldr  = (( color >> 11 ) & 0x1f)<<3;
+	int oldg  = (( color >> 5 ) & 0x3f)<<2;
+	int oldb  = (( color ) & 0x1f)<<3;
+
+	nr    = (((nr - oldr)*alpha)>>8) + oldr;
+	ng    = (((ng - oldg)*alpha)>>8) + oldg;
+	nb    = (((nb - oldb)*alpha)>>8) + oldb;
+
+	return ( nr << 16 ) + ( ng << 8 ) + nb;
+}
diff --git a/src/EVA11/base/Png.h b/src/EVA11/base/Png.h
new file mode 100644
index 0000000..47e61d5
--- /dev/null
+++ b/src/EVA11/base/Png.h
@@ -0,0 +1,40 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Png.h
+ *
+ *    Description:  Manage Png picture process class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月01日 10时16分57秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PNG_INC
+#define  _PNG_INC
+
+#include	<png.h>
+#include 	<stdint.h>
+
+class Graphic;
+class Png
+{
+	public:
+		Png ();                             /* constructor */
+		~Png ();                            /* destructor */
+
+		void Read_PNG_File(Graphic& g,const char* path,const int& x,const int& y);
+		void Write_PNG_File(Graphic& g,const char* path,const int& width,const int& height);
+	protected:
+
+	private:
+		int Alpha_Color(uint8_t *row,short color);
+};
+
+#endif   /* ----- #ifndef _PNG_INC  ----- */
diff --git a/src/EVA11/base/Process.cpp b/src/EVA11/base/Process.cpp
new file mode 100644
index 0000000..732f299
--- /dev/null
+++ b/src/EVA11/base/Process.cpp
@@ -0,0 +1,3445 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Process.cpp
+ *
+ *    Description:  Implementation of process sets
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月04日 14时47分20秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<unistd.h>
+#include 	<cstdio>
+
+#include 	"Language.h"
+#include	"Process.h" 
+#include	"Global.h"
+#include 	"Device.h"
+#include 	"Object.h"
+#include 	"Basewin.h"
+#include 	"Parawin.h"
+#include 	"Loadwin.h"
+#include	"Modifywin.h"
+#include 	"Logic.h"
+#include 	"Mainwin.h"
+#include 	"Algorithm.h"
+#include 	"Datawin.h"
+#include 	"PICwin.h"
+#include 	"Operationwin.h"
+
+IProcess::IProcess(Mainwin* mwin)
+{
+	m_gp     = Global::Instance();
+	m_device = Device::Instance();
+	m_mwin   = mwin;
+}
+
+IProcess::~IProcess() {}
+
+DetectProcess::DetectProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+
+void DetectProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0:
+			Do_Event_ColorPanel(g,sub,nor,key);
+			break;
+
+		case 1: 
+			Do_Event_VideoPanel(g,sub,nor,key);
+			break;
+
+		case 2:
+			Do_Event_ZKPanel(g,sub,nor,key);
+			break;
+
+		case 3:
+			Do_Event_DZKPanel(g,sub,nor,key);
+			break;
+
+		case 4:
+			Do_Event_OZKPanel(g,sub,nor,key);
+			break;
+
+		case 5:
+			Do_Event_CZKPanel(g,sub,nor,key);
+			break;
+	}
+}
+
+void DetectProcess::Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							int gain = m_gp->ColorGain;
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->ColorGain = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY ) 
+						{
+							int gain = m_gp->ColorGain;
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->ColorGain = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ColorSpotFreqIndex == 0 )
+								m_gp->ColorSpotFreqIndex = Global::FREQCOUNT-1;
+							else
+								m_gp->ColorSpotFreqIndex --;
+
+							for ( int i=0;i<Global::CHANCOUNT;i++ )
+							{
+								m_device->Write_Para_SignalID(i,
+											    i+1,
+											    m_gp->ColorSpotFreqIndex+1);
+							}
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ColorSpotFreqIndex == Global::FREQCOUNT-1 )
+								m_gp->ColorSpotFreqIndex = 0;
+							else
+								m_gp->ColorSpotFreqIndex ++;
+
+							for ( int i=0;i<Global::CHANCOUNT;i++ )
+							{
+								m_device->Write_Para_SignalID(i,
+											    i+1,
+											    m_gp->ColorSpotFreqIndex+1);
+							}
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->ColorSpotFreqIndex]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->ColorSpotFreqIndex] = newfreqvalue;
+							for ( int i=0;i<Global::CHANCOUNT;i++ )
+							{
+								m_device->Write_Para_Frequence_Value(i,newfreqvalue);
+							}
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->ColorSpotFreqIndex]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->ColorSpotFreqIndex] = newfreqvalue;
+							for ( int i=0;i<Global::CHANCOUNT;i++ )
+							{
+								m_device->Write_Para_Frequence_Value(i,newfreqvalue);
+							}
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 4:
+					{
+					}
+					break;
+				case 5: 
+					{
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ColorSpotScanSpeed == 1 )
+								m_gp->ColorSpotScanSpeed = 100;
+							else 
+								m_gp->ColorSpotScanSpeed --;
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ColorSpotScanSpeed == 100 )
+								m_gp->ColorSpotScanSpeed = 1;
+							else 
+								m_gp->ColorSpotScanSpeed ++; 
+						}
+					}
+					break;
+			}
+			break;
+	}
+}
+void DetectProcess::Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				switch ( nor )
+				{
+					case 1:
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->ScopeChan == 0 ) m_gp->ScopeChan = 7;
+								else m_gp->ScopeChan --;
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->ScopeChan == 7 ) m_gp->ScopeChan = 0;
+								else m_gp->ScopeChan ++;
+							}
+						}
+						break;
+					case 2:
+						{
+							if 	( key == LKEY )
+							{
+								int gain = m_gp->CrossGain[m_gp->ScopeChan];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( gain == 5 ) gain = 900;
+									else gain -= 5;
+								}
+								m_gp->CrossGain[m_gp->ScopeChan] = gain;
+								m_gp->Calculate_Gain();
+							}
+							else if ( key == RKEY )
+							{
+								int gain = m_gp->CrossGain[m_gp->ScopeChan];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( gain == 900 ) gain = 5;
+									else gain += 5;
+								}
+								m_gp->CrossGain[m_gp->ScopeChan] = gain;
+								m_gp->Calculate_Gain();
+							}
+						}
+						break;
+					case 3: 
+						{
+							if 	( key == LKEY )
+							{
+								int degree = m_gp->CrossDegree[m_gp->ScopeChan];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( degree == 0 ) degree = 359;
+									else degree -= 1;
+								}
+								m_gp->CrossDegree[m_gp->ScopeChan] = degree;
+							}
+							else if ( key == RKEY )
+							{
+								int degree = m_gp->CrossDegree[m_gp->ScopeChan];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( degree == 359 ) degree = 0;
+									else degree += 1;
+								}
+								m_gp->CrossDegree[m_gp->ScopeChan] = degree;
+							}
+						}
+						break;
+					case 4:
+						{
+							if 	( key == LKEY || key == RKEY )
+							{
+								m_mwin->Sync_Cross_Chan_Parameters(g);
+							}
+						}
+						break;
+					case 5: 
+						{
+						}
+						break;
+					case 6: 
+						{
+						}
+						break;
+				}
+			}
+			break;
+	}
+}
+void DetectProcess::Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			{
+				switch ( nor )
+				{
+					case 1:
+						{
+						}
+						break;
+					case 2:
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->bSingleSrcPause == false ) break;
+								int gain = m_gp->Gain[m_gp->SingleFocusSignal];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( gain == 5 ) gain = 900;
+									else gain -= 5;
+								}
+								m_gp->Gain[m_gp->SingleFocusSignal] = gain;
+								m_gp->Calculate_Gain();
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->bSingleSrcPause == false ) break;
+								int gain = m_gp->Gain[m_gp->SingleFocusSignal];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( gain == 900 ) gain = 5;
+									else gain += 5;
+								}
+								m_gp->Gain[m_gp->SingleFocusSignal] = gain;
+								m_gp->Calculate_Gain();
+							}
+						}
+						break;
+					case 3: 
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->bSingleSrcPause == false ) break;
+								int degree = m_gp->Degree[m_gp->SingleFocusSignal];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( degree == 0 ) degree = 359;
+									else degree -= 1;
+								}
+								m_gp->Degree[m_gp->SingleFocusSignal] = degree;
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->bSingleSrcPause == false ) break;
+								int degree = m_gp->Degree[m_gp->SingleFocusSignal];
+								for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+								{
+									if ( degree == 359 ) degree = 0;
+									else degree += 1;
+								}
+								m_gp->Degree[m_gp->SingleFocusSignal] = degree;
+							}
+						}
+						break;
+					case 4:
+						{
+							if 	( key == LKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
+								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
+							}
+							else if ( key == RKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
+								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
+							}
+						}
+						break;
+					case 5: 
+						{
+							if 	( key == LKEY || key == RKEY )
+							{
+								if 	( m_gp->TimeScaleDisp == 0 )
+									m_gp->TimeScaleDisp = 1;
+								else if ( m_gp->TimeScaleDisp == 1 )
+									m_gp->TimeScaleDisp = 2;
+								else if ( m_gp->TimeScaleDisp == 2 )
+									m_gp->TimeScaleDisp = 0;
+							}
+						}
+						break;
+					case 6: 
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->TimeScaleSpeed == 1 )
+									m_gp->TimeScaleSpeed = 25;
+								else
+									m_gp->TimeScaleSpeed --; 
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->TimeScaleSpeed == 25 )
+									m_gp->TimeScaleSpeed = 1;
+								else
+									m_gp->TimeScaleSpeed ++; 
+							}
+						}
+						break;
+				}
+			}
+			break;
+	}
+}
+void DetectProcess::Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->ScrSigFocus == 0 )
+								m_gp->ScrSigFocus = 1;
+							else
+								m_gp->ScrSigFocus --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->ScrSigFocus == 1 )
+								m_gp->ScrSigFocus = 0;
+							else 
+								m_gp->ScrSigFocus ++;
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 0 )
+								m_gp->ScrSigM[m_gp->ScrSigFocus] = 2;
+							else
+								m_gp->ScrSigM[m_gp->ScrSigFocus] --;
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 2 )
+								m_gp->ScrSigM[m_gp->ScrSigFocus] = 0;
+							else
+								m_gp->ScrSigM[m_gp->ScrSigFocus] ++;
+						}
+					}
+					break;
+				case 3:
+					{
+
+
+
+						if 	( key == LKEY )
+						{
+							if ( m_gp->bDoubleSrcPause == false ) return;
+							int gain;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
+							else 
+								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
+
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->bDoubleSrcPause == false ) return;
+							int gain;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
+							else 
+								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
+
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 4: 
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->bDoubleSrcPause == false ) return;
+
+							int degree;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
+							else
+								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->bDoubleSrcPause == false ) return;
+
+							int degree;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
+							else
+								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
+						}
+					}
+					break;
+				case 5:
+					{
+						if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+						{
+							if 	( key == LKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]]);
+								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->ScrSigM[m_gp->ScrSigFocus],newfreqvalue);
+							}
+							else if ( key == RKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]]);
+								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->ScrSigM[m_gp->ScrSigFocus]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->ScrSigM[m_gp->ScrSigFocus],newfreqvalue);
+							}
+						}
+						else
+						{
+							if 	( key == LKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
+								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
+							}
+							else if ( key == RKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
+								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->MixPrimarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
+							}
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+						{
+
+						}
+						else
+						{
+							if 	( key == LKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
+								freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
+							}
+							else if ( key == RKEY )
+							{
+								int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]]);
+								freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+								int newfreqvalue = m_device->Get_Frequence(freqindex);
+								m_gp->FreqValue[m_gp->FreqIndex[m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2]]] = newfreqvalue;
+								m_device->Set_Para_Frequence_Value(m_gp->MixSecondarySig[m_gp->ScrSigM[m_gp->ScrSigFocus]-2],newfreqvalue);
+							}
+						}
+
+					}
+					break;
+			}
+			break;
+	}
+}
+
+void DetectProcess::Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->ScrSigFocus == 0 )
+								m_gp->ScrSigFocus = 1;
+							else
+								m_gp->ScrSigFocus --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->ScrSigFocus == 1 )
+								m_gp->ScrSigFocus = 0;
+							else 
+								m_gp->ScrSigFocus ++;
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 0 )
+								m_gp->ScrSigM[m_gp->ScrSigFocus] = 2;
+							else
+								m_gp->ScrSigM[m_gp->ScrSigFocus] --;
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ScrSigM[m_gp->ScrSigFocus] == 2 )
+								m_gp->ScrSigM[m_gp->ScrSigFocus] = 0;
+							else
+								m_gp->ScrSigM[m_gp->ScrSigFocus] ++;
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->bCompositeSrcPause == false ) return;
+
+							int gain;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
+							else 
+								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
+
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->bCompositeSrcPause == false ) return;
+
+							int gain;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								gain = m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								gain = m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Gain[m_gp->ScrSigM[m_gp->ScrSigFocus]] = gain;
+							else 
+								m_gp->MixGain[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = gain;
+
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 4: 
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->bCompositeSrcPause == false ) return;
+
+							int degree;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
+							else
+								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->bCompositeSrcPause == false ) return;
+
+							int degree;
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								degree = m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]];
+							else 
+								degree = m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+							if ( m_gp->ScrSigM[m_gp->ScrSigFocus] < 2 )
+								m_gp->Degree[m_gp->ScrSigM[m_gp->ScrSigFocus]] = degree;
+							else
+								m_gp->MixDegree[m_gp->ScrSigM[m_gp->ScrSigFocus]-2] = degree;
+						}
+					}
+					break;
+				case 5:
+					{
+
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							int gain = m_gp->Gain[m_gp->AScanMapChan[0]];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->Gain[m_gp->AScanMapChan[0]] = gain;
+							m_gp->Gain[m_gp->AScanMapChan[1]] = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							int gain = m_gp->Gain[m_gp->AScanMapChan[0]];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->Gain[m_gp->AScanMapChan[0]] = gain;
+							m_gp->Gain[m_gp->AScanMapChan[1]] = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+			}
+			break;
+	}
+}
+
+void DetectProcess::Do_Event_VideoPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+			}
+			break;
+	}
+}
+
+ParameterProcess::ParameterProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+
+void ParameterProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	Global *gp = Global::Instance();
+	switch ( gp->PanelType ) 
+	{
+		case 0:
+			Do_Event_ColorPanel(g,sub,nor,key);
+			break;
+		case 2:
+			Do_Event_ZKPanel(g,sub,nor,key);
+			break;
+		case 3:
+			Do_Event_DZKPanel(g,sub,nor,key);
+			break;
+		case 4:
+			Do_Event_OZKPanel(g,sub,nor,key);
+			break;
+		case 5:
+			Do_Event_CZKPanel(g,sub,nor,key);
+			break;
+		default:
+			Do_Event_ZKPanel(g,sub,nor,key);
+			break;
+	}
+}
+
+void ParameterProcess::Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY || key == RKEY )
+						{
+							if	( m_gp->ColorSpotSampleType == 0 )
+								m_gp->ColorSpotSampleType = 1;
+							else
+								m_gp->ColorSpotSampleType = 0;
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( m_gp->ColorSpotSampleType == 0 )
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->ColorSpotSampIntervalClock == 1000 )
+									m_gp->ColorSpotSampIntervalClock = 10000;
+								else
+									m_gp->ColorSpotSampIntervalClock --; 
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->ColorSpotSampIntervalClock == 10000 )
+									m_gp->ColorSpotSampIntervalClock = 1000;
+								else
+									m_gp->ColorSpotSampIntervalClock ++; 
+							}
+						}
+						else if ( m_gp->ColorSpotSampleType == 1 )
+						{
+							if 	( key == LKEY )
+							{
+								if ( m_gp->ColorSPotSampOutPuls == 1000 )
+									m_gp->ColorSPotSampOutPuls = 10000;
+								else
+									m_gp->ColorSPotSampOutPuls --; 
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->ColorSPotSampOutPuls == 10000 )
+									m_gp->ColorSPotSampOutPuls = 1000;
+								else
+									m_gp->ColorSPotSampOutPuls ++; 
+							}
+						}
+					}
+					break;
+				case 3: 
+					{
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ColorSpotDispMode == 0 )
+								m_gp->ColorSpotDispMode = 1;
+							else 
+								m_gp->ColorSpotDispMode --;
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ColorSpotDispMode == 1 )
+								m_gp->ColorSpotDispMode = 0;
+							else 
+								m_gp->ColorSpotDispMode ++;
+						}
+					}
+					break;
+			}
+			break;
+	}
+
+}
+
+void ParameterProcess::Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 0 )
+								m_gp->ProbeFun[m_gp->SingleFocusSignal] = 3;
+							else
+								m_gp->ProbeFun[m_gp->SingleFocusSignal] --;
+
+							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
+										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
+										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->SingleFocusSignal] == 3)
+								m_gp->ProbeFun[m_gp->SingleFocusSignal] = 0; 
+							else
+								m_gp->ProbeFun[m_gp->SingleFocusSignal] ++;
+
+							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
+										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
+										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->SingleFocusSignal] == 0 )
+								m_gp->FreqIndex[m_gp->SingleFocusSignal] = Global::FREQCOUNT-1;
+							else
+								m_gp->FreqIndex[m_gp->SingleFocusSignal] --;
+
+							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
+										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
+										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->SingleFocusSignal] == Global::FREQCOUNT-1 )
+								m_gp->FreqIndex[m_gp->SingleFocusSignal] = 0;
+							else
+								m_gp->FreqIndex[m_gp->SingleFocusSignal] ++;
+
+							m_device->Set_Para_SignalID(m_gp->SingleFocusSignal,
+										    m_gp->ProbeFun[m_gp->SingleFocusSignal],
+										    m_gp->FreqIndex[m_gp->SingleFocusSignal]+1);
+						}
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->SingleFocusSignal]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->SingleFocusSignal,newfreqvalue);
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 0 )
+								m_gp->DFilter[m_gp->SingleFocusSignal] = 7;
+							else
+								m_gp->DFilter[m_gp->SingleFocusSignal] --;
+							
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->SingleFocusSignal,m_gp->DFilter[m_gp->SingleFocusSignal]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->SingleFocusSignal] == 7 )
+								m_gp->DFilter[m_gp->SingleFocusSignal] = 0;
+							else
+								m_gp->DFilter[m_gp->SingleFocusSignal] ++;
+
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->SingleFocusSignal,m_gp->DFilter[m_gp->SingleFocusSignal]);
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+			}
+			break;
+		case 2: 
+			switch ( nor )
+			{
+				case 1:
+					{
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							int gain = m_gp->Gain[m_gp->SingleFocusSignal];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->Gain[m_gp->SingleFocusSignal] = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							int gain = m_gp->Gain[m_gp->SingleFocusSignal];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->Gain[m_gp->SingleFocusSignal] = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							int degree = m_gp->Degree[m_gp->SingleFocusSignal];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+							m_gp->Degree[m_gp->SingleFocusSignal] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							int degree = m_gp->Degree[m_gp->SingleFocusSignal];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+							m_gp->Degree[m_gp->SingleFocusSignal] = degree;
+						}
+					}
+					break;
+				case 4:
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
+						lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                       /* the low filter closed */
+								{
+									hff --;		
+									if ( hff == -1 )
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 100000;
+										else hff = 0; 
+
+									}
+								}
+								else                                   /* normal lff value */
+								{
+									hff --;		
+									if ( hff == -1 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											hff = lff - 1;
+											if ( hff == -1 ) hff = 0;
+										}
+										else hff = 0;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->SingleFocusSignal] = hff;
+							m_device->Write_Para_HiFilter(m_gp->SingleFocusSignal,m_gp->HiFilter[m_gp->SingleFocusSignal]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                /* the low filter closed */
+								{
+									hff ++;		
+									if ( hff >= 100001 )
+									{
+										hff = 0;
+									}
+									else if ( hff == 1 )
+									{
+										if ( m_gp->MultiKey != 0 ) hff = 0;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									hff ++;		
+									if ( hff >= lff ) 
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 0;
+										else hff --;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->SingleFocusSignal] = hff;
+							m_device->Write_Para_HiFilter(m_gp->SingleFocusSignal,m_gp->HiFilter[m_gp->SingleFocusSignal]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 5: 
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
+						lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff --;		
+									if ( lff == -2 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = 100000;
+										}
+										else lff ++; 
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff --;
+									if ( lff <= hff && lff != -2 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == -2 ) 
+									{
+
+										if ( m_gp->MultiKey == 0 )
+										{
+											if ( hff == 100000 ) lff = -1;
+											else lff = 100000;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->SingleFocusSignal] = lff;
+							m_device->Write_Para_LowFilter(m_gp->SingleFocusSignal,m_gp->LoFilter[m_gp->SingleFocusSignal]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							hff = m_gp->HiFilter[m_gp->SingleFocusSignal];
+							lff = m_gp->LoFilter[m_gp->SingleFocusSignal];
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff ++;		
+									if ( lff == 100000 ); 
+									{
+										if ( m_gp->MultiKey == 0 ) lff = -1;
+										else lff --;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff ++;
+									if ( lff > 100000 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == 0 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = hff + 1;
+											if ( lff > 100000 ) lff = -1;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->SingleFocusSignal] = lff;
+							m_device->Write_Para_LowFilter(m_gp->SingleFocusSignal,m_gp->LoFilter[m_gp->SingleFocusSignal]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->Auto_Disappear == 10 )
+								m_gp->Auto_Disappear = 128;
+							else
+								m_gp->Auto_Disappear --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->Auto_Disappear == 128 )
+								m_gp->Auto_Disappear = 10;
+							else
+								m_gp->Auto_Disappear ++;
+						}
+					}
+					break;
+			}
+			break;
+
+		case 3:
+			switch ( nor ) 
+			{
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							Algorithm* m_alg = Algorithm::Instance();
+							if ( m_gp->GainRatio == 1 )
+								m_gp->GainRatio = 100;
+							else
+								m_gp->GainRatio--;
+							m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+						}
+						else if ( key == RKEY )
+						{
+							Algorithm* m_alg = Algorithm::Instance();
+							if ( m_gp->GainRatio == 100 )
+								m_gp->GainRatio = 1;
+							else
+								m_gp->GainRatio ++;
+							m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+						}
+					}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+	}
+}
+ 
+void ParameterProcess::Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->DParaChan == 0 ) m_gp->DParaChan = 1;
+							else m_gp->DParaChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->DParaChan == 1 ) m_gp->DParaChan = 0;
+							else m_gp->DParaChan ++;
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 0 )
+								m_gp->ProbeFun[m_gp->DParaChan] = 3;
+							else
+								m_gp->ProbeFun[m_gp->DParaChan] --;
+
+							m_device->Set_Para_SignalID(m_gp->DParaChan,
+										    m_gp->ProbeFun[m_gp->DParaChan],
+										    m_gp->FreqIndex[m_gp->DParaChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->DParaChan] == 3 )
+								m_gp->ProbeFun[m_gp->DParaChan] = 0; 
+							else
+								m_gp->ProbeFun[m_gp->DParaChan] ++;
+
+							m_device->Set_Para_SignalID(m_gp->DParaChan,
+										    m_gp->ProbeFun[m_gp->DParaChan],
+										    m_gp->FreqIndex[m_gp->DParaChan]+1);
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->DParaChan] == 0 )
+								m_gp->FreqIndex[m_gp->DParaChan] = Global::FREQCOUNT-1;
+							else
+								m_gp->FreqIndex[m_gp->DParaChan] --;
+
+							m_device->Set_Para_SignalID(m_gp->DParaChan,
+										    m_gp->ProbeFun[m_gp->DParaChan],
+										    m_gp->FreqIndex[m_gp->DParaChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->DParaChan] == Global::FREQCOUNT-1 )
+								m_gp->FreqIndex[m_gp->DParaChan] = 0;
+							else
+								m_gp->FreqIndex[m_gp->DParaChan] ++;
+
+							m_device->Set_Para_SignalID(m_gp->DParaChan,
+										    m_gp->ProbeFun[m_gp->DParaChan],
+										    m_gp->FreqIndex[m_gp->DParaChan]+1);
+						}
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->DParaChan,newfreqvalue);
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DParaChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->DParaChan,newfreqvalue);
+						}
+					}
+					break;
+				case 5:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->DParaChan] == 0 )
+								m_gp->DFilter[m_gp->DParaChan] = 7;
+							else
+								m_gp->DFilter[m_gp->DParaChan] --;
+
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->DParaChan,m_gp->DFilter[m_gp->DParaChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->DParaChan] == 7 )
+								m_gp->DFilter[m_gp->DParaChan] = 0;
+							else
+								m_gp->DFilter[m_gp->DParaChan] ++;
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->DParaChan,m_gp->DFilter[m_gp->DParaChan]);
+						}
+					}
+					break;
+				case 6:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Logic *lo = Logic::Instance();
+						lo->Restore_Mix_Factor(g);
+					}
+					break;
+			}
+			break;
+		case 2: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->DParaChan == 0 ) m_gp->DParaChan = 1;
+							else m_gp->DParaChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->DParaChan == 1 ) m_gp->DParaChan = 0;
+							else m_gp->DParaChan ++;
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							int gain = m_gp->Gain[m_gp->DParaChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->Gain[m_gp->DParaChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							int gain = m_gp->Gain[m_gp->DParaChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->Gain[m_gp->DParaChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							int degree = m_gp->Degree[m_gp->DParaChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+							m_gp->Degree[m_gp->DParaChan] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							int degree = m_gp->Degree[m_gp->DParaChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+							m_gp->Degree[m_gp->DParaChan] = degree;
+						}
+					}
+					break;
+				case 4:
+					{
+						int hff = m_gp->HiFilter[m_gp->DParaChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if 	( hff == 0 )
+								{
+									if 	( m_gp->MultiKey == 0 )
+										hff = 1000;
+								}
+								else
+								{
+
+									hff --;
+								}
+							}
+							m_gp->HiFilter[m_gp->DParaChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->DParaChan,m_gp->HiFilter[m_gp->DParaChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if 	( hff == 1000 )
+									hff = 0;
+								else if ( hff == 0 )
+								{
+									if 	( m_gp->MultiKey == 0 )
+										hff = 1;
+								}
+								else
+									hff ++;
+							}
+							m_gp->HiFilter[m_gp->DParaChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->DParaChan,m_gp->HiFilter[m_gp->DParaChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 5:
+					{
+						int lff = m_gp->LoFilter[m_gp->DParaChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if 	( lff == 100 )
+									lff = -1;
+								else if ( lff == -1 )
+								{
+									if 	( m_gp->MultiKey == 0 )
+											lff = 20000;
+								}
+								else
+									lff --;
+							}
+							m_gp->LoFilter[m_gp->DParaChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->DParaChan,m_gp->LoFilter[m_gp->DParaChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if 	( lff == 20000 )
+									lff = -1;
+								else if ( lff == -1 )
+								{
+									if 	( m_gp->MultiKey == 0 )
+										lff = 100;
+								}
+								else
+									lff ++;
+							}
+							m_gp->LoFilter[m_gp->DParaChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->DParaChan,m_gp->LoFilter[m_gp->DParaChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->Auto_Disappear == 10 )
+								m_gp->Auto_Disappear = 128;
+							else
+								m_gp->Auto_Disappear --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->Auto_Disappear == 128 )
+								m_gp->Auto_Disappear = 10;
+							else
+								m_gp->Auto_Disappear ++;
+						}
+					}
+					break;
+			}
+			break;
+		case 3:
+			{
+				switch ( nor ) 
+				{
+					case 5: 
+						{
+							Algorithm* m_alg = Algorithm::Instance();
+							if 	( key == LKEY )
+							{
+								if ( m_gp->GainRatio == 1 )
+									m_gp->GainRatio = 100;
+								else
+									m_gp->GainRatio--;
+								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+							}
+							else if ( key == RKEY )
+							{
+								if ( m_gp->GainRatio == 100 )
+									m_gp->GainRatio = 1;
+								else
+									m_gp->GainRatio ++;
+								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+							}
+						}
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+
+void ParameterProcess::Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->CompositeChan == 0 ) m_gp->CompositeChan = 3;
+							else m_gp->CompositeChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->CompositeChan == 3 ) m_gp->CompositeChan = 0;
+							else m_gp->CompositeChan ++;
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 0 )
+								m_gp->ProbeFun[m_gp->CompositeChan] = 3;
+							else
+								m_gp->ProbeFun[m_gp->CompositeChan] --;
+							m_device->Set_Para_SignalID(m_gp->CompositeChan,
+										    m_gp->ProbeFun[m_gp->CompositeChan],
+										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->CompositeChan] == 3 )
+								m_gp->ProbeFun[m_gp->CompositeChan] = 0; 
+							else
+								m_gp->ProbeFun[m_gp->CompositeChan] ++;
+							m_device->Set_Para_SignalID(m_gp->CompositeChan,
+										    m_gp->ProbeFun[m_gp->CompositeChan],
+										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->CompositeChan] == 0 )
+								m_gp->FreqIndex[m_gp->CompositeChan] = Global::FREQCOUNT-1;
+							else
+								m_gp->FreqIndex[m_gp->CompositeChan] --;
+
+							m_device->Set_Para_SignalID(m_gp->CompositeChan,
+										    m_gp->ProbeFun[m_gp->CompositeChan],
+										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->CompositeChan] == Global::FREQCOUNT-1 )
+								m_gp->FreqIndex[m_gp->CompositeChan] = 0;
+							else
+								m_gp->FreqIndex[m_gp->CompositeChan] ++;
+
+							m_device->Set_Para_SignalID(m_gp->CompositeChan,
+										    m_gp->ProbeFun[m_gp->CompositeChan],
+										    m_gp->FreqIndex[m_gp->CompositeChan]+1);
+						}
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->CompositeChan,newfreqvalue);
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->CompositeChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->CompositeChan,newfreqvalue);
+						}
+					}
+					break;
+				case 5:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->CompositeChan] == 0 )
+								m_gp->DFilter[m_gp->CompositeChan] = 7;
+							else
+								m_gp->DFilter[m_gp->CompositeChan] --;
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->CompositeChan,m_gp->DFilter[m_gp->CompositeChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->CompositeChan] == 7 )
+								m_gp->DFilter[m_gp->CompositeChan] = 0;
+							else
+								m_gp->DFilter[m_gp->CompositeChan] ++;
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->CompositeChan,m_gp->DFilter[m_gp->CompositeChan]);
+						}
+					}
+					break;
+				case 6:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->AScanSpeed == 1 )
+								m_gp->AScanSpeed = 19;
+							else 
+								m_gp->AScanSpeed --;
+				
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->AScanSpeed == 19 )
+								m_gp->AScanSpeed = 1;
+							else 
+								m_gp->AScanSpeed ++;
+
+						}
+					}
+					break;
+			}
+			break;
+		case 2: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->CompositeChan == 0 ) m_gp->CompositeChan = 1;
+							else m_gp->CompositeChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->CompositeChan == 1 ) m_gp->CompositeChan = 0;
+							else m_gp->CompositeChan ++;
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == LKEY )
+						{
+							int gain = m_gp->Gain[m_gp->CompositeChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->Gain[m_gp->CompositeChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							int gain = m_gp->Gain[m_gp->CompositeChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->Gain[m_gp->CompositeChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							int degree = m_gp->Degree[m_gp->CompositeChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+							m_gp->Degree[m_gp->CompositeChan] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							int degree = m_gp->Degree[m_gp->CompositeChan];
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+							m_gp->Degree[m_gp->CompositeChan] = degree;
+						}
+					}
+					break;
+				case 4:
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->CompositeChan];
+						lff = m_gp->LoFilter[m_gp->CompositeChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                       /* the low filter closed */
+								{
+									hff --;		
+									if ( hff == -1 )
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 100000;
+										else hff = 0; 
+
+									}
+								}
+								else                                   /* normal lff value */
+								{
+									hff --;		
+									if ( hff == -1 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											hff = lff - 1;
+											if ( hff == -1 ) hff = 0;
+										}
+										else hff = 0;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->CompositeChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->CompositeChan,m_gp->HiFilter[m_gp->CompositeChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                /* the low filter closed */
+								{
+									hff ++;		
+									if ( hff >= 100001 )
+									{
+										hff = 0;
+									}
+									else if ( hff == 1 )
+									{
+										if ( m_gp->MultiKey != 0 ) hff = 0;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									hff ++;		
+									if ( hff >= lff ) 
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 0;
+										else hff --;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->CompositeChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->CompositeChan,m_gp->HiFilter[m_gp->CompositeChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 5: 
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->CompositeChan];
+						lff = m_gp->LoFilter[m_gp->CompositeChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff --;		
+									if ( lff == -2 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = 100000;
+										}
+										else lff ++; 
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff --;
+									if ( lff <= hff && lff != -2 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == -2 ) 
+									{
+
+										if ( m_gp->MultiKey == 0 )
+										{
+											if ( hff == 100000 ) lff = -1;
+											else lff = 100000;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->CompositeChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->CompositeChan,m_gp->LoFilter[m_gp->CompositeChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							hff = m_gp->HiFilter[m_gp->CompositeChan];
+							lff = m_gp->LoFilter[m_gp->CompositeChan];
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff ++;		
+									if ( lff == 100000 ); 
+									{
+										if ( m_gp->MultiKey == 0 ) lff = -1;
+										else lff --;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff ++;
+									if ( lff > 100000 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == 0 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = hff + 1;
+											if ( lff > 100000 ) lff = -1;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->CompositeChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->CompositeChan,m_gp->LoFilter[m_gp->CompositeChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->Auto_Disappear == 10 )
+								m_gp->Auto_Disappear = 128;
+							else
+								m_gp->Auto_Disappear --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->Auto_Disappear == 128 )
+								m_gp->Auto_Disappear = 10;
+							else
+								m_gp->Auto_Disappear ++;
+						}
+					}
+					break;
+			}
+			break;
+		case 3:
+			{
+				switch ( nor ) 
+				{
+					case 5: 
+						{
+							if 	( key == LKEY )
+							{
+								Algorithm* m_alg = Algorithm::Instance();
+								if ( m_gp->GainRatio == 1 )
+									m_gp->GainRatio = 100;
+								else
+									m_gp->GainRatio--;
+								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+							}
+							else if ( key == RKEY )
+							{
+								Algorithm* m_alg = Algorithm::Instance();
+								if ( m_gp->GainRatio == 100 )
+									m_gp->GainRatio = 1;
+								else
+									m_gp->GainRatio ++;
+								m_alg->Calculate_Gain_Ratio(m_gp->GainRatio);
+							}
+						}
+						break;
+				}				/* -----  end switch  ----- */
+			}
+			break;
+	}
+}
+		
+void ParameterProcess::Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->QuadChan == 0 ) m_gp->QuadChan = 15;
+							else m_gp->QuadChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->QuadChan == 15 ) m_gp->QuadChan = 0;
+							else m_gp->QuadChan ++;
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 0 )
+								m_gp->ProbeFun[m_gp->QuadChan] = 3;
+							else
+								m_gp->ProbeFun[m_gp->QuadChan] --;
+
+							m_device->Set_Para_SignalID(m_gp->QuadChan,
+										    m_gp->ProbeFun[m_gp->QuadChan],
+										    m_gp->FreqIndex[m_gp->QuadChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->ProbeFun[m_gp->QuadChan] == 3 )
+								m_gp->ProbeFun[m_gp->QuadChan] = 0; 
+							else
+								m_gp->ProbeFun[m_gp->QuadChan] ++;
+
+							m_device->Set_Para_SignalID(m_gp->QuadChan,
+										    m_gp->ProbeFun[m_gp->QuadChan],
+										    m_gp->FreqIndex[m_gp->QuadChan]+1);
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->QuadChan] == 0 )
+								m_gp->FreqIndex[m_gp->QuadChan] = Global::FREQCOUNT-1;
+							else
+								m_gp->FreqIndex[m_gp->QuadChan] --;
+
+							m_device->Set_Para_SignalID(m_gp->QuadChan,
+										    m_gp->ProbeFun[m_gp->QuadChan],
+										    m_gp->FreqIndex[m_gp->QuadChan]+1);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->FreqIndex[m_gp->QuadChan] == Global::FREQCOUNT-1 )
+								m_gp->FreqIndex[m_gp->QuadChan] = 0;
+							else
+								m_gp->FreqIndex[m_gp->QuadChan] ++;
+
+							m_device->Set_Para_SignalID(m_gp->QuadChan,
+										    m_gp->ProbeFun[m_gp->QuadChan],
+										    m_gp->FreqIndex[m_gp->QuadChan]+1);
+						}
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->QuadChan,newfreqvalue);
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->QuadChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->QuadChan,newfreqvalue);
+						}
+					}
+					break;
+				case 5:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->QuadChan] == 0 )
+								m_gp->DFilter[m_gp->QuadChan] = 7;
+							else
+								m_gp->DFilter[m_gp->QuadChan] --;
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->QuadChan,m_gp->DFilter[m_gp->QuadChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DFilter[m_gp->QuadChan] == 7 )
+								m_gp->DFilter[m_gp->QuadChan] = 0;
+							else
+								m_gp->DFilter[m_gp->QuadChan] ++;
+							Algorithm* alg = Algorithm::Instance();
+							alg->Reset_MAX_Value(m_gp->QuadChan,m_gp->DFilter[m_gp->QuadChan]);
+						}
+					}
+					break;
+				case 6:
+					{
+					}
+					break;
+			}
+			break;
+		case 2: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if ( m_gp->QuadChan == 0 ) m_gp->QuadChan = 7;
+							else m_gp->QuadChan --;
+						}
+						else if ( key == RKEY )
+						{
+							if ( m_gp->QuadChan == 7 ) m_gp->QuadChan = 0;
+							else m_gp->QuadChan ++;
+						}
+					}
+					break;
+				case 2:
+					{
+						int gain = m_gp->Gain[m_gp->QuadChan];
+						if 	( key == LKEY )
+						{
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 5 ) gain = 900;
+								else gain -= 5;
+							}
+							m_gp->Gain[m_gp->QuadChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( gain == 900 ) gain = 5;
+								else gain += 5;
+							}
+							m_gp->Gain[m_gp->QuadChan] = gain;
+							m_gp->Calculate_Gain();
+						}
+					}
+					break;
+				case 3: 
+					{
+						int degree = m_gp->Degree[m_gp->QuadChan];
+						if 	( key == LKEY )
+						{
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 0 ) degree = 359;
+								else degree -= 1;
+							}
+							m_gp->Degree[m_gp->QuadChan] = degree;
+						}
+						else if ( key == RKEY )
+						{
+							for ( int i=0;i<m_gp->MultiKey*2 + 1;i++ )
+							{
+								if ( degree == 359 ) degree = 0;
+								else degree += 1;
+							}
+							m_gp->Degree[m_gp->QuadChan] = degree;
+						}
+					}
+					break;
+				case 4:
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->QuadChan];
+						lff = m_gp->LoFilter[m_gp->QuadChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                       /* the low filter closed */
+								{
+									hff --;		
+									if ( hff == -1 )
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 100000;
+										else hff = 0; 
+
+									}
+								}
+								else                                   /* normal lff value */
+								{
+									hff --;		
+									if ( hff == -1 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											hff = lff - 1;
+											if ( hff == -1 ) hff = 0;
+										}
+										else hff = 0;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->QuadChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->QuadChan,m_gp->HiFilter[m_gp->QuadChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( lff == -1 )                /* the low filter closed */
+								{
+									hff ++;		
+									if ( hff >= 100001 )
+									{
+										hff = 0;
+									}
+									else if ( hff == 1 )
+									{
+										if ( m_gp->MultiKey != 0 ) hff = 0;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									hff ++;		
+									if ( hff >= lff ) 
+									{
+										if ( m_gp->MultiKey == 0 ) hff = 0;
+										else hff --;
+									}
+								}
+							}
+							m_gp->HiFilter[m_gp->QuadChan] = hff;
+							m_device->Write_Para_HiFilter(m_gp->QuadChan,m_gp->HiFilter[m_gp->QuadChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 5: 
+					{
+						int hff,lff;
+						hff = m_gp->HiFilter[m_gp->QuadChan];
+						lff = m_gp->LoFilter[m_gp->QuadChan];
+						if 	( key == LKEY )
+						{
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff --;		
+									if ( lff == -2 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = 100000;
+										}
+										else lff ++; 
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff --;
+									if ( lff <= hff && lff != -2 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == -2 ) 
+									{
+
+										if ( m_gp->MultiKey == 0 )
+										{
+											if ( hff == 100000 ) lff = -1;
+											else lff = 100000;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->QuadChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->QuadChan,m_gp->LoFilter[m_gp->QuadChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+						else if ( key == RKEY )
+						{
+							hff = m_gp->HiFilter[m_gp->QuadChan];
+							lff = m_gp->LoFilter[m_gp->QuadChan];
+							for ( int j=0;j<m_gp->MultiKey*15 + 1;j++ )
+							{
+								if ( hff == -1 )                /* the low filter closed */
+								{
+									lff ++;		
+									if ( lff == 100000 ); 
+									{
+										if ( m_gp->MultiKey == 0 ) lff = -1;
+										else lff --;
+									}
+								}
+								else                            /* normal lff value */
+								{
+									lff ++;
+									if ( lff > 100000 ) 
+									{
+										lff = -1;
+									}	
+									else if ( lff == 0 ) 
+									{
+										if ( m_gp->MultiKey == 0 )
+										{
+											lff = hff + 1;
+											if ( lff > 100000 ) lff = -1;
+										}
+										else lff = -1;
+									}
+								}
+							}
+							m_gp->LoFilter[m_gp->QuadChan] = lff;
+							m_device->Write_Para_LowFilter(m_gp->QuadChan,m_gp->LoFilter[m_gp->QuadChan]);
+							m_device->Transfer_ECT_Parameters();
+						}
+					}
+					break;
+				case 6: 
+					{
+					}
+					break;
+			}
+			break;
+	}
+}
+
+DebugProcess::DebugProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+void DebugProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DebugChan == 0 )
+								m_gp->DebugChan = Global::CHANCOUNT - 1;
+							else
+								m_gp->DebugChan --;
+
+							m_device->Set_Para_SignalWave(m_gp->DebugChan);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DebugChan == Global::CHANCOUNT - 1 )
+								m_gp->DebugChan = 0;
+							else
+								m_gp->DebugChan ++;
+
+							m_device->Set_Para_SignalWave(m_gp->DebugChan);
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->HDGain[m_gp->DebugChan] == 0 )
+								m_gp->HDGain[m_gp->DebugChan] = 7;
+							else
+								m_gp->HDGain[m_gp->DebugChan] --;
+							m_device->Set_Para_HDGain(m_gp->DebugChan,m_gp->HDGain[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->HDGain[m_gp->DebugChan] == 7 )
+								m_gp->HDGain[m_gp->DebugChan] = 0;
+							else 
+								m_gp->HDGain[m_gp->DebugChan] ++;
+							m_device->Set_Para_HDGain(m_gp->DebugChan,m_gp->HDGain[m_gp->DebugChan]);
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(false,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->FreqIndex[m_gp->DebugChan],newfreqvalue);
+						}
+						else if ( key == RKEY )
+						{
+							int freqindex = m_device->Get_Frequence_Index(m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]]);
+							freqindex     = m_device->Calculate_New_Frequence(true,freqindex,1);
+							int newfreqvalue = m_device->Get_Frequence(freqindex);
+							m_gp->FreqValue[m_gp->FreqIndex[m_gp->DebugChan]] = newfreqvalue;
+							m_device->Set_Para_Frequence_Value(m_gp->FreqIndex[m_gp->DebugChan],newfreqvalue);
+						}
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->Driver == 0 )
+								m_gp->Driver = 7;
+							else
+								m_gp->Driver --;
+							m_device->Set_Para_Driver(m_gp->Driver);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->Driver == 7 )
+								m_gp->Driver = 0;
+							else
+								m_gp->Driver ++;
+							m_device->Set_Para_Driver(m_gp->Driver);
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->Offset == -100 )
+								m_gp->Offset = 100;
+							else
+								m_gp->Offset --;
+							m_device->Set_Para_Offset(m_gp->Offset);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->Offset == 100 )
+								m_gp->Offset = -100;
+							else
+								m_gp->Offset ++;
+							m_device->Set_Para_Offset(m_gp->Offset);
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY || key == RKEY )
+						{
+							if 	( m_gp->bRFFilterEnable == true )
+							{
+								m_gp->bRFFilterEnable = false;
+								m_device->Set_Para_RF_Filter(m_gp->bRFFilterEnable);
+							}
+							else
+							{
+								m_gp->bRFFilterEnable = true;
+								m_device->Set_Para_RF_Filter(m_gp->bRFFilterEnable);
+							}
+						}
+					}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+		case 2:
+			switch ( nor ) 
+			{
+				case 1:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->Precision == 0 )
+								m_gp->Precision = 16;
+							else if ( m_gp->Precision == 16 )
+								m_gp->Precision = 8;
+							else if ( m_gp->Precision == 8 )
+								m_gp->Precision = 0;
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->Precision == 16 )
+								m_gp->Precision = 0;
+							else if ( m_gp->Precision == 0 )
+								m_gp->Precision = 8;
+							else if ( m_gp->Precision == 8 )
+								m_gp->Precision = 16;
+						}
+					break;
+
+				case 2:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DriverBal[m_gp->DebugChan] == 1 )
+								m_gp->DriverBal[m_gp->DebugChan] = 15;
+							else
+								m_gp->DriverBal[m_gp->DebugChan] --;
+							m_device->Set_Para_DriverBal(m_gp->DebugChan,m_gp->DriverBal[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DriverBal[m_gp->DebugChan] == 15 )
+								m_gp->DriverBal[m_gp->DebugChan] = 1;
+							else 
+								m_gp->DriverBal[m_gp->DebugChan] ++;
+							m_device->Set_Para_DriverBal(m_gp->DebugChan,m_gp->DriverBal[m_gp->DebugChan]);
+						}
+					break;
+
+				case 3:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DriverA_ID[m_gp->DebugChan] == 0 )
+								m_gp->DriverA_ID[m_gp->DebugChan] = 255;
+							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 254 )
+								m_gp->DriverA_ID[m_gp->DebugChan] = 247;
+							else
+								m_gp->DriverA_ID[m_gp->DebugChan] --;
+							m_device->Set_Para_DriveA_ID(m_gp->DebugChan,m_gp->DriverA_ID[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DriverA_ID[m_gp->DebugChan] == 255 )
+								m_gp->DriverA_ID[m_gp->DebugChan] = 0;
+							else if ( m_gp->DriverA_ID[m_gp->DebugChan] == 247 )
+								m_gp->DriverA_ID[m_gp->DebugChan] = 254;
+							else
+								m_gp->DriverA_ID[m_gp->DebugChan] ++;
+							m_device->Set_Para_DriveA_ID(m_gp->DebugChan,m_gp->DriverA_ID[m_gp->DebugChan]);
+						}
+					break;
+
+				case 4:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->DriverB_ID[m_gp->DebugChan] == 0 )
+								m_gp->DriverB_ID[m_gp->DebugChan] = 255;
+							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 254 )
+								m_gp->DriverB_ID[m_gp->DebugChan] = 247;
+							else
+								m_gp->DriverB_ID[m_gp->DebugChan] --;
+							m_device->Set_Para_DriveB_ID(m_gp->DebugChan,m_gp->DriverB_ID[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->DriverB_ID[m_gp->DebugChan] == 255 )
+								m_gp->DriverB_ID[m_gp->DebugChan] = 0;
+							else if ( m_gp->DriverB_ID[m_gp->DebugChan] == 247 )
+								m_gp->DriverB_ID[m_gp->DebugChan] = 254;
+							else
+								m_gp->DriverB_ID[m_gp->DebugChan] ++;
+							m_device->Set_Para_DriveB_ID(m_gp->DebugChan,m_gp->DriverB_ID[m_gp->DebugChan]);
+						}
+					break;
+
+				case 5:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->PickA_ID[m_gp->DebugChan] == 0 )
+								m_gp->PickA_ID[m_gp->DebugChan] = 255;
+							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 254 )
+								m_gp->PickA_ID[m_gp->DebugChan] = 247;
+							else
+								m_gp->PickA_ID[m_gp->DebugChan] --;
+							m_device->Set_Para_PickA_ID(m_gp->DebugChan,m_gp->PickA_ID[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->PickA_ID[m_gp->DebugChan] == 255 )
+								m_gp->PickA_ID[m_gp->DebugChan] = 0;
+							else if ( m_gp->PickA_ID[m_gp->DebugChan] == 247 )
+								m_gp->PickA_ID[m_gp->DebugChan] = 254;
+							else
+								m_gp->PickA_ID[m_gp->DebugChan] ++;
+							m_device->Set_Para_PickA_ID(m_gp->DebugChan,m_gp->PickA_ID[m_gp->DebugChan]);
+						}
+					break;
+
+				case 6:
+						if 	( key == LKEY )
+						{
+							if 	( m_gp->PickB_ID[m_gp->DebugChan] == 0 )
+								m_gp->PickB_ID[m_gp->DebugChan] = 255;
+							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 254 )
+								m_gp->PickB_ID[m_gp->DebugChan] = 247;
+							else
+								m_gp->PickB_ID[m_gp->DebugChan] --;
+							m_device->Set_Para_PickB_ID(m_gp->DebugChan,m_gp->PickB_ID[m_gp->DebugChan]);
+						}
+						else if ( key == RKEY )
+						{
+							if 	( m_gp->PickB_ID[m_gp->DebugChan] == 255 )
+								m_gp->PickB_ID[m_gp->DebugChan] = 0;
+							else if ( m_gp->PickB_ID[m_gp->DebugChan] == 247 )
+								m_gp->PickB_ID[m_gp->DebugChan] = 254;
+							else
+								m_gp->PickB_ID[m_gp->DebugChan] ++;
+							m_device->Set_Para_PickB_ID(m_gp->DebugChan,m_gp->PickB_ID[m_gp->DebugChan]);
+						}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+AlarmProcess::AlarmProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+void AlarmProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+AnalyzeProcess::AnalyzeProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+void AnalyzeProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub ) 
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 2: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 3: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+
+					}
+					break;
+				case 4:
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 5: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+				case 6: 
+					{
+						if 	( key == LKEY )
+						{
+
+						}
+						else if ( key == RKEY )
+						{
+
+						}
+					}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+DisplayProcess::DisplayProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+void DisplayProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						m_gp->PanelType = 5;
+					}
+					break;
+				case 2:
+					{
+						m_gp->PanelType = 4;
+					}
+					break;
+				case 3:
+					{
+						m_gp->PanelType = 3;
+					}
+					break;
+				case 4:
+					{
+						m_gp->PanelType = 2;
+					}
+					break;
+				case 5:
+					{
+						m_gp->PanelType = 0;
+					}
+					break;
+				case 6:
+					{
+						m_gp->PanelType = 1;
+					}
+					break;
+			}				/* -----  end switch  ----- */
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+OthersProcess::OthersProcess(Mainwin* mwin)
+	: IProcess(mwin)
+{
+}
+void OthersProcess::Do_Event(Graphic& g,int sub,int nor,RLKEY key)
+{
+	switch ( sub )
+	{
+		case 1: 
+			switch ( nor )
+			{
+				case 1:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::LT_SAVE);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+				case 2:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::LT_LOAD);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+				case 3:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::LT_DELE);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+				case 4:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::DA_SAVE);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+				case 5:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::DA_LOAD);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+				case 6:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Modifywin *mdw = new Modifywin(g,Loadwin::DA_DELE);
+						int result = mdw->Loopwindow(g);
+						delete mdw;
+						mdw = NULL;
+					}
+					break;
+			}
+			break;
+
+		case 2:
+			switch ( nor ) 
+			{
+				case 1:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Logic *lo = Logic::Instance();
+						lo->Update_Program(g);
+					}
+					break;
+
+				case 2:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						Logic *lo = Logic::Instance();
+						lo->Restore_Default_Value(g);
+					}
+					break;
+
+				case 3:
+					{
+						m_mwin->Refresh_Normal_Label_Text(g);
+						PICwin *picwin = new PICwin();
+						picwin->Loopwindow(g);
+						delete picwin;
+						picwin = NULL;
+					}
+					break;
+
+				case 4:
+					{
+						if ( m_gp->KeyBeep == true )
+							m_gp->KeyBeep =false;
+						else
+							m_gp->KeyBeep =true;
+					}
+					break;
+
+				case 5:
+					{
+						Operationwin *opwin = new Operationwin();
+						opwin->Loopwindow(g);
+						delete opwin;
+						opwin = NULL;
+					}
+					break;
+
+				case 6:
+					{
+						Language* m_lan = Language::Instance();
+						if ( m_gp->Language == 0 )
+							m_gp->Language = 1;
+						else 
+							m_gp->Language = 0;
+						m_lan->SetLang(m_gp->Language);
+						m_mwin->Switch_Language(g);
+					}
+					break;
+
+				default:
+					break;
+			}
+			break;
+		case 4:
+			switch ( nor )
+			{
+				case 1:
+					{
+						if 	( key == RKEY )
+						{
+						}
+						else if ( key == LKEY )
+						{
+						}
+						else if	( key == ENTER )
+						{
+							Set_Syetm_Date(g);
+						}
+					}
+					break;
+				case 2:
+					{
+						if 	( key == RKEY )
+						{
+						}
+						else if ( key == LKEY )
+						{
+						}
+						else if	( key == ENTER )
+						{
+							Set_Syetm_Time(g);
+						}
+					}
+					break;
+				case 3:
+					{
+						if 	( key == RKEY || key == LKEY )
+						{
+							m_mwin->Refresh_Normal_Label_Text(g);
+							Logic *lo = Logic::Instance();
+							lo->About_Box(g,180,100);
+						}
+					}
+					break;
+
+				default:
+					break;
+			}
+			break;
+	}
+}
+
+void OthersProcess::Set_Syetm_Date(Graphic &g)
+{
+	char key;
+	struct tm *timenow;
+	time_t now;
+	char timebuf[20];
+	bool flag    = false;
+	bool outflag = false;
+	int focus    = 0;
+	time(&now);
+	timenow = localtime(&now);
+
+	Algorithm *alg = Algorithm::Instance();
+
+	Logic *lo = Logic::Instance();
+	key       = lo->Get_Key();
+	m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
+	while ( outflag != true )
+	{
+		flag = !flag;
+		if 	( focus == 0 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
+			else
+				sprintf(timebuf,"**/%02d/%02d",timenow->tm_mon + 1,timenow->tm_mday);
+		}
+		else if ( focus == 1 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
+			else
+				sprintf(timebuf,"%02d/**/%02d",timenow->tm_year - 100,timenow->tm_mday);
+		}
+		else if ( focus == 2 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d/%02d/%02d",timenow->tm_year - 100,timenow->tm_mon + 1,timenow->tm_mday);
+			else
+				sprintf(timebuf,"%02d/%02d/**",timenow->tm_year - 100,timenow->tm_mon + 1);
+		}
+
+		m_mwin->Update_Date(g,timebuf);
+
+		key = lo->Get_Key();
+		switch ( key ) {
+			case KEY_ENTER:         /* enable the new system time  */
+				{
+					now = mktime(timenow);
+					stime(&now);    /* set the system time */
+					lo->Excute_Command("/sbin/hwclock -w",false);
+					outflag = true;
+
+					boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
+					m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
+					m_gp->Time_start = m_gp->Time_now - time_elapse;
+					goto Exit;
+				}
+				break;
+			case KEY_ESC:        /* just go out the loop */
+				outflag = true;
+				break;
+			case KEY_FUN1L:         /* change year month day decrease */
+				if ( focus == 0 ) focus = 2;
+				else focus --;
+				break;
+			case KEY_FUN1R:         /* change year month day increase */
+				if ( focus == 2 ) focus = 0;
+				else focus ++;
+				break;
+			case KEY_F3:            /* decrease */
+				if ( focus == 0 ) /* year */
+				{
+					if ( timenow->tm_year == 100 ) timenow->tm_year = 199; /* 2000 - 2099 */
+					else timenow->tm_year --;
+				}
+				else if ( focus == 1 ) /* month */
+				{
+					if ( timenow->tm_mon == 0 ) timenow->tm_mon = 11;
+					else timenow->tm_mon --;
+				}
+				else if ( focus == 2 ) /* day */
+				{
+					if ( timenow->tm_mon + 1 == 4 || 
+					     timenow->tm_mon + 1 == 6 ||
+					     timenow->tm_mon + 1 == 9 ||
+					     timenow->tm_mon + 1 == 11 )
+					{
+						if ( timenow->tm_mday == 1 ) timenow->tm_mday = 30;
+						else timenow->tm_mday --;
+					}
+					else if ( timenow->tm_mon + 1 == 2 ) 
+					{
+						if ( (timenow->tm_year + 1900) % 4 == 0 && 
+						     ((timenow->tm_year + 1900 ) % 100) || 
+						     (timenow->tm_year + 1900) % 400 == 0)
+						{
+							if ( timenow->tm_mday == 1 ) timenow->tm_mday = 29;
+							else timenow->tm_mday --;
+						}
+						else
+						{
+							if ( timenow->tm_mday == 1 ) timenow->tm_mday = 28;
+							else timenow->tm_mday --;
+						}
+					}
+					else
+					{
+						if ( timenow->tm_mday == 1 ) timenow->tm_mday = 31;
+						else timenow->tm_mday --;
+					}
+				}
+				break;
+			case KEY_F4:            /* increase */
+				if ( focus == 0 ) /* year */
+				{
+					if ( timenow->tm_year == 199 ) timenow->tm_year = 100; /* 2000 - 2099 */
+					else timenow->tm_year ++;
+				}
+				else if ( focus == 1 ) /* month */
+				{
+					if ( timenow->tm_mon == 11 ) timenow->tm_mon = 0;
+					else timenow->tm_mon ++;
+				}
+				else if ( focus == 2 ) /* day */
+				{
+					if ( timenow->tm_mon + 1 == 4 || 
+					     timenow->tm_mon + 1 == 6 ||
+					     timenow->tm_mon + 1 == 9 ||
+					     timenow->tm_mon + 1 == 11 )
+					{
+						if ( timenow->tm_mday == 30 ) timenow->tm_mday = 1;
+						else timenow->tm_mday ++;
+					}
+					else if ( timenow->tm_mon + 1 == 2 ) 
+					{
+						if ( (timenow->tm_year + 1900) % 4 == 0 && 
+						     ((timenow->tm_year + 1900 ) % 100) || 
+						     (timenow->tm_year + 1900) % 400 == 0)
+						{
+							if ( timenow->tm_mday == 29 ) timenow->tm_mday = 1;
+							else timenow->tm_mday ++;
+						}
+						else
+						{
+							if ( timenow->tm_mday == 28 ) timenow->tm_mday = 1;
+							else timenow->tm_mday ++;
+						}
+					}
+					else
+					{
+						if ( timenow->tm_mday == 31 ) timenow->tm_mday = 1;
+						else timenow->tm_mday ++;
+					}
+				}
+				break;
+			default:	
+				break;
+		}				/* -----  end switch  ----- */
+		alg->MDelay(80);
+	}
+Exit:
+	;
+}
+void OthersProcess::Set_Syetm_Time(Graphic &g)
+{
+	char key;
+	struct tm *timenow;
+	char timebuf[20];
+	time_t now;
+	bool flag = false;
+	bool outflag = false;
+	int focus=0;                            /* Initiate the setting year */
+	Algorithm *alg = Algorithm::Instance();
+	time(&now);
+	timenow = localtime(&now);
+	Logic *lo = Logic::Instance();
+	key = lo->Get_Key();
+	m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
+	while ( outflag != true )
+	{
+		flag = !flag;
+
+		if ( focus == 0 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+			else
+				sprintf(timebuf,"**:%02d:%02d",timenow->tm_min,timenow->tm_sec);
+		}
+		else if ( focus == 1 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+			else
+				sprintf(timebuf,"%02d:**:%02d",timenow->tm_hour,timenow->tm_sec);
+		}
+		else if ( focus == 2 )
+		{
+			if ( flag == true )
+				sprintf(timebuf,"%02d:%02d:%02d",timenow->tm_hour,timenow->tm_min,timenow->tm_sec);
+			else
+				sprintf(timebuf,"%02d:%02d:**",timenow->tm_hour,timenow->tm_min);
+		}
+
+		m_mwin->Update_Time(g,timebuf);
+
+		key = lo->Get_Key();
+		switch ( key ) {
+			case KEY_ENTER:         /* enable the new system time  */
+				{
+					now = mktime(timenow);
+					stime(&now);
+					lo->Excute_Command("/sbin/hwclock -w",false);
+					outflag = true;
+
+					boost::posix_time::millisec_posix_time_system_config::time_duration_type time_elapse = m_gp->Time_now - m_gp->Time_start;
+					m_gp->Time_now   = boost::posix_time::second_clock::universal_time();
+					m_gp->Time_start = m_gp->Time_now - time_elapse;
+					goto Exit;
+				}
+				break;
+			case KEY_ESC:        /* just go out the loop */
+				outflag = true;
+				break;
+			case KEY_FUN2L:         /* change year month day decrease */
+				if ( focus == 0 ) focus = 2;
+				else focus --;
+				break;
+			case KEY_FUN2R:         /* change year month day increase */
+				if ( focus == 2 ) focus = 0;
+				else focus ++;
+				break;
+			case KEY_F3:            /* decrease */
+				if ( focus == 0 ) /* hour */
+				{
+					if ( timenow->tm_hour == 0 ) timenow->tm_hour = 23; /* 2000 - 2099 */
+					else timenow->tm_hour --;
+				}
+				else if ( focus == 1 ) /* min */
+				{
+					if ( timenow->tm_min == 0 ) timenow->tm_min = 59;
+					else timenow->tm_min --;
+				}
+				else if ( focus == 2 ) /* second */
+				{
+					if ( timenow->tm_sec == 0 ) timenow->tm_sec = 59;
+					else timenow->tm_sec --;
+				}
+				break;
+			case KEY_F4:             /* increase */
+				if ( focus == 0 ) /* hour */
+				{
+					if ( timenow->tm_hour == 23 ) timenow->tm_hour = 0; /* 2000 - 2099 */
+					else timenow->tm_hour ++;
+				}
+				else if ( focus == 1 ) /* min */
+				{
+					if ( timenow->tm_min == 59 ) timenow->tm_min = 0;
+					else timenow->tm_min ++;
+				}
+				else if ( focus == 2 ) /* second */
+				{
+					if ( timenow->tm_sec == 59 ) timenow->tm_sec = 0;
+					else timenow->tm_sec ++;
+				}
+				break;
+			default:	
+				break;
+		}				/* -----  end switch  ----- */
+		alg->MDelay(80);
+	}
+Exit:
+	;
+}
diff --git a/src/EVA11/base/Process.h b/src/EVA11/base/Process.h
new file mode 100644
index 0000000..03f6e4a
--- /dev/null
+++ b/src/EVA11/base/Process.h
@@ -0,0 +1,115 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Process.h
+ *
+ *    Description:  Manage key process class sets
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月04日 14时37分08秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PROCESS_INC
+#define  _PROCESS_INC
+
+class Global;
+class Device;
+class Graphic;
+class Mainwin;
+class Lgoic;
+class IProcess
+{
+	public:
+		enum RLKEY
+		{
+			RKEY  = 0,
+			LKEY  = 1,
+			ENTER = 2
+		};				/* ----------  end of enum RLFLAG  ---------- */
+		typedef enum RLKEY RLKEY;
+		IProcess(Mainwin* mwin);
+		virtual ~IProcess() = 0;
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key) = 0;
+
+	protected:
+		Global				     *m_gp;
+		Device				     *m_device;
+		Mainwin				     *m_mwin;
+
+	private:
+
+}; /* -----  end of class IProcess  ----- */
+
+class DetectProcess : public IProcess
+{
+	public:
+		DetectProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+	private:
+		void Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_VideoPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class ParameterProcess : public IProcess
+{
+	public:
+		ParameterProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+	private:
+		void Do_Event_ColorPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_ZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_DZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_OZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+		void Do_Event_CZKPanel(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class DebugProcess : public IProcess
+{
+	public:
+		DebugProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class AlarmProcess : public IProcess
+{
+	public:
+		AlarmProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class AnalyzeProcess : public IProcess
+{
+	public:
+		AnalyzeProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class DisplayProcess : public IProcess
+{
+	public:
+		DisplayProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+};
+
+class OthersProcess : public IProcess
+{
+	public:
+		OthersProcess(Mainwin* mwin);
+		virtual void Do_Event(Graphic& g,int sub,int nor,RLKEY key);
+	private:
+		void Set_Syetm_Date(Graphic &g);
+		void Set_Syetm_Time(Graphic &g);
+};
+
+#endif   /* ----- #ifndef _PROCESS_INC  ----- */
diff --git a/src/EVA11/base/ProjectFixHead.h b/src/EVA11/base/ProjectFixHead.h
new file mode 100644
index 0000000..6d3994f
--- /dev/null
+++ b/src/EVA11/base/ProjectFixHead.h
@@ -0,0 +1,243 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ProjectFixHead.h
+ *
+ *    Description:  Record something that not chang follow the project
+ *
+ *        Version:  1.0
+ *        Created:  2010年05月17日 22时05分13秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN) eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PROJECTFIXHEAD_INC
+#define  _PROJECTFIXHEAD_INC
+/*-----------------------------------------------------------------------------
+ *  DATA TYPE USED BY PROJECT
+ *-----------------------------------------------------------------------------*/
+/*-----------------------------------------------------------------------------
+ *      SYSTEM DATA TYPE
+ *-----------------------------------------------------------------------------*/
+typedef unsigned char  		UCHAR;
+typedef char                    CHAR;
+typedef unsigned short          UINT16;
+typedef short                   INT16;
+typedef unsigned int            UINT32;
+typedef int                     INT32;
+typedef double                  DOUBLE;
+typedef long long               INT64;
+typedef unsigned long long      UINT64;
+typedef bool                    BOOL;
+/*-----------------------------------------------------------------------------
+ *      APPLICATION DATA TYPE
+ *-----------------------------------------------------------------------------*/
+typedef double         		DATATYPE;
+typedef int			ETDATA;                         /* the data type get from ET broad */
+typedef float	       		DVTYPE;                	        /* The data type of device */
+typedef int 	       		COLORTYPE;
+
+/*-----------------------------------------------------------------------------
+ *  Debug Message MAROC  when release programal did not need define _DEBUG_ MAROC 
+ *-----------------------------------------------------------------------------*/
+#define _DEBUG_
+#if defined(_DEBUG_)
+#define DMESSAGE(index,S)      printf("index %d:%s\n",index,S);
+#define DMS(S)                 printf("%s\n",S);
+#define DM1S(N,V)              printf("%s = %d\n",N,V);
+#else
+#define DMESSAGE(index,S) 
+#define DMS(S)
+#define DM1S(N,V)              
+#endif
+
+/*-----------------------------------------------------------------------------
+ *  Define the color used by project
+ *-----------------------------------------------------------------------------*/
+/*-----------------------------------------------------------------------------
+ *  Description:  The color define with 16 bits mode under Linux environment
+ *                         00000   000000   00000
+ *                field     red     green    blue
+ *  example:
+ *                red     1111 1000 0000 0000   0xf800
+ *                green   0000 0111 1110 0000   0x07e0
+ *                blue    0000 0000 0001 1111   0x001f
+ *-----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+ *  16 bpp used
+ *-----------------------------------------------------------------------------*/
+#define	RED_16     	0xf800			
+#define	TESTRED_16     	0xf800			
+#define	GREEN_16        0x07e0		
+#define BLUE_16         0x001F         
+#define	WHITE_16        0xffff	
+#define	BLACK_16        0x0000	
+#define YELLOW_16	0xffe0
+#define PINK_16		0xf81f
+#define ORANGE_16	0xfE00
+#define GRASS_16	0x87e0 
+#define LIGHTBLUE_16	0x4610
+/*-----------------------------------------------------------------------------
+ *  8 BPP USED SYSTEM DEFINE  MY VALUE
+ *-----------------------------------------------------------------------------*/
+/*-----------------------------------------------------------------------------
+ *  USED BY 308 DEVICE DEFAULT VALUE
+ *-----------------------------------------------------------------------------*/
+#define	BLACK_8         0xE0	
+#define	RED_8     	0xE1
+#define BLUE_8          0xE2
+#define	GREEN_8         0xE3
+#define YELLOW_8	0xE4
+#define ORANGE_8	0xE5
+#define PINK_8		0xE6
+#define LIGHTBLUE_8	0xE7
+#define LIGHTGREEN_8    0xE8
+#define HIGHGREEN_8     0xE9
+#define GOLD_8          0xF0
+#define GRASS_8		0xF1
+#define GRAY_8          0xF2
+#define	WHITE_8         0xFD
+/*-----------------------------------------------------------------------------
+ *  1 BPP USED SYSTEM DEFINE
+ *-----------------------------------------------------------------------------*/
+#define	WHITE_1         1	
+#define	BLACK_1         0	
+
+
+#ifdef _KEY_308_A_
+#define KEY_BOTTOM1  0x03                        /* first bottom button key value */
+#define KEY_BOTTOM2  0x05
+#define KEY_BOTTOM3  0x06
+#define KEY_BOTTOM4  0x09
+#define KEY_BOTTOM5  0x0a
+#define KEY_BOTTOM6  0x0C
+#define KEY_BOTTOM7  0x3F                        /*  */
+#define KEY_QUIT     0xfe 
+#define KEY_ESCAPE   0x18 
+#define KEY_FUN1L    0x7E
+#define KEY_FUN1R    0x41
+#define KEY_FUN2L    0x7D
+#define KEY_FUN2R    0x42
+#define KEY_FUN3L    0x7B
+#define KEY_FUN3R    0x44
+#define KEY_FUN4L    0x77
+#define KEY_FUN4R    0x48
+#define KEY_FUN5L    0x6F
+#define KEY_FUN5R    0x50
+#define KEY_FUN6L    0x5F
+#define KEY_FUN6R    0x60
+#define KEY_ENTER    0x30 
+#define KEY_ESC	     0x18                        /*  */
+#define KEY_F1       0x21                        /* re-define */
+#define KEY_F2       0x11                        /* re-define */
+#define KEY_F3       0x22                        /* re-define */
+#define KEY_F4       0x12                        /* re-define */
+#define KEY_F5       0x24                        /* re-define */
+#define KEY_F6       0x14                        /* re-define */
+#define KEY_F7       0x28                        /* re-define */
+
+#define KEY_UP       0x44
+#define KEY_DOWN     0x14
+#define KEY_LEFT     0x24
+#define KEY_RIGHT    0x28
+#endif
+
+
+#ifdef _KEY_308_1_
+#define KEY_BOTTOM1  0x3f                        /* first bottom button key value */
+#define KEY_BOTTOM2  0x5f
+#define KEY_BOTTOM3  0x60
+#define KEY_BOTTOM4  0x6f 
+#define KEY_BOTTOM5  0x50
+#define KEY_BOTTOM6  0x30
+#define KEY_BOTTOM7  0x03                        /*  */
+#define KEY_QUIT     0xfe 
+#define KEY_ESCAPE   0x18 
+#define KEY_FUN1L    0x7e
+#define KEY_FUN1R    0x7d
+#define KEY_FUN2L    0x41
+#define KEY_FUN2R    0x42
+#define KEY_FUN3L    0x21                        /*  */
+#define KEY_FUN3R    0x22
+#define KEY_FUN4L    0x11
+#define KEY_FUN4R    0x12
+#define KEY_FUN5L    0x09                        /*  */
+#define KEY_FUN5R    0x0a 
+#define KEY_FUN6L    0x05
+#define KEY_FUN6R    0x06
+#define KEY_ENTER    0x0c 
+#define KEY_ESC	     0x18                        /*  */
+#define KEY_F1       0x7b                        /* re-define */
+#define KEY_F2       0x77                        /* re-define */
+#define KEY_F3       0x44                        /* re-define */
+#define KEY_F4       0x48                        /* re-define */
+#define KEY_F5       0x24                        /* re-define */
+#define KEY_F6       0x28                        /* re-define */
+#define KEY_F7       0x14                        /* re-define */
+
+#define KEY_UP       0x44
+#define KEY_DOWN     0x14
+#define KEY_LEFT     0x24
+#define KEY_RIGHT    0x28
+#endif
+
+#ifdef _KEY_PC_
+#define KEY_BOTTOM1  '1'                       /* first bottom button key value */
+#define KEY_BOTTOM2  '2'
+#define KEY_BOTTOM3  '3'
+#define KEY_BOTTOM4  '4'
+#define KEY_BOTTOM5  '5'
+#define KEY_BOTTOM6  '6'
+#define KEY_BOTTOM7  '7'
+#define KEY_QUIT     'q'
+#define KEY_ESCAPE   '6'
+#define KEY_FUN1L    'y'
+#define KEY_FUN1R    'g'
+#define KEY_FUN2L    'u'
+#define KEY_FUN2R    'h'
+#define KEY_FUN3L    'i'
+#define KEY_FUN3R    'j'
+#define KEY_FUN4L    'o'
+#define KEY_FUN4R    'k'
+#define KEY_FUN5L    'p'
+#define KEY_FUN5R    'l'
+#define KEY_FUN6L    '['
+#define KEY_FUN6R    ';'
+#define KEY_ENTER    10
+#define KEY_ESC	     27
+#define KEY_F1       'z'                        /* re-define */
+#define KEY_F2       'x'                        /* re-define */
+#define KEY_F3       'c'                        /* re-define */
+#define KEY_F4       'v'                        /* re-define */
+#define KEY_F5       'b'                        /* re-define */
+#define KEY_F6       'n'                        /* re-define */
+#define KEY_F7       'm'                        /* re-define */
+#define KEY_F8       ','                        /* re-define */
+
+#define KEY_LEFT     'a'
+#define KEY_RIGHT    'd'
+#define KEY_UP       'w'
+#define KEY_DOWN     's'
+
+#define KEY_0        '0'
+#define KEY_1        '1' 
+#define KEY_2        '2' 
+#define KEY_3        '3'
+#define KEY_4        '4' 
+#define KEY_5        '5' 
+
+#define KEY_6        '6' 
+#define KEY_7        '7' 
+#define KEY_8        '8' 
+#define KEY_9        '9' 
+#define KEY_10       '-'                        /* # */
+#define KEY_11       '='                        /* * */
+#endif
+
+#endif   /* ----- #ifndef projectfixhead_INC  ----- */
diff --git a/src/EVA11/base/ProjectGBText.h b/src/EVA11/base/ProjectGBText.h
new file mode 100644
index 0000000..ffeed38
--- /dev/null
+++ b/src/EVA11/base/ProjectGBText.h
@@ -0,0 +1,770 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ProjectGBText.h
+ *
+ *    Description:  The file define the Texts used by Programme with GB2312 Code
+ *
+ *        Version:  1.0
+ *        Created:  20120605 13ʱ4955
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun (XIAMEN)
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _PROGBTEXT_INC
+#define  _PROGBTEXT_INC
+
+#define MAINTITLE_CN                "EVA-11ɱ"
+
+#define DETECT_CN		    ""
+#define PARAM_CN                    ""
+#define DEBUG_CN  		    ""
+#define ALARM_CN   		    ""
+#define ANALYZE_CN 		    ""
+#define LAYOUT_CN                   "" 
+#define OTHERS_CN  		    ""
+
+#define PREVIOUSE_CN                ""
+#define NEXT_CN                     ""
+#define LEFTC_CN                    ""
+#define RIGHTC_CN                   ""
+
+#define COMFIRM_CN	 	    "ȷ"
+#define BACKOUT_CN		    "˳"
+
+#define SUBTITLE_CN                 "ѡ"
+#define MAINBUTTON_CN               "ͨ"
+#define RESERVE_CN                  "Ԥ"
+#define	CANCEL_CN		    "ȡ"	 
+#define COMFIRMEXIT_CN		    "ȷҪ˳" 
+#define INFORMESG09_CN              " : Ӳػ飡"
+#define INFORMESG08_CN              "ؼľ뾡챣ػ"
+
+#define SCREEN_CN		    "迹ͼ"
+#define CHANNEL_CN		    "ŵ"
+#define HDGAIN_CN   		    "ǰ"
+#define FREQUENCEVALUE_CN           "Ƶֵ"
+#define DRIVER_CN  		    ""
+#define OFFSET_CN  		    "ƫ"
+
+#define PROBE_CN                    "̽ͷ"
+#define FREQUENCE_CN                "Ƶ"
+#define DIFILTER_CN 		    "˲"
+
+#define GAIN_CN 		    ""
+#define PHASE_CN   		    "λ"
+#define HIFILTER_CN 		    "ͨ˲"
+#define LOFILTER_CN 		    "ͨ˲"
+#define CRAFTPARA_CN		    "ղ"
+
+#define	SAVEPARAM_CN		    ""
+#define	LOADPARAM_CN		    "ȡ"
+#define	DELPARAM_CN                 "ɾ"
+#define SUB_TITLE2_CN               "˵"
+#define SUB_TITLE3_CN               "˵"
+#define EXCUTE_CN   		    "ִ"
+
+#define LOADEMPTYDOC_CN             "λûĵ޷ȡ"
+#define DELEMPTYDOC_CN              "λûĵ޷ɾ"
+#define OVERWRITECHECK_CN           "ĵ! ȷ"
+#define INFO_PASSWORD_CN            ",[ȷ]"
+#define INFO_PD_INVAIL_CN           "Чûȡ"
+#define	CLOSED_CN		    ""
+
+#define HELPTITLE1_CN               "            EVA-11ɱ"
+#define HELPTITLE2_CN               "===================================="
+#define HELPB1F1_CN                 "  [  F1    ]      /˳ϵͳ"
+#define HELPB1F2_CN                 "  [  F2    ]       | Ƭ"
+#define HELPB1F3_CN                 "  [  F3    ]      ʾʽ ->->"
+#define HELPB1F3_O_CN               "  [  F3    ]      ʾʽ ->->"
+#define HELPB1F5_CN                 "  [  F5    ]      ȡĻ" 
+#define HELPB1F4_CN                 "  [  F4    ]      ƽ | Ƭ"
+#define HELPB1F6_CN                 "  [  F6    ]      " 
+#define HELPB1F7_CN                 "  [  F7    ]      ץȡ/Ƶ" 
+#define HELPB1ESC_CN                "  [  ESC   ]      ͣ⣬ص" 
+#define HELPB1ENTER_CN              "  [  ENTER ]      "
+
+#define GRAPHICFILE_CN              "ͼļ"
+#define GRAPHICSAVE_CN              "Ƿ񱣴?"
+#define INFORMESG10_CN              "޷ͼƬ"
+
+#define	VIDEODISPLAY_CN		    "Ƶʾ"
+#define COLORDISPLAY_CN		    "ɫʾ"
+#define SIGZKDISPLAY_CN		    "迹ʾ"
+#define INFORMESG22_CN              "޷ʼƵ̽ͷ"
+
+#define	SAVEDATA_CN		    ""
+#define LOADDATA_CN		    "ȡ"
+#define DELEDATA_CN		    "ɾ"
+
+#define	UPDATEPRO_CN		    ""
+#define	UPDATECOMFIRM_CN	    "Ƿг?"
+#define TRANINFO1_CN                "ڽԵ......" 
+#define	ALLGAIN_CN		    "ɫ"
+
+#define VIDEOOPEN_CN		    "Ƶ"
+#define VIDEOCLOSE_CN		    "رƵ"
+#define ADJRES_CN		    "ֱ"
+#define AUTODI_CN  		    "Զ"
+#define PAGE5_CN                    " 5 ҳ"
+
+#define CHCOL_CN	   	    ""
+#define PGUP_CN    		    "ҳ"
+#define PGDN_CN    		    "ҳ" 
+
+#define BLANK_CN                    ""
+#define	DATAFILE_CN                 "ļ"
+
+#define LOADDATA1_CN                "ڶȡԵ......"
+#define SAVEDATA1_CN                "ڱԵ......"
+
+#define LANGUAGE_CN                 ""
+#define LAN_VALUE_CN                ""
+
+#define DZKDISPLAY_CN		    "˫ʾ"
+
+#define DATE_CN			    "ǰ"
+#define TIME_CN			    "ǰʱ"
+#define VERSION_CN		    "汾˵"
+
+#define ABOUTMSG1_CN                "    ˵  "
+#define ABOUTMSG2_CN                "ӭʹSmartϵϵͳ"
+#define ABOUTMSG21_CN               "ϵͳ汾ΪV"
+#define ABOUTMSG22_CN               " ʹ"
+#define ABOUTMSG3_CN                "κҪеַϵ"
+#define ABOUTMSG4_CN                "ɭ()޹˾"
+#define ABOUTMSG5_CN                "ַź·57ŽԴ19A"
+#define ABOUTMSG6_CN                "绰0592-2211133  0592-2230833"
+#define ABOUTMSG7_CN                "棺0592-2237091"
+#define ABOUTMSG8_CN                "ַWWW.EDDYSUN.COM"
+
+#define SAMPLETYPE_CN		    "ģʽ" 
+#define INSIDESAMP_CN		    "ڲʱ" 
+#define	OUTSIDESAMP_CN		    "ⲿ"
+#define	STIMEINTER_CN		    ""
+#define	SAMPPLUS_CN		    ""
+
+#define	COLORSPOTDM_CN		    "ʾģʽ"
+#define	DISPMOD_3D_CN		    "3D ʾ"
+#define	DISPMOD_2D_CN		    "2D ʾ"
+
+#define SCANSPEED_CN		    "ɨٶ"
+
+#define EDDYNETWORK_CN		    "       "
+
+#define IPMESG_CN		    "IP  192.168.1.120  ˿ں 5200"
+#define	ERRORMSG1_CN		    "޷ʼ ˳"
+
+#define INFORMESG07_CN		    "³ɹ!"
+#define INFORMESG06_CN		    "ʧܣٴθ!"
+
+#define	SYSTEMDATE_CN		    "ϵͳ"
+#define	SYSTEMTIME_CN		    "ϵͳʱ"
+
+#define INFORMESG21_CN              "...... δְĵ"
+#define	DELETE_CN		    "ɾ"
+#define	DELETEHELP_CN		    "ɾĵɹ"
+#define	PICMANAGE_CN		    "ͼƬ"
+#define	PREVIEW_CN		    "Ԥ"
+#define PREPIC_CN		    "ԤͼƬ"
+#define	PICFILE_CN	            "ͼƬļ"
+#define	PREVIEWPIC_CN		    "ͼƬԤ....ESC˳"
+#define	DELPICFILE_CN		    "ɾͼƬļɹ"
+
+#define	ALARMTYPE_CN		    ""
+#define	ALARMACOUNT_CN		    "Ŀ"
+#define ALARMBEEP_CN                ""
+#define	ALARMOUT_CN		    ""
+#define	ALARMDISP_CN	            "ʾ"
+
+#define	ALARMWINS_CN		    "  "
+
+#define LEFTLIMIT_CN  		    "  "
+#define RIGHTLIMIT_CN 		    "  "
+#define UPLIMIT_CN    		    "  "
+#define DOWNLIMIT_CN  		    "  "
+
+#define DEGREE1_CN  		    "Ƕ 1"
+#define DEGREE2_CN  		    "Ƕ 2"
+#define XHALF_CN  		    "X 뾶"
+#define YHALF_CN  		    "Y 뾶"
+
+#define	RECTALARM_CN		    ""
+#define	AMPALARM_CN		    ""
+#define	HAMPALARM_CN		    ""
+#define ALARMWINMENU_CN  	    ""
+#define OPEN_CN			    ""
+#define	DEFAULT_CN		    "Ĭϲ"
+#define	RESTORE_CN		    "ָ"
+#define RESTOREDEFAULT_CN	    "Ƿָ?"
+#define REBOOTMSG_CN		    "ָɣ!"	
+#define	CLEANBUF_CN		    "Ƿݻ?"
+
+#define	RUNTIME_CN		    "ʱ"
+#define	KEYBEEP_CN		    ""
+
+#define SHUTDOWNMSG1_CN             "      "
+#define SHUTDOWNMSG2_CN             "          ,     !"
+
+#define TIMESCALE_CN		    "ʱʾ"
+#define TIMESCALESPEED_CN	    "ʱٶ"
+
+#define MIXINGINFO1_CN		    "ڽлƵ......" 
+
+#define PRIFREQ_CN		    "S1 Ƶֵ"
+#define SECFREQ_CN		    "S2 Ƶֵ"
+#define MIXFACTOR_CN		    "Ƶϵ"
+
+#define MIXFACTORCOMFIRM_CN	    "ǷָĬϵĻƵϵ?"
+#define SAVEMIXCOMFIRM_CN	    "Ƿ񱣴˴λƵ?"
+
+#define X1POINT_CN		    "ƫ X1"
+#define Y1POINT_CN		    "ƫ Y1"
+#define X2POINT_CN		    "ƫ X2"
+#define Y2POINT_CN		    "ƫ Y2"
+
+#define XNPOINT_CN		    "ƫ Xn"
+#define YNPOINT_CN		    "ƫ Yn"
+
+#define	GAINRATIO_CN		    ""
+#define CLEANPHOTO_CN		    "ǷƬͼ?"
+
+#define OZKDISPLAY_CN		    "ģʽ"
+#define SCOPE_CN		    "÷Χ"
+#define WHOLE_CN		    "ȫͨ"
+
+#define CROSSCHAN_CN		    "ŵ"
+#define ALARMLIMIT_CN		    ""
+
+#define COMBINING_CN		    "ģʽ"
+#define ASCANCHAN_CN		    "Aɨŵ"
+#define EMSGAIN_CN		    "ż"
+#define ASCANSPEED_CN		    "Aɨٶ"
+
+#define PARASYNC_CN		    "ͬ"
+#define PARASYNCCOMFIRM_CN	    "Ƿ񽫸ͨ桢λͬͨ?"
+
+#define RESBALACE_CN		    "ƽ"
+#define ADRIVE_CN 		    "·A"
+#define BDRIVE_CN 		    "·B"
+#define APICK_CN 		    "յ·A"
+#define BPICK_CN 		    "յ·B"
+
+#define RFFILTER_CN		    "RF˲"
+#define PRECISION_CN		    ""
+#define PREHIGH_CN		    ""
+#define PREMED_CN		    ""
+#define PRELOW_CN		    ""
+
+#define OPERATION_CN		    "־"
+
+#define	NONE_CN			    "  "
+/* ********************************************************************  */
+
+#define MAINTITLE_EN                "EVA-11 Variable Array Eddy Current Instrument"
+
+#define DETECT_EN		    "Detect"
+#define PARAM_EN                    "Parameter"
+#define DEBUG_EN   		    "Debug"
+#define ALARM_EN   		    "Alarm"
+#define ANALYZE_EN 		    "Analyze"
+#define LAYOUT_EN                   "Disp.Mode" 
+#define OTHERS_EN  		    "Others"
+
+#define PREVIOUSE_EN                "  Up  "
+#define NEXT_EN                     " Down "
+#define LEFTC_EN                    " Left "
+#define RIGHTC_EN                   " Right"
+
+#define COMFIRM_EN	 	    " O.K. "
+#define BACKOUT_EN		    " Exit "
+
+#define SUBTITLE_EN                 "Sel. Para."
+#define MAINBUTTON_EN               "Standard Testing"
+#define RESERVE_EN                  "Reserve"
+#define	CANCEL_EN		    "Cancel"	 
+#define COMFIRMEXIT_EN		    "Do you want to quit?"
+#define INFORMESG08_EN              "Discharge Off Soon, Pls. Save!"
+#define INFORMESG09_EN              "Hardware Error,Shutdown&Check!"
+#define SCREEN_EN		    "Screen No."
+#define CHANNEL_EN		    "Sig.Chan."
+#define HDGAIN_EN   		    "Prob.Gain"
+#define FREQUENCEVALUE_EN           "Freq.Value"
+#define DRIVER_EN  		    "Driver"
+#define OFFSET_EN  		    "Offset"
+
+#define PROBE_EN                    "Probe"
+#define FREQUENCE_EN                "Freq.Index"
+#define DIFILTER_EN 		    "Filter"
+
+#define GAIN_EN 		    "Gain"
+#define PHASE_EN   		    "Phase"
+#define HIFILTER_EN 		    "Hi.Pass"
+#define LOFILTER_EN 		    "Lo.Pass"
+#define CRAFTPARA_EN		    "Parameters"
+
+#define	SAVEPARAM_EN		    "Save Para."
+#define	LOADPARAM_EN		    "Load Para."
+#define	DELPARAM_EN                 "Del Para."
+#define SUB_TITLE2_EN               "Lv.2 Menu"
+#define SUB_TITLE3_EN               "Lv.3 Menu"
+#define EXCUTE_EN   		    "Excute"
+#define LOADEMPTYDOC_EN             "No File Found, Can't Load!"
+#define DELEMPTYDOC_EN              "No File Found, Can't Delete!"
+#define OVERWRITECHECK_EN           "File Exist! Overwrite?"
+#define INFO_PASSWORD_EN            "Enter Password, Push [Enter] Key to Confirm"
+#define INFO_PD_INVAIL_EN           "Password Invalidity or Cancelled by User"
+#define	CLOSED_EN		    "Closed"
+
+#define HELPTITLE1_EN               "EVA-11 Variable Array Eddy Current Instrument"
+#define HELPTITLE2_EN               "==============================================="
+#define HELPB1F1_EN                 "  [  F1    ]      Enter/Quit Help System"
+#define HELPB1F2_EN                 "  [  F2    ]      Clean Screen | Make Plate"
+#define HELPB1F3_EN                 "  [  F3    ]      Mode: Point->Lin.->Aut."
+#define HELPB1F3_O_EN               "  [  F3    ]      Mode: Point->Lin.->Spe."
+#define HELPB1F5_EN                 "  [  F5    ]      Save Screen" 
+#define HELPB1F4_EN                 "  [  F4    ]      Balance | Clean Plate"
+#define HELPB1F6_EN                 "  [  F6    ]      Clean Buffer" 
+#define HELPB1F7_EN                 "  [  F7    ]      Mixing Signal" 
+#define HELPB1ESC_EN                "  [  ESC   ]      Pause DetectReturn" 
+#define HELPB1ENTER_EN              "  [  ENTER ]      Resume to Detect"
+#define GRAPHICFILE_EN              "PIC file"
+#define GRAPHICSAVE_EN              "be Saved?" 
+#define INFORMESG10_EN              "Buffer full,Can't save file!"
+
+#define	VIDEODISPLAY_EN		    "Video"
+#define COLORDISPLAY_EN		    "Color.Belt"
+#define SIGZKDISPLAY_EN		    "Impedance"
+#define INFORMESG22_EN              "Unable to init Video Probe "
+
+#define	SAVEDATA_EN		    "Save Data"
+#define LOADDATA_EN		    "Load Data"
+#define DELEDATA_EN		    "Del  Data"
+
+#define	UPDATEPRO_EN		    "Update Pro."
+#define	UPDATECOMFIRM_EN	    "Update Application or Not?"
+#define TRANINFO1_EN                "Transmit.... Wait Please"
+#define	ALLGAIN_EN		    "CD. Gain"
+
+#define VIDEOOPEN_EN		    "Open Video"
+#define VIDEOCLOSE_EN		    "Close Video"
+#define ADJRES_EN		    "Resolution"
+#define AUTODI_EN  		    "Disp.Delay"
+#define PAGE5_EN                    "Total 5 Pages"
+
+#define CHCOL_EN	   	    "  Row "
+#define PGUP_EN    		    " PgUp "
+#define PGDN_EN    		    " PgDn "
+
+#define BLANK_EN                    "Blank"
+#define DATAFILE_EN                 "Data File"
+
+#define LOADDATA1_EN                "Data Load... Wait Please"
+#define SAVEDATA1_EN                "Data Save... Wait Please"
+
+#define LANGUAGE_EN                 "Language"
+#define LAN_VALUE_EN                "English"
+
+#define DZKDISPLAY_EN		    "Double Imp."
+
+#define DATE_EN			    "Date"
+#define TIME_EN			    "Time"
+#define VERSION_EN		    "Version"
+
+#define ABOUTMSG1_EN                "Version Information"
+#define ABOUTMSG2_EN                "Welcome to use ECT of Smart series."
+#define ABOUTMSG21_EN               "VER.: V"
+                                 
+#define ABOUTMSG22_EN               "When you have" 
+#define ABOUTMSG3_EN                "any question, please contact"
+#define ABOUTMSG4_EN                "Eddysun(Xiamen)Electronics Co.,Ltd"
+#define ABOUTMSG5_EN                "Addr.:Hubinnan Road No.57 Jinyuan"
+				        
+#define ABOUTMSG7_EN                "Tel:0592-2211133  0592-2230833"
+#define ABOUTMSG6_EN                "19A Xiamen China. Fax:0592-2237091"
+#define ABOUTMSG8_EN                "Web:WWW.EDDYSUN.COM"
+
+#define SAMPLETYPE_EN		    "Samp. Type" 
+#define INSIDESAMP_EN		    "In. Clock" 
+#define	OUTSIDESAMP_EN		    "Out. Plus"
+#define	STIMEINTER_EN		    "Samp.Inter."
+#define	SAMPPLUS_EN		    "Samp.Plus"
+
+#define	COLORSPOTDM_EN		    "Disp.Mode"
+#define	DISPMOD_3D_EN		    "3D Mode"
+#define	DISPMOD_2D_EN		    "2D Mode"
+
+#define SCANSPEED_EN		    "Scan Speed"
+
+#define EDDYNETWORK_EN		    "Eddy Detect Network Interface"
+#define IPMESG_EN		    "Device IP  192.168.1.1  Port 5200"
+#define	ERRORMSG1_EN		    "Init Networking fail! Exit Programe!"
+
+#define INFORMESG07_EN		    "Update successfully! Reboot App!"
+#define INFORMESG06_EN		    "Update failPlease try again!"
+
+#define	SYSTEMDATE_EN		    "Sys.Date"
+#define	SYSTEMTIME_EN		    "Sys.Time"
+#define INFORMESG21_EN              "...... Not Help Document Found"
+#define	DELETE_EN		    "Delete"
+#define	DELETEHELP_EN		    "Delete Help Doc. Successfully"
+#define	PICMANAGE_EN		    "PIC.Manage"
+#define	PREVIEW_EN		    "Preview"
+#define PREPIC_EN		    "Preview Picture"
+#define	PICFILE_EN	            "Pic.File"
+
+#define	PREVIEWPIC_EN		    "Picture Preview....Push [ESC] Exit"
+#define	DELPICFILE_EN		    "Delete Pictrue Doc. Successfully"
+
+#define	ALARMTYPE_EN		    "Ala.Type"
+#define	ALARMACOUNT_EN		    "Ala.Count"
+#define ALARMBEEP_EN                "Ala.Beep"
+#define	ALARMOUT_EN		    "Ala.Output"
+#define	ALARMDISP_EN	            "Ala.Disp."
+
+#define	ALARMWINS_EN		    "Ala.Region"
+
+#define LEFTLIMIT_EN  		    "L.Border"
+#define RIGHTLIMIT_EN 		    "R.Border"
+#define UPLIMIT_EN    		    "U.Border"
+#define DOWNLIMIT_EN  		    "D.Border"
+
+#define DEGREE1_EN  		    "Angle 1"
+#define DEGREE2_EN  		    "Angle 2"
+#define XHALF_EN  		    "X Radius"
+#define YHALF_EN  		    "Y Radius"
+
+#define	RECTALARM_EN		    "Rectangle"
+#define	AMPALARM_EN		    "Amp-Pha"
+#define	HAMPALARM_EN		    "H-Amp-Pha"
+#define ALARMWINMENU_EN  	    "Region No."
+#define OPEN_EN			    "Open"
+#define	DEFAULT_EN		    "Def.Val."
+#define	RESTORE_EN		    "Restore"
+#define RESTOREDEFAULT_EN	    "Restore to Default Value?"
+#define REBOOTMSG_EN		    "Restore Parameters OK! Reboot App!"	
+#define	CLEANBUF_EN		    "Clean Up Data Buffer?"
+#define	RUNTIME_EN		    "Run Time"
+#define	KEYBEEP_EN		    "Key Beep"
+
+#define SHUTDOWNMSG1_EN            "Shutdown Waiting"
+#define SHUTDOWNMSG2_EN            "Please Waiting, Shutdown Device ...."
+
+#define TIMESCALE_EN		    "Chart Disp."
+#define TIMESCALESPEED_EN	    "Chart Speed"
+
+#define MIXINGINFO1_EN		    "Mixing Frequence Calculating......" 
+
+#define PRIFREQ_EN		    "Pri.Freq."
+#define SECFREQ_EN		    "Sec.Freq."
+#define MIXFACTOR_EN		    "Mix.Factor"
+
+#define MIXFACTORCOMFIRM_EN	    "Restore to default Mix. factor?"
+#define SAVEMIXCOMFIRM_EN	    "Save the Mixing result?"
+
+#define X1POINT_EN		    "Offset X1"
+#define Y1POINT_EN		    "Offset Y1"
+#define X2POINT_EN		    "Offset X2"
+#define Y2POINT_EN		    "Offset Y2"
+
+#define XNPOINT_EN		    "Offset Xn"
+#define YNPOINT_EN		    "Offset Yn"
+
+#define	GAINRATIO_EN		    "X/Y Ratio"
+#define CLEANPHOTO_EN		    "Clean Plate, OK?"
+
+#define OZKDISPLAY_EN		    "Quad.Patern"
+#define SCOPE_EN		    "Scope"
+#define WHOLE_EN		    "All Chan."
+
+#define CROSSCHAN_EN		    "Quad.Chan."
+#define ALARMLIMIT_EN		    "Alarm Limit"
+
+#define COMBINING_EN		    "Combining"
+#define ASCANCHAN_EN		    "AScan Chan."
+#define EMSGAIN_EN		    "EMS Gain"
+#define ASCANSPEED_EN		    "AScan Speed"
+
+#define PARASYNC_EN		    "Para.Sync."
+#define PARASYNCCOMFIRM_EN	    "Sync. Chan. Gain and Phase to other Chan.?"
+
+#define RESBALACE_EN		    "Res.Balance"
+#define ADRIVE_EN 		    "Driver A"
+#define BDRIVE_EN 		    "Driver B"
+#define APICK_EN 		    "Pick A"
+#define BPICK_EN 		    "Pick B"
+
+#define RFFILTER_EN		    "RF Filter"
+#define PRECISION_EN		    "Precision"
+#define PREHIGH_EN		    "High"
+#define PREMED_EN		    "Medial"
+#define PRELOW_EN		    "Low"
+
+#define OPERATION_EN		    "Oper.Log"
+
+#define	NONE_EN			    "  "
+/* ********************************************************************  */
+
+#define MAINTITLE		    0 
+
+#define DETECT			    1
+#define PARAM			    2
+#define DEBUG			    3
+#define ALARM			    4
+#define ANALYZE			    5
+#define LAYOUT			    6
+#define OTHERS		   	    7  
+                                    
+#define PREVIOUSE		    8
+#define NEXT			    9
+#define LEFTC			    10
+#define RIGHTC			    11  
+                                    
+#define COMFIRM			    12
+#define BACKOUT			    13
+#define SUBTITLE                    14 
+#define MAINBUTTON                  15 
+#define RESERVE			    16
+#define	CANCEL			    17
+#define COMFIRMEXIT		    18
+
+#define	INFORMESG08		    19
+#define	INFORMESG09		    20
+
+#define	SCREEN			    21
+#define CHANNEL			    22
+#define HDGAIN   		    23 
+#define FREQUENCEVALUE              24 
+#define DRIVER  		    25 
+#define OFFSET  		    26 
+
+#define PROBE			    27
+#define FREQUENCE                   28
+#define DIFILTER                    29 
+
+#define GAIN                        30
+#define PHASE                       31
+#define HIFILTER                    32
+#define LOFILTER                    33
+#define CRAFTPARA		    34
+
+#define SAVEPARAM		    35
+#define LOADPARAM                   36
+#define DELPARAM                    37
+#define SUB_TITLE2 		    38
+#define EXCUTE			    39
+
+#define LOADEMPTYDOC                40
+#define DELEMPTYDOC                 41
+#define OVERWRITECHECK              42
+#define INFO_PASSWORD               43
+#define INFO_PD_INVAIL              44
+#define	CLOSED			    45
+
+#define HELPTITLE1                  47
+#define HELPTITLE2                  48
+#define HELPB1F1                    49
+#define HELPB1F2                    50
+#define HELPB1F3                    51
+#define HELPB1F5                    52
+#define HELPB1F4                    53
+#define HELPB1F6                    54
+#define HELPB1F7                    55
+#define HELPB1ESC                   56
+#define HELPB1ENTER                 57
+#define GRAPHICFILE                 58
+#define GRAPHICSAVE                 59
+#define INFORMESG10                 60
+
+#define VIDEODISPLAY		    61
+#define COLORDISPLAY		    62
+#define SIGZKDISPLAY	            63
+#define INFORMESG22                 64
+
+#define	SAVEDATA		    65
+#define LOADDATA 		    66
+#define DELEDATA		    67
+
+#define SUB_TITLE3    	   	    68           
+#define	UPDATEPRO		    69
+#define	UPDATECOMFIRM	    	    70 
+#define TRANINFO1                   71
+#define	ALLGAIN		   	    72 
+
+#define VIDEOOPEN		    73
+#define VIDEOCLOSE		    74
+#define ADJRES			    75
+#define AUTODI			    76
+#define PAGE5                       77 
+
+#define CHCOL			    78
+#define PGUP			    79
+#define PGDN			    80
+
+#define BLANK			    81
+#define DATAFILE                    82
+
+#define LOADDATA1		    83
+#define SAVEDATA1		    84
+
+#define LANGUAGE                    85 
+#define LAN_VALUE                   86 
+
+#define DZKDISPLAY		    87
+
+#define DATE			    88	
+#define TIME			    89	
+#define VERSION		   	    90 
+
+#define ABOUTMSG1 		    91
+#define ABOUTMSG2                   92
+#define ABOUTMSG21                  93
+                  
+#define ABOUTMSG22                  94
+#define ABOUTMSG3                   95
+#define ABOUTMSG4		    96 
+#define ABOUTMSG5                   97
+		  
+#define ABOUTMSG7                   98 
+#define ABOUTMSG6                   99
+#define ABOUTMSG8                   100
+
+#define SAMPLETYPE		    101 
+#define INSIDESAMP		    102 
+#define	OUTSIDESAMP		    103 
+#define	STIMEINTER		    104 
+#define	SAMPPLUS		    105 
+
+#define	COLORSPOTDM		    106 
+
+#define	DISPMOD_3D		    107 
+#define	DISPMOD_2D		    108 
+
+#define SCANSPEED		    109 
+
+#define EDDYNETWORK		    110
+#define IPMESG		    	    111 
+#define	ERRORMSG1		    112
+
+#define INFORMESG07		    113
+#define INFORMESG06		    114
+
+#define	SYSTEMDATE		    115
+#define	SYSTEMTIME		    116
+
+#define INFORMESG21		    117
+#define	DELETE			    118
+#define	DELETEHELP		    119 
+#define	PICMANAGE 		    120
+#define	PREVIEW			    121
+#define PREPIC			    122
+#define	PICFILE			    123
+#define	PREVIEWPIC		    124
+#define	DELPICFILE		    125
+
+#define	ALARMTYPE		    126 
+#define	ALARMACOUNT                 127
+#define ALARMBEEP                   128 
+#define	ALARMOUT		    129 
+#define	ALARMDISP	            130 
+
+#define	ALARMWINS		    131 
+
+#define LEFTLIMIT  		    132 
+#define RIGHTLIMIT 		    133 
+#define UPLIMIT    		    134 
+#define DOWNLIMIT  		    135 
+
+#define DEGREE1  		    136 
+#define DEGREE2  		    137 
+#define XHALF  		    	    138 
+#define YHALF  		    	    139 
+
+#define	RECTALARM		    140 
+#define	AMPALARM		    141 
+#define	HAMPALARM		    142 
+#define ALARMWINMENU  	    	    143 
+
+#define OPEN			    144 
+#define	DEFAULT		     	    145 
+#define	RESTORE		   	    146 
+#define RESTOREDEFAULT              147
+#define REBOOTMSG		    148
+#define	CLEANBUF		    149 
+#define	RUNTIME			    150
+#define	KEYBEEP		   	    151
+
+#define SHUTDOWNMSG1		    152
+#define SHUTDOWNMSG2                153
+#define TIMESCALE		    154
+#define TIMESCALESPEED	    	    155	
+#define MIXINGINFO1                 156
+
+#define PRIFREQ			    157
+#define SECFREQ                     158
+#define MIXFACTOR	   	    159 
+#define MIXFACTORCOMFIRM            160
+#define SAVEMIXCOMFIRM		    161
+
+#define X1POINT			    162
+#define Y1POINT                     163
+#define X2POINT			    164
+#define Y2POINT			    165
+
+#define	GAINRATIO		    166
+#define CLEANPHOTO		    167
+
+#define OZKDISPLAY		    168 
+
+#define XNPOINT			    169
+#define YNPOINT			    170
+
+#define SCOPE			    171
+#define WHOLE			    172
+
+#define CROSSCHAN		    173
+#define ALARMLIMIT		    174
+
+#define COMBINING		    175
+
+#define ASCANCHAN		    176
+#define EMSGAIN			    177
+
+#define ASCANSPEED		    178
+#define HELPB1F3_O                  179 
+#define PARASYNC		    180
+#define PARASYNCCOMFIRM		    181
+
+#define RESBALACE		    182	
+#define ADRIVE 		    	    183
+#define BDRIVE 		            184 
+#define APICK 		  	    185 
+#define BPICK 		            186 
+#define RFFILTER		    187
+
+#define PRECISION		    188
+#define PREHIGH			    189
+#define PREMED 			    190
+#define PRELOW                      191
+#define OPERATION		    192 
+
+#define	NONE			    999
+
+#define CSTRING_A		    "A"
+#define CSTRING_B		    "B"
+#define CSTRING_C		    "C"
+#define CSTRING_D		    "D"
+#define CSTRING_E		    "E"
+#define CSTRING_F		    "F"
+#define CSTRING_G		    "G"
+#define CSTRING_H		    "H"
+
+#define	TEST			   "л񹲺͹GB2312"
+#define GGG			   ''
+#endif
+//#endif   /* ----- #ifndef _progbtext_INC  /
diff --git a/src/EVA11/base/Resource.cpp b/src/EVA11/base/Resource.cpp
new file mode 100644
index 0000000..d18ee0f
--- /dev/null
+++ b/src/EVA11/base/Resource.cpp
@@ -0,0 +1,264 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Resource.cpp
+ *
+ *    Description:  Implementation of Resource class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 10时25分07秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<fstream>
+
+#include 	"Graphic.h"
+#include	"Global.h"
+#include 	"Resource.h"
+#include	"JpegOper.h"
+#include 	"Png.h"
+#include 	"Gif.h"
+
+#define		TEMPFILEPATH		"/var/"
+
+extern "C"
+{
+	extern char _binary_JPGS_backscreen_png_start;
+	extern int _binary_JPGS_backscreen_png_size;
+
+	extern char _binary_JPGS_startup_jpg_start;
+	extern int _binary_JPGS_startup_jpg_size;
+
+	/* i120 * 90 */
+	extern char _binary_JPGS_video_jpg_start;
+	extern int _binary_JPGS_video_jpg_size;
+
+	extern char _binary_JPGS_colorspot_jpg_start;
+	extern int _binary_JPGS_colorspot_jpg_size;
+
+	extern char _binary_JPGS_zkscreen_jpg_start;
+	extern int _binary_JPGS_zkscreen_jpg_size;
+
+	extern char _binary_JPGS_dzkscreen_jpg_start;
+	extern int _binary_JPGS_dzkscreen_jpg_size;
+
+	extern char _binary_JPGS_ozkscreen_jpg_start;
+	extern int _binary_JPGS_ozkscreen_jpg_size;
+
+	extern char _binary_JPGS_czkscreen_jpg_start;
+	extern int _binary_JPGS_czkscreen_jpg_size;
+
+	extern char _binary_JPGS_eddysunlogo_png_start;
+	extern int _binary_JPGS_eddysunlogo_png_size;
+
+	extern char _binary_JPGS_stop_png_start;
+	extern int _binary_JPGS_stop_png_size;
+
+	extern char _binary_JPGS_run_png_start;
+	extern int _binary_JPGS_run_png_size;
+
+	extern char _binary_JPGS_splash_gif_start;
+	extern int _binary_JPGS_splash_gif_size;
+}
+
+std::auto_ptr<Resource> Resource::m_Instance;
+
+Resource::Resource ()
+{
+	m_Initflag = false;
+	filename   = NULL;
+	filename   = new char[60];
+}
+
+Resource::~Resource ()
+{
+	if ( filename != NULL )
+	{
+		delete[] filename;
+		filename = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Resource* Resource::Instance()
+{
+	if ( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Resource() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance_Resource
+ *  Description:  Instance the resource of jpeg 
+ * =====================================================================================
+ */
+bool Resource::Instance_Resource(const char* path, int index)
+{
+	int length;
+	char *addr;
+
+	switch ( index ) 
+	{
+		case 1:
+			length = (int)(&_binary_JPGS_backscreen_png_size);
+			addr   = &_binary_JPGS_backscreen_png_start;
+			break;
+		case 2: 
+			length = (int)(&_binary_JPGS_startup_jpg_size);
+			addr   = &_binary_JPGS_startup_jpg_start;
+			break;
+		case 3:
+			length = (int)(&_binary_JPGS_video_jpg_size);
+			addr   = &_binary_JPGS_video_jpg_start;
+			break;
+		case 4:
+			length = (int)(&_binary_JPGS_colorspot_jpg_size);
+			addr   = &_binary_JPGS_colorspot_jpg_start;
+			break;
+		case 5:
+			length = (int)(&_binary_JPGS_zkscreen_jpg_size);
+			addr   = &_binary_JPGS_zkscreen_jpg_start;
+			break;
+		case 6:
+			length = (int)(&_binary_JPGS_dzkscreen_jpg_size);
+			addr   = &_binary_JPGS_dzkscreen_jpg_start;
+			break;
+		case 7:
+			length = (int)(&_binary_JPGS_eddysunlogo_png_size);
+			addr   = &_binary_JPGS_eddysunlogo_png_start;
+			break;
+		case 8:
+			length = (int)(&_binary_JPGS_stop_png_size);
+			addr   = &_binary_JPGS_stop_png_start;
+			break;
+		case 9:
+			length = (int)(&_binary_JPGS_run_png_size);
+			addr   = &_binary_JPGS_run_png_start;
+			break;
+		case 10:
+			length = (int)(&_binary_JPGS_ozkscreen_jpg_size);
+			addr   = &_binary_JPGS_ozkscreen_jpg_start;
+			break;
+		case 11:
+			length = (int)(&_binary_JPGS_czkscreen_jpg_size);
+			addr   = &_binary_JPGS_czkscreen_jpg_start;
+			break;
+		case 12:
+			length = (int)(&_binary_JPGS_splash_gif_size);
+			addr   = &_binary_JPGS_splash_gif_start;
+			break;
+	}				/* -----  end switch  ----- */
+
+	std::ofstream oo;
+	oo.open(path,std::ofstream::binary|std::ofstream::trunc);
+	if ( !oo )
+	{
+		perror("can't open the /var/%s");
+		return false;
+	}
+	else
+	{
+		for ( int i=0;i<length;i++ )
+		{
+			oo<<*addr;
+			addr ++;
+		}
+		oo.flush();
+	}
+	oo.close();
+	sync();
+
+	return true;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Resource_Jpeg
+ *  Description:  Very important function show JPEG file onto screen 
+ * =====================================================================================
+ */
+void Resource::Show_Resource_Jpeg(Graphic& g,int index,
+				       int Jpeg_x,int Jpeg_y,
+				       int fb_x,int fb_y,
+				       int Play_width,int Play_height)
+{
+	sprintf ( filename,"%s1.jpeg",TEMPFILEPATH );
+	Instance_Resource(filename,index);
+	if ( access(filename,0) == 0 )
+	{
+		m_Jpeg     = new JpegOper;
+		m_Jpeg->JpegGetFrameBufferInfo(g.Get_Screen_Ptr(),g.Get_bpp(),g.Get_Screen_Width(),g.Get_Screen_Height());
+		m_Initflag = true;
+
+		m_Jpeg->JpegSetJpegPara(filename,5,5,JCS_RGB);
+		m_Jpeg->JpegReadJpegFile();
+		m_Jpeg->JpegPlayJpeg(Jpeg_x,Jpeg_y,fb_x,fb_y,Play_width,Play_height);
+
+		delete m_Jpeg;
+		m_Jpeg = NULL;
+
+		remove(filename);
+		sync();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Resource_Png
+ *  Description:  Very important function show PNG file onto screen 
+ * =====================================================================================
+ */
+void Resource::Show_Resource_Png(Graphic& g,const int& index,const int& x,const int& y)
+{
+	sprintf ( filename,"%s1.png",TEMPFILEPATH );
+	Instance_Resource(filename,index);
+
+	if ( access(filename,0) == 0 )
+	{
+		Png *png = new Png;
+		png->Read_PNG_File(g,filename,x,y);
+		delete png;
+		png = NULL;
+
+		remove(filename);
+		sync();
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Resource_Gif
+ *  Description:  Very important function show GIF file onto screen 
+ * =====================================================================================
+ */
+void Resource::Show_Resource_Gif(const int& index,const int& mdelay,const int& loopcount,const int& x,const int& y)
+{
+	sprintf ( filename,"%s1.gif",TEMPFILEPATH );
+	Instance_Resource(filename,index);
+
+	if ( access(filename,0) == 0 )
+	{
+		Gif *gif = new Gif;
+		gif->Set_Delay_MSecond(mdelay);
+		for ( int i = 0; i < loopcount; i += 1 ) 
+			gif->Read_Gif_File(filename,x,y);
+		delete gif;
+		gif = NULL;
+
+		remove(filename);
+		sync();
+	}
+}
diff --git a/src/EVA11/base/Resource.h b/src/EVA11/base/Resource.h
new file mode 100644
index 0000000..ae9cf0a
--- /dev/null
+++ b/src/EVA11/base/Resource.h
@@ -0,0 +1,58 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Resource.h
+ *
+ *    Description:  Manage Resource class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 10时22分36秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _RESOURCE_INC
+#define  _RESOURCE_INC
+
+#include 	<memory>
+
+class Graphic;
+class JpegOper;
+
+class Resource
+{
+	public:
+		static Resource* Instance();
+		static void      Release();
+
+		void Show_Resource_Jpeg(Graphic& g,int index,
+				       int Jpeg_x,int Jpeg_y,
+				       int fb_x,int fb_y,
+				       int Play_width,int Play_height );
+
+		void Show_Resource_Png(Graphic& g,const int& index,const int& x,const int& Y);
+
+		void Show_Resource_Gif(const int& index,const int& mdelay,const int& loopcount,const int& x,const int& Y);
+	protected:
+
+	private:
+		Resource ();
+		~Resource ();
+		Resource (const Resource&);
+		Resource& operator = (const Resource&);
+
+		bool Instance_Resource(const char* path, int index);
+
+		friend class std::auto_ptr<Resource>;
+		static std::auto_ptr<Resource>		m_Instance;
+	private:
+		JpegOper			       *m_Jpeg;
+		bool 					m_Initflag;
+		char				       *filename;
+};
+#endif
diff --git a/src/EVA11/base/Rule.cpp b/src/EVA11/base/Rule.cpp
new file mode 100644
index 0000000..9696c0c
--- /dev/null
+++ b/src/EVA11/base/Rule.cpp
@@ -0,0 +1,181 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Rule.cpp
+ *
+ *    Description:  implementation of Rule class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月12日 14时04分03秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<new>
+#include 	"Graphic.h"
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Rule.h"
+
+#include 	"FreeType.h"
+
+struct Rule::PImpl
+{
+	static const int	RULESPACE = 20;
+	int			m_Factor;
+	int			m_10Step;
+	int			m_Step;
+	short			m_RuleFGColor1; 
+	short			m_RuleBGColor1; 
+	short			m_RuleFGColor2; 
+	short			m_RuleBGColor2; 
+	FreeType*		m_ft;
+};
+
+Rule::Rule (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh) , m_Imple(new struct PImpl)
+{
+	m_Imple->m_Factor 	= 2;
+	m_Imple->m_10Step     	= ( m_Right - m_Left + 1 ) >> 3;
+	m_Imple->m_Step		= m_Imple->m_10Step / 10;
+
+	m_Imple->m_ft 	   	= FreeType::Instance();
+	m_Imple->m_ft->Set_Font_Size(12);
+}
+
+Rule::~Rule ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Rule_Color
+ *  Description:  Init the color used by rule class 
+ * =====================================================================================
+ */
+void Rule::Init_Rule_Color(Graphic& g)
+{
+	m_Imple->m_RuleBGColor1  = g.RGB24_16(0xa5fd00);
+	m_Imple->m_RuleFGColor1  = g.RGB24_16(0x000000);
+	m_Imple->m_RuleBGColor2  = g.RGB24_16(0xa5fd00);
+	m_Imple->m_RuleFGColor2  = g.RGB24_16(0x000000);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Rule::Refreshme(Graphic& g)
+{
+	short co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_Imple->m_RuleBGColor2);
+	for ( int i=0;i<8;i++ )
+	{
+		DrawBigMark(g,m_Imple->RULESPACE-2,i,false);
+		for ( int j=0;j<10;j++ )
+		{
+			DrawSmallMark(g,4,i,j,false);
+		}
+	}
+
+	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
+	else g.Setcolor(m_Imple->m_RuleFGColor1);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
+	g.Setcolor(co);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawBigMark
+ *  Description: Draw the Mark on Rule 
+ *               type : false  Down Rule
+ *                      true Left Rule
+ *               pos  : 0~7
+ * =====================================================================================
+ */
+void Rule::DrawBigMark(Graphic &g,int value,int pos,bool type)
+{
+	if ( type == false )                              /* Down Rule Lable  */
+	{
+		if ( pos != 0 ) 
+		{
+			for ( int i=0;i<value;i++ )
+			{
+				g.Setpixel(m_Left + pos * m_Imple->m_10Step, m_Up + i, m_Imple->m_RuleFGColor1);
+			}
+		}
+		char *mes = new(std::nothrow) char[20];
+		if ( mes != NULL )
+		{
+			sprintf(mes,"%d",(-40+pos*10)*m_Imple->m_Factor);
+			m_Imple->m_ft->Set_Font_Size(12);
+			m_Imple->m_ft->Set_Color(FreeType::FGCOLOR,m_Imple->m_RuleFGColor1);
+			m_Imple->m_ft->Set_Color(FreeType::BGCOLOR,m_Imple->m_RuleBGColor1);
+			m_Imple->m_ft->Text(m_Left + pos * m_Imple->m_10Step + 2,m_Up + 4+12,mes);
+			delete[] mes;
+			mes = NULL;
+		}
+	}
+	else                                              /* Left Rule Lable  */
+	{
+		if ( pos != 0 ) 
+		{
+			for ( int i=0;i<value;i++ )
+			{
+				g.Setpixel(m_Right - i,m_Down - pos * m_Imple->m_10Step, m_Imple->m_RuleFGColor2);
+			}
+		}
+		char *mes = new(std::nothrow) char[20];
+		if ( mes != NULL )
+		{
+			sprintf(mes,"%d",(-40+pos*10)*m_Imple->m_Factor);
+//			g.Ascii90((480-m_Down) + pos * m_Imple->m_10Step + 10,m_Right - 18,mes,m_Imple->m_RuleFGColor2,m_Imple->m_RuleBGColor2);
+			delete[] mes;
+			mes = NULL;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawSmallMark
+ *  Description: Draw the Mark on Rule 
+ *               type : false  Down Rule
+ *                      true Left Rule
+ *               pos  : 0~7
+ * =====================================================================================
+ */
+void Rule::DrawSmallMark(Graphic &g,int value,int offset,int pos,bool type)
+{
+	if ( type == false )                              /* Down Rule Lable  */
+	{
+		if ( pos != 0 ) 
+		{
+			if ( pos == 5 ) value += 3;
+			for ( int i=0;i<value;i++ )
+			{
+				g.Setpixel(m_Left + offset * m_Imple->m_10Step + pos * m_Imple->m_Step, m_Up + i, m_Imple->m_RuleFGColor1);
+			}
+		}
+	}
+	else                                              /* Left Rule Lable  */
+	{
+		if ( pos != 0 ) 
+		{
+			if ( pos == 5 ) value += 3;
+			for ( int i=0;i<value;i++ )
+			{
+				g.Setpixel(m_Right - i,m_Down - offset * m_Imple->m_10Step - pos * m_Imple->m_Step,m_Imple->m_RuleFGColor1);
+			}
+		}
+	}
+}
diff --git a/src/EVA11/base/Rule.h b/src/EVA11/base/Rule.h
new file mode 100644
index 0000000..d4ebdd1
--- /dev/null
+++ b/src/EVA11/base/Rule.h
@@ -0,0 +1,43 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Rule.h
+ *
+ *    Description:  Display Rule on screen
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月12日 14时01分50秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _RULE_INC
+#define  _RULE_INC
+
+#include 	<memory>	
+class Graphic;
+class Basescreen;
+class Rule : public Basescreen
+{
+	public:
+		Rule (int x,int y,int width,int heigh);
+		~Rule ();
+
+		void Init_Rule_Color(Graphic& g);
+	protected:
+		virtual void Refreshme(Graphic& g);
+
+	private:
+		void DrawBigMark(Graphic &g,int value,int pos,bool type);
+		void DrawSmallMark(Graphic &g,int value,int offset,int pos,bool type);
+	private:
+		struct PImpl;
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif
diff --git a/src/EVA11/base/SQLLiteWrapper.cpp b/src/EVA11/base/SQLLiteWrapper.cpp
new file mode 100644
index 0000000..84a23ae
--- /dev/null
+++ b/src/EVA11/base/SQLLiteWrapper.cpp
@@ -0,0 +1,253 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  SQLLiteWrapper.cpp
+ *
+ *    Description:  Implementation of SQLLiteWrapper class
+ *
+ *        Version:  1.0
+ *        Created:  2013年07月30日 22时19分33秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+#include 	<cstdio>
+#include	<iostream>	
+#include 	"SQLLiteWrapper.h"
+
+SQLiteDB::SQLiteDB()
+{
+	m_bConnected=false;
+	pSQLiteConn = new SQLITECONNECTIONOBJECT();
+}
+
+SQLiteDB::~SQLiteDB()
+{
+	CloseConnection();
+	delete pSQLiteConn;
+}
+
+void SQLiteDB::CloseConnection()
+{
+	if	(pSQLiteConn->pCon)
+		sqlite3_close(pSQLiteConn->pCon);
+}
+
+std::string SQLiteDB::GetLastError()
+{
+	return m_strLastError;
+}
+
+bool   SQLiteDB::isConnected()
+{
+	return m_bConnected;
+}
+
+bool SQLiteDB::OpenConnection(std::string DatabaseName,std::string DatabaseDir)
+{
+	pSQLiteConn->SQLiteDatabaseName = DatabaseName;
+	pSQLiteConn->SQLiteDBPath	    = DatabaseDir;
+	
+	m_bConnected = true;
+
+	std::string db=pSQLiteConn->SQLiteDatabaseName;
+	std::string dir=pSQLiteConn->SQLiteDBPath;
+	std::string path=dir.append(db);
+
+	int rc = sqlite3_open(path.c_str(), &(pSQLiteConn->pCon));
+
+	m_strLastError =(std::string)sqlite3_errmsg(pSQLiteConn->pCon);
+	
+	if	(!rc)
+	{
+		if	(m_strLastError.find("not an error") == std::string::npos)
+			m_bConnected = false;
+	}
+
+	return m_bConnected;
+}
+
+void SQLiteDB::BeginTransaction()
+{
+	sqlite3_exec(pSQLiteConn->pCon, "BEGIN TRANSACTION", NULL, NULL,NULL);
+}
+
+void SQLiteDB::CommitTransection()
+{
+	sqlite3_exec(pSQLiteConn->pCon, "COMMIT TRANSACTION", NULL, NULL,NULL);
+}
+
+IResult*  SQLiteDB::ExcuteSelect(const char *Query)
+{
+	if	(!isConnected())
+		return NULL;
+
+	if	(sqlite3_prepare_v2(pSQLiteConn->pCon,Query,-1, &pSQLiteConn->pRes, NULL) != SQLITE_OK)
+	{
+		m_strLastError=sqlite3_errmsg(pSQLiteConn->pCon);		
+		sqlite3_finalize(pSQLiteConn->pRes);
+		return NULL;
+	}
+	else
+	{			
+		m_iColumnCount   =sqlite3_column_count(pSQLiteConn->pRes);
+		IResult *ires=this;
+		return ires;
+	}
+}
+
+unsigned int SQLiteDB::Excute(const char *Query)
+{
+	if	(!isConnected())
+		return 0;
+	m_strLastError="";
+	
+	char* err=0;
+	
+	if	(sqlite3_exec(pSQLiteConn->pCon, Query, NULL, 0, &err) != SQLITE_OK)
+	{
+		m_strLastError=sqlite3_errmsg(pSQLiteConn->pCon);
+		return 0;
+	}
+	return sqlite3_total_changes(pSQLiteConn->pCon);	
+}
+
+/*Result Set Definations*/
+int	SQLiteDB::GetColumnCount()
+{
+	return m_iColumnCount;
+}
+
+const char* SQLiteDB::NextColomnName(int iClmnCount)
+{
+	if	(iClmnCount > m_iColumnCount)
+		return "";
+	return sqlite3_column_name(pSQLiteConn->pRes,iClmnCount);
+}
+
+bool SQLiteDB:: Next()
+{
+	return (sqlite3_step(pSQLiteConn->pRes)==SQLITE_ROW) ? true : false;
+}
+
+const char*  SQLiteDB::ColomnData(int clmNum)
+{
+	if	(clmNum > m_iColumnCount)
+		return "";
+	return ((const char*)sqlite3_column_text(pSQLiteConn->pRes,clmNum));
+}
+
+void SQLiteDB::Release()
+{
+	sqlite3_finalize(pSQLiteConn->pRes);
+	m_iColumnCount=0;
+	m_strLastError="";
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Test
+ *  Description:  Below code used to test SQLLiteWrapper 
+ * =====================================================================================
+ */
+static int callback(void *NotUsed, int argc, char **argv, char **azColName)
+{
+	int i;
+	for(i=0; i<argc;i++)
+	{
+		printf("%s = %s\n", azColName[i], argv [i]);
+
+	}
+	printf("\n");
+	return 0;
+}
+
+void SQLiteDB::Test()
+{
+	char *zErrMsg = 0;
+	sqlite3* db;
+	int rc;
+	rc = sqlite3_open("test.db",&db);
+	if 	( rc )
+	{
+		printf ( "cannot open database %s\n",sqlite3_errmsg(db) );
+
+		sqlite3_close(db);
+	}
+
+	rc = sqlite3_exec(db, "select * from fime", callback, 0, &zErrMsg);
+
+	if	( rc!=SQLITE_OK )
+	{
+		printf ( "SQL error: %s\n", zErrMsg );
+	} 
+
+	sqlite3_close(db);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Self_Test
+ *  Description:  Self Test Code from Cplusplus website 
+ * =====================================================================================
+ */
+void SQLiteDB::Self_Test()
+{
+	SQLiteDB *pSQLite;
+	pSQLite=new SQLiteDB();
+
+	if	(!pSQLite->OpenConnection("SQLiteTest.db","/jffs2/"))
+	{
+		std::cout<<"\nConnecting To DB Failed :"<<pSQLite->GetLastError().c_str();
+		return;
+	}
+
+	//Create DB
+	int effected=pSQLite->Excute("create table test (seq int(2),name varchar(50));");
+
+	if	(effected>0)
+		std::cout<<"\nColoumn Effected :"<<effected;
+	else
+		std::cout<<"\nError in Query : "<<pSQLite->GetLastError().c_str();
+	effected=pSQLite->Excute("insert into test (seq,name) values (1,'SQLLiteDBtest');");
+	if	(effected>0)
+		std::cout<<"\nColoumn Effected :"<<effected;
+	else
+		std::cout<<"\nError in Query : "<<pSQLite->GetLastError().c_str();
+
+	//Get Data From DB
+	IResult *res=pSQLite->ExcuteSelect("Select * from test;");
+	if	(!res)
+		std::cout<<"\n Error:"<<pSQLite->GetLastError().c_str();
+	else
+	{
+		int i = res->GetColumnCount();
+
+		for(int k=0;k<i;k++)
+		{
+			printf("%s\t",res->NextColomnName(k));	
+		}
+		std::cout<<std::endl;
+
+		while(res->Next())
+		{
+			for(int k=0;k<i;k++)
+				printf("%s\t",res->ColomnData(k));		
+			std::cout<<std::endl;
+		}
+
+		//release Result Data
+		res->Release();
+	}
+
+	//Insert Heavey Data in DB
+	pSQLite->BeginTransaction();
+	for(int i=0;i<10000;i++)
+		pSQLite->Excute("insert into test (seq,name) values (1,'SQLLiteDBtest');");
+	pSQLite->CommitTransection();
+	delete pSQLite;
+}
diff --git a/src/EVA11/base/SQLLiteWrapper.h b/src/EVA11/base/SQLLiteWrapper.h
new file mode 100644
index 0000000..531b4b5
--- /dev/null
+++ b/src/EVA11/base/SQLLiteWrapper.h
@@ -0,0 +1,115 @@
+/******************************************************************************************
+       Author : Saurabh Bhushan
+       Dated  : 22 Feb 2013
+  
+    This Class provide the simple wrapper for SQLite DB.			 
+******************************************************************************************/
+
+#ifndef  _SQLLITE_DB
+#define  _SQLLITE_DB
+
+#include 	<string>
+#include 	<sqlite3.h>
+
+//using namespace std;
+
+/*Interface class for Result data of query*/
+class IResult
+{
+public:
+	/*This function return of count of column 
+	  present in result set of last excueted query*/
+	virtual int	    GetColumnCount() = 0;
+
+	/*Get the next coloumn name*/
+	virtual const char* NextColomnName(int iClmnCount) = 0;
+	
+	/*This function returns TRUE if still rows are 
+	der in result set of last excueted query FALSE 
+	if no row present*/
+	virtual bool  Next() = 0;
+
+	/*Get the next coloumn data*/
+	virtual const char*  ColomnData(int clmNum) = 0;
+
+	/*RELEASE all result set as well as RESET all data*/
+	virtual void Release() = 0;
+};
+
+//SQLite Wrapper Class
+class SQLiteDB : public IResult
+{
+
+public:
+	SQLiteDB();
+	~SQLiteDB();
+	
+	/*Open Connection*/
+	bool OpenConnection(std::string DatabaseName,std::string DatabaseDir); 
+
+
+	/*Close Connection*/
+	void CloseConnection();
+
+	/*Query Wrapper*/
+	/*For large insert operation Memory Insert option for SQLLITE dbJournal*/
+	void BeginTransaction();
+	void CommitTransection();
+
+	/*This Method called when SELECT Query to be excuted. 
+	Return RESULTSET class pointer on success else NULL of failed*/
+	IResult*  ExcuteSelect(const char *Query);
+
+	/*This Method called when INSERT/DELETE/UPDATE Query to be excuted. 
+	Return UINT count of effected data on success*/
+	unsigned int Excute(const char *Query);
+
+	/*Get Last Error of excution*/
+	std::string GetLastError();
+
+	/*Return TRUE if databse is connected else FALSE*/
+	bool  isConnected() ;	
+
+
+	void Self_Test();
+	void Test();
+protected:
+	/*SQLite Connection Object*/
+	typedef struct SQLLITEConnection
+	{
+		std::string		 SQLiteDatabaseName;   //Database Name
+		std::string		 SQLiteDBPath;		   //Databse File Dir
+		sqlite3		 *pCon;				   //SQLite Connection Object
+		sqlite3_stmt *pRes;				   //SQLite statement object 
+	}SQLITECONNECTIONOBJECT;
+
+	//SQLite Connection Details
+	SQLITECONNECTIONOBJECT	 *pSQLiteConn;
+
+	bool	m_bConnected;      /*Is Connected To DB*/
+	bool    m_bConsole;	       /*If Console Application*/
+	std::string  m_strLastError;    /*Last Error String*/
+	int	    m_iColumnCount;    /*No.Of Column in Result*/
+
+
+private:
+	/*This function return of count of column 
+	  present in result set of last excueted query*/
+	int	    GetColumnCount();
+
+	/*Get the next coloumn name*/
+	const char* NextColomnName(int iClmnCount);
+	
+	/*This function returns TRUE if still rows are 
+	der in result set of last excueted query FALSE 
+	if no row present*/
+	bool  Next();
+
+	/*Get the next coloumn data*/
+	const char*  ColomnData(int clmNum);
+
+	/*RELEASE all result set as well as RESET all data*/
+	void Release(); 
+
+};
+#endif
diff --git a/src/EVA11/base/ShellCommand.cpp b/src/EVA11/base/ShellCommand.cpp
new file mode 100644
index 0000000..035976c
--- /dev/null
+++ b/src/EVA11/base/ShellCommand.cpp
@@ -0,0 +1,130 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ShellCommand.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年03月15日 10时25分31秒
+ *       Revision:  none
+ *       Compiler:  arm-g++
+ *
+ *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include	<getopt.h>
+#include 	<cstring>
+#include        <cstdio>
+
+#include	"main.h"
+#include	"ShellCommand.h"
+
+ShellCommand::ShellCommand ()
+{
+	m_Version = NULL;
+	m_Version = new char[10];
+	sprintf(m_Version,"%s","1.00");
+}
+
+ShellCommand::~ShellCommand ()
+{
+	if ( m_Version != NULL ) { delete[] m_Version; m_Version = NULL; }
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  ShellCommand
+ *  Description:  Shell Command analyze function
+ * =====================================================================================
+ */
+ShellCommand::SHELLCOMMAND ShellCommand::Analyze( int argc, char* argv[] ) 
+{
+	if ( argc == 1 )
+		return SHELLCOMMAND_NORMAL;
+
+	int opt;
+	struct option longopts[] =  
+	{
+		{ "normal",0,NULL,'n' },
+		{ "tcp",0,NULL,'t' },
+		{ "sdl",0,NULL,'s' },
+		{ "version",0,NULL,'v' },
+		{ "help",0,NULL,'h' },
+	};
+
+	while( ( opt = getopt_long(argc,argv,"ntshv?",longopts,NULL) ) != -1 )
+	{
+		switch ( opt )
+		{
+			case 's':
+				return SHELLCOMMAND_SDL;
+				break;
+			case 'n':
+				return SHELLCOMMAND_NORMAL;
+				break;
+			case 't':
+				return SHELLCOMMAND_TCPNETWORK;
+				break;
+			case 'v':
+				printf ( "\n" );
+				printf("Version %s\n",m_Version);
+				printf ( "\n" );
+				return SHELLCOMMAND_INVALID;
+				break;
+			case 'h':
+				{
+					Help_Doc();
+					return SHELLCOMMAND_INVALID;
+				}
+				break;
+			case '?':
+				Help_Doc();
+				return SHELLCOMMAND_INVALID;
+				break;
+		}				/* -----  end switch  ----- */
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Help_Doc
+ *  Description:  Help Document when type -h switch  
+ * =====================================================================================
+ */
+void ShellCommand::Help_Doc()
+{
+	printf ( "============================================================\n" );
+	printf ( "Compiler:   eabi-gcc %s\n",__VERSION__ );
+	printf ( "Build Time: %s %s\n",__DATE__,__TIME__ );
+	printf ( "Program:    EVA11 with 128 channels eddy current detect intrument\n");
+	printf ( "par file save in such path %s\n",PAR_FILE_PATH);
+	printf ( "log file save in such path %s\n",LOGDIRECTORY);
+	printf ( "\n" );
+	printf ( "Usage: main_EVA11 [Option]\n" );
+	printf ( "\n" );
+	printf ( "Option:\n" );
+	printf ( "none option :  Run Program in normal status.\n" );
+	printf ( "-n --normal :  Run Program in normal status.\n" );
+	printf ( "-t --tcp :     Run Program as TCP network mode\n" );
+	printf ( "-s --sdl :     Test SDL function\n" );
+	printf ( "-v --version:  Show the Version of Programe.\n" );
+	printf ( "-h --help:     Show this message.\n" );
+	printf ( "============================================================\n" );
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  SetVer
+ *  Description:  Set the Version Value 
+ * =====================================================================================
+ */
+void ShellCommand::SetVer(const char *value)
+{
+	if ( strlen(value) == 0 ) return;
+	if ( m_Version != NULL ) delete[] m_Version;
+	m_Version = new char[strlen(value)+1];      /* be careful strlen function not including /0 charactor  */
+	strcpy(m_Version,value);
+}
diff --git a/src/EVA11/base/ShellCommand.h b/src/EVA11/base/ShellCommand.h
new file mode 100644
index 0000000..26f8b60
--- /dev/null
+++ b/src/EVA11/base/ShellCommand.h
@@ -0,0 +1,45 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ShellCommand.h
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年03月15日 10时25分21秒
+*       Revision:  none
+ *       Compiler:  arm-g++
+ *
+ *         Author:  kevin (kevin.wang), kevin.wang2004@hotmail.com
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _SHELLCOMMAND_INC
+#define  _SHELLCOMMAND_INC
+
+class ShellCommand
+{
+	public:
+		typedef enum {
+			SHELLCOMMAND_INVALID    = 0,
+			SHELLCOMMAND_NORMAL     = 1,
+			SHELLCOMMAND_TCPNETWORK = 2,
+			SHELLCOMMAND_MD5	= 3,
+			SHELLCOMMAND_SDL	= 4,
+			SHELLCOMMAND_TEST       = 99,
+		} SHELLCOMMAND;
+
+		ShellCommand ();                                  /* constructor */
+		~ShellCommand ();                                 /* destructor  */
+		SHELLCOMMAND Analyze( int argc, char* argv[] ); 
+		void SetVer(const char *value);
+	protected:
+		void Help_Doc();
+	private:
+		char *m_Version;
+
+};
+
+#endif
diff --git a/src/EVA11/base/Sinscreen.cpp b/src/EVA11/base/Sinscreen.cpp
new file mode 100644
index 0000000..7e4758c
--- /dev/null
+++ b/src/EVA11/base/Sinscreen.cpp
@@ -0,0 +1,108 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Sinscreen.cpp
+ *
+ *    Description:  implementation of Sinscreen class
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月01日 13时39分12秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Graphic.h"
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Sinscreen.h"
+
+#include 	"Filte.h"
+
+Sinscreen::Sinscreen (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+	, m_BackCoordinate(GRID)
+{
+	m_Filter = new Filte;
+	m_Filter->Init_Algorithm1_Data_Structure();
+}
+
+Sinscreen::~Sinscreen ()
+{
+	delete m_Filter;
+	m_Filter = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Sinscreen::Refreshme(Graphic& g)
+{
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);	
+	if ( m_BackCoordinate == GRID )
+		DrawGrid(g);
+	if ( m_Focus == true ) g.Setcolor(m_FocusColor);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);	
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);	
+	g.Setcolor(co);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_SIN_Wave
+ *  Description:  Draw the SIN wave on screen 
+ * =====================================================================================
+ */
+void Sinscreen::Draw_SIN_Wave(Graphic &g,int *databuf,int len)
+{
+	g.Switch_Screen();
+	Refreshme(g);
+
+	m_Filter->Calculate_Algorithm1(databuf,len);
+
+	for ( int i=0;i<len-1;i++ )
+	{
+		DrawPoint_SIN(g,i,databuf[i],databuf[i+1],len);
+	}
+
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawPoint_SIN
+ *  Description:  Showing the SIN wave 
+ * =====================================================================================
+ */
+void Sinscreen::DrawPoint_SIN(Graphic &g,int x,int y,int y1,int samdataN)
+{
+	int cx,cy,cx1,cy1;
+	cx = static_cast<int>(m_Width * ((x+1) / static_cast<double>(samdataN)));
+	cy = static_cast<int>(m_Heigh * ( static_cast<double>(y) / 0x40dfffff));
+	cx1 = static_cast<int>(m_Width * ((x+2) / static_cast<double>(samdataN)));
+	cy1 = static_cast<int>(m_Heigh * ( static_cast<double>(y1) / 0x40dfffff));
+
+	Draw_Line_In_Arrange(g,m_Left+cx,m_Center_Y+cy,m_Left+cx1,m_Center_Y+cy1,m_PointColor);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Back_Coordinate
+ *  Description:  
+ * =====================================================================================
+ */
+void Sinscreen::Set_Back_Coordinate(BACKCOOR back)
+{
+	m_BackCoordinate = back;
+}
diff --git a/src/EVA11/base/Sinscreen.h b/src/EVA11/base/Sinscreen.h
new file mode 100644
index 0000000..4b199c5
--- /dev/null
+++ b/src/EVA11/base/Sinscreen.h
@@ -0,0 +1,48 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Sinscreen.h
+ *
+ *    Description:  Just only draw sin wave on screen 
+ *
+ *        Version:  1.0
+ *        Created:  2012年08月01日 13时36分41秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  SINSCREEN_INC
+#define  SINSCREEN_INC
+
+class Basescreen;
+class Graphic;
+class Filte;
+class Sinscreen : public Basescreen
+{
+	public:
+		enum BACKCOOR 
+		{
+			BKNONE = 0,
+			GRID   = 1,
+		};				/* ----------  end of enum BACKCOOR  ---------- */
+		typedef enum BACKCOOR BACKCOOR;
+		Sinscreen (int x,int y,int width,int heigh);
+		~Sinscreen();
+
+		void Draw_SIN_Wave(Graphic &g,int *databuf,int len);
+		void DrawPoint_SIN(Graphic &g,int x,int y,int y1,int samdataN);
+		void Set_Back_Coordinate(BACKCOOR);
+
+	protected:
+		virtual void Refreshme(Graphic& g);
+	private:
+		BACKCOOR		m_BackCoordinate;
+		Filte*			m_Filter;
+};
+
+#endif
diff --git a/src/EVA11/base/Splashscreen.cpp b/src/EVA11/base/Splashscreen.cpp
new file mode 100644
index 0000000..a655736
--- /dev/null
+++ b/src/EVA11/base/Splashscreen.cpp
@@ -0,0 +1,67 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Splashscreen.cpp
+ *
+ *    Description:  Implemntation of splash screen
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 09时36分00秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"Splashscreen.h"
+#include 	"Resource.h"
+#include 	"Graphic.h"
+#include 	"FreeType.h"
+
+Splashscreen::Splashscreen (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+{
+}
+
+Splashscreen::~Splashscreen ()
+{
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Splashscreen::Refreshme(Graphic& g)
+{
+	Resource *res = Resource::Instance();
+	res->Show_Resource_Jpeg(g,2,0,0,m_X,m_Y,320,240);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Info
+ *  Description:  Show the message into on screen 
+ * =====================================================================================
+ */
+void Splashscreen::Show_Info(Graphic& g,const char* info)
+{
+	Refreshme(g);
+	FreeType *ft = FreeType::Instance();
+	bool tr = ft->Get_Transparce();
+	ft->Set_Transparce(true);
+	ft->Set_Font_Size(16);
+	ft->Set_Color(FreeType::FGCOLOR,g.RGB24_16(0xffffff));
+	ft->Set_Color(FreeType::BGCOLOR,g.RGB24_16(0x000000));
+	ft->Text(m_X+2,m_Y+18+12,info);
+	ft->Set_Transparce(tr);
+#ifdef X86
+	g.Update_Rect(m_X,m_Y,320,240);
+#endif
+}
diff --git a/src/EVA11/base/Splashscreen.h b/src/EVA11/base/Splashscreen.h
new file mode 100644
index 0000000..71e90bd
--- /dev/null
+++ b/src/EVA11/base/Splashscreen.h
@@ -0,0 +1,37 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Splashscreen.h
+ *
+ *    Description:  Show start up information
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月18日 09时30分39秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  SPLASHSCREEN_INC
+#define  SPLASHSCREEN_INC
+
+class Graphic;
+class Basescreen;
+class Splashscreen : public Basescreen
+{
+	public:
+		Splashscreen (int x,int y,int width,int heigh);
+		~Splashscreen();
+
+		void Show_Info(Graphic& g,const char*);
+	protected:
+		virtual void Refreshme(Graphic& g);
+
+	private:
+
+}; /* -----  end of class Splashscreen  ----- */
+#endif   /* ----- #ifndef SPLASHSCREEN_INC  ----- */
diff --git a/src/EVA11/base/TCPMainwin.cpp b/src/EVA11/base/TCPMainwin.cpp
new file mode 100644
index 0000000..ab11a87
--- /dev/null
+++ b/src/EVA11/base/TCPMainwin.cpp
@@ -0,0 +1,212 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  TCPMainwin.cpp
+ *
+ *    Description:  implementation of TCP Mainwin class
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月12日 08时57分17秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<string.h>
+
+#include 	"Object.h"
+#include 	"Graphic.h"
+#include 	"Basewin.h"
+#include 	"TCPMainwin.h"
+#include	"Language.h"
+#include 	"Label.h"
+#include 	"Netclient.h"
+#include 	"Logic.h"
+
+TCPMainwin::TCPMainwin ()
+{
+	m_pl   = Language::Instance();
+	m_lo   = Logic::Instance();
+	m_netc = new Netclient;
+}
+
+TCPMainwin::~TCPMainwin ()
+{
+	if 	( m_netc != NULL )
+	{
+		delete m_netc;
+		m_netc = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void TCPMainwin::Drawme(Graphic &g)
+{
+	g.Clearscreen();
+	g.DrawFillRect(0,0,640,480,g.RGB24_16(0x00000000));
+	g.Setcolor(g_MAINFG_CO);
+	m_Title->Drawme(g);
+	m_SubTitle->Drawme(g);
+	m_labTest->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loopwindow
+ *  Description:  Main loop in Mainwin class 
+ * =====================================================================================
+ */
+int TCPMainwin::Loopwindow(Graphic &g)
+{
+	Init_GUI(g);
+	Drawme(g);
+
+	if ( m_netc->Open_Socket() == false )
+	{
+		m_MsgLab->Set_Text(m_pl->GetText(ERRORMSG1));
+		m_MsgLab->Drawme(g); 
+		goto ExitNetError;
+	}
+
+	if ( !Connect_Server(g,*m_MsgLab) ) goto Exit;
+Exit:
+	m_netc->Close_Socket();
+
+ExitNetError:
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void TCPMainwin::Init_GUI(Graphic &g)
+{
+	m_Title = new Label(2,60,636,20);
+	m_Title->Set_Font_Size(24);
+	m_Title->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_Title->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
+	m_Title->Set_Text(m_pl->GetText(EDDYNETWORK));
+
+	m_SubTitle = new Label(2,100,636,20);
+	m_SubTitle->Set_Font_Size(24);
+	m_SubTitle->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_SubTitle->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
+	m_SubTitle->Set_Text(m_pl->GetText(IPMESG));
+
+	m_MsgLab = new Label(240,140,336,20);
+	m_MsgLab->Set_Display_Type(Label::LA_DT_LEFT);
+	m_MsgLab->Set_Font_Size(24);
+	m_MsgLab->Set_Label_Color(Label::LA_BGNO_COLOR,g_MAINBG_CO);
+	m_MsgLab->Set_Label_Color(Label::LA_FGNO_COLOR,g_MAINFG_CO);
+
+	m_labTest = new Label(200,200,150,72);
+	Language *lan = Language::Instance();
+	m_labTest->Set_Text(lan->GetText(SCREEN));
+	m_labTest->Set_Content("25.5 dB");
+	m_labTest->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	m_labTest->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_labTest->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	m_labTest->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	m_labTest->Set_Font_Size(18);
+	m_labTest->Set_Focus(false);
+	m_labTest->Set_Label_Type(Label::LA_THIN);
+	m_labTest->Set_Display_Type(Label::LA_DT_CENTER);
+
+
+//	double dx = 0.65;
+//	int x = 88; 
+//	int z = 2;
+//	int y = x * dx - z;
+//	printf ( "%d\n",y );
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Detroy all GUI object 
+ * =====================================================================================
+ */
+void TCPMainwin::Destroy_GUI()
+{
+	if 	( m_Title != NULL ) 
+	{
+		delete m_Title;
+		m_Title = NULL;
+	}
+	if 	( m_SubTitle != NULL ) 
+	{
+		delete m_SubTitle;
+		m_SubTitle = NULL;
+	}
+	if 	( m_MsgLab != NULL ) 
+	{
+		delete m_MsgLab;
+		m_MsgLab = NULL;
+	}
+	if 	( m_labTest != NULL ) 
+	{
+		delete m_labTest;
+		m_labTest = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Connect_Server
+ *  Description:  Connect the Server and show the message 
+ * =====================================================================================
+ */
+bool TCPMainwin::Connect_Server(Graphic& g,Label& msglab)
+{
+	int key     = 0;
+	int temp    = 0;
+	bool result = false;
+
+	std::string msg[5] = {"*","* *","* * *","* * * *","* * * * *"};
+	while ( !m_netc->Connect_Server() )
+	{
+		key = m_lo->Get_Key();
+		if 	( key == KEY_ESC )
+		{
+			result = false;
+			goto Exit;
+		}
+
+		msglab.Set_Text(msg[temp].c_str());
+		msglab.Drawme(g);
+
+		usleep(400000);
+		temp ++;
+		if ( temp == 5 ) temp = 0;
+	}
+	result = true;
+Exit:
+	return result;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_Fun
+ *  Description:  Dealwith each key function 
+ * =====================================================================================
+ */
+int TCPMainwin::Key_Esc_Fun(Graphic& g)
+{
+
+}
+int TCPMainwin::Key_Enter_Fun(Graphic& g)
+{
+
+}
diff --git a/src/EVA11/base/TCPMainwin.h b/src/EVA11/base/TCPMainwin.h
new file mode 100644
index 0000000..0e4df5b
--- /dev/null
+++ b/src/EVA11/base/TCPMainwin.h
@@ -0,0 +1,54 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  TCPMainwin.h
+ *
+ *    Description:  Manage the TCP network Mainwin class 
+ *
+ *        Version:  1.0
+ *        Created:  2012年09月12日 08时55分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  TCPMAINWIN_INC
+#define  TCPMAINWIN_INC
+
+class Basewin;
+class Graphic;
+class Netclient;
+class Label;
+class TCPMainwin : public Basewin
+{
+	public:
+		TCPMainwin ();
+		virtual ~TCPMainwin ();
+		void Drawme (Graphic&);
+		int Loopwindow(Graphic &);
+
+	protected:
+		void Init_GUI(Graphic& g);
+		void Destroy_GUI();
+		bool Connect_Server(Graphic& g,Label& msg);
+
+		virtual int Key_Esc_Fun(Graphic& g);
+		virtual int Key_Enter_Fun(Graphic& g);
+
+	private:
+		Label*				    m_Title;
+		Label*				    m_SubTitle;
+		Label*				    m_MsgLab;
+
+		Label*				    m_labTest;
+
+		Language			    *m_pl;
+		Netclient			    *m_netc;
+		Logic				    *m_lo;
+};
+
+#endif
diff --git a/src/EVA11/base/USB.cpp b/src/EVA11/base/USB.cpp
new file mode 100644
index 0000000..dc85a0c
--- /dev/null
+++ b/src/EVA11/base/USB.cpp
@@ -0,0 +1,117 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  USB.cpp
+ *
+ *    Description:  Implementation of USB
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月03日 12时27分01秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cstdio>
+#include 	"USB.h"
+
+#define    USB_VENDOR_ID  		0x05ba
+#define    USB_PRODUCT_ID		0x000a 
+
+USB::USB ()
+{
+}
+
+USB::~USB ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_USB
+ *  Description:  Init the USB libary used environment
+ * =====================================================================================
+ */
+bool USB::Init_USB()
+{
+	int rc = 1;
+	rc = libusb_init(NULL);
+	if 	( rc < 0 )
+	{
+		perror("fail to init usb lib");
+		return false;
+	}
+//	m_devh = NULL;
+//	m_devh = libusb_open_device_with_vid_pid(NULL, 0x05ba, 0x000a);
+//	if 	( m_devh == NULL )
+//	{
+//		perror("fail to open the usb device");
+//		libusb_exit(NULL);
+//		return false;
+//	}
+//	rc = libusb_claim_interface(m_devh, 0);
+//	if 	(rc < 0) 
+//	{
+//		perror("fail to claim interface");
+//		libusb_close(m_devh);
+//		libusb_exit(NULL);
+//		return false;
+//	}
+
+	return true;
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_USB
+ *  Description:  Destroy the USB library environment
+ * =====================================================================================
+ */
+void USB::Destroy_USB()
+{
+//	libusb_release_interface(m_devh, 0);
+//	libusb_close(m_devh);
+	libusb_exit(NULL);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_USB_List
+ *  Description:  List All USB device of system
+ * =====================================================================================
+ */
+void USB::Show_USB_List()
+{
+	libusb_device **devs;
+	ssize_t cnt;
+	cnt = libusb_get_device_list(NULL, &devs);
+	if (cnt < 0)
+	{
+		perror("can't get device list");
+		return;
+	}
+
+	libusb_device *dev;
+	int i = 0;
+
+	while ((dev = devs[i++]) != NULL) {
+		struct libusb_device_descriptor desc;
+		int r = libusb_get_device_descriptor(dev, &desc);
+		if (r < 0) 
+		{
+			fprintf(stderr, "failed to get device descriptor");
+			return;
+		}
+
+		printf("%04x:%04x (bus %d, device %d)\n",
+			desc.idVendor, desc.idProduct,
+			libusb_get_bus_number(dev), libusb_get_device_address(dev));
+	}
+
+	libusb_free_device_list(devs, 1);
+}
diff --git a/src/EVA11/base/USB.h b/src/EVA11/base/USB.h
new file mode 100644
index 0000000..9e99605
--- /dev/null
+++ b/src/EVA11/base/USB.h
@@ -0,0 +1,41 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  USB.h
+ *
+ *    Description:  Management of USB port
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月03日 12时24分48秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _USB_INC
+#define  _USB_INC
+
+#include 	<libusb.h>
+
+class USB
+{
+	public:
+		USB ();                             /* constructor */
+		~USB ();                            /* destructor */
+		bool Init_USB();
+		void Destroy_USB();
+
+
+		void Show_USB_List();
+	protected:
+
+	private:
+		struct libusb_device_handle 			*m_devh;
+
+};
+
+#endif   /* ----- #ifndef _USB_INC  ----- */
diff --git a/src/EVA11/base/Uart.cpp b/src/EVA11/base/Uart.cpp
new file mode 100644
index 0000000..b758105
--- /dev/null
+++ b/src/EVA11/base/Uart.cpp
@@ -0,0 +1,102 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Uart.cpp
+ *
+ *    Description:  implementation of Uart class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月07日 13时43分30秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<list>
+#include 	<cstdlib>
+#include 	<cstdio>
+
+#include 	"Uart.h"
+
+std::list<uint8_t>		m_Buf;
+
+static void callback(int id,
+	             uint8_t *buf,
+		     int length)
+{
+	for ( int i=0;i<length;i++ )
+	{
+		m_Buf.push_back(buf[i]);
+	}
+}
+
+Uart::Uart ()
+{
+}
+
+Uart::~Uart ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Uart
+ *  Description:  Init the Uart class 
+ * =====================================================================================
+ */
+bool Uart::Init_Uart()
+{
+	cssl_start();
+	m_Serial = cssl_open("/dev/ttySAC0",callback,0,19200,8,0,1);
+	if ( !m_Serial )
+	{
+		printf("%s\n",cssl_geterrormsg());
+		cssl_stop();
+		return false;
+	}
+	else
+		printf ( "OK\n" );
+	m_Buf.clear();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_Uart
+ *  Description:  Destroy the Uart class 
+ * =====================================================================================
+ */
+void Uart::Destory_Uart()
+{
+	cssl_close(m_Serial);
+	cssl_stop();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Send_Data
+ *  Description:  Send the Data into 
+ * =====================================================================================
+ */
+void Uart::Send_Data(uint8_t *data,int length)
+{
+	cssl_putdata(m_Serial,data,length);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Data
+ *  Description:  Get the Data from module 
+ * =====================================================================================
+ */
+void Uart::Get_Data(uint8_t *data,int length)
+{
+	for ( int i=0;i<length;i++ )
+	{
+		data[i] = m_Buf.front();
+		m_Buf.pop_front();
+	}
+}
diff --git a/src/EVA11/base/Uart.h b/src/EVA11/base/Uart.h
new file mode 100644
index 0000000..3a04afb
--- /dev/null
+++ b/src/EVA11/base/Uart.h
@@ -0,0 +1,39 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Uart.h
+ *
+ *    Description:  Manage the UART port class
+ *
+ *        Version:  1.0
+ *        Created:  2012年11月07日 13时42分23秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _UART_INC
+#define  _UART_INC
+
+#include 	"cssl.h"
+class Uart
+{
+	public:
+		Uart ();                             /* constructor */
+		~Uart ();                            /* destructor */
+		bool Init_Uart();
+		void Destory_Uart();
+		void Send_Data(uint8_t *data,int length);
+		void Get_Data(uint8_t *data,int length);
+
+	protected:
+
+	private:
+		cssl_t 				*m_Serial;
+};
+
+#endif   /* ----- #ifndef _UART_INC  ----- */
diff --git a/src/EVA11/base/Video.cpp b/src/EVA11/base/Video.cpp
new file mode 100644
index 0000000..ce95762
--- /dev/null
+++ b/src/EVA11/base/Video.cpp
@@ -0,0 +1,1038 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Video.cpp
+ *
+ *    Description:  Implementation of Video class 
+ *
+ *        Version:  1.0
+ *        Created:  2011年12月05日 20时20分43秒
+ *       Revision:  none 
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  Eddysun Xiamen
+ *
+ * =====================================================================================
+ */
+
+#include	<time.h>
+#include	"Video.h"
+
+#define CoefRv 1402
+#define CoefGu 344//714 // 344
+#define CoefGv 714//344 // 714
+#define CoefBu 1772
+
+#define  FOUR_TWO_TWO 2		//Y00 Cb Y01 Cr
+
+#define CLIP(color) (unsigned char)(((color)>0xFF)?0xff:(((color)<0)?0:(color)))
+
+Video::Video()
+{
+	m_AdjLight = 60;
+	m_Posx = 160;
+	m_Posy = 120;
+}
+Video::~Video()
+{
+
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Output_Pos
+ *  Description:  
+ * =====================================================================================
+ */
+void Video::Set_Output_Pos(const int& x,const int& y)
+{
+	m_Posx = x;
+	m_Posy = y;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Video
+ *  Description:  Init the Video resource 
+ * =====================================================================================
+ */
+bool Video::Init_Video(int width,int height)
+{
+    	videoIn = (struct vdIn *) calloc(1, sizeof(struct vdIn)); 		/* OK  */
+	if ( init_videoIn(videoIn, (char *)"/dev/video0", width, height, 10, V4L2_PIX_FMT_YUYV, 1, (char *)"video.avi") < 0 )
+	{
+		free(videoIn);
+		videoIn = NULL;
+		return false;
+	}
+	else
+	{
+		initLut();
+		m_Width  = width;
+		m_Height = height; 
+		return true;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Release_Video
+ *  Description:  Release the video resource 
+ * =====================================================================================
+ */
+void Video::Release_Video()
+{
+    	close_v4l2(videoIn);
+	freeLut();
+	free(videoIn);
+	videoIn = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  init_videoIn
+ *  Description:  Init the video resource 
+ * =====================================================================================
+ */
+int Video::init_videoIn(struct vdIn *vd, char *device, int width, int height, int fps,
+	     int format, int grabmethod, char *avifilename)
+{
+	if (vd == NULL || device == NULL)
+		return -1;
+	if (width == 0 || height == 0)
+		return -1;
+
+	if (grabmethod < 0 || grabmethod > 1)
+		grabmethod = 1;
+
+	vd->videodevice = NULL;
+	vd->status = NULL;
+	vd->pictName = NULL;
+	vd->videodevice = (char *) calloc(1, 16 * sizeof(char));
+	vd->status = (char *) calloc(1, 100 * sizeof(char));
+	vd->pictName = (char *) calloc(1, 80 * sizeof(char));
+	snprintf(vd->videodevice, 12, "%s", device);
+	vd->toggleAvi = 0;
+	vd->avifile = NULL;
+	vd->avifilename = avifilename;
+	vd->recordtime = 0;
+	vd->framecount = 0;
+	vd->recordstart = 0;
+	vd->signalquit = 1;
+	vd->width = width;
+	vd->height = height;
+	vd->fps = fps;
+	vd->formatIn = format;
+	vd->grabmethod = grabmethod;
+	vd->fileCounter = 0;
+	vd->rawFrameCapture = 0;
+	vd->rfsBytesWritten = 0;
+	vd->rfsFramesWritten = 0;
+	vd->captureFile = NULL;
+	vd->bytesWritten = 0;
+	vd->framesWritten = 0;
+
+	if (init_v4l2(vd) < 0) 
+	{
+		printf(" Init v4L2 failed !! exit fatal \n");
+		goto error;;
+	}
+
+	vd->framesizeIn = (vd->width * vd->height << 1);
+
+	vd->framebuffer = (unsigned char *) calloc(1, (size_t) vd->framesizeIn);
+
+	if (!vd->framebuffer)
+	{
+		goto error;
+	}
+	return 0;
+
+error:
+	free(vd->videodevice);
+	free(vd->status);
+	free(vd->pictName);
+	close(vd->fd);
+	return -1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  init_v4l2
+ *  Description:  init_v4l2 
+ * =====================================================================================
+ */
+int Video::init_v4l2(struct vdIn *vd)
+{
+	int i;
+	int ret = 0;
+	if ((vd->fd = open(vd->videodevice, O_RDWR)) == -1) 
+	{
+		perror("ERROR opening V4L interface \n");
+		return -1;
+	}
+
+	memset(&vd->cap, 0, sizeof(struct v4l2_capability));
+	ret = ioctl(vd->fd, VIDIOC_QUERYCAP, &vd->cap);
+	if (ret < 0)
+	{
+		printf("Error opening device %s: unable to query device.\n",
+				vd->videodevice);
+		goto fatal;
+	}
+
+	if ((vd->cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0) 
+	{
+		printf("Error opening device %s: video capture not supported.\n",
+				vd->videodevice);
+		goto fatal;;
+	}
+
+	if (!(vd->cap.capabilities & V4L2_CAP_STREAMING)) 
+	{
+		printf("%s does not support streaming i/o\n", vd->videodevice);
+		goto fatal;
+	}
+
+	/* set format in */
+	memset(&vd->fmt, 0, sizeof(struct v4l2_format));
+	vd->fmt.type 		    = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vd->fmt.fmt.pix.width       = vd->width;
+	vd->fmt.fmt.pix.height      = vd->height;
+	vd->fmt.fmt.pix.pixelformat = vd->formatIn;
+	vd->fmt.fmt.pix.field       = V4L2_FIELD_ANY;
+	//vd->fmt.fmt.pix.field       = V4L2_FIELD_INTERLACED;
+	ret = ioctl(vd->fd, VIDIOC_S_FMT, &vd->fmt);
+	if (ret < 0) 
+	{
+		perror("Unable to set format");
+		goto fatal;
+	}
+	else
+		printf ( "Format OK\n" );
+
+	if ((vd->fmt.fmt.pix.width != (unsigned int)vd->width) ||
+			(vd->fmt.fmt.pix.height != (unsigned int)vd->height)) 
+	{
+		printf(" format asked unavailable get width %d height %d \n",
+				vd->fmt.fmt.pix.width, vd->fmt.fmt.pix.height);
+		vd->width = vd->fmt.fmt.pix.width;
+		vd->height = vd->fmt.fmt.pix.height;
+	}
+
+	/* set framerate */
+	struct v4l2_streamparm* setfps;  
+	setfps= new struct v4l2_streamparm;
+	memset(setfps, 0, sizeof(struct v4l2_streamparm));
+	setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	setfps->parm.capture.timeperframe.numerator=1;
+	setfps->parm.capture.timeperframe.denominator=vd->fps;
+	if ( ioctl(vd->fd, VIDIOC_S_PARM, setfps) < 0 )
+	{
+		perror("unable to set param\n");
+		delete setfps;
+		setfps = NULL;
+		goto fatal;
+	}
+	delete setfps;
+	setfps = NULL;
+
+	/* request buffers */
+	memset(&vd->rb, 0, sizeof(struct v4l2_requestbuffers));
+	vd->rb.count = NB_BUFFER;
+	vd->rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vd->rb.memory = V4L2_MEMORY_MMAP;
+
+	ret = ioctl(vd->fd, VIDIOC_REQBUFS, &vd->rb);
+	if (ret < 0) 
+	{
+		printf("Unable to allocate buffers: %d.\n", errno);
+		goto fatal;
+	}
+
+	/* map the buffers */
+	for (i = 0; i < NB_BUFFER; i++)
+	{
+		t_buf.index = i;
+  		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  		t_buf.memory = V4L2_MEMORY_MMAP;
+
+		ret = ioctl(vd->fd, VIDIOC_QUERYBUF, &t_buf);
+		if (ret < 0) 
+		{
+			printf("Unable to query buffer (%d).\n", errno);
+			goto fatal;
+		}
+
+		vd->mapbuflength[i] = t_buf.length;
+		vd->mem[i] = mmap(0,
+				t_buf.length, PROT_READ, MAP_SHARED, vd->fd,
+				t_buf.m.offset);
+		if (vd->mem[i] == MAP_FAILED) 
+		{
+			printf("Unable to map buffer (%d)\n", errno);
+			goto fatal;
+		}
+	}
+	/* Queue the buffers. */
+
+	for ( i=0;i<NB_BUFFER;i++ )
+	{
+		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		t_buf.memory = V4L2_MEMORY_MMAP;
+		t_buf.index = i;
+
+		if (ioctl(vd->fd, VIDIOC_QBUF, &t_buf) < 0) 
+		{
+			printf("Unable to requeue buffer (%d).\n", errno);
+			goto fatal;
+		}
+	}
+
+	Show_Video_Info();
+
+	return 0;
+fatal:
+	return -1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  initLut
+ *  Description:  Init Lut 
+ * =====================================================================================
+ */
+void Video::initLut(void)
+{
+	LutRv  = NULL;
+	LutGu  = NULL;
+	LutGv  = NULL;
+	LutBu  = NULL;
+
+	int i;
+	LutRv = (int *)malloc(256*sizeof(int));
+	LutGu = (int *)malloc(256*sizeof(int));
+	LutGv = (int *)malloc(256*sizeof(int));
+	LutBu = (int *)malloc(256*sizeof(int));
+
+	for (i= 0;i < 256;i++)
+	{
+		LutRv[i] = (i-128)*CoefRv/1000;
+		LutBu[i] = (i-128)*CoefBu/1000;
+		LutGu[i] = (128-i)*CoefGu/1000;
+		LutGv[i] = (128-i)*CoefGv/1000;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  freeLut
+ *  Description:  FreeLut 
+ * =====================================================================================
+ */
+void Video::freeLut(void)
+{
+	free(LutRv);
+	free(LutGu);
+	free(LutGv);
+	free(LutBu);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  close_v4l2
+ *  Description:  close_v4l2 
+ * =====================================================================================
+ */
+int Video::close_v4l2(struct vdIn *vd)
+{
+	if (vd->isstreaming)
+		video_disable(vd);
+	free(vd->framebuffer);
+	vd->framebuffer = NULL;
+	free(vd->videodevice);
+	free(vd->status);
+	free(vd->pictName);
+	vd->videodevice = NULL;
+	vd->status = NULL;
+	vd->pictName = NULL;
+	for (int i = 0; i < NB_BUFFER; i++) 
+	{
+		munmap(vd->mem[i],vd->mapbuflength[i]);
+	}
+	close(vd->fd);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  video_disable
+ *  Description:  video_disable
+ * =====================================================================================
+ */
+int Video::video_disable(struct vdIn *vd)
+{
+	int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	int ret;
+	ret = ioctl(vd->fd, VIDIOC_STREAMOFF, &type);
+	if (ret < 0) 
+	{
+		perror("Unable to %s capture");
+		return ret;
+	}
+	vd->isstreaming = 0;
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  uvGrab
+ *  Description:  uvcGrab Capture the video file 
+ * =====================================================================================
+ */
+int Video::uvcGrab(struct vdIn *vd)
+{
+	if (!vd->isstreaming)
+	{
+		if (video_enable(vd))
+			goto err;
+		else
+			printf ( "isstreaming=%d\n",vd->isstreaming );
+	}
+	q_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q_buf.memory = V4L2_MEMORY_MMAP;
+
+	if (ioctl(vd->fd, VIDIOC_DQBUF, &q_buf) < 0) 
+	{
+		perror("Unable to dequeue buffer");
+		goto err;
+	}
+
+	if ( q_buf.bytesused> 0 )
+	{
+		vd->buf.index = q_buf.index;
+		t_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		t_buf.memory = V4L2_MEMORY_MMAP;
+		t_buf.index = vd->buf.index;
+
+		if (ioctl(vd->fd,VIDIOC_QBUF,&t_buf) < 0)
+		{
+			printf("Unable to requeue buffer (%d).\n", errno);
+			goto err;
+		}
+
+		return 0;
+	}
+	else
+		printf ( "File %s: Line %d\n",__FILE__,__LINE__ );
+
+err:
+	vd->signalquit = 0;
+	return -1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  video_enable
+ *  Description:  video_enable function 
+ * =====================================================================================
+ */
+int Video::video_enable(struct vdIn *vd)
+{
+	int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	int ret;
+	ret = ioctl(vd->fd, VIDIOC_STREAMON, &type);
+	if (ret < 0) 
+	{
+		printf("Unable to %s capture: %d.\n", "start", errno);
+		return ret;
+	}
+	vd->isstreaming = 1;
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  get_pictureYV2
+ *  Description:  get_pictureYV2
+ * =====================================================================================
+ */
+int Video::get_pictureYV2(unsigned char *buf,int width,int height)
+{
+	FILE *foutpict;
+	unsigned char *picture = NULL;
+	char *name = NULL;
+	name = (char *)calloc(80,1);
+	getPictureName (name, 0);
+	picture = (unsigned char *)malloc(width*height*3*sizeof(char));
+	if(picture)
+	{
+		Pyuv422torgb24(buf, picture, width, height);
+	}
+	else
+	{
+		printf(" no room to take a picture \n");
+		return 0;
+	}
+	if(name)
+	{
+		foutpict = fopen (name, "wb");
+		fprintf (foutpict, "P6\n%d %d\n255\n", width, height);
+		size_t result = fwrite (picture, sizeof (char), width * height * 3, foutpict);
+		fclose (foutpict);
+		free(name);
+	}
+	free(picture);
+	picture = NULL;
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  fill_bufYV2
+ *  Description:  
+ * =====================================================================================
+ */
+int Video::fill_bufYV2(unsigned char *buf,unsigned char *pic,int width,int height)
+{
+	Pyuv422torgb24(buf, pic, width, height);
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  getPictureName
+ *  Description:  getPictureName
+ * =====================================================================================
+ */
+void Video::getPictureName (char *Picture, int fmt)
+{
+	fmt = fmt;
+	char temp[80];
+/* 	time_t curdate;
+ * 	struct tm *tdate;
+ * 	memset (temp, '\0', sizeof (temp));
+ * 	time (&curdate);
+ * 	tdate = localtime (&curdate);
+ */
+/* 	snprintf (temp, 26, "P_%02d_%02d_%02d.%s",
+ * 			tdate->tm_hour, tdate->tm_min, tdate->tm_sec, "pnm");
+ */
+	sprintf(temp,"%s","video.pnm");
+	memcpy (Picture, temp, strlen (temp));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torgb24
+ *  Description:  
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torgb24(unsigned char * input_ptr, unsigned char * output_ptr, 
+		                   unsigned int image_width, unsigned int image_height)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_pt = output_ptr;
+	size = image_width * image_height >> 1;
+	for (i = size; i > 0; i--) 
+	{
+		/* bgr instead rgb ?? */
+		Y = buff[0] ;
+		U = buff[1] ;
+		Y1 = buff[2];
+		V = buff[3];
+		buff += 4;
+		*output_pt++ = R_FROMYV(Y,V);
+		*output_pt++ = G_FROMYUV(Y,U,V); //b
+		*output_pt++ = B_FROMYU(Y,U); //v
+			
+		*output_pt++ = R_FROMYV(Y1,V);
+		*output_pt++ = G_FROMYUV(Y1,U,V); //b
+		*output_pt++ = B_FROMYU(Y1,U); //v
+	}
+	return FOUR_TWO_TWO;
+} 
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torbut16_Low
+ *  Description:  Display Data on screen directly 
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torbut16_Low(unsigned char * input_ptr, unsigned char * source_ptr, 
+		                   unsigned int image_width, unsigned int image_height,short scr_w,
+				   short scr_h)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_ptr = source_ptr;
+	size = image_width * image_height >> 1;
+	unsigned short color;
+	unsigned short *loc;
+	int w = 0;
+	int h = 0;
+	unsigned char temp1,temp2,temp3;
+
+	for ( i = size; i > 0; i-- ) 
+	{
+		Y = CLIP(buff[0]+m_AdjLight);
+		U = buff[1] ;
+		Y1 = CLIP(buff[2]+m_AdjLight);
+		V = buff[3];
+		buff += 4;
+
+//		color  = (B_FROMYU(Y,U)>>3);
+//		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
+//		color += ((R_FROMYV(Y,V)>>3)<<11);
+
+		temp1 = (unsigned char)(B_FROMYU(Y,U)*m_FactB+0.5);
+		temp2 = (unsigned char)(G_FROMYUV(Y,U,V)*m_FactG+0.5);
+		temp3 = (unsigned char)(R_FROMYV(Y,V)*m_FactR+0.5);
+		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
+
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + h * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + h * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + ( h + 1 ) * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + ( h + 1 ) * 2 ) );
+		*loc = color;
+		
+		w +=2;
+		if ( w == image_width * 2 )
+		{
+			w = 0;
+			h +=2;
+		}
+
+//		color  = ( B_FROMYU(Y1,U)>>3 );
+//		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
+//		color += ((R_FROMYV(Y1,V)>>3)<<11);
+
+		temp1 = (unsigned char)(B_FROMYU(Y1,U)*m_FactB+0.5);
+		temp2 = (unsigned char)(G_FROMYUV(Y1,U,V)*m_FactG+0.5);
+		temp3 = (unsigned char)(R_FROMYV(Y1,V)*m_FactR+0.5);
+		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
+
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + h * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + h * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - w ) * scr_h * 2 + ( h + 1 ) * 2 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + ( ( scr_w - 1 - ( w + 1 ) ) * scr_h * 2 + ( h + 1 ) * 2 ) );
+		*loc = color;
+		
+		w +=2;
+		if ( w == image_width * 2 )
+		{
+			w = 0;
+			h +=2;
+		}
+	}
+	return FOUR_TWO_TWO;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torbut16_5097_Low
+ *  Description:  Display Data on screen directly 
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torbut16_5097_Low(unsigned char * input_ptr, unsigned char * source_ptr, 
+		                   unsigned int image_width, unsigned int image_height,short scr_w,
+				   short scr_h)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_ptr = source_ptr + scr_w * m_Posy * 2 + m_Posx * 2;
+	size = image_width * image_height >> 1;
+	unsigned short color;
+	unsigned short *loc;
+	int w = 0;
+	int h = 0;
+	unsigned char temp1,temp2,temp3;
+
+	for ( i = size; i > 0; i-- ) 
+	{
+		Y = CLIP(buff[0]+m_AdjLight);
+		U = buff[1] ;
+		Y1 = CLIP(buff[2]+m_AdjLight);
+		V = buff[3];
+		buff += 4;
+
+		temp1 = (unsigned char)(B_FROMYU(Y,U)*m_FactB+0.5);
+		temp2 = (unsigned char)(G_FROMYUV(Y,U,V)*m_FactG+0.5);
+		temp3 = (unsigned char)(R_FROMYV(Y,V)*m_FactR+0.5);
+		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
+
+		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( ( w + 1 ) << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( ( w + 1 ) << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( w << 1 ) );
+		*loc = color;
+		
+		w +=2;
+		if ( w == image_width * 2 )
+		{
+			w = 0;
+			h +=2;
+		}
+
+
+		temp1 = (unsigned char)(B_FROMYU(Y1,U)*m_FactB+0.5);
+		temp2 = (unsigned char)(G_FROMYUV(Y1,U,V)*m_FactG+0.5);
+		temp3 = (unsigned char)(R_FROMYV(Y1,V)*m_FactR+0.5);
+		color = temp1 + ( temp2<<5 ) + ( temp3<<11 );
+
+		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( ( w + 1 ) << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( ( w + 1 ) << 1 ) );
+		*loc = color;
+		loc  = (unsigned short *)( output_ptr + scr_w * ( ( h + 1 ) << 1 ) + ( w << 1 ) );
+		*loc = color;
+		
+		w +=2;
+		if ( w == image_width * 2 )
+		{
+			w = 0;
+			h +=2;
+		}
+	}
+	return FOUR_TWO_TWO;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torbut16_High
+ *  Description:  Display Data on screen directly 
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torbut16_High(unsigned char * input_ptr, unsigned char * source_ptr, 
+		                   unsigned int image_width, unsigned int image_height,short scr_w,
+				   short scr_h)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_ptr = source_ptr;
+	size = image_width * image_height >> 1;
+	unsigned short color,color1;
+	unsigned short *loc;
+	int w = 0;
+	int h = 0;
+
+	for ( i = size; i > 0; i-- ) 
+	{
+		Y = buff[0];
+		U = buff[1] ;
+		Y1 = buff[2];
+		V = buff[3];
+		buff += 4;
+
+		color  = (B_FROMYU(Y,U)>>3);
+		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + (  ( scr_w - 1 - w ) * ( scr_h << 1 )  + ( h << 1 ) ) ) = color;
+
+		w ++;
+
+		color  = ( B_FROMYU(Y1,U)>>3 );
+		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y1,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + (  ( scr_w - 1 - w ) * ( scr_h << 1 )  + ( h << 1 ) ) ) = color;
+
+		w ++;
+		if ( w == image_width )
+		{
+			w = 0;
+			h ++;
+		}
+	}
+
+	return FOUR_TWO_TWO;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torbut16_High
+ *  Description:  Display Data on screen directly 
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torbut16_5097_High(unsigned char * input_ptr, unsigned char * source_ptr, 
+		                   unsigned int image_width, unsigned int image_height,short scr_w,
+				   short scr_h)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_ptr = source_ptr + scr_w * m_Posy * 2 + m_Posx * 2;
+	size = image_width * image_height >> 1;
+	unsigned short color,color1;
+	unsigned short *loc;
+	int w = 0;
+	int h = 0;
+
+	for ( i = size; i > 0; i-- ) 
+	{
+		Y = buff[0];
+		U = buff[1] ;
+		Y1 = buff[2];
+		V = buff[3];
+		buff += 4;
+
+		color  = (B_FROMYU(Y,U)>>3);
+		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
+
+		w ++;
+
+		color  = ( B_FROMYU(Y1,U)>>3 );
+		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y1,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
+
+		w ++;
+		if ( w == image_width )
+		{
+			w = 0;
+			h ++;
+		}
+	}
+
+	return FOUR_TWO_TWO;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Pyuv422torbut16_High
+ *  Description:  Display Data on screen directly 
+ * =====================================================================================
+ */
+unsigned int Video::Pyuv422torbut16_5097_Super_High(unsigned char * input_ptr, unsigned char * source_ptr, 
+		                   unsigned int image_width, unsigned int image_height,short scr_w,
+				   short scr_h)
+{
+	unsigned int i, size;
+	unsigned char Y, Y1, U, V;
+	unsigned char *buff = input_ptr;
+	unsigned char *output_ptr = source_ptr;
+	size = image_width * image_height >> 1;
+	unsigned short color,color1;
+	unsigned short *loc;
+	int w = 0;
+	int h = 0;
+
+	for ( i = size; i > 0; i-- )
+	{
+		Y = buff[0];
+		U = buff[1] ;
+		Y1 = buff[2];
+		V = buff[3];
+		buff += 4;
+
+		color  = (B_FROMYU(Y,U)>>3);
+		color += ((G_FROMYUV(Y,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
+
+		w ++;
+
+		color  = ( B_FROMYU(Y1,U)>>3 );
+		color += ((G_FROMYUV(Y1,U,V)>>2)<<5);
+		color += ((R_FROMYV(Y1,V)>>3)<<11);
+
+		*(unsigned short *)( output_ptr + scr_w * ( h << 1 ) + ( w << 1 ) ) = color;
+
+		w ++;
+		if ( w == image_width )
+		{
+			w = 0;
+			h ++;
+		}
+	}
+
+	return FOUR_TWO_TWO;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  RGB_Functions
+ *  Description:  RGB_Functions sets
+ *
+ *  R = Y + 1.403V'
+ *  G = Y - 0.344U' - 0.714V'
+ *  B = Y + 1.770U'
+ * =====================================================================================
+ */
+unsigned char Video::R_FROMYV(unsigned char y, unsigned char v)
+{
+	return CLIP(y + LutRv[v]);
+}
+
+unsigned char Video::G_FROMYUV(unsigned char y, unsigned char u, unsigned char v)
+{
+	return CLIP(y + LutGu[u] + LutGv[v]);
+}
+
+unsigned char Video::B_FROMYU(unsigned char y, unsigned char u)
+{
+	return CLIP(y + LutBu[u]);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Pic
+ *  Description:  Sample picture 
+ * =====================================================================================
+ */
+void Video::Sample_Pic()
+{
+	for ( int i=0;i<2;i++ )
+	{
+		uvcGrab(videoIn);
+	}
+	get_pictureYV2(videoIn->framebuffer,videoIn->width,videoIn->height);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Pic
+ *  Description:  Sample picture 
+ * =====================================================================================
+ */
+void Video::Sample_Pic2(unsigned char* pic)
+{
+	if ( uvcGrab(videoIn) != -1 )
+		fill_bufYV2((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Pic
+ *  Description:  Sample picture 
+ * =====================================================================================
+ */
+void Video::Sample_Pic3(unsigned char* pic,short scr_w,short scr_h)
+{
+	if ( uvcGrab(videoIn) != -1 )
+	{
+		if 	( videoIn->width == 160 && videoIn->height == 120 )
+			Pyuv422torbut16_Low((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
+		else if ( videoIn->width == 320 && videoIn->height == 240 )
+			Pyuv422torbut16_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
+	}
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Pic4
+ *  Description:  Smart5097 Used Function 
+ * =====================================================================================
+ */
+void Video::Sample_Pic4(unsigned char* pic,short scr_w,short scr_h)
+{
+	if ( uvcGrab(videoIn) != -1 )
+	{
+		if 	( videoIn->width == 160 && videoIn->height == 120 )
+			Pyuv422torbut16_5097_Low((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
+		else if ( videoIn->width == 320 && videoIn->height == 240 )
+			Pyuv422torbut16_5097_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
+		else if ( videoIn->width == 640 && videoIn->height == 480 )
+			Pyuv422torbut16_5097_Super_High((unsigned char *)videoIn->mem[videoIn->buf.index],pic,videoIn->width,videoIn->height,scr_w,scr_h);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Adjust_Light
+ *  Description:  flag == false more light 
+ *                flag == true more dark
+ * =====================================================================================
+ */
+void Video::Adjust_Light(bool flag)
+{
+	if ( flag == false )
+		m_AdjLight ++;
+	else
+		m_AdjLight --;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Video_Info
+ *  Description:  Show Video Infomation 
+ * =====================================================================================
+ */
+void Video::Show_Video_Info()
+{
+	struct vdIn	*vd = videoIn;
+	memset(&vd->fmt, 0, sizeof(struct v4l2_format));
+	vd->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (ioctl(vd->fd, VIDIOC_G_FMT, &vd->fmt) < 0)
+	{
+		printf("get format failed\n");
+	}
+	else
+	{
+		printf("Video Width = %d\n", vd->fmt.fmt.pix.width);
+		printf("Video Height = %d\n", vd->fmt.fmt.pix.height);
+	 	unsigned char F1,F2,F3,F4;	
+		F1 = vd->fmt.fmt.pix.pixelformat & 0xff;
+		F2 = ( vd->fmt.fmt.pix.pixelformat >> 8 ) & 0xff;
+		F3 = ( vd->fmt.fmt.pix.pixelformat >> 16 ) & 0xff;
+		F4 = ( vd->fmt.fmt.pix.pixelformat >> 24 ) & 0xff;
+		printf ( "Video Format = %c%c%c%c\n",F1,F2,F3,F4 );
+	}
+
+//	v4l2_std_id id;
+//	int ret;
+//	int add=0;
+//	do{
+//		ret = ioctl(vd->fd,VIDIOC_QUERYSTD,&id);
+//		add ++;
+//	}while( ret == -1 && add < 1000 );
+//
+//	if ( add >= 999 )
+//	{
+//		printf ( "can't get value\n" );
+//	}
+//
+//	if 	( id == V4L2_STD_NTSC )
+//	{
+//		printf ( "Video std = ntsc \n" );
+//	}
+//	else if ( id == V4L2_STD_PAL )
+//	{
+//		printf ( "Video std = pal \n" );
+//	}
+//	else
+//	{
+//		printf ( "no found std\n" );
+//	}
+
+
+//	struct v4l2_fmtdesc* argp;
+//	memset(argp, 0, sizeof(struct v4l2_fmtdesc));
+//	if (ioctl(vd->fd, VIDIOC_ENUM_FMT, argp) < 0)
+//	{
+//		printf ( "%d\n",argp->type );
+//	}
+}
diff --git a/src/EVA11/base/Video.h b/src/EVA11/base/Video.h
new file mode 100644
index 0000000..e992c0e
--- /dev/null
+++ b/src/EVA11/base/Video.h
@@ -0,0 +1,98 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  Video.h
+ *
+ *    Description:  Manage USB port camera class
+ *
+ *        Version:  1.0
+ *        Created:  2011年12月05日 20时14分48秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  Eddysun Xiamen
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _VIDEO_INC
+#define  _VIDEO_INC
+
+#include	"VideoHead.h"
+
+class Video
+{
+	public:
+		Video();
+		~Video();
+		bool Init_Video(int width,int height);
+		void Release_Video();
+		void Sample_Pic();
+		void Sample_Pic2(unsigned char*);
+		void Sample_Pic3(unsigned char*,short scr_w,short scr_h);
+		void Sample_Pic4(unsigned char*,short scr_w,short scr_h);
+		void Adjust_Light(bool);
+
+		void Set_Output_Pos(const int& x,const int& y); 
+	private:
+		int init_videoIn(struct vdIn *vd, char *device, 
+				int width, int height, int fps,
+			        int format, int grabmethod, char *avifilename);
+		int init_v4l2(struct vdIn *vd);
+		int close_v4l2(struct vdIn *vd);
+		void initLut(void);
+		void freeLut(void);
+		int video_disable(struct vdIn *vd);
+		int video_enable(struct vdIn *vd);
+		int uvcGrab(struct vdIn *vd);
+		int get_pictureYV2(unsigned char *buf,int width,int height);
+		int fill_bufYV2(unsigned char *buf,unsigned char *pic,int width,int height);
+		void getPictureName (char *Picture, int fmt);
+		unsigned char R_FROMYV(unsigned char y, unsigned char v);
+		unsigned char G_FROMYUV(unsigned char y,unsigned char u ,unsigned char v);
+		unsigned char B_FROMYU(unsigned char y, unsigned char u);
+		unsigned int  Pyuv422torgb24(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height);
+
+		unsigned int  Pyuv422torbut16_Low(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
+		unsigned int  Pyuv422torbut16_High(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
+
+		unsigned int  Pyuv422torbut16_5097_Super_High(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
+		unsigned int  Pyuv422torbut16_5097_High(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
+		unsigned int  Pyuv422torbut16_5097_Low(unsigned char * input_ptr, unsigned char * output_ptr, 
+			       unsigned int image_width, unsigned int image_height,short scr_w,short scr_h);
+
+		void Show_Video_Info();
+	private:
+#ifdef ARM9
+		constexpr static double	m_FactR = static_cast<double>(31) / static_cast<double>(255);
+		constexpr static double	m_FactG = static_cast<double>(63) / static_cast<double>(255);
+		constexpr static double	m_FactB = static_cast<double>(31) / static_cast<double>(255);
+#endif
+
+#ifdef X86 
+		const static double	m_FactR = 31. / 255.;
+		const static double	m_FactG = 63. / 255.;
+		const static double	m_FactB = 31. / 255.;
+#endif
+
+		int		m_Width;
+		int		m_Height;
+		int 		*LutRv ;
+		int 		*LutGu ;
+		int 		*LutGv ;
+		int		*LutBu ;
+		struct vdIn	*videoIn;
+		v4l2_buffer     t_buf;
+		v4l2_buffer 	q_buf;
+		unsigned char	m_AdjLight;
+
+		int		m_Posx;
+		int		m_Posy;
+};
+#endif   /* ----- #ifndef _VIDEO_INC  ----- */
diff --git a/src/EVA11/base/VideoHead.h b/src/EVA11/base/VideoHead.h
new file mode 100644
index 0000000..e413877
--- /dev/null
+++ b/src/EVA11/base/VideoHead.h
@@ -0,0 +1,205 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  VideoHead.h
+ *
+ *    Description:  Video class used head file
+ *
+ *        Version:  1.0
+ *        Created:  2011年12月05日 20时42分28秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  kevin.wang (), kevin.wang2004@gmail.com
+ *        Company:  Eddysun Xiamen
+ *
+ * =====================================================================================
+ */
+#ifndef  _VIDEOHEAD_INC
+#define  _VIDEOHEAD_INC
+
+#include 	<cstdio>
+#include	<cstdlib>
+#include 	<string.h>
+#include 	<fcntl.h>
+#include 	<unistd.h>
+#include 	<errno.h>
+#include 	<sys/ioctl.h>
+#include 	<sys/mman.h>
+#include 	<sys/select.h>
+#include 	<linux/videodev2.h>
+
+#define NB_BUFFER 	    	4//4
+#define AVI_MAX_TRACKS  	2
+
+#define uint32_t 		unsigned int 
+#define uint8_t  		unsigned char 
+#define uint16_t 		unsigned short
+#define uint64_t 		unsigned long long
+
+typedef struct
+{
+	off_t key;
+	off_t pos;
+	off_t len;
+} video_index_entry;
+
+typedef struct
+{
+	off_t pos;
+	off_t len;
+	off_t tot;
+} audio_index_entry;
+
+typedef struct track_s
+{
+	long   a_fmt;             /* Audio format, see #defines below */
+	long   a_chans;           /* Audio channels, 0 for no audio */
+	long   a_rate;            /* Rate in Hz */
+	long   a_bits;            /* bits per audio sample */
+	long   mp3rate;           /* mp3 bitrate kbs*/
+	long   audio_strn;        /* Audio stream number */
+	off_t  audio_bytes;       /* Total number of bytes of audio data */
+	long   audio_chunks;      /* Chunks of audio data in the file */
+	char   audio_tag[4];      /* Tag of audio data */
+	long   audio_posc;        /* Audio position: chunk */
+	long   audio_posb;        /* Audio position: byte within chunk */
+	off_t a_codech_off;       /* absolut offset of audio codec information */ 
+	off_t a_codecf_off;       /* absolut offset of audio codec information */ 
+	audio_index_entry *audio_index;
+} track_t;
+
+typedef struct
+{
+	uint32_t	bi_size;
+	uint32_t  bi_width;
+	uint32_t  bi_height;
+	uint16_t  bi_planes;
+	uint16_t  bi_bit_count;
+	uint32_t  bi_compression;
+	uint32_t  bi_size_image;
+	uint32_t  bi_x_pels_per_meter;
+	uint32_t  bi_y_pels_per_meter;
+	uint32_t  bi_clr_used;
+	uint32_t  bi_clr_important;
+} BITMAPINFOHEADER_avilib;
+
+typedef struct
+{
+	uint16_t  w_format_tag;
+	uint16_t  n_channels;
+	uint32_t  n_samples_per_sec;
+	uint32_t  n_avg_bytes_per_sec;
+	uint16_t  n_block_align;
+	uint16_t  w_bits_per_sample;
+	uint16_t  cb_size;
+} WAVEFORMATEX_avilib;
+
+typedef struct
+{
+	uint32_t fcc_type; 
+	uint32_t fcc_handler; 
+	uint32_t dw_flags; 
+	uint32_t dw_caps; 
+	uint16_t w_priority;
+	uint16_t w_language;
+	uint32_t dw_scale;
+	uint32_t dw_rate;
+	uint32_t dw_start;
+	uint32_t dw_length;
+	uint32_t dw_initial_frames;
+	uint32_t dw_suggested_buffer_size;
+	uint32_t dw_quality;
+	uint32_t dw_sample_size;
+	uint32_t dw_left;
+	uint32_t dw_top;
+	uint32_t dw_right;
+	uint32_t dw_bottom;
+	uint32_t dw_edit_count;
+	uint32_t dw_format_change_count;
+	char     sz_name[64];
+} AVISTREAMINFO;
+
+typedef struct
+{
+	long   fdes;              /* File descriptor of AVI file */
+	long   mode;              /* 0 for reading, 1 for writing */
+
+	long   width;             /* Width  of a video frame */
+	long   height;            /* Height of a video frame */
+	double fps;               /* Frames per second */
+	char   compressor[8];     /* Type of compressor, 4 bytes + padding for 0 byte */
+	char   compressor2[8];     /* Type of compressor, 4 bytes + padding for 0 byte */
+	long   video_strn;        /* Video stream number */
+	long   video_frames;      /* Number of video frames */
+	char   video_tag[4];      /* Tag of video data */
+	long   video_pos;         /* Number of next frame to be read
+			       (if index present) */
+
+	unsigned long max_len;    /* maximum video chunk present */
+
+	track_t track[AVI_MAX_TRACKS];  // up to AVI_MAX_TRACKS audio tracks supported
+
+	off_t pos;        /* position in file */
+	long   n_idx;             /* number of index entries actually filled */
+	long   max_idx;           /* number of index entries actually allocated */
+
+	off_t v_codech_off;       /* absolut offset of video codec (strh) info */ 
+	off_t v_codecf_off;       /* absolut offset of video codec (strf) info */ 
+
+	unsigned char (*idx)[16]; /* index entries (AVI idx1 tag) */
+	video_index_entry *video_index;
+
+	off_t last_pos;          /* Position of last frame written */
+	unsigned long last_len;          /* Length of last frame written */
+	int must_use_index;              /* Flag if frames are duplicated */
+	off_t movi_start;
+
+	int anum;            // total number of audio tracks 
+	int aptr;            // current audio working track 
+
+	BITMAPINFOHEADER_avilib *bitmap_info_header;
+	WAVEFORMATEX_avilib *wave_format_ex[AVI_MAX_TRACKS];
+} avi_t;
+
+struct vdIn {
+	int fd;
+	char *videodevice;
+	char *status;
+	char *pictName;
+	struct v4l2_capability cap;
+	struct v4l2_format fmt;
+	struct v4l2_buffer buf;
+	struct v4l2_requestbuffers rb;
+	void *mem[NB_BUFFER];
+	int mapbuflength[NB_BUFFER];
+	unsigned char *framebuffer;
+	int isstreaming;
+	int grabmethod;
+	int width;
+	int height;
+	int fps;
+	int formatIn;
+	int formatOut;
+	int framesizeIn;
+	int signalquit;
+	int toggleAvi;
+	int getPict;
+	int rawFrameCapture;
+	/* raw frame capture */
+	unsigned int fileCounter;
+	/* raw frame stream capture */
+	unsigned int rfsFramesWritten;
+	unsigned int rfsBytesWritten;
+	/* raw stream capture */
+	FILE *captureFile;
+	unsigned int framesWritten;
+	unsigned int bytesWritten;
+	avi_t *avifile;
+	char *avifilename;
+	int framecount;
+	int recordstart;
+	int recordtime;
+};
+#endif   /* ----- #ifndef videohead_INC  ----- */
+
diff --git a/src/EVA11/base/VideoPanel.cpp b/src/EVA11/base/VideoPanel.cpp
new file mode 100644
index 0000000..bbc35ed
--- /dev/null
+++ b/src/EVA11/base/VideoPanel.cpp
@@ -0,0 +1,283 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  VideoPanel.cpp
+ *
+ *    Description:  implementation of VideoPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月19日 10时57分49秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Video.h"
+#include 	"Msgbox.h"
+#include 	"Algorithm.h"
+
+#include 	"Object.h"
+#include 	"BasePanel.h"
+#include 	"VideoPanel.h"
+
+#include 	"FreeType.h"
+
+VideoPanel::VideoPanel (int x,int y,int width,int heigh)
+	: BasePanel(x,y,width,heigh)
+{
+}
+
+VideoPanel::~VideoPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI screen object 
+ * =====================================================================================
+ */
+void VideoPanel::Init_GUI(Graphic& g)
+{
+	m_pVideo                = new Video;
+
+	m_VideoX                = 100;
+	m_VideoY                = 109;
+
+	m_pVideo->Set_Output_Pos(m_VideoX,m_VideoY);
+
+	m_VideoW                = 320;
+	m_VideoH                = 240;
+
+	m_Status                = 0;
+	resolution_x            = 160;
+	resolution_y            = 120;
+	
+	m_bVideoEnableFlag      = false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI object 
+ * =====================================================================================
+ */
+void VideoPanel::Destroy_GUI()
+{
+	if ( m_bVideoEnableFlag == true )
+	{
+		m_pVideo->Release_Video();
+	}
+	delete m_pVideo;
+	m_pVideo = NULL;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Only Drawme on screen 
+ * =====================================================================================
+ */
+void VideoPanel::Drawme(Graphic& g,bool flag)
+{
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,g.RGB24_16(0x000000));
+	DrawColorbar(g);
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawColorbar
+ *  Description:  
+ * =====================================================================================
+ */
+void VideoPanel::DrawColorbar(Graphic& g)
+{
+	int step = (m_VideoW >> 3);
+	g.DrawFillRect(m_VideoX,m_VideoY,step,m_VideoH,g.RGB24_16(0xff0000));
+	g.DrawFillRect(m_VideoX+step,m_VideoY,step,m_VideoH,g.RGB24_16(0xff00ff));
+	g.DrawFillRect(m_VideoX+2*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x0000ff));
+	g.DrawFillRect(m_VideoX+3*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x00ffff));
+	g.DrawFillRect(m_VideoX+4*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x00ff00));
+	g.DrawFillRect(m_VideoX+5*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0xffff00));
+	g.DrawFillRect(m_VideoX+6*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0x000000));
+	g.DrawFillRect(m_VideoX+7*step+1,m_VideoY,step,m_VideoH,g.RGB24_16(0xffffff));
+}
+		
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Status
+ *  Description:  Set the video status
+ * =====================================================================================
+ */
+void VideoPanel::Set_Status(int status)
+{
+	if 	( status == 0 )
+	{
+		resolution_x = 160;
+		resolution_y = 120;
+	}
+	else if ( status == 1 )
+	{
+		resolution_x = 320;
+		resolution_y = 240;
+	}
+	else if ( status == 2 )
+	{
+		resolution_x = 640;
+		resolution_y = 480;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Video
+ *  Description:  Init the video device when enter the loop
+ * =====================================================================================
+ */
+void VideoPanel::Init_Video(Graphic& g)
+{
+	if 	( m_bVideoEnableFlag == false )
+	{
+		if 	( m_pVideo->Init_Video(resolution_x,resolution_y) == true )
+		{
+			m_bVideoEnableFlag = true;
+		}
+		else
+		{
+			Language *pl = Language::Instance();
+			Msgbox *ms = new Msgbox(200,170,260,80,pl->GetText(INFORMESG22),Msgbox::MSG_OK);
+			ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+			ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+			ms->Showme(g);
+			delete ms;
+			ms = NULL;
+		}
+	}
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  
+ * =====================================================================================
+ */
+int VideoPanel::Loop_Panel(Graphic& g)
+{
+	if 	( g.Get_bpp() == 8 )
+		return 0;
+
+	if 	( m_bVideoEnableFlag == true )
+	{
+		m_pVideo->Sample_Pic4(g.Get_Screen_Ptr(),640,480);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void VideoPanel::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_FX_Fun
+ *  Description:  Key Function process 
+ * =====================================================================================
+ */
+int VideoPanel::Key_F2_Fun(Graphic& g)
+{
+}
+int VideoPanel::Key_F3_Fun(Graphic& g)
+{
+}
+int VideoPanel::Key_F4_Fun(Graphic& g)
+{
+}
+int VideoPanel::Key_F6_Fun(Graphic& g)
+{
+}
+int VideoPanel::Key_NL1_Fun(Graphic& g,int sub)
+{
+	if 	( m_bVideoEnableFlag == false )
+		Init_Video(g);
+}
+int VideoPanel::Key_NR1_Fun(Graphic& g,int sub)
+{
+	if 	( m_bVideoEnableFlag == false )
+		Init_Video(g);
+}
+int VideoPanel::Key_NL2_Fun(Graphic& g,int sub)
+{
+	if 	( m_bVideoEnableFlag == true )
+	{
+		m_pVideo->Release_Video();
+		m_bVideoEnableFlag = false;
+		g.DrawFillRect(m_VideoX,m_VideoY,m_VideoW,m_VideoH+1,g.RGB24_16(0x000000));
+		DrawColorbar(g);
+	}
+}
+int VideoPanel::Key_NR2_Fun(Graphic& g,int sub)
+{
+	if 	( m_bVideoEnableFlag == true )
+	{
+		m_pVideo->Release_Video();
+		m_bVideoEnableFlag = false;
+		g.DrawFillRect(m_VideoX,m_VideoY,m_VideoW,m_VideoH+1,g.RGB24_16(0x000000));
+		DrawColorbar(g);
+	}
+}
+int VideoPanel::Key_NL3_Fun(Graphic& g,int sub)
+{
+	if ( m_bVideoEnableFlag == true )
+	{
+		if ( m_Status == 0 )
+			m_Status = 1;
+		else
+			m_Status --;
+
+		Set_Status(m_Status);
+		m_pVideo->Release_Video();
+		m_bVideoEnableFlag = false;
+		Init_Video(g);
+	}
+}
+int VideoPanel::Key_NR3_Fun(Graphic& g,int sub)
+{
+	if ( m_bVideoEnableFlag == true )
+	{
+		if ( m_Status == 1 )
+			m_Status = 0;
+		else
+			m_Status ++;
+
+		Set_Status(m_Status);
+		m_pVideo->Release_Video();
+		m_bVideoEnableFlag = false;
+		Init_Video(g);
+	}
+}
diff --git a/src/EVA11/base/VideoPanel.h b/src/EVA11/base/VideoPanel.h
new file mode 100644
index 0000000..ac99e26
--- /dev/null
+++ b/src/EVA11/base/VideoPanel.h
@@ -0,0 +1,71 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  VideoPanel.h
+ *
+ *    Description:  only display vieo
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月19日 10时55分42秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _VIDEOPANEL_INC
+#define  _VIDEOPANEL_INC
+
+class BasePanel;
+class Video;
+class VideoPanel : public BasePanel
+{
+	public:
+		VideoPanel (int x,int y,int width,int heigh);
+		~VideoPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+
+		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+
+		void Init_Video(Graphic& g);
+		void Set_Status(int);
+
+	protected:
+
+		void DrawColorbar(Graphic& g);
+
+	private:
+		Video			*m_pVideo;
+
+		int			m_VideoX;
+		int			m_VideoY;
+		int			m_VideoW;
+		int			m_VideoH;
+
+		bool			m_bVideoEnableFlag;
+
+		int			m_Status;                 /* 0:low   1:high   2:super high */
+		int 			resolution_x;
+                int                	resolution_y;
+};
+
+#endif
diff --git a/src/EVA11/base/ZKPanel.cpp b/src/EVA11/base/ZKPanel.cpp
new file mode 100644
index 0000000..8e6bea7
--- /dev/null
+++ b/src/EVA11/base/ZKPanel.cpp
@@ -0,0 +1,941 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ZKPanel.cpp
+ *
+ *    Description:  implementation of ZKPanel class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月23日 20时01分10秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#include 	<new>
+
+#include 	"Object.h"
+#include 	"IDataProcess.h"
+#include 	"ConcreteDataProcess.h"
+#include 	"Language.h"
+#include 	"Graphic.h"
+#include 	"Global.h"
+#include 	"Bufferbar.h"
+#include 	"Device.h"
+#include 	"DataRepo.h"
+#include 	"Label.h"
+#include 	"Chart.h"
+#include 	"Language.h"
+
+#include 	"Msgbox.h"
+
+#include 	"AlarmManage.h"
+#include 	"Basescreen.h"
+#include 	"ZScreen.h"
+#include 	"BasePanel.h"
+#include 	"ZKPanel.h"
+
+#include 	"FreeType.h"
+
+#include 	"Logic.h"
+#include 	"Resource.h"
+
+const static  char* AlarmText[8] = {"A","B","C","D","E","F","G","H"};
+
+ZKPanel::ZKPanel (int x,int y,int width,int heigh)
+	: BasePanel(x,y,width,heigh)
+{
+}
+
+ZKPanel::~ZKPanel ()
+{
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Drawme
+ *  Description:  Draw the GUI on scree
+ * =====================================================================================
+ */
+void ZKPanel::Drawme(Graphic& g,bool flag)
+{
+	DataRepo *datarepo = DataRepo::Instance();
+	if 	( flag == true )
+		g.Switch_Screen();
+	m_Bufbar->Drawme(g,datarepo->Get_Bytes_Of_Buffer(),false);
+
+	Refresh_FREQ(g);
+	Refresh_Signal(g);
+	Swtich_Status(g);
+
+	m_LabFreMsg->Drawme(g,false);
+	m_LabAMPMsg->Drawme(g,false);
+	m_LabPHAMsg->Drawme(g,false);
+	m_LabCHAMsg->Drawme(g,false);
+	m_LabAlarmSt->Drawme(g,false);
+
+	m_Zscreen->Drawme(g,false);
+	m_Chart->Drawme(g,false);
+	m_AlarmManage->Draw_Alarm_Sets(g,false);
+
+	if 	( flag == true )
+	{
+		g.Switch_Screen();
+		g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_GUI
+ *  Description:  Init the GUI object 
+ * =====================================================================================
+ */
+void ZKPanel::Init_GUI(Graphic& g)
+{
+	Global *gp = Global::Instance();
+
+	m_Zscreen = new(std::nothrow) Zscreen(2+130,13+31,400,399);
+	m_Zscreen->Set_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
+
+	m_Zscreen->Set_Color(Zscreen::LA_FG_COLOR,g_BUTXNO_CO);
+	m_Zscreen->Set_Color(Zscreen::LA_BG_COLOR,g_SCBG_CO);
+	m_Zscreen->Set_Color(Zscreen::LA_GRID_COLOR,g_BUBGNO_CO);
+	m_Zscreen->Set_Color(Zscreen::LA_POINT_COLOR,g_SCTX_CO);
+	m_Zscreen->Set_Color(Zscreen::LA_FOCUS_COLOR,g_SCTX_CO);
+	m_Zscreen->Set_ID(1);
+
+	m_Bufbar = new(std::nothrow) Bufferbar(2,2,532,6);
+	m_Bufbar->Set_Color(Bufferbar::BUF_FG_COLOR,g_SCTX_CO);
+	m_Bufbar->Set_Color(Bufferbar::BUF_BG_COLOR,g_BUTXNO_CO);
+	m_Bufbar->Init_Buffer_Bar(g,gp->DataBufLength);
+
+	m_LabFreMsg = new Label(131+265,8,104,18);
+	m_LabFreMsg->Set_Label_Type(Label::LA_THIN);
+	m_LabFreMsg->Set_Font_Size(16);
+	m_LabFreMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_LabFreMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_LabFreMsg->Set_Text(" ");
+
+	m_LabAMPMsg = new Label(131+265,25,104,18);
+	m_LabAMPMsg->Set_Label_Type(Label::LA_THIN);
+	m_LabAMPMsg->Set_Font_Size(16);
+	m_LabAMPMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_LabAMPMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_LabAMPMsg->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	m_LabAMPMsg->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	m_LabAMPMsg->Set_Focus(true);
+	m_LabAMPMsg->Set_Text(" ");
+
+	m_LabPHAMsg = new Label(42+265,25,90,18);
+	m_LabPHAMsg->Set_Label_Type(Label::LA_THIN);
+	m_LabPHAMsg->Set_Font_Size(16);
+	m_LabPHAMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_LabPHAMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_LabPHAMsg->Set_Label_Color(Label::LA_BGFO_COLOR,g_BUBGFO_CO);
+	m_LabPHAMsg->Set_Label_Color(Label::LA_FGFO_COLOR,g_BUTXFO_CO);
+	m_LabPHAMsg->Set_Focus(true);
+	m_LabPHAMsg->Set_Text(" ");
+
+	m_LabCHAMsg = new Label(42+265,8,90,18);
+	m_LabCHAMsg->Set_Label_Type(Label::LA_THIN);
+	m_LabCHAMsg->Set_Font_Size(16);
+	m_LabCHAMsg->Set_Label_Color(Label::LA_FGNO_COLOR,g.RGB24_16(0x000000));
+	m_LabCHAMsg->Set_Label_Color(Label::LA_BGNO_COLOR,g.RGB24_16(0xefe559));
+	m_LabCHAMsg->Set_Display_Type(Label::LA_DT_LEFT);
+	m_LabCHAMsg->Set_Text(" ");
+
+	m_LastStatus = 0xff;
+
+	m_LabAlarmSt = new(std::nothrow) Label(235+265,9,30,32);
+	m_LabAlarmSt->Set_Label_Type(Label::LA_THIN);
+	m_LabAlarmSt->Set_Font_Size(24);
+	m_LabAlarmSt->Set_Text(" ");
+	m_LabAlarmSt->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	m_LabAlarmSt->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+
+	if 	( gp->DrawMode == 0 )
+		m_Zscreen->Set_Draw_Mode(Zscreen::POINT);
+	else if ( gp->DrawMode == 1 )
+		m_Zscreen->Set_Draw_Mode(Zscreen::LINE);
+	else if ( gp->DrawMode == 2 )
+		m_Zscreen->Set_Draw_Mode(Zscreen::AUTO);
+
+	m_DataProcess = new(std::nothrow) ZKDataProcess;
+
+	m_AlarmManage = new(std::nothrow) AlarmManage(2+130,13+31,400,399);
+	m_AlarmManage->Init_Alarm_Sets(g);
+
+	gp->bSNeedResetAlarmArea = true;                    // Notice when init we need let DZK to load alarm para
+	Load_Alarm_Para();
+
+	m_Chart = new(std::nothrow) Chart(2,13+31,130,399);
+	m_Chart->Set_Chart_Direct(Chart::VERTICAL);
+	m_Chart->Set_Coef(m_Heigh);
+
+	m_gp->bSingleSrcPause = false;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Alarm_Para
+ *  Description:  Load Alarm Parameters from Global 
+ *                When Load Para from device call this function
+ * =====================================================================================
+ */
+void ZKPanel::Load_Alarm_Para()
+{
+	Global* gp = Global::Instance();
+	if 	( gp->bSNeedResetAlarmArea == true )
+	{
+		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
+		for ( int i=0;i<3;i++ )
+		{
+			m_AlarmManage->Set_Alarm_Index(i,gp->SAlarmIndex[i]);
+			m_AlarmManage->Set_Alarm_Count(i,gp->SAlarmCount[i]);
+		}
+		m_AlarmManage->Load_Alarm_Para(gp->SAlarmPara);
+
+		m_AlarmManage->Create_Alarm_Area_Mask();
+		gp->bSNeedResetAlarmArea = false;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Destroy_GUI
+ *  Description:  Destroy the GUI Object 
+ * =====================================================================================
+ */
+void ZKPanel::Destroy_GUI()
+{
+	if ( m_Zscreen != NULL )
+	{
+		delete m_Zscreen;
+		m_Zscreen = NULL;
+	}
+	if ( m_LabFreMsg != NULL )
+	{
+		delete m_LabFreMsg;
+		m_LabFreMsg = NULL;
+	}
+	if ( m_LabAMPMsg != NULL )
+	{
+		delete m_LabAMPMsg;
+		m_LabAMPMsg = NULL;
+	}
+	if ( m_LabPHAMsg != NULL )
+	{
+		delete m_LabPHAMsg;
+		m_LabPHAMsg = NULL;
+	}
+	if ( m_LabCHAMsg != NULL )
+	{
+		delete m_LabCHAMsg;
+		m_LabCHAMsg = NULL;
+	}
+
+	if ( m_LabAlarmSt != NULL )
+	{
+		delete m_LabAlarmSt;
+		m_LabAlarmSt = NULL;
+	}
+	if ( m_DataProcess != NULL )
+	{
+		delete m_DataProcess;
+		m_DataProcess = NULL;
+	}
+	if ( m_Bufbar != NULL )
+	{
+		delete m_Bufbar;
+		m_Bufbar = NULL;
+	}
+	if ( m_Chart != NULL )
+	{
+		delete m_Chart;
+		m_Chart = NULL;
+	}
+	m_AlarmManage->Destroy_Alarm_Sets();
+	if ( m_AlarmManage != NULL )
+	{
+		delete m_AlarmManage;
+		m_AlarmManage = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Loop_Panel
+ *  Description:  important function, deal with data
+ * =====================================================================================
+ */
+int ZKPanel::Loop_Panel(Graphic& g)
+{
+	if ( m_gp->bSingleSrcPause == true ) return 0;
+
+	m_DataProcess->Data_Process();
+
+	m_DataProcess->Get_Data(m_RawBuf);
+
+	int x,y;
+	int result;
+
+	m_Zscreen->Draw_ET_Point(g,m_RawBuf[(m_gp->DebugChan<<1)],m_RawBuf[(m_gp->DebugChan<<1)+1]);
+
+//	if ( m_gp->sos == true )
+//	{
+//		printf ( "sos end\n" );
+//		m_gp->sos = false;
+//	}
+
+	m_Zscreen->Get_SX_SY(x,y);
+	result = m_AlarmManage->Is_In_Alarm(x,y);
+
+	switch ( m_gp->TimeScaleDisp )
+	{
+		case 0:
+			{
+				m_Chart->Mapping_Value(g,m_RawBuf[(m_gp->DebugChan<<1)]);
+				for ( int i=0;i<m_gp->TimeScaleSpeed;i++ )
+					m_Chart->Roll_Bar(g);
+
+				if ( m_oldtick != m_gp->Tick )
+				{
+					m_Chart->Set_TimeScale(g);
+					m_oldtick = m_gp->Tick;
+				}
+			}
+			break;
+
+		case 1:
+			{
+				m_Chart->Mapping_Value(g,m_RawBuf[(m_gp->DebugChan<<1)+1]);
+				for ( int i=0;i<m_gp->TimeScaleSpeed;i++ )
+					m_Chart->Roll_Bar(g);
+
+				if ( m_oldtick != m_gp->Tick )
+				{
+					m_Chart->Set_TimeScale(g);
+					m_oldtick = m_gp->Tick;
+				}
+			}
+			break;
+
+		default:
+			break;
+	}				/* -----  end switch  ----- */
+
+	if (  result != 0xff )
+	{
+		if 	( result != m_LastStatus )
+		{
+			m_LabAlarmSt->Set_Text(AlarmText[result]);
+			m_LabAlarmSt->Drawme(g);
+			m_LastStatus = result;
+//			m_gp->AlarmStatus.set(m_LastStatus);
+		}
+	}
+	else
+	{
+		if 	( result != m_LastStatus )
+		{
+//			m_gp->AlarmStatus.reset(m_LastStatus);
+			m_LabAlarmSt->Set_Text(" ");
+			m_LabAlarmSt->Drawme(g);
+			m_LastStatus = result;
+		}
+	}
+
+	m_Bufbar->Save_Bytes_Number(g,1<<2);
+
+	return 0;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Show_Help_System
+ *  Description:  Show the help message
+ * =====================================================================================
+ */
+void ZKPanel::Show_Help_System(Graphic& g,int x,int y)
+{
+	short bgcolor = g_BUBGNO_CO,fgcolor    = g_BUTXNO_CO;
+	Language  *pl = Language::Instance();
+
+	FreeType *font = FreeType::Instance();
+	font->Set_Color(FreeType::FGCOLOR,fgcolor);
+	font->Set_Color(FreeType::BGCOLOR,bgcolor);
+	font->Set_Font_Size(16);
+	font->Set_Transparce(true);
+
+	font->Text(x+34,y+30,pl->GetText(HELPTITLE1));
+	font->Text(x+20,y+45,pl->GetText(HELPTITLE2));
+	font->Text(x+30,y+70,pl->GetText(HELPB1F1));
+	font->Text(x+30,y+90,pl->GetText(HELPB1F2));
+	font->Text(x+30,y+110,pl->GetText(HELPB1F3));
+	font->Text(x+30,y+130,pl->GetText(HELPB1F4));
+	font->Text(x+30,y+150,pl->GetText(HELPB1F5));
+	font->Text(x+30,y+170,pl->GetText(HELPB1F6));
+	font->Text(x+30,y+190,pl->GetText(HELPB1F7));
+	font->Text(x+30,y+210,pl->GetText(HELPB1ESC));
+	font->Text(x+30,y+230,pl->GetText(HELPB1ENTER));
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_ZKScreen
+ *  Description:  Clean the ZKScreen 
+ * =====================================================================================
+ */
+void ZKPanel::Clean_ZKScreen(Graphic& g)
+{
+	m_LabFreMsg->Drawme(g,true);
+	m_LabCHAMsg->Drawme(g,true);
+	m_LabAlarmSt->Drawme(g,true);
+
+	m_LabAMPMsg->Set_Text(" ");
+	m_LabPHAMsg->Set_Text(" ");
+	m_LabAMPMsg->Drawme(g,true);
+	m_LabPHAMsg->Drawme(g,true);
+
+	m_Zscreen->Drawme(g,true);
+	m_AlarmManage->Draw_Alarm_Sets(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Key_FX_Fun
+ *  Description:  Shot Functions 
+ * =====================================================================================
+ */
+int ZKPanel::Key_F2_Fun(Graphic& g)
+{
+	if 	( m_gp->bSingleSrcPause == false )
+		Clean_ZKScreen(g);
+	else
+	{
+		Language *m_pl = Language::Instance();
+		Msgbox *ms = new Msgbox(200,170,260,100,m_pl->GetText(CLEANPHOTO),Msgbox::MSG_OKCANCEL);	
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+		ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+		if ( ms->Showme(g) == true )
+		{
+			delete ms;
+			ms = NULL;
+			m_Zscreen->Clean_Photo();
+			m_Zscreen->Drawme(g);
+			return 0; 
+		}
+		delete ms;
+		ms = NULL;
+	}
+}
+int ZKPanel::Key_F3_Fun(Graphic& g)
+{
+	if 	( m_gp->DrawMode == 0 )
+	{
+		m_gp->DrawMode = 1;
+		m_Zscreen->Set_Draw_Mode(Zscreen::LINE);
+	}
+	else if ( m_gp->DrawMode == 1 )
+	{
+		m_gp->DrawMode = 2;
+		m_Zscreen->Set_Draw_Mode(Zscreen::AUTO);
+	}
+	else if ( m_gp->DrawMode == 2 )
+	{
+		m_gp->DrawMode = 0;
+		m_Zscreen->Set_Draw_Mode(Zscreen::POINT);
+	}
+	m_Zscreen->Reset_Trace();
+}
+int ZKPanel::Key_F4_Fun(Graphic& g)
+{
+	if 	( m_gp->bSingleSrcPause == false )
+	{
+		m_DataProcess->Trigger_Balacne_Process();
+		m_gp->sos = true;
+	}
+	else
+	{
+		m_Zscreen->Save_Photo(g);
+		m_Zscreen->Drawme(g);
+	}
+}
+int ZKPanel::Key_F6_Fun(Graphic& g)
+{
+	Language* m_pl = Language::Instance();
+	Msgbox *ms = new Msgbox(200,170,260,80,m_pl->GetText(CLEANBUF),Msgbox::MSG_OKCANCEL);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_BG,g_BUBGNO_CO);
+	ms->Set_Color(Msgbox::MSG_COLORTYPE_FG,g_BUTXNO_CO);
+	if ( ms->Showme(g) == false )
+	{
+		delete ms;
+		ms = NULL;
+		return 0;
+	}
+	delete ms;
+	ms = NULL;
+	m_Bufbar->Clean_Buffer_Bar(g);
+}
+
+int ZKPanel::Key_NL1_Fun(Graphic& g,int sub)
+{
+	Refresh_Signal(g);
+	Refresh_FREQ(g);
+	m_LabCHAMsg->Drawme(g,true);
+	m_LabFreMsg->Drawme(g,true);
+}
+int ZKPanel::Key_NR1_Fun(Graphic& g,int sub)
+{
+	Refresh_Signal(g);
+	Refresh_FREQ(g);
+	m_LabCHAMsg->Drawme(g,true);
+	m_LabFreMsg->Drawme(g,true);
+}
+int ZKPanel::Key_NL2_Fun(Graphic& g,int sub)         // gain
+{
+	m_gp->bSingleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
+	Refresh_AMP_PHA(g);
+}
+int ZKPanel::Key_NR2_Fun(Graphic& g,int sub)         // gain
+{
+	m_gp->bSingleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
+	Refresh_AMP_PHA(g);
+}
+int ZKPanel::Key_NL3_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bSingleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
+	Refresh_AMP_PHA(g);
+}
+int ZKPanel::Key_NR3_Fun(Graphic& g,int sub)         // degree
+{
+	m_gp->bSingleSrcPause = true;
+	Swtich_Status(g);
+	m_Zscreen->Set_Gain_Degree_ReDraw(g,0);
+	Refresh_AMP_PHA(g);
+}
+int ZKPanel::Key_NL4_Fun(Graphic& g,int sub)
+{
+	Refresh_FREQ(g);
+	m_LabFreMsg->Drawme(g,true);
+}
+int ZKPanel::Key_NR4_Fun(Graphic& g,int sub)
+{
+	Refresh_FREQ(g);
+	m_LabFreMsg->Drawme(g,true);
+}
+
+int ZKPanel::Key_Enter_Fun(Graphic& g)
+{
+	m_gp->bSingleSrcPause = false;
+	Swtich_Status(g);
+
+	m_LabFreMsg->Drawme(g,true);
+	m_LabCHAMsg->Drawme(g,true);
+	m_LabAlarmSt->Drawme(g,true);
+
+	m_LabAMPMsg->Set_Text(" ");
+	m_LabPHAMsg->Set_Text(" ");
+	m_LabAMPMsg->Drawme(g,true);
+	m_LabPHAMsg->Drawme(g,true);
+
+	m_Zscreen->Drawme(g,true);
+	m_AlarmManage->Draw_Alarm_Sets(g,true);
+}
+
+/* --------------------------------------------------------------------- */
+/* --TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT-- */
+/* --------------------------------------------------------------------- */
+
+int ZKPanel::Alarm_NL1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->SAlarmType == 0  ) gp->SAlarmType = 3;
+		else gp->SAlarmType --;
+		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->SAlarmType == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->SAlarmIndex[gp->SAlarmType] == 0 )
+				gp->SAlarmIndex[gp->SAlarmType] = gp->SAlarmCount[gp->SAlarmType];
+			else
+				gp->SAlarmIndex[gp->SAlarmType] -= 1; 
+		}
+		m_AlarmManage->Set_Alarm_Index(gp->SAlarmType,gp->SAlarmIndex[gp->SAlarmType]);
+	}
+}
+int ZKPanel::Alarm_NR1_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->SAlarmType == 3  ) gp->SAlarmType = 0;
+		else gp->SAlarmType ++;
+		m_AlarmManage->Set_Alarm_Type(gp->SAlarmType);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		if ( gp->SAlarmType == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->SAlarmIndex[gp->SAlarmType] == 7 || 
+					gp->SAlarmIndex[gp->SAlarmType] >= gp->SAlarmCount[gp->SAlarmType] )
+			{
+				gp->SAlarmIndex[gp->SAlarmType] = 0;
+			}
+			else
+				gp->SAlarmIndex[gp->SAlarmType] += 1;
+		}
+		m_AlarmManage->Set_Alarm_Index(gp->SAlarmType,gp->SAlarmIndex[gp->SAlarmType]);
+	}
+}
+int ZKPanel::Alarm_NL2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->SAlarmType == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->SAlarmCount[gp->SAlarmType] == 0 )
+				gp->SAlarmCount[gp->SAlarmType] = 7;
+			else
+			{
+				gp->SAlarmCount[gp->SAlarmType] --;
+				if ( gp->SAlarmCount[gp->SAlarmType] < gp->SAlarmIndex[gp->SAlarmType] )
+				{
+					gp->SAlarmIndex[gp->SAlarmType] = gp->SAlarmCount[gp->SAlarmType];
+				}
+			}
+			m_AlarmManage->Set_Alarm_Count(gp->SAlarmType,gp->SAlarmCount[gp->SAlarmType]);
+		}
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P1(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NR2_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->SAlarmType == 3 )
+			return 0;
+		else
+		{
+			if 	( gp->SAlarmCount[gp->SAlarmType] == 7 )
+				gp->SAlarmCount[gp->SAlarmType] = 0;
+			else
+				gp->SAlarmCount[gp->SAlarmType] ++;
+			m_AlarmManage->Set_Alarm_Count(gp->SAlarmType,gp->SAlarmCount[gp->SAlarmType]);
+		}
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P1((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NL3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P2(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NR3_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmBeep == true ) gp->AlarmBeep =false;
+		else gp->AlarmBeep =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P2((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NL4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P3(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NR4_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmOutput == true ) gp->AlarmOutput =false;
+		else gp->AlarmOutput =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P3((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NL5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P4(-(m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NR5_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+		if ( gp->AlarmDisplay == true ) gp->AlarmDisplay =false;
+		else gp->AlarmDisplay =true;
+	}
+	else if ( sub == 2 )
+	{
+		m_AlarmManage->Adj_P4((m_gp->MultiKey*2 + 1),gp->SAlarmPara);
+		Drawme(g,true);
+		gp->bSNeedResetAlarmArea = true;
+	}
+}
+int ZKPanel::Alarm_NL6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+	}
+	else if ( sub == 2 )
+	{
+
+	}
+}
+int ZKPanel::Alarm_NR6_Fun(Graphic& g,int sub)
+{
+	Global *gp = Global::Instance();
+	if 	( sub == 1 )
+	{
+	}
+	else if ( sub == 2 )
+	{
+
+	}
+}
+
+int ZKPanel::Para_NL1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen->Adjust_Center_Point(g,Zscreen::LEFT,3);
+		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
+	}
+}
+int ZKPanel::Para_NR1_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen->Adjust_Center_Point(g,Zscreen::RIGHT,3);
+		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
+	}
+}
+int ZKPanel::Para_NL2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen->Adjust_Center_Point(g,Zscreen::UP,3);
+		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
+	}
+}
+int ZKPanel::Para_NR2_Fun(Graphic& g,int sub)
+{
+	if ( sub == 3 )
+	{
+		m_Zscreen->Adjust_Center_Point(g,Zscreen::DOWN,3);
+		m_Zscreen->Get_Center_Point(m_gp->SingleCentX,m_gp->SingleCentY);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Panel
+ *  Description:  Switch panel call this function 
+ * =====================================================================================
+ */
+void ZKPanel::Switch_Panel()
+{
+	Device* device = Device::Instance();
+	device->Write_Para_Func(Device::NORMAL);
+
+	for ( int ch=0;ch<1;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 1;			// ECT
+		device->Write_Para_SignalID(ch,m_gp->ProbeFun[ch],m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int ch=1;ch<Global::CHANCOUNT;ch++ )
+	{
+		m_gp->ProbeFun[ch] = 0;		       // CLOSE
+		device->Write_Para_SignalID(ch,0,m_gp->FreqIndex[ch]+1);
+		device->Write_Para_LowFilter(ch,m_gp->LoFilter[ch]);
+		device->Write_Para_HiFilter(ch,m_gp->HiFilter[ch]);
+		device->Write_Para_HDGain(ch,m_gp->HDGain[ch]);
+	}
+	for ( int i=0;i<Global::FREQCOUNT;i++ )
+	{
+		device->Write_Para_Frequence_Value(i,m_gp->FreqValue[i]);
+	}
+
+	device->Write_Para_Driver(m_gp->Driver);
+	device->Write_Para_Offset(m_gp->Offset);
+	device->Write_Para_SignalWave(0);
+
+	device->Transfer_ECT_Parameters();
+
+	Load_Alarm_Para();
+
+	m_DataProcess->Trigger_Balacne_Process();       // very Important
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Switch_Status
+ *  Description:  When stop the signal switch the system status 
+ * =====================================================================================
+ */
+void ZKPanel::Swtich_Status(Graphic& g)
+{
+	if 	( m_gp->bSingleSrcPause == true )
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,8,5,15);
+	}
+	else
+	{
+		Resource *res = Resource::Instance();
+		res->Show_Resource_Png(g,9,5,15);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_AMP_PHA
+ *  Description:  Display the AMP and PHA value 
+ * =====================================================================================
+ */
+void ZKPanel::Refresh_AMP_PHA(Graphic& g)
+{
+	std::stringstream strtmp;
+	strtmp<<"A:"<<m_Zscreen->Get_AMP();
+	std::string str(strtmp.str());
+	m_LabAMPMsg->Set_Text(str.c_str());
+	m_LabAMPMsg->Drawme(g,true);
+
+	strtmp.clear();
+	strtmp.str("");
+	str.clear();
+
+	strtmp<<"P:"<<m_Zscreen->Get_PHA();
+	str = strtmp.str();
+	m_LabPHAMsg->Set_Text(str.c_str());
+	m_LabPHAMsg->Drawme(g,true);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_FREQ
+ *  Description:  Display Frequence value 
+ * =====================================================================================
+ */
+void ZKPanel::Refresh_FREQ(Graphic& g)
+{
+	char *msg = new char[100];
+
+	Logic *m_lo = Logic::Instance();
+	m_lo->Frequence_2_Char(m_gp->FreqValue[m_gp->FreqIndex[0]],msg);
+	m_LabFreMsg->Set_Text(msg);
+
+	delete[] msg;
+	msg = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refresh_Signal
+ *  Description:  
+ * =====================================================================================
+ */
+void ZKPanel::Refresh_Signal(Graphic& g)
+{
+	char *msg = new char[100];
+
+	if 	( m_gp->ProbeFun[0] == 0 )
+		sprintf(msg," S%d OFF",1);
+	else
+	{
+		Logic *m_lo = Logic::Instance();
+		m_lo->Probe_Fun_2_Char(1,m_gp->ProbeFun[0],m_gp->FreqIndex[0]+1,msg);
+	}
+
+	m_LabCHAMsg->Set_Text(msg);
+	delete[] msg;
+	msg = NULL;
+}
diff --git a/src/EVA11/base/ZKPanel.h b/src/EVA11/base/ZKPanel.h
new file mode 100644
index 0000000..645a348
--- /dev/null
+++ b/src/EVA11/base/ZKPanel.h
@@ -0,0 +1,103 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ZKPanel.h
+ *
+ *    Description:  Just Draw ZKscreen 
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月23日 19时59分06秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ZKPANEL_INC
+#define  _ZKPANEL_INC
+
+class BasePanel;
+class Zscreen;
+class Bufferbar;
+class ZKDataProcess;
+class AlarmManage;
+class Label;
+class Chart;
+
+class ZKPanel : public BasePanel
+{
+	public:
+		ZKPanel (int x,int y,int width,int heigh);
+		~ZKPanel ();
+
+		virtual void Init_GUI(Graphic& g);
+		virtual void Destroy_GUI();
+		virtual void Drawme(Graphic& g,bool flag=true);
+		virtual int  Loop_Panel(Graphic& g);
+
+		virtual	int Key_NL1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR1_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR2_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR3_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NL4_Fun(Graphic& g,int sub=1);
+		virtual	int Key_NR4_Fun(Graphic& g,int sub=1);
+
+		virtual int Key_F2_Fun(Graphic& g);
+		virtual int Key_F3_Fun(Graphic& g);
+		virtual int Key_F4_Fun(Graphic& g);
+		virtual int Key_F6_Fun(Graphic& g);
+
+		virtual int Key_Enter_Fun(Graphic& g);
+
+		virtual int Alarm_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR2_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR3_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR4_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR5_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NL6_Fun(Graphic& g,int sub=1);
+		virtual int Alarm_NR6_Fun(Graphic& g,int sub=1);
+
+		virtual int Para_NL1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR1_Fun(Graphic& g,int sub=1);
+		virtual int Para_NL2_Fun(Graphic& g,int sub=1);
+		virtual int Para_NR2_Fun(Graphic& g,int sub=1);
+
+		virtual void Show_Help_System(Graphic& g,int x,int y);
+		virtual void Switch_Panel();
+	protected:
+
+	private:
+		void Refresh_AMP_PHA(Graphic& g);
+		void Refresh_FREQ(Graphic& g);
+		void Refresh_Signal(Graphic& g);
+		void Swtich_Status(Graphic& g);
+		void Clean_ZKScreen(Graphic& g);
+		void Load_Alarm_Para();
+
+	private:
+		Label*					m_LabAlarmSt;
+
+		Label*					m_LabFreMsg;
+		Label*					m_LabAMPMsg;
+		Label*					m_LabPHAMsg;
+		Label*					m_LabCHAMsg;
+
+		Bufferbar				*m_Bufbar;
+		Zscreen					*m_Zscreen;
+		ZKDataProcess    			*m_DataProcess;
+		AlarmManage				*m_AlarmManage;
+		Chart					*m_Chart;	
+		int					m_LastStatus;
+		int					 m_oldtick;
+};
+#endif   /* ----- #ifndef _ZKPANEL_INC  ----- */
diff --git a/src/EVA11/base/ZScreen.cpp b/src/EVA11/base/ZScreen.cpp
new file mode 100644
index 0000000..36d56f7
--- /dev/null
+++ b/src/EVA11/base/ZScreen.cpp
@@ -0,0 +1,999 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ZScreen.cpp
+ *
+ *    Description:  implementation of ZScreen class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 09时23分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include	<string.h>
+
+#include 	"Object.h"
+#include 	"Label.h"
+#include 	"Graphic.h"
+#include 	"Global.h"
+#include 	"DataRepo.h"
+#include 	"Algorithm.h"
+
+#include 	"Object.h"
+#include 	"Basescreen.h"
+#include 	"ZScreen.h"
+
+#include 	"Language.h"
+#include 	"MixingManage.h"
+
+#include 	"Msgbox.h"
+#include 	"CalculateCenter.h"
+
+Zscreen::Zscreen (int x,int y,int width,int heigh)
+	: Basescreen(x,y,width,heigh)
+	, m_BackCoordinate(GRID) , m_DrawMode(LINE) , m_ID(1)
+{
+	m_Trace                 = NULL;
+	int leng                = (m_Width-2)*(m_Heigh-2);
+	m_Trace                 = new unsigned char[leng];
+	memset(m_Trace,0,leng);
+	m_Data_Ball.databuff    = NULL;
+	m_Data_Ball.databuff    = new ETDATA[DISP_DATA_LENGTH];
+	for ( int i             = 0;i<DISP_DATA_LENGTH;i++ )
+	{
+		m_Data_Ball.databuff[i] = 0;
+	}
+	m_Data_Ball.dataindex   = 0;
+
+	CHAR temp[5];
+	sprintf(temp,"%d",m_ID);
+
+	m_Focus = false;
+
+	m_labID			= new Label(m_X+m_Width-19,m_Y+m_Heigh-23,16,20);
+	m_labID->Set_Text(temp);
+	m_labID->Set_Label_Type(Label::LA_THIN);
+	m_labID->Set_Font_Size(16);
+
+	if ( m_Focus == false )
+	{
+		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	}                                     
+	else                                  
+	{                                     
+		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGFO_CO);
+		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXFO_CO);
+	}
+	m_alg = Algorithm::Instance();
+	
+	m_Photo = NULL;
+}
+
+Zscreen::~Zscreen ()
+{
+	if 	( m_Trace != NULL ) 
+	{
+		delete[] m_Trace;
+		m_Trace = NULL;
+	}
+
+	if 	( m_Data_Ball.databuff != NULL )
+	{
+		delete[] m_Data_Ball.databuff;
+		m_Data_Ball.databuff = NULL;
+	}
+	if ( m_labID != NULL )
+	{
+		delete m_labID;
+		m_labID = NULL;
+	}
+	if ( m_Photo != NULL )
+	{
+		delete[] m_Photo;
+		m_Photo = NULL;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Refreshme
+ *  Description:  Only Draw the Zscreen class GUI object 
+ * =====================================================================================
+ */
+void Zscreen::Refreshme(Graphic& g)
+{
+	COLORTYPE co;
+	co = g.Getcolor();
+	g.Setcolor(m_FGColor);
+	g.DrawFillRect(m_X,m_Y,m_Width,m_Heigh,m_BGColor);
+	if ( m_BackCoordinate == GRID )
+		DrawGrid(g);
+	Draw_Photo(g);
+	m_labID->Drawme(g);
+
+	g.DrawRect(m_X,m_Y,m_Width,m_Heigh);
+	g.DrawRect(m_X+1,m_Y+1,m_Width-2,m_Heigh-2);
+	g.Setcolor(co);
+	Init_Variables();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Back_Coordinate
+ *  Description:  Set the Back Coordinate of screen object  
+ * =====================================================================================
+ */
+void Zscreen::Set_Back_Coordinate(BACKCOOR back)
+{
+	m_BackCoordinate = back;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ID
+ *  Description:  Set the ID of screen 
+ * =====================================================================================
+ */
+void Zscreen::Set_ID(int id)
+{
+	m_ID = id;
+	CHAR temp[5];
+	sprintf(temp,"%d",m_ID);
+	m_labID->Set_Text(temp);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_ET_Point
+ *  Description:  Draw ET pointers to screen
+ * =====================================================================================
+ */
+void Zscreen::Draw_ET_Point(Graphic& g,const int& x,const int& y)
+{
+	switch ( m_DrawMode  )
+	{
+		case POINT: 
+			{
+				if 	( (m_last_p_x != x) && (m_last_p_y != y) )
+				{
+					if ( (m_last_p_x != m_cDPV) && (m_last_p_y != m_cDPV) )
+						DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x ,m_Center_Y+m_Offset_Y+m_last_p_y);
+					m_last_p_x = x;
+					m_last_p_y = y;
+					m_SX = m_Center_X+m_Offset_X+x;
+					m_SY = m_Center_Y+m_Offset_Y+y;
+					DrawFocus(g,m_SX,m_SY);
+				}
+			}
+			break;
+		case LINE:
+			{
+				if 	( m_last_l_x == m_cDPV && m_last_l_y == m_cDPV )
+				{
+					m_SX = m_Center_X+m_Offset_X+x;
+					m_SY = m_Center_Y+m_Offset_Y+y;
+					m_last_l_x = m_SX;
+					m_last_l_y = m_SY;
+				}
+				else
+				{
+					m_SX = m_Center_X+m_Offset_X+x;
+					m_SY = m_Center_Y+m_Offset_Y+y;
+					Draw_Line_In_Arrange(g,m_SX,m_SY,m_last_l_x,m_last_l_y,m_PointColor);
+					m_last_l_x = m_SX;
+					m_last_l_y = m_SY;
+				}
+			}
+			break;
+		case AUTO:
+			{
+				Global *gp = Global::Instance();
+				int MAXi = gp->Auto_Disappear * (  DISP_DATA_LENGTH >> 7  ) ; 
+				int index = m_Data_Ball.dataindex;
+				g.SetMode(Graphic::MODE_SRC_XOR_DST);
+
+				if ( index ==  MAXi )
+				{
+					m_Data_Ball.dataindex = 0;
+					index = 0;
+				}
+
+				if ( index == MAXi - 2 )
+				{
+					Draw_Line_In_Trace(g,
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[MAXi-2],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[MAXi-1],
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[0],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[1],m_PointColor^m_BGColor,false);
+				}
+				else
+				{
+					Draw_Line_In_Trace(g,
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+1],
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index+2],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+3],m_PointColor^m_BGColor,false);
+				}
+
+				m_Data_Ball.databuff[m_Data_Ball.dataindex]   = x;
+				m_Data_Ball.databuff[m_Data_Ball.dataindex+1] = y;
+
+				if ( index == 0 )
+				{
+					Draw_Line_In_Trace(g,
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[MAXi-2],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[MAXi-1],
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[0],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[1],m_PointColor^m_BGColor,true);
+				}
+				else
+				{
+					Draw_Line_In_Trace(g,
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index-2],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index-1],
+							   m_Center_X+m_Offset_X+m_Data_Ball.databuff[index],
+							   m_Center_Y+m_Offset_Y+m_Data_Ball.databuff[index+1],m_PointColor^m_BGColor,true);
+				}
+				m_Data_Ball.dataindex += 2;
+				g.SetMode(Graphic::MODE_SRC);
+
+				m_SX = m_Center_X+m_Offset_X+x;
+				m_SY = m_Center_Y+m_Offset_Y+y;
+			}
+			break;
+		case SPEC:					// only used by OZKPanel
+			{
+				if 	( m_AlarmStatus == true )
+				{
+					if 	( m_LastAlarmStatus == false )
+					{
+						if 	( (m_last_p_x != m_cDPV) && (m_last_p_y != m_cDPV) )
+							DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x,m_Center_Y+m_Offset_Y+m_last_p_y);
+
+						m_last_p_x = m_cDPV;
+						m_last_p_y = m_cDPV;
+
+						m_last_l_x = m_Center_X+m_Offset_X+x;
+						m_last_l_y = m_Center_Y+m_Offset_Y+y;
+					}
+					else
+					{
+						if 	( (m_last_l_x == m_cDPV) && (m_last_l_y == m_cDPV) )
+						{
+							m_last_l_x = m_Center_X+m_Offset_X+x;
+							m_last_l_y = m_Center_Y+m_Offset_Y+y;
+						}
+						else
+						{
+							Draw_Line_In_Trace(g,
+									   m_Center_X+m_Offset_X+x,
+									   m_Center_Y+m_Offset_Y+y,
+									   m_last_l_x, 
+									   m_last_l_y,m_PointColor^m_BGColor,true);
+							m_last_l_x = m_Center_X+m_Offset_X+x;
+							m_last_l_y = m_Center_Y+m_Offset_Y+y;
+						}
+					}
+				}
+				else
+				{
+					if ( m_LastAlarmStatus == false )
+					{
+						if ( m_Decay == 0 )
+						{
+							if ( (m_last_p_x != x) || (m_last_p_y != y) )
+							{
+								if 	((m_last_p_x != m_cDPV) && (m_last_p_x != m_cDPV))
+									DrawFocus(g,m_Center_X+m_Offset_X+m_last_p_x,m_Center_Y+m_Offset_Y+m_last_p_y);
+								m_last_p_x = x;
+								m_last_p_y = y;
+								DrawFocus(g,m_Center_X+m_Offset_X+x,m_Center_Y+m_Offset_Y+y);
+								goto Exit;
+							}
+							else
+								goto Exit;
+						}
+						else
+						{
+							if 	( (m_last_l_x == m_cDPV) && (m_last_l_y == m_cDPV) )
+							{
+								m_last_l_x = m_Center_X + m_Offset_X + x;
+								m_last_l_y = m_Center_Y + m_Offset_Y + y;
+							}
+							else
+							{
+								Draw_Line_In_Trace(g,
+										   m_Center_X+m_Offset_X+x,
+										   m_Center_Y+m_Offset_Y+y,
+										   m_last_l_x, 
+										   m_last_l_y,m_PointColor^m_BGColor,true);
+								m_last_l_x  = m_Center_X+m_Offset_X+x;
+								m_last_l_y  = m_Center_Y+m_Offset_Y+y;
+							}
+							m_Decay --;
+						}
+					}
+					else
+					{
+						Draw_Line_In_Trace(g,
+								   m_Center_X+m_Offset_X+x,
+								   m_Center_Y+m_Offset_Y+y,
+								   m_last_l_x, 
+								   m_last_l_y,m_PointColor^m_BGColor,true);
+
+						m_last_l_x = m_Center_X + m_Offset_X + x;
+						m_last_l_y = m_Center_Y + m_Offset_Y + y;
+						m_Decay    = 480;
+						m_last_p_x = m_cDPV;
+						m_last_p_y = m_cDPV;
+					}
+				}
+Exit:				m_LastAlarmStatus = m_AlarmStatus;
+			}
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  DrawFocus
+ *  Description:  Draw a arrow on screen of grid for each display trace
+ * =====================================================================================
+ */
+void Zscreen::DrawFocus(Graphic &g,const int x,const int y)
+{
+	Graphic::CopyMode save_mode;
+	save_mode = g.GetMode();
+	g.SetMode(Graphic::MODE_SRC_XOR_DST);
+	for (int i=1;i<5;i++)
+	{
+		if ( ((x-i) > m_Left) && ((x-i) < m_Right) && ((y) < m_Down) && ((y) > m_Up) ) 
+			g.Setpixel(x-i,y,m_FGColor);
+		if ( ((x+i) > m_Left) && ((x+i) < m_Right) && ((y) < m_Down) && ((y) > m_Up) ) 
+			g.Setpixel(x+i,y,m_FGColor);
+		if ( ((x) > m_Left) && ((x) < m_Right) && ((y+i) < m_Down) && ((y+i) > m_Up) ) 
+			g.Setpixel(x,y+i,m_FGColor);
+		if ( ((x) > m_Left) && ((x) < m_Right) && ((y-i) < m_Down) && ((y-i) > m_Up) ) 
+			g.Setpixel(x,y-i,m_FGColor);
+	}
+	g.SetMode(save_mode);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Variables
+ *  Description:  Init variables of screen 
+ *                Often call this function, after redraw screen
+ * =====================================================================================
+ */
+void Zscreen::Init_Variables()
+{
+	m_last_p_x = m_cDPV;
+	m_last_p_y = m_cDPV;
+
+	m_last_l_x = m_cDPV;
+	m_last_l_y = m_cDPV;
+
+	m_Decay    = 0;
+
+	Reset_Trace();
+
+	m_Data_Ball.dataindex = 0;
+	for (int j=0;j<DISP_DATA_LENGTH;j++)
+	{
+		m_Data_Ball.databuff[j] = 0x00;
+	}
+	m_bDrawFocus = false;
+
+
+	m_AlarmStatus     = false;
+	m_LastAlarmStatus = false;
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Draw_Mode
+ *  Description:  Set the Draw mode parameters 
+ * =====================================================================================
+ */
+void Zscreen::Set_Draw_Mode(DRAWMODE mode)
+{
+	m_DrawMode = mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Line_In_Trace
+ *  Description:  Draw line in screen arrange
+ * =====================================================================================
+ */
+void Zscreen::Draw_Line_In_Trace(Graphic &g,int x1,int y1,int x2,int y2,
+				    int color,bool flag)
+{
+	int dx,dy;
+	if ( y1 > y2) 
+	{
+		int t = y1;
+		y1 = y2;
+		y2 = t;
+		t = x1;
+		x1 = x2;
+		x2 = t;
+	}
+	dx = x2-x1;
+	dy = y2-y1;
+	if (dx > 0) 
+	{
+		if (dx > dy)
+			draw_xish_line_Trace(g,x1, y1, dx, dy, 1,color,flag);
+		else
+			draw_yish_line_Trace(g,x1, y1, dx, dy, 1,color,flag);
+	} 
+	else 
+	{
+		dx = -dx;
+		if (dx > dy)
+			draw_xish_line_Trace(g,x1, y1, dx, dy, -1,color,flag);
+		else
+			draw_yish_line_Trace(g,x1, y1, dx, dy, -1,color,flag);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  draw_xish_line_Trace
+ *  Description:  Draw line on ZKScreen depending on the x y
+ * =====================================================================================
+ */
+void Zscreen::draw_xish_line_Trace(Graphic &g,int x,int y,int dx,int dy,int xdir,
+		                      int ncolor,bool flag)
+{
+	int dyX2=dy+dy;
+	int dyX2mdxX2=dyX2-(dx+dx);
+	int error=dyX2-dx;
+	int offset_x,offset_y;
+
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down)
+	{
+		if ( flag == true )
+		{
+			offset_x = x - (m_X+1);
+			offset_y = y - (m_Y+1); 
+			m_Trace[offset_x+offset_y*(m_Width-2)] ++;
+			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
+				g.Setpixel(x, y, ncolor);
+		}
+		else
+		{
+			offset_x = x - (m_X+1);
+			offset_y = y - (m_Y+1); 
+			m_Trace[offset_x+offset_y*(m_Width-2)] --;
+			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
+				g.Setpixel(x, y, ncolor);
+		}
+	}
+	while (dx--) 
+	{
+		if (error >= 0) 
+		{
+			y++;
+			error += dyX2mdxX2;
+		} 
+		else 
+		{
+			error += dyX2;
+		}
+		x += xdir;
+		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
+		{
+			if ( flag == true )
+			{
+				offset_x = x - (m_X+1);
+				offset_y = y - (m_Y+1); 
+				m_Trace[offset_x+offset_y*(m_Width-2)] ++;
+				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
+					g.Setpixel(x, y, ncolor);
+			}
+			else
+			{
+				offset_x = x - (m_X+1);
+				offset_y = y - (m_Y+1); 
+				m_Trace[offset_x+offset_y*(m_Width-2)] --;
+				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
+					g.Setpixel(x, y, ncolor);
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  draw_yish_line_Trace
+ *  Description:  Draw line on screen depending on y direct
+ * =====================================================================================
+ */
+void Zscreen::draw_yish_line_Trace(Graphic &g,int x,int y,int dx,int dy,int xdir,
+				      int ncolor,bool flag)
+{
+	int dxX2=(dx<<1) ;
+	int dxX2mdyX2=dxX2-(dy<<1);
+	int error=dxX2-dy;
+	int offset_x,offset_y;
+
+	if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
+	{
+		if ( flag == true )
+		{
+			offset_x = x - (m_X+1);
+			offset_y = y - (m_Y+1); 
+			m_Trace[offset_x+offset_y*(m_Width-2)] ++;
+			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
+				g.Setpixel(x, y, ncolor);
+		}
+		else
+		{
+			offset_x = x - (m_X+1);
+			offset_y = y - (m_Y+1); 
+			m_Trace[offset_x+offset_y*(m_Width-2)] --;
+			if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
+				g.Setpixel(x, y, ncolor);
+		}
+	}
+	while (dy--) 
+	{
+		if (error >= 0) 
+		{
+			x+= xdir;
+			error += dxX2mdyX2;
+		} else 
+		{
+			error += dxX2;
+		}
+		y++;
+		if ( x > m_Left && x < m_Right && y > m_Up && y < m_Down )
+		{
+			if ( flag == true )
+			{
+				offset_x = x - (m_X+1);
+				offset_y = y - (m_Y+1); 
+				m_Trace[offset_x+offset_y*(m_Width-2)] ++;
+				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 1 )
+					g.Setpixel(x, y, ncolor);
+			}
+			else
+			{
+				offset_x = x - (m_X+1);
+				offset_y = y - (m_Y+1); 
+				m_Trace[offset_x+offset_y*(m_Width-2)] --;
+				if ( m_Trace[offset_x+offset_y*(m_Width-2)] == 0 )
+					g.Setpixel(x, y, ncolor);
+			}
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Focus
+ *  Description:  Set the Zscreen 
+ * =====================================================================================
+ */
+void Zscreen::Set_Focus(Graphic& g,bool value,bool redraw)
+{
+	m_Focus = value;
+	if ( m_Focus == false )
+	{
+		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	}                                     
+	else                                  
+	{                                     
+		m_labID->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGFO_CO);
+		m_labID->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXFO_CO);
+	}
+	if ( redraw == true )
+		m_labID->Drawme(g);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Gain_Degree_ReDraw
+ *  Description:  When set the Gain or Degree Re-draw single on screen 
+ * =====================================================================================
+ */
+void Zscreen::Set_Gain_Degree_ReDraw(Graphic& g,int channel,int loopstart,int loopend)
+{
+	g.Switch_Screen();
+	Refreshme(g);
+	Reset_Trace();
+	DRAWMODE drawmode = m_DrawMode;
+	double X_temp,Y_temp;
+	ETDATA X_,Y_;
+	m_DrawMode = LINE;
+	DataRepo *repo = DataRepo::Instance();
+	MixingManage *mixm = MixingManage::Instance();
+	Global *gp     = Global::Instance();
+
+	if 	( repo->GetLoopCount() < loopend ) { loopstart =  repo->GetLoopCount(); loopend = 0; }
+	else if ( repo->GetLoopCount() > loopend && repo->GetLoopCount() < loopstart )
+		loopstart =  repo->GetLoopCount();
+
+	CalculateCenter cc;
+	cc.Init_Object();
+
+	ETDATA *rawdata = new ETDATA[repo->Get_Each_Loop_Word_Count()];
+
+	for ( int loop=loopstart;loop!=loopend;loop-- )
+	{
+		repo->Get_One_Loop_Back(rawdata,loop);
+		if 	( channel == 2 )
+		{
+			mixm->Mixing(0,rawdata[0],rawdata[1],rawdata[2],rawdata[3]);
+			X_temp = rawdata[2]   * gp->SoftMixGain[channel-2];
+			Y_temp = 0 - rawdata[3] * gp->SoftMixGain[channel-2];
+			Y_temp = m_alg->Gain_Ratio(Y_temp);
+			m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
+			Y_ = 0 - Y_;
+			Draw_ET_Point(g,X_,Y_);
+			cc.Calculate_Graphic_MAX_MIN_Value(rawdata[2],
+							   m_alg->Gain_Ratio(static_cast<double>(rawdata[3])));
+		}
+		else
+		{
+			X_temp = rawdata[(channel<<1)]   * gp->SoftGain[channel];
+			Y_temp = 0 - rawdata[(channel<<1)+1] * gp->SoftGain[channel];
+			Y_temp = m_alg->Gain_Ratio(Y_temp);
+			m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
+			Y_ = 0 - Y_;
+			Draw_ET_Point(g,X_,Y_);
+			cc.Calculate_Graphic_MAX_MIN_Value(rawdata[(channel<<1)],
+							   m_alg->Gain_Ratio(static_cast<double>(rawdata[(channel<<1)+1])));
+		}
+	}
+
+	cc.Calculate_Graphic_Center();
+	cc.Reset_AMPBALL();
+
+	if 	( channel == 2 )
+	{
+		for ( int loop=loopstart;loop!=loopend;loop-- )
+		{
+			repo->Get_One_Loop_Back(rawdata,loop);
+			mixm->Mixing(0,rawdata[0],rawdata[1],rawdata[2],rawdata[3]);
+			cc.Record_MAXValue(rawdata[2],m_alg->Gain_Ratio(static_cast<double>(rawdata[3])));
+		}
+	}
+	else
+	{
+		for ( int loop=loopstart;loop!=loopend;loop-- )
+		{
+			repo->Get_One_Loop_Back(rawdata,loop);
+			cc.Record_MAXValue(rawdata[(channel<<1)],m_alg->Gain_Ratio(static_cast<double>(rawdata[(channel<<1)+1])));
+		}
+	}
+
+	int rx,ry,lx,ly;
+	cc.Get_MAX_Point(rx,ry,lx,ly);
+	cc.Calculate_AMP_PHA();
+
+	m_AMP = cc.Get_AMP();
+	if 	( channel == 2 )
+		m_AMP = static_cast<long long>(static_cast<double>(cc.Get_AMP()) * gp->SoftMixGain[channel-2]);
+	else
+		m_AMP = static_cast<long long>(static_cast<double>(cc.Get_AMP()) * gp->SoftGain[channel]);
+
+	if 	( channel == 2 )
+		m_PHA = cc.Get_PHA() + gp->MixDegree[channel-2];
+	else
+		m_PHA = cc.Get_PHA() + gp->Degree[channel];
+	if 	( m_PHA < 0 ) m_PHA += 360;
+	else if ( m_PHA >= 360 ) m_PHA -= 360;
+
+	if 	( channel == 2 )
+	{
+		X_temp = lx * gp->SoftMixGain[channel-2];
+		Y_temp = 0 - ly * gp->SoftMixGain[channel-2];
+		m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
+		lx = X_; ly = 0 - Y_;
+
+		X_temp = rx * gp->SoftMixGain[channel-2];
+		Y_temp = 0 - ry * gp->SoftMixGain[channel-2];
+		m_alg->Rotation(gp->MixDegree[channel-2],X_temp,Y_temp,X_,Y_);
+		rx = X_; ry = 0 - Y_;
+	}
+	else
+	{
+		X_temp = lx * gp->SoftGain[channel];
+		Y_temp = 0 - ly * gp->SoftGain[channel];
+		m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
+		lx = X_; ly = 0 - Y_;
+
+		X_temp = rx * gp->SoftGain[channel];
+		Y_temp = 0 - ry * gp->SoftGain[channel];
+		m_alg->Rotation(gp->Degree[channel],X_temp,Y_temp,X_,Y_);
+		rx = X_; ry = 0 - Y_;
+	}
+
+	if ( cc.Get_LR_Point() == true )
+		Draw_MAXAMP_Point(g,rx,ry,lx,ly,g.RGB24_16(0x00ff00),g.RGB24_16(0xffffff));
+	else
+		Draw_MAXAMP_Point(g,rx,ry,lx,ly,g.RGB24_16(0xffffff),g.RGB24_16(0x00ff00));
+
+	delete[] rawdata;
+	rawdata = NULL;
+	m_DrawMode = drawmode;
+	g.Switch_Screen();
+	g.Screen_Copy(m_X,m_Y,m_X+m_Width-1,m_Y+m_Heigh-1,false);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Mixing_Parameters_Calculate
+ *  Description: Calculat the Mixing parameters 
+ * =====================================================================================
+ */
+void Zscreen::Mixing_Parameters_Calculate(Graphic& g,int loopstart,int loopend)
+{
+	MixingManage *mixm = MixingManage::Instance();
+	mixm->Clean_Data_From_Buffer(0);
+	DataRepo *repo = DataRepo::Instance();
+	ETDATA *rawdata = new ETDATA[repo->Get_Each_Loop_Word_Count()];
+	
+	if 	( repo->GetLoopCount() < loopend ) { loopstart =  repo->GetLoopCount(); loopend = 0; }
+	else if ( repo->GetLoopCount() > loopend && repo->GetLoopCount() < loopstart )
+		loopstart =  repo->GetLoopCount();
+
+	mixm->Clean_Data_From_Buffer(0);
+	for ( int loop=loopstart;loop!=loopend;loop-- )
+	{
+		repo->Get_One_Loop_Back(rawdata,loop);
+		mixm->Load_Data_Into_Buffer(0,rawdata);
+	}
+
+	unsigned char *mem = new unsigned char[g.Get_Disp_Area_Bytes(0,0,639,479)];
+	g.Load_Disp_Area(0,0,639,479,mem);
+
+	Language *m_pl = Language::Instance();
+	Label *lab = new Label(220,230,250,25);
+	lab->Set_Label_Type(Label::LA_THIN);
+	lab->Set_Text(m_pl->GetText(MIXINGINFO1));
+	lab->Set_Font_Size(16);
+	lab->Set_Label_Color(Label::LA_FGNO_COLOR,g_BUTXNO_CO);
+	lab->Set_Label_Color(Label::LA_BGNO_COLOR,g_BUBGNO_CO);
+	lab->Drawme(g);
+	delete lab;
+	lab = NULL;
+	mixm->Calculate_Mix_Para(0);
+
+	g.Restore_Disp_Area(0,0,639,479,mem);
+	delete[] mem;
+	mem = NULL;
+
+	delete[] rawdata;
+	rawdata = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Reset_Trace
+ *  Description:  Reset the Screen Trace 
+ * =====================================================================================
+ */
+void Zscreen::Reset_Trace()
+{
+	int leng = (m_Width-2)*(m_Heigh-2);
+	memset(m_Trace,0,leng);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_MAXAMP_Point
+ *  Description:  Draw the MAX AMP points on screen which calculated before 
+ * =====================================================================================
+ */
+void Zscreen::Draw_MAXAMP_Point(Graphic &g,int rx,int ry,int lx,int ly,int lcolor,int rcolor)
+{
+	BresenhamCircle(g,m_Center_X+m_Offset_X+rx,m_Center_Y+m_Offset_Y+ry,6,rcolor);
+	BresenhamCircle(g,m_Center_X+m_Offset_X+lx,m_Center_Y+m_Offset_Y+ly,6,lcolor);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  BresenhamCircle
+ *  Description:  The second drawing circle algorithmic
+ * =====================================================================================
+ */
+void Zscreen::BresenhamCircle(Graphic &g,int xc,int yc,int radius,int color)
+{
+	int x=0;
+	int y=radius;
+	int d=3-(radius<<1);
+	while(x<y)
+	{
+		WholeCircle(g,xc,yc,x,y,color);
+		if (d<0) d = d + (x<<2) + 6;
+		else 
+		{
+			d = d + ((x-y)<<2) + 10;
+			y--;
+		}
+		x++;
+	}
+	if ( x==y ) WholeCircle(g,xc,yc,x,y,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  WholeCircle
+ *  Description:  The second circle drawing meathod
+ * =====================================================================================
+ */
+void Zscreen::WholeCircle(Graphic &g,int xc,int yc,int x,int y,int color)
+{
+	if ( xc+x > m_Left && xc+x < m_Right && yc+y > m_Up && yc+y < m_Down )
+		g.Setpixel(xc+x,yc+y,color);
+	if ( xc-x > m_Left && xc-x < m_Right && yc+y > m_Up && yc+y < m_Down )
+		g.Setpixel(xc-x,yc+y,color);
+	if ( xc+x > m_Left && xc+x < m_Right && yc-y > m_Up && yc-y < m_Down )
+		g.Setpixel(xc+x,yc-y,color);
+	if ( xc-x > m_Left && xc-x < m_Right && yc-y > m_Up && yc-y < m_Down )
+		g.Setpixel(xc-x,yc-y,color);
+	if ( xc+y > m_Left && xc+y < m_Right && yc+x > m_Up && yc+x < m_Down )
+		g.Setpixel(xc+y,yc+x,color);
+	if ( xc-y > m_Left && xc-y < m_Right && yc+x > m_Up && yc+x < m_Down )
+		g.Setpixel(xc-y,yc+x,color);
+	if ( xc+y > m_Left && xc+y < m_Right && yc-x > m_Up && yc-x < m_Down )
+		g.Setpixel(xc+y,yc-x,color);
+	if ( xc-y > m_Left && xc-y < m_Right && yc-x > m_Up && yc-x < m_Down )
+		g.Setpixel(xc-y,yc-x,color);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Center_Point
+ *  Description:  Set the center point of the screen 
+ * =====================================================================================
+ */
+void Zscreen::Set_Center_Point(const int x,const int y)
+{
+	m_Offset_X = x;
+	m_Offset_Y = y;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Center_Point
+ *  Description: Get the center point of the screen  
+ * =====================================================================================
+ */
+void Zscreen::Get_Center_Point(int& x,int& y)
+{
+	x = m_Offset_X;
+	y = m_Offset_Y;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Adjust_Center_Point
+ *  Description: Adjust the Center Point of Screen  
+ * =====================================================================================
+ */
+void Zscreen::Adjust_Center_Point(Graphic& g,DIRECT dir,int value)
+{
+	if 	( m_bDrawFocus == false )
+	{
+		DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
+		m_bDrawFocus = true;
+		return;
+	}
+	else
+		DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
+
+	for ( int v=0;v<value;v++ )
+	{
+		switch ( dir ) 
+		{
+			case UP:
+				{
+					m_Offset_Y --; 
+					if ( m_Center_Y + m_Offset_Y < m_Up + 10 )
+						m_Offset_Y = m_Up + 10 - m_Center_Y;
+				}
+				break;
+
+			case LEFT:
+				{
+					m_Offset_X --; 
+					if ( m_Center_X + m_Offset_X < m_Left + 10 )
+						m_Offset_X = m_Left + 10 - m_Center_X;
+				}
+				break;
+
+			case RIGHT:
+				{
+					m_Offset_X ++; 
+					if ( m_Center_X + m_Offset_X > m_Right - 10 )
+						m_Offset_X = m_Right - 10 - m_Center_X;
+				}
+				break;
+
+			case DOWN:
+				{
+					m_Offset_Y ++; 
+					if ( m_Center_Y + m_Offset_Y > m_Down - 10 )
+						m_Offset_Y = m_Down - 10 - m_Center_Y;
+				}
+				break;
+		}				/* -----  end switch  ----- */
+	}
+	DrawFocus(g,m_Center_X+m_Offset_X,m_Center_Y+m_Offset_Y);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Draw_Photo
+ *  Description:  Draw the Photo on to Screen 
+ * =====================================================================================
+ */
+void Zscreen::Draw_Photo(Graphic& g)
+{
+	if ( m_Photo == NULL )
+		return;
+
+	for ( int x=m_Left+1;x<m_Right;x++ )
+	{
+		for ( int y=m_Up+1;y<m_Down;y++ )
+		{
+			if ( m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)]  != 0 )
+				g.Setpixel(x,y,m_GRIDColor);
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Save_Photo
+ *  Description:  Save the Screen Picture into Buffer 
+ * =====================================================================================
+ */
+void Zscreen::Save_Photo(Graphic& g)
+{
+	if ( m_Photo == NULL )
+	{
+		m_Photo = new char[(m_Width-2)*(m_Heigh-2)];
+		memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
+	}
+	else
+	{
+		memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
+	}
+
+	for ( int x=m_Left+1;x<m_Right;x++ )
+	{
+		for ( int y=m_Up+1;y<m_Down;y++ )
+		{
+			if ( g.Getpixel(x,y) == m_PointColor )
+				m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)] = 1;
+			else
+				m_Photo[x-(m_X+1)+(y-(m_Y+1))*(m_Width-2)] = 0;
+		}
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clean_Photo
+ *  Description:  Clean the Screen Photo 
+ * =====================================================================================
+ */
+void Zscreen::Clean_Photo()
+{
+	memset(m_Photo,0,(m_Width-2)*(m_Heigh-2));
+}
diff --git a/src/EVA11/base/ZScreen.h b/src/EVA11/base/ZScreen.h
new file mode 100644
index 0000000..854e7f7
--- /dev/null
+++ b/src/EVA11/base/ZScreen.h
@@ -0,0 +1,161 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  ZScreen.h
+ *
+ *    Description:  Head File of ZScreen Class
+ *
+ *        Version:  1.0
+ *        Created:  2012年07月10日 09时18分37秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ZSCREEN_INC
+#define  _ZSCREEN_INC
+
+#include 	"main.h"
+
+class Label;
+class Basescreen;
+class Algorithm;
+class Zscreen : public Basescreen 
+{
+	public:
+		enum BACKCOOR 
+		{
+			BKNONE = 0,
+			GRID   = 1,
+		};
+		typedef enum BACKCOOR BACKCOOR;
+
+		enum DRAWMODE 
+		{
+			POINT = 0,
+			LINE  = 1,
+			AUTO  = 2,
+			SPEC  = 3
+		};
+
+		typedef enum DRAWMODE DRAWMODE;
+
+		enum DIRECT
+		{
+			LEFT  = 0,
+			UP    = 1,	
+			RIGHT = 2,
+			DOWN  = 3
+		};
+
+		typedef enum DIRECT DIRECT;
+
+		Zscreen (int x,int y,int width,int heigh);
+		~Zscreen ();
+		void Set_Back_Coordinate(BACKCOOR);
+		void Set_Draw_Mode(DRAWMODE);
+
+		void Draw_ET_Point(Graphic& g,const int& x,const int& y);
+		void Set_ID(int id);
+
+		void inline Get_SX_SY(int& x,int& y){ x = m_SX; y = m_SY; }
+		void inline Map_XY_To_Scr(int& x,int& y) { x = m_Center_X+m_Offset_X+x; y = m_Center_Y+m_Offset_Y+y; }
+		void inline Set_Alarm_Status(bool v) { m_AlarmStatus = v; }
+
+		void Set_Focus(Graphic& g,bool value,bool redraw=false);
+
+		void Set_Gain_Degree_ReDraw(Graphic& g,int ch,int start=9000,int end=100);
+		void Mixing_Parameters_Calculate(Graphic& g,int start=9000,int end=100);
+
+		inline long long Get_AMP() { return m_AMP; }
+		inline int	 Get_PHA() { return m_PHA; }
+
+		void Set_Center_Point(const int x,const int y);
+		void Get_Center_Point(int& x,int& y);
+
+		void Adjust_Center_Point(Graphic&,DIRECT,int);
+
+		void Reset_Trace();
+		void Save_Photo(Graphic& g);
+		void Clean_Photo();
+
+	protected:
+		virtual void Refreshme(Graphic& g);
+	private:
+		void DrawFocus(Graphic &g,const int x,const int y);
+		void Init_Variables();
+
+		void Draw_Line_In_Trace(Graphic &g,
+				          int x1,int y1,
+				          int x2,int y2,
+					  int color,
+					  bool flag=true);
+		void draw_xish_line_Trace(Graphic &g, 
+				            int x,int y,
+					    int dx,int dy,
+					    int xdir,int ncolor,
+					    bool flag=true);
+		void draw_yish_line_Trace(Graphic &g, 
+				            int x,int y,
+					    int dx,int dy,
+					    int xdir,int ncolor,
+					    bool flag=true);
+
+		void Draw_MAXAMP_Point(Graphic &g,int rx,int ry,int lx,int ly,int lcolor,int rcolor);
+
+		void WholeCircle(Graphic &g,int xc,int yc,int x,int y,int color);
+		void BresenhamCircle(Graphic &g,int xc,int yc,int radius,int color);
+		void Draw_Photo(Graphic& g);
+	private:
+		struct DATABALL 
+		{
+			ETDATA* databuff;
+			long    dataindex;
+		};
+		typedef struct DATABALL DATABALL;
+
+		static const int		DISP_DATA_LENGTH = 7680;
+		static const int		m_cDPV           = 0x7fff;
+		BACKCOOR			m_BackCoordinate;
+		DRAWMODE			m_DrawMode;
+
+		int				m_ID;
+
+		int				m_last_p_x;
+		int				m_last_p_y;
+		int				m_last_l_x;
+		int				m_last_l_y;
+
+		unsigned char			*m_Trace;
+		DATABALL 			m_Data_Ball;
+
+		Label*				m_labID;
+
+		int				m_SX;
+		int				m_SY;
+
+		Algorithm*			m_alg;
+
+		long long 			m_AMP;
+		int	 			m_PHA;
+
+		bool				m_bDrawFocus;
+
+		char*				m_Photo;
+
+		int				m_Offset_X;
+		int				m_Offset_Y;
+
+		/*-----------------------------------------------------------------------------
+		 * Special Draw Mode
+		 *-----------------------------------------------------------------------------*/
+		bool 				m_AlarmStatus;             /* True when alarm, False when normal */
+		bool 				m_LastAlarmStatus;
+		double 				m_LastResult;              /* Record Last Detect value */
+		int 				m_Decay;
+};
+#endif
diff --git a/src/EVA11/base/cssl.c b/src/EVA11/base/cssl.c
new file mode 100644
index 0000000..a287d0a
--- /dev/null
+++ b/src/EVA11/base/cssl.c
@@ -0,0 +1,564 @@
+/* Copyright 2003 Marcin Siennicki <m.siennicki@cloos.pl>
+ * see COPYING file for details */
+#define _GNU_SOURCE
+
+#include <stdio.h>
+
+#include <string.h>
+#include <termios.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include "cssl.h"
+
+/*
+ * Static variables and constants
+ */
+
+/* signal number for serial i/o read */
+static int CSSL_SIGNAL=0;
+
+/* boolean that say if we have started cssl */
+static int cssl_started=0;
+
+/* sigactions */
+static struct sigaction sa;
+static struct sigaction oldsa;
+
+/* head of the cssl_t list */
+static cssl_t *head=0;
+
+/* error messages table */
+static const char *cssl_errors[]= {
+    "cssl: OK",
+    "cssl: there's no free signal",
+    "cssl: not started",
+    "cssl: null pointer",
+    "cssl: oops",
+    "cssl: out of memory",
+    "cssl: cannot open file"
+};
+
+/* status of last cssl function */ 
+static cssl_error_t cssl_error=CSSL_OK;
+
+/* prototype of signal handler */
+static void cssl_handler(int signo, siginfo_t *info, void *ignored);
+
+
+/**************************************
+ * Public functions
+ **************************************/
+
+/*-------------------------------------
+ * Error handling
+ */
+
+/* gets the last operation status message */
+const char *cssl_geterrormsg()
+{
+    return cssl_errors[cssl_error];
+}
+
+
+/* gets the last error code */
+int cssl_geterror()
+{
+    return cssl_error;
+}
+
+/*-------------------------------------
+ * Startig/stoping cssl
+ */
+
+/* starts cssl */
+void cssl_start()
+{
+    int sig;
+
+    if (cssl_started) {
+	return;
+    }
+
+    /* Here we scan for unused real time signal */
+    sig=SIGRTMIN;
+
+    do {
+	
+	/* get old sigaction */
+	sigaction(sig,0,&oldsa);
+	
+	/* if signal's handler is empty */
+	if (oldsa.sa_handler == 0) 
+	{
+	    /* set the signal handler, and others */
+	    CSSL_SIGNAL=sig;
+	    sa.sa_sigaction = cssl_handler;
+	    sa.sa_flags = SA_SIGINFO;
+	    sa.sa_restorer = NULL;
+	    sigemptyset(&sa.sa_mask);
+	    sigaction(CSSL_SIGNAL,&sa,0);
+
+	    /* OK, the cssl is started */
+	    cssl_started=1;
+	    cssl_error=CSSL_OK;
+	    return;
+	} else {
+	    /* signal handler was not empty, 
+	       restore original */
+	    sigaction(CSSL_SIGNAL,&oldsa,0);
+	}
+	sig++;
+    } while(sig<=SIGRTMAX);
+    
+
+    /* Sorry, there's no free signal */
+    cssl_error=CSSL_ERROR_NOSIGNAL;
+    
+}
+
+/* stops the cssl */
+void cssl_stop()
+{
+    /* if not started we do nothing */
+    if (!cssl_started)
+	return;
+
+    /* we close all ports, and free the list */
+    while (head)
+	cssl_close(head);
+
+    /* then we remove the signal handler */
+    sigaction(CSSL_SIGNAL,&oldsa,NULL);
+
+    /* And at least : */
+    cssl_started=0;
+    cssl_error=CSSL_OK;
+}
+
+/*-------------------------------------
+ * Basic port operation - open/close
+ */
+
+
+/* opens the port */
+cssl_t *cssl_open(const char *fname,
+		  cssl_callback_t callback,
+		  int id,
+		  int baud,
+		  int bits,
+		  int parity,
+		  int stop)
+{
+    cssl_t *serial;
+
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return NULL;
+    }
+    
+    /* create new cssl_t structure */
+    serial=calloc(1,sizeof(cssl_t));
+
+    /* oops, no memory */
+    if (!serial) {
+	cssl_error=CSSL_ERROR_MEMORY;
+	return 0;
+    }
+
+    /* opening the file */
+    if(callback) {
+	/* user wants event driven reading */
+	serial->fd=open(fname,O_RDWR|O_NOCTTY|O_NONBLOCK);
+	fcntl(serial->fd,F_SETSIG,CSSL_SIGNAL);
+	fcntl(serial->fd,F_SETOWN,getpid());
+	fcntl(serial->fd,F_SETFL,O_ASYNC|O_NONBLOCK);
+    } else {
+	/* the read/write operations will be bloking */
+	serial->fd=open(fname,O_RDWR|O_NOCTTY);
+    }
+
+    /* oops, cannot open */
+    if (serial->fd == -1) {
+	cssl_error=CSSL_ERROR_OPEN;
+	free(serial);
+	return NULL;
+    }
+
+    /* we remember old termios */
+    tcgetattr(serial->fd,&(serial->oldtio));
+    
+    /* now we set new values */
+    cssl_setup(serial,baud,parity,bits,stop);
+
+    /* and id */
+    serial->id=id;
+
+    /* then set the callback */
+    serial->callback=callback;
+    
+    /* we add the serial to our list */
+    serial->next=head;
+    head=serial;
+	
+    cssl_error=CSSL_OK;
+
+    return serial;
+}
+
+
+/* closes file, removes serial from the list and frees it */
+void cssl_close(cssl_t *serial)
+{
+    cssl_t *cur;
+    
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }
+    
+    /* first we flush the port */
+    tcflush(serial->fd,TCOFLUSH); 
+    tcflush(serial->fd,TCIFLUSH); 
+    
+    /* then we restore old settings */
+    tcsetattr(serial->fd,TCSANOW,&(serial->oldtio));
+    
+    /* and close the file */
+    close(serial->fd);
+    
+    /* now we can remove the serial from the list */
+
+    if (head==serial) {
+	head=serial->next;
+	free(serial);
+	cssl_error=CSSL_OK;
+	return;
+    }
+
+    for (cur=head;cur;cur=cur->next) {
+	if (cur->next==serial) {
+	    cur->next=serial->next;
+	    free(serial);
+	    cssl_error=CSSL_OK;
+	    return;
+	}
+    }
+
+    /* we should never reach there,
+       it means, that serial was not found in the list */
+    cssl_error=CSSL_ERROR_OOPS;
+}
+
+/*-------------------------------------
+ * Port setup
+ */
+
+/* sets up the port parameters */
+void cssl_setup(cssl_t *serial,
+		   int baud,
+		   int bits,
+		   int parity,
+		   int stop)
+{
+    tcflag_t baudrate;
+    tcflag_t databits;
+    tcflag_t stopbits;
+    tcflag_t checkparity;
+
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }    
+
+    /* get the propr baudrate */
+    switch (baud) {
+    case 75:
+	baudrate=B75;
+	break;
+    case 110:
+	baudrate=B110;
+	break;
+    case 150:
+	baudrate=B150;
+	break;
+    case 300:
+	baudrate=B300;
+	break;
+    case 600:
+	baudrate=B600;
+	break;
+    case 1200:
+	baudrate=B1200;
+	break;
+    case 2400:
+	baudrate=B2400;
+	break;
+    case 4800:
+	baudrate=B4800;
+	break;
+    case 9600:
+	baudrate=B9600;
+	break;
+    case 19200:
+	baudrate=B19200;
+	break;
+    case 38400:
+	baudrate=B38400;
+	break;
+    case 57600:
+	baudrate=B57600;
+	break;
+    case 115200:
+	baudrate=B115200;
+	break;
+    default:
+	baudrate=B9600;
+    }
+
+    /* databits */
+    switch (bits) {
+    case 7:
+	databits=CS7;
+	break;
+    case 8:
+	databits=CS8;
+	break;
+    default:
+	databits=CS8;
+    }
+    
+    /* parity, */
+    switch (parity) {
+    case 0:
+	checkparity=0;
+	break;
+    case 1:   //odd
+	checkparity=PARENB|PARODD;
+	break;
+    case 2:
+	checkparity=PARENB;
+	break;
+    default:
+	checkparity=0;
+    }
+    
+    /* and stop bits */
+    switch (stop) {
+    case 1:
+	stopbits=0;
+	break;
+    case 2:
+	stopbits=CSTOPB;
+	break;
+    default:
+	stopbits=0;
+    }
+    
+    /* now we setup the values in port's termios */
+    serial->tio.c_cflag=baudrate|databits|checkparity|stopbits|CLOCAL|CREAD;
+    serial->tio.c_iflag=IGNPAR;
+    serial->tio.c_oflag=0;
+    serial->tio.c_lflag=0;
+    serial->tio.c_cc[VMIN]=1;
+    serial->tio.c_cc[VTIME]=0;
+
+    /* we flush the port */
+    tcflush(serial->fd,TCOFLUSH);
+    tcflush(serial->fd,TCIFLUSH);
+    
+    /* we send new config to the port */
+    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
+
+    cssl_error=CSSL_OK;
+}
+
+void cssl_setflowcontrol(cssl_t *serial,
+			 int rtscts,
+			 int xonxoff)
+{
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }    
+
+    /* We setup rts/cts (hardware) flow control */
+    if (rtscts) {
+	serial->tio.c_cflag |= CRTSCTS;
+    } else {
+	serial->tio.c_cflag &= ~CRTSCTS;
+    }
+    
+    /* We setup xon/xoff (soft) flow control */
+    if (xonxoff) {
+	serial->tio.c_iflag |= (IXON|IXOFF);
+    } else {
+	serial->tio.c_iflag &= ~(IXON|IXOFF);
+    }
+    
+    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
+
+    cssl_error=CSSL_OK;
+}
+
+/* Blocking mode: sets the timeout in 
+   hundreds of miliseconds */
+void cssl_settimeout(cssl_t *serial, int timeout)
+{
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }    
+
+    serial->tio.c_cc[VTIME]=timeout;
+    
+    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
+
+    cssl_error=CSSL_OK;
+}
+
+/*-------------------------------------
+ * Serial communication
+ */
+
+/* sending a char */
+void cssl_putchar(cssl_t *serial,
+		     char c)
+{
+    if (!cssl_started) 
+    {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) 
+    {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }
+
+    int result = write(serial->fd,&c,1);
+}
+
+/* sending a null-terminated string */
+void cssl_putstring(cssl_t *serial,
+		     char *str)
+{
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }
+
+    int result = write(serial->fd,str,strlen(str));
+}
+
+/* sending a data of known size */
+void cssl_putdata(cssl_t *serial,
+		  uint8_t *data,
+		  int datalen)
+{
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }    
+
+    int result = write(serial->fd,data,datalen);
+}
+
+void cssl_drain(cssl_t *serial)
+{
+    if (!cssl_started) {
+	cssl_error=CSSL_ERROR_NOTSTARTED;
+	return;
+    }
+    
+    if (!serial) {
+	cssl_error=CSSL_ERROR_NULLPOINTER;
+	return;
+    }    
+
+    tcdrain(serial->fd);
+}
+
+/* blocking mode: reading a char */
+int cssl_getchar(cssl_t *serial)
+{
+    uint8_t c;
+    int result = read(serial->fd,&c,sizeof(c));
+    if (result<=0)
+	return -1;
+    
+    return c;
+}
+
+/* blocking mode: reading a data buffer */
+int cssl_getdata(cssl_t *serial,
+		 uint8_t *buffer,
+		 int size)
+{
+    return read(serial->fd,buffer,size);
+}
+
+/*------------------------------------------*/
+
+/* The most important: signal handler */
+void cssl_handler(int signo, siginfo_t *info, void *ignored)
+{
+    cssl_t *cur;
+    int n;
+
+    /* is this signal which says about
+       incoming of the data? */
+    if (info->si_code==POLL_IN) {
+
+	/* Yes, we got some data */
+	for(cur=head;cur;cur=cur->next) {
+
+	    /* Let's find proper cssl_t */
+	    if (cur->fd==info->si_fd) {
+
+		/* Got it */
+		n=read(cur->fd,cur->buffer,255);
+
+		/* Execute callback */
+		if ((n>0)&&(cur->callback))
+		    cur->callback(cur->id,cur->buffer,n);
+		return;
+	    }
+	}
+    }
+}
diff --git a/src/EVA11/base/cssl.h b/src/EVA11/base/cssl.h
new file mode 100644
index 0000000..823aab5
--- /dev/null
+++ b/src/EVA11/base/cssl.h
@@ -0,0 +1,128 @@
+/* Copyright 2003 Marcin Siennicki <m.siennicki@cloos.pl>
+ * see COPYING file for details */
+
+#ifndef __CSSL_H__
+#define __CSSL_H__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include <stdint.h>
+#include <signal.h>
+#include <termios.h>
+
+typedef void (*cssl_callback_t)(int id,  /* id passed to callback */
+				uint8_t *buffer, /* data received */
+				int len); /* length of data in bytes */
+
+typedef struct __cssl_t {
+
+    uint8_t buffer[255];      /* input buffer */
+
+    int fd;                   /* tty file descriptor */
+
+    struct termios tio;       /* termios structure for the port */
+    struct termios oldtio;    /* old termios structure */
+
+    cssl_callback_t callback; /* callback function */
+
+    int id;                   /* id which would be passed to callback */
+
+    struct __cssl_t *next;
+
+} cssl_t;
+
+typedef enum {
+    CSSL_OK,                 /* everything is all right */
+    CSSL_ERROR_NOSIGNAL,     /* there's no free signal */
+    CSSL_ERROR_NOTSTARTED,   /* you should first start cssl */
+    CSSL_ERROR_NULLPOINTER,  /* you gave a null pointer to the function */
+    CSSL_ERROR_OOPS,         /* internal error, something's erong */
+    CSSL_ERROR_MEMORY,       /* there's no memory for cssl_t structure */
+    CSSL_ERROR_OPEN          /* file doesnt exist or you aren't good user */
+} cssl_error_t;
+
+/* get the error message */
+const char *cssl_geterrormsg();
+
+/* get the error code */
+int cssl_geterror();
+
+/* start the cssl */
+void cssl_start();
+
+/* finish all jobs, clear memory, etc. */
+void cssl_stop();
+
+/* alloc new cssl_t struct and open the port */
+cssl_t *cssl_open(const char *fname, /* pathname of port file,
+				      * for example "/dev/ttyS0" */
+		  cssl_callback_t callback, /* callback function
+					     * If you dont want
+					     * event driven reading - set
+					     * it to NULL */
+		  int id,     /* your own id for the port, it can help
+			       * to identify the port in callback f.*/
+		  int baud,   /* baudrate, integer, for example 19200 */
+		  int bits,   /* data bits: 7 or 8 */
+		  int parity, /* parity: 0 - none, 1-odd, 2-even */
+		  int stop);  /* stop bits: 1 or 2 */
+
+/* closes the port, and frees its cssl_t struct */
+void cssl_close(cssl_t *serial);
+
+/* setups the port, look at cssl_open */
+void cssl_setup(cssl_t *serial,
+		   int baud,
+		   int bits,
+		   int parity,
+		   int stop);
+
+void cssl_setflowcontrol(cssl_t *serial,
+			 int rtscts,   /* Boolean: 
+					* 0 - no rts/cts control,
+					* 1 - rts/cts control 
+					*/
+			 int xonxoff); /* Boolean: 
+					* 0 - no xon/xoff, 
+					* 1 - xon/xoff 
+					*/
+
+/* sends a char via serial port */
+void cssl_putchar(cssl_t *serial,
+		     char c);
+
+/* sends a null terminated string */
+void cssl_putstring(cssl_t *serial,
+		       char *str);
+
+/* sends a data of known size */
+void cssl_putdata(cssl_t *serial,
+		  uint8_t *data, /* data */
+		  int datalen);  /* length of data */
+
+/* waits until all data has been transmited */
+
+void cssl_drain(cssl_t *serial);
+
+/*====================================== 
+ * Blocking mode 
+ */
+
+/* Sets port timeout (deciseconds) in blocking mode */
+void cssl_settimeout(cssl_t *serial, int timeout);
+
+/* reads a char in blocking mode */
+int cssl_getchar(cssl_t *serial);
+
+/* reads a data to a buffer in blocking mode*/
+int cssl_getdata(cssl_t *serial,
+		 uint8_t *buffer,  /* buffer for data */
+		 int size);        /* buffer size */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __CSSL_H__ */
diff --git a/src/EVA11/base/etio.cpp b/src/EVA11/base/etio.cpp
new file mode 100644
index 0000000..f8728ea
--- /dev/null
+++ b/src/EVA11/base/etio.cpp
@@ -0,0 +1,1762 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  etio.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月18日 11时07分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cmath>
+#include 	<cstdio>
+#include 	<cstdlib>
+#include 	<fcntl.h>
+#include 	<unistd.h>
+#include 	<sys/mman.h>
+
+#include 	"etio.h"
+
+#define 	DEVICE_KBTEST	"/dev/ECT"
+#define 	PI              3.1415926
+
+std::auto_ptr<Etio> Etio::m_Instance;
+
+struct Etio::BOARDSTATUS
+{
+	unsigned 		SampleReady : 1;
+	unsigned 		None3       : 3;
+	unsigned 		PowerOn     : 1;
+	unsigned 		Running     : 1;
+	unsigned 		Shutdown    : 1;
+	unsigned 		None1       : 1;
+};
+
+struct Etio::PROBBALGAIN
+{
+	unsigned 		ProbeGain : 3;
+	unsigned 		None	  : 1;
+	unsigned 		ProbeBal  : 4;
+};
+
+struct Etio::JOBAMOUNT
+{
+	unsigned 		WpAmount : 4;
+	unsigned 		ChJob    : 4;
+};
+
+struct Etio::WPARAMS
+{
+	uint8_t 		WpDivisorLo;
+	uint8_t 		WpDivisorHi;
+	uint8_t 		WpAmount;
+
+	Etio::JOBAMOUNT		JobWpAmount;
+
+	uint8_t 		WpDeltaLo;
+	uint8_t 		WpDeltaMi;
+	uint8_t 		WpDeltaHi;
+
+	Etio::PROBBALGAIN	ProbeBalGain;
+
+	uint8_t			CoilNumforPickB;
+	uint8_t			CoilNumforPickA;
+
+	uint8_t			CoilNumforDriverB;
+	uint8_t			CoilNumforDriverA;
+
+	uint8_t			RfLpCoefLo;
+	uint8_t			RfLpCoefHi;
+
+	uint8_t			RfHpCoefLo;
+	uint8_t			RfHpCoefHi;
+
+	uint8_t			LfLpCoefLo;
+	uint8_t			LfLpCoefHi;
+
+	uint8_t			LfHpCoefLo;
+	uint8_t			LfHpCoefHi;
+};
+
+struct Etio::FREQUENCESTR
+{
+	int			Frequence;
+	int			Wck;
+};
+
+struct Etio::PImpl
+{
+	static const int 	m_Version 	   = 101;
+	static const int	m_FREQVALUEN_40MHz = 2216;
+	static const int	m_cMAXSN 	   = 128;   // Max Structure Number
+	static const int	m_cMAXFreqAmount   = 8;
+
+	int			m_FD;
+
+	volatile uint8_t*	m_pET;
+
+	FUNMODE			m_Work_Mode;		    // Normal\Sin
+	int			m_Sin_Channel;		    // select the SIN channel
+	/*-----------------------------------------------------------------------------
+	 * Media layer  
+	 *-----------------------------------------------------------------------------*/
+	int			m_High_Filter[m_cMAXSN];
+	int			m_Low_Filter[m_cMAXSN];
+	int			m_Offset;
+	int			m_SineAmp;
+	CHANTYPE		m_Chan_Type[m_cMAXSN];
+	int			m_MediaChanFreq[m_cMAXFreqAmount];
+	/*-----------------------------------------------------------------------------
+	 * Board Information  
+	 *-----------------------------------------------------------------------------*/
+	uint8_t			m_TQ_Main_Version;          // 03
+	uint8_t 		m_TQ_Sub_Version;      	    // 4
+	uint8_t			m_FPGA_Version;	       	    // 1 ..
+
+	uint8_t			m_MAX_Channels;        	    // 1~128
+
+	bool			m_bECT;
+	bool			m_bFECT;
+	bool			m_bRF;
+	bool			m_bEMS;
+	bool			m_bLF;
+
+	bool			m_RF_Filter_Enable;	    // it desides whether RF readmode need to set RF Filter Enable
+
+	Etio::FREQUENCESTR	m_FreqValue[m_FREQVALUEN_40MHz];	
+	int			m_FreqValueLength;
+
+	int			m_Channels_Number;	     // Current MAX channels
+	int			m_ChanFreq[m_cMAXSN];
+	int			m_ChanMapMedia2FreqIndex[m_cMAXSN];
+	Etio::WPARAMS           m_ChanPara[m_cMAXSN];	     // used this strcuture to configrature probe
+
+	bool			m_Timer1Mode;
+	bool			m_Timer2Mode;
+
+	Etio::BOARDSTATUS       BoardStatus;
+};
+
+Etio::Etio () : m_Imple(new struct PImpl)
+{
+}
+
+Etio::~Etio ()
+{
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Etio* Etio::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Etio() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Version
+ *  Description:  Get the share library version 
+ * =====================================================================================
+ */
+int Etio::Version()
+{
+	return m_Imple->m_Version; 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Board_Version
+ *  Description:  Get the Board Version information from board 
+ * =====================================================================================
+ */
+void Etio::Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA)
+{
+#ifdef X86
+	Main = 1;
+	Sub  = 2;
+	FPGA = 3;
+#else
+	Main = m_Imple->m_TQ_Main_Version;
+	Sub  = m_Imple->m_TQ_Sub_Version;
+	FPGA = m_Imple->m_FPGA_Version;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Board_Information
+ *  Description:  Load infromation from Board 
+ * =====================================================================================
+ */
+void Etio::Load_Board_Information()
+{
+#ifdef X86
+	m_Imple->m_TQ_Sub_Version = 3;
+	m_Imple->m_FPGA_Version   = 2;
+	m_Imple->m_TQ_Main_Version= 1; 
+	m_Imple->m_MAX_Channels   = 128;
+
+	m_Imple->m_bECT  = true;
+	m_Imple->m_bFECT = true;
+	m_Imple->m_bRF   = true;
+	m_Imple->m_bEMS  = true;  
+	m_Imple->m_bLF   = true;
+#else
+	uint8_t t = PEEKB_TC(0x0000);
+	m_Imple->m_TQ_Sub_Version  = ( t & 0xf0 ) >> 4;
+	m_Imple->m_FPGA_Version    = t & 0x0f;
+	m_Imple->m_TQ_Main_Version = PEEKB_TC(0x0001);
+	m_Imple->m_MAX_Channels    = pow(2,PEEKB_TC(0x0002) & 0x07);
+
+	m_Imple->m_bECT  = false;
+	m_Imple->m_bFECT = false;
+	m_Imple->m_bRF   = false;
+	m_Imple->m_bEMS  = false;  
+	m_Imple->m_bLF   = false;
+
+	t = ( PEEKB_TC(0x0002) & 0xf8 ) >> 3;
+
+	if ( t & 0x01 )
+		m_Imple->m_bECT  = true;
+
+	if ( (t>>1) & 0x01 )
+		m_Imple->m_bFECT = true;
+
+	if ( (t>>2) & 0x01 )
+		m_Imple->m_bRF   = true;
+
+	if ( (t>>3) & 0x01 )
+		m_Imple->m_bEMS  = true;
+
+	if ( (t>>4) & 0x01 )
+		m_Imple->m_bLF   = true;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  POKEB_TC
+ *  Description:  Set value into TCB 
+ * =====================================================================================
+ */
+void Etio::POKEB_TC(int add,uint8_t value)
+{
+#ifdef X86
+#else
+	m_Imple->m_pET[2] = static_cast<uint8_t>( add & 0xff );
+	m_Imple->m_pET[3] = static_cast<uint8_t>( ( add >> 8 ) & 0xff ); 
+	m_Imple->m_pET[4] = value; 
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  PEEKB_TC
+ *  Description:  Read Dat from TC 
+ * =====================================================================================
+ */
+uint8_t Etio::PEEKB_TC(int add)
+{
+#ifdef X86
+	return 0;
+#else
+	m_Imple->m_pET[2]   = static_cast<uint8_t>( add & 0xff );
+	m_Imple->m_pET[3]   = static_cast<uint8_t>( (add>>8) & 0xff );
+	return m_Imple->m_pET[8];
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  InitialteETIO
+ *  Description:  Initialte the ETIO board 
+ * =====================================================================================
+ */
+bool Etio::InitiateETIO()
+{
+#ifdef X86
+#else
+	if	( (m_Imple->m_FD=open(DEVICE_KBTEST, O_RDWR ))<0 )
+	{ 
+		perror("can not open device");
+		return false;
+	}
+	else
+	{ 
+		m_Imple->m_pET =(volatile uint8_t*) mmap(NULL, 16, PROT_READ|PROT_WRITE, /*0*/MAP_SHARED, m_Imple->m_FD, 0); 
+		if	( m_Imple->m_pET==MAP_FAILED )
+		{
+			perror("Map Failed"); 
+			return false;
+		}
+
+		POKEB_TC(0x10,0); 
+		if	( ( PEEKB_TC(0x06) & 0x10 ) !=0 )
+		{
+			perror("No Found the ET Board");
+			return false;
+		}
+		POKEB_TC(0x10,1); 
+		if	( ( PEEKB_TC(0x06) & 0x10 ) != 0x10 ) 
+		{
+			perror("No Found the ET Board");
+			return false;
+		}
+	}
+#endif
+
+	/*-----------------------------------------------------------------------------
+	 *  Init FPGA Board variables
+	 *-----------------------------------------------------------------------------*/
+	uint8_t main,sub,fpga;
+	Load_Board_Information();
+	Refresh_Board_Status();
+	Get_Board_Version(main,sub,fpga);
+	printf ( "FPGA Information TQ%02d-%c FPGA%d\n",main,'A'+sub,fpga );
+
+	Init_Frequence_Value();
+	Init_Default_Value();
+
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  UnInitiateETIO
+ *  Description:  Release Board Value
+ * =====================================================================================
+ */
+void Etio::UnInitiateETIO()
+{
+	Running(false);
+	Power(false);
+#ifdef X86
+#else
+	munmap((void *)(m_Imple->m_pET),16); 
+	close(m_Imple->m_FD); 
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Chan_Data
+ *  Description:  Sample the Each Channel Data
+ *	          x0-data[0] y0-data[1]
+ *	          x1-data[2] y1-data[3]
+ *	          x2-data[4] y1-data[5]
+ *	          .
+ *	          .
+ *	          x127-data[254] y127-data[255]
+ *
+ *       return:  false    Sample NOT OK   
+ *       	  true     Sample OK 
+ * =====================================================================================
+ */
+bool Etio::Sample_Chan_Data(int* data,SAMPLETYPE st)
+{
+#ifdef X86
+#else
+	int addr;
+	uint8_t t1,t2,t3,t4;
+
+	if ( PEEKB_TC(0x006) & 0x01 == true )
+		return false;
+
+	switch ( st ) 
+	{
+		case TIMERS:    // INT EXT1  EXT2
+			{
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		case RAWECT:    //  X0 Y0 .... .... Xn Yn
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+			}
+			break;
+
+		case RAWEMS:	// X0 0  .... .... Xn 0
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+					data[(i<<1) + 1] = 0; 
+				}
+			}
+			break;
+
+		case ALLECT:   //  X0 Y0 .... .... Xn Yn INTTIME EXTTIME1 EXTTIME2
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		case ALLEMS:   //  X0 0 .... .... Xn 0 INTTIME EXTTIME1 EXTTIME2
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+					data[(i<<1) + 1] = 0; 
+				}
+
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		default:       // RAW ECT
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+			}
+			break;
+	}				/* -----  end switch  ----- */
+
+	POKEB_TC(0x020,0x01);		// restart next sample
+#endif
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_WparaRam
+ *  Description:  Acoording the Wparameters then set the value to FPGA 
+ * =====================================================================================
+ */
+void Etio::Set_WparamRam_Into_FPGA(int chan)
+{
+	int addr = 0x2000 +  ( chan << 4 );
+
+	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].WpDivisorLo);
+	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].WpDivisorHi);
+	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].WpAmount);
+
+	uint8_t v = m_Imple->m_ChanPara[chan].JobWpAmount.WpAmount + ( m_Imple->m_ChanPara[chan].JobWpAmount.ChJob<<4 );
+	POKEB_TC(addr+0x003,v);
+
+	POKEB_TC(addr+0x004,m_Imple->m_ChanPara[chan].WpDeltaLo);
+	POKEB_TC(addr+0x005,m_Imple->m_ChanPara[chan].WpDeltaMi);
+	POKEB_TC(addr+0x006,m_Imple->m_ChanPara[chan].WpDeltaHi);
+
+	v = 0;
+	v = m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeGain + ( m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeBal<<4 );
+	POKEB_TC(addr+0x007,v);
+
+	POKEB_TC(addr+0x008,m_Imple->m_ChanPara[chan].CoilNumforPickB);
+	POKEB_TC(addr+0x009,m_Imple->m_ChanPara[chan].CoilNumforPickA);
+	POKEB_TC(addr+0x00a,m_Imple->m_ChanPara[chan].CoilNumforDriverB);
+	POKEB_TC(addr+0x00b,m_Imple->m_ChanPara[chan].CoilNumforDriverA);
+
+	POKEB_TC(addr+0x00c,m_Imple->m_ChanPara[chan].RfLpCoefLo);
+	POKEB_TC(addr+0x00d,m_Imple->m_ChanPara[chan].RfLpCoefHi);
+	POKEB_TC(addr+0x00e,m_Imple->m_ChanPara[chan].RfHpCoefLo);
+	POKEB_TC(addr+0x00f,m_Imple->m_ChanPara[chan].RfHpCoefHi);
+
+	addr = 0x3000 +  ( chan << 2 );
+	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].LfLpCoefLo);
+	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].LfLpCoefHi);
+	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].LfHpCoefLo);
+	POKEB_TC(addr+0x003,m_Imple->m_ChanPara[chan].LfHpCoefHi);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Board_Status
+ *  Description:  Refresh the Board Status into mem_fun1_ref_tnory
+ * =====================================================================================
+ */
+void Etio::Refresh_Board_Status()
+{
+#ifdef X86
+#else
+	uint8_t v = PEEKB_TC(0x006);
+
+	m_Imple->BoardStatus.SampleReady = v & 0x01;
+	m_Imple->BoardStatus.PowerOn     = ( v & 0x10 ) >> 4;
+	m_Imple->BoardStatus.Running     = ( v & 0x20 ) >> 5;
+	m_Imple->BoardStatus.Shutdown    = ( v & 0x40 ) >> 6;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Power
+ *  Description:  Set the Power flag  
+ *         flag:  true  	PowerOn
+ *                false 	PowerOff
+ * =====================================================================================
+ */
+void Etio::Power(bool flag)
+{
+	uint8_t v = 0;
+	if 	( flag == true )
+		v = 1;
+
+	POKEB_TC(0x010,v);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Running
+ *  Description:  Set the Running flag 
+ *         flag:  true           Running
+ *                false          Stopping
+ * =====================================================================================
+ */
+void Etio::Running(bool flag)
+{
+	uint8_t v = 0;
+	if 	( flag == true )
+		v = 1;
+
+	POKEB_TC(0x011,v);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Chan_Amount
+ *  Description:  Set the Channel Amount 
+ *  		  1~128
+ * =====================================================================================
+ */
+void Etio::Set_Chan_Amount(int amount)
+{
+	if 	( amount > 128 || amount < 1 )
+		return;
+
+	POKEB_TC(0x015,amount);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_AdOffset
+ *  Description:  Set the Offset (-100 +100)
+ * =====================================================================================
+ */
+void Etio::Set_AdOffset(int offset)
+{
+	if 	( offset > 100 || offset < -100 )
+		return;
+
+	POKEB_TC(0x018,offset);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_SineAmplitude
+ *  Description:  Set the sine Amplitude times  0~15
+ * =====================================================================================
+ */
+void Etio::Set_SineAmplitude(int value)
+{
+	if 	( value > 15 || value < 0 )
+		return;
+
+	POKEB_TC(0x01F,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restart
+ *  Description:  Restart the Board 
+ * =====================================================================================
+ */
+void Etio::Restart()
+{
+	POKEB_TC(0x020,0x01);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GKey
+ *  Description:  Get the Key Value from ECT Board 
+ *                0~6 bits	Key Value
+ *                7 bits   	Length Push
+ * =====================================================================================
+ */
+uint8_t Etio::GKey()
+{
+	return PEEKB_TC(0x02F);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ET
+ *  Description:  Set the ETIO parameter into Board
+ *                this function convert all device parameters from package to FPGA parameters
+ * =====================================================================================
+ */
+void Etio::Set_ET()
+{
+	Running(false);		  	// halt the system
+
+	if 	( m_Imple->m_Work_Mode == SIN )
+		POKEB_TC(0x016,(m_Imple->m_Sin_Channel|0x80));
+	else 
+		POKEB_TC(0x016,(m_Imple->m_Sin_Channel&0x7F));
+
+	Set_Chan_Type();		// set each channels paramters and calculate channels number
+	Set_Chan_Amount(m_Imple->m_Channels_Number);
+	Set_AdOffset(m_Imple->m_Offset);
+	Set_SineAmplitude(m_Imple->m_SineAmp);
+	Set_Timer_Mode();
+	Convert_Media_FreqValue_To_Inside_FreqIndex();
+	Calculate_Channel_Parameters();
+
+	for ( int i = 0; i < m_Imple->m_cMAXSN; i += 1 ) 
+		Set_WparamRam_Into_FPGA(i);
+
+	Running(true);			// re-running system
+	Restart();			// Start Sample
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clear_Timers
+ *  Description:  Clear the Int Ext1 Ext2 Timers 
+ * =====================================================================================
+ */
+void Etio::Clear_Timers(int index)
+{
+	switch ( index ) 
+	{
+		case 0:			// InTimer
+			POKEB_TC(0x024,0x01);
+			break;
+
+		case 1:			// Extimer1 
+			POKEB_TC(0x024,0x02);
+			break;
+
+		case 2:			// Extimer2 
+			POKEB_TC(0x024,0x04);
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Frequence_Value
+ *  Description:  Init Frequence Value into Buffer  
+ * =====================================================================================
+ */
+void Etio::Init_Frequence_Value()
+{
+	int fn = 0;
+
+	m_Imple->m_FreqValue[fn].Frequence 	   = 1;
+	m_Imple->m_FreqValue[fn].Wck       	   = 2000;
+	fn ++;
+
+	for ( int i=2;i<4;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 4000;
+		fn ++;
+	}
+
+	for ( int i=4;i<8;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 8000;
+		fn ++;
+	}
+
+	for ( int i=8;i<16;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 16000;
+		fn ++;
+	}
+
+	for ( int i=16;i<32;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 32000;
+		fn ++;
+	}
+
+	for ( int i=32;i<80; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 64000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=80;i<151; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 160000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=160;i<391; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 320000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=400;i<791; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 800000;
+		fn ++;
+		i += 4;
+	}
+
+	for ( int i=800;i<1901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 1600000;
+		fn ++;
+		i += 4;
+	}
+
+	for ( int i=2000;i<3901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 3200000;
+		fn ++;
+		i += 5;
+	}
+
+	for ( int i=4000;i<9901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 8000000;
+		fn ++;
+		i += 6;
+	}
+
+	for ( int i=10000;i<19001; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 20000000;
+		fn ++;
+		i += 300;
+	}
+
+	for ( int i=20000;i<100000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 1000;
+	}
+
+	for ( int i=100000;i<1000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 10000;
+	}
+
+	for ( int i=1000000;i<3000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 40000;
+	}
+
+	for ( int i=3200000;i<=5000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 100000;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Default_Value
+ *  Description:  Init the Default Value 
+ *                Before User Configrature give the board a default value
+ * =====================================================================================
+ */
+void Etio::Init_Default_Value()
+{
+	/*-----------------------------------------------------------------------------
+	 *  Default Frequence and RF LF Filter Parameters
+	 *-----------------------------------------------------------------------------*/
+	m_Imple->m_Work_Mode			       = NORMAL;
+	m_Imple->m_Sin_Channel			       = 0;
+	m_Imple->m_RF_Filter_Enable		       = false;
+	m_Imple->m_Channels_Number		       = 1;		// only one signal channel
+
+	for ( int i = 0; i < m_Imple->m_cMAXFreqAmount; i += 1 ) 
+	{
+		m_Imple->m_MediaChanFreq[i]            = 25000;
+	}
+
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		m_Imple->m_ChanMapMedia2FreqIndex[i]   = 0;
+
+		m_Imple->m_Chan_Type[i]                = CLOSE;
+		m_Imple->m_ChanFreq[i]                 = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);		// 1982: 25KHz
+
+		m_Imple->m_ChanPara[i].RfLpCoefLo      = 0xff;
+                m_Imple->m_ChanPara[i].RfLpCoefHi      = 0xff;
+
+		m_Imple->m_ChanPara[i].RfHpCoefLo      = 0x00;
+                m_Imple->m_ChanPara[i].RfHpCoefHi      = 0x00;
+
+		m_Imple->m_ChanPara[i].LfLpCoefLo      = 0xff;
+                m_Imple->m_ChanPara[i].LfLpCoefHi      = 0xff;
+
+		m_Imple->m_ChanPara[i].LfHpCoefLo      = 0x00;
+                m_Imple->m_ChanPara[i].LfHpCoefHi      = 0x00;
+
+		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeBal
+			                               = 8;
+		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeGain 
+						       = 7;
+		m_Imple->m_ChanPara[i].JobWpAmount.ChJob     
+			 			       = 0;		// Nomal ET
+
+		m_Imple->m_ChanPara[i].CoilNumforPickB = 255;		// Close all Channels
+                m_Imple->m_ChanPara[i].CoilNumforPickA = 255;
+
+		m_Imple->m_ChanPara[i].CoilNumforDriverB 
+						       = 255;
+		m_Imple->m_ChanPara[i].CoilNumforDriverA 
+			                               = 255;
+
+		if 	( i == 0 )					// Init only one Channels
+		{
+                 	m_Imple->m_ChanPara[i].CoilNumforPickA
+						       = 0;
+			m_Imple->m_ChanPara[i].CoilNumforPickB
+						       = 1;
+
+			m_Imple->m_ChanPara[i].CoilNumforDriverA 
+						       = 0;
+			m_Imple->m_ChanPara[i].CoilNumforDriverB 
+						       = 1;
+		}
+
+		m_Imple->m_High_Filter[i]              = 0;		// Close High Filter
+		m_Imple->m_Low_Filter[i]               = -1;		// Close Low Filter
+	}
+
+	for ( int i = 0; i < m_Imple->m_Channels_Number; i += 1 ) 
+	{
+		m_Imple->m_Chan_Type[i]		       = ECT;
+	}
+
+	m_Imple->m_Offset			       = 0;
+	m_Imple->m_SineAmp			       = 7;
+
+	m_Imple->m_Timer1Mode			       = false;
+	m_Imple->m_Timer2Mode			       = false;
+	Set_Timer_Mode();
+
+	Calculate_Channel_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Channel_Parameters
+ *  Description:  According to the Channel Frequence parameters to set Probe 
+ * =====================================================================================
+ */
+void Etio::Calculate_Channel_Parameters()
+{
+	unsigned short v,t;
+	int s;
+
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		if 	( m_Imple->m_Chan_Type[i] == EMS )             //  WCk=40MHz    Freq=80KHz
+		{
+			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / 40000000 - 1 );
+
+			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
+			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
+
+			v = static_cast<unsigned short>(static_cast<double>(40000000) / 80000);
+
+			t = v;                                 			//  500 pts
+
+			m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
+			m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
+
+			t = 2048 / v;
+
+			m_Imple->m_ChanPara[i].WpDeltaHi = t;
+
+			s = ( ( 2048 - v * t ) * 65536 ) / v; 
+		}
+		else
+		{
+			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck - 1 );
+
+			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
+			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
+
+			v = static_cast<unsigned short>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Frequence);
+
+			t = v % 4; 
+
+			if 	( t == 0 )
+			{
+				m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
+				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
+			}
+			else
+			{
+				m_Imple->m_ChanPara[i].WpAmount 	    = ( v + ( 4 - t ) ) & 0x00ff;
+				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( ( v + ( 4 - t ) ) >> 8 ) & 0x0f;
+			}
+
+			t = 2048 / v;
+
+			m_Imple->m_ChanPara[i].WpDeltaHi = t;
+
+			s = ( ( 2048 - v * t ) * 65536 ) / v; 
+		}
+
+		m_Imple->m_ChanPara[i].WpDeltaLo = s & 0x00ff;
+		m_Imple->m_ChanPara[i].WpDeltaMi = ( s >> 8 ) & 0x00ff;
+
+		if 	( m_Imple->m_Work_Mode == SIN && m_Imple->m_RF_Filter_Enable == false )	// enter SIN Mode disable RF-Filter
+			Disable_RFCoef(i);
+		else
+			Calculate_RFCoef(i);
+
+		Calculate_LFCoef(i);							        // calculate the LFCoef
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_RFCoef
+ *  Description:  Calculate the RF Coef 
+ * =====================================================================================
+ */
+void Etio::Calculate_RFCoef(int index)
+{
+	double T;
+	double Ft;
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		T    	  = 1 / static_cast<double>( 40000000 );
+		Ft        = 1 / static_cast<double>( 80000 );
+	}
+	else
+	{
+		T    	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
+		Ft        = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+	}
+
+	double Fc   	  = 0.3 * Ft;
+
+	double t1   	  = 2 * PI * Fc * T;
+	double temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
+	unsigned short vh = static_cast<unsigned short>(temp* 65535);
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		T    	  = 1 / static_cast<double>( 40000000 );
+		Fc        = 1 / static_cast<double>( 80000 );
+	}
+	else
+	{
+		T   	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
+		Fc   	  = 4 * static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+	}
+
+	t1   	  	  = 2 * PI * Fc * T;
+	temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
+	unsigned short vl = static_cast<unsigned short>(temp* 65535);
+
+	m_Imple->m_ChanPara[index].RfHpCoefLo
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].RfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Disable_RFCoef
+ *  Description:  When Enter RF Mode Disbale RFCoef
+ * =====================================================================================
+ */
+void Etio::Disable_RFCoef(int index)
+{
+	unsigned short vh = 0;
+	unsigned short vl = static_cast<unsigned short>(65535);
+
+	m_Imple->m_ChanPara[index].RfHpCoefLo 
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].RfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_LFCoef
+ *  Description:  Calculate the LF Coef 
+ *                注意关闭的情况
+ * =====================================================================================
+ */
+void Etio::Calculate_LFCoef(int index)
+{
+	double st;
+	int    M;
+	int   quot;
+	double T;
+	double Fc;
+	double t1;
+	double temp;
+	unsigned short vh,vl;
+
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		st	  = 1 / static_cast<double>( 80000 );
+		M      	  = static_cast<int>( static_cast<double>( 40000000 ) / \
+			    static_cast<double>( 80000 ));
+	}
+	else
+	{
+		st	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+		M      	  = static_cast<int>( static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck ) / \
+			    static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence ));
+	}
+
+	div_t result = div(400,M);
+	if 	( result.rem == 0 )
+		quot = result.quot;
+	else 
+		quot = result.quot + 1;
+
+	if 	( m_Imple->m_Chan_Type[index] == FECT )
+		T	  = 1 * quot * st;
+	else
+		T	  = 2 * quot * st;
+
+	Fc   	  = m_Imple->m_High_Filter[index] / static_cast<double>(10); 
+	t1   	  = 2 * PI * Fc * T;
+	temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
+
+	if 	( m_Imple->m_High_Filter[index] != 0 )
+	{
+		vh = static_cast<unsigned short>(temp* 65535);
+	}
+	else
+		vh = 0; 
+
+	if 	( m_Imple->m_Low_Filter[index] != -1 )
+	{
+		Fc   	  	  = m_Imple->m_Low_Filter[index] / static_cast<double>(10);
+		t1   	  	  = 2 * PI * Fc * T;
+		temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
+		vl = static_cast<unsigned short>(temp* 65535);
+	}
+	else
+		vl = static_cast<unsigned short>(65535);
+
+	m_Imple->m_ChanPara[index].LfHpCoefLo 
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].LfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].LfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].LfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Type
+ *  Description:  Set the Channel run type
+ *         type:  CLOSE|ECT|FECT|EMS
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Type(int ch,CHANTYPE type)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+		m_Imple->m_Chan_Type[ch] = type;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Amount
+ *  Description:  Set the device work channels 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Amount(int v)
+{
+	if 	( v <= m_Imple->m_MAX_Channels )
+		m_Imple->m_Channels_Number = v;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Frequence_Value
+ *  Description:  Set the Channel's value 
+ *  	     ch:  0-7
+ *  	      v:  10~5MHz 
+ *  	          Notice it is index value
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Frequence_Value(int ch,int v)
+{
+	if 	( ch >= 0 && ch <= 7 )
+		m_Imple->m_MediaChanFreq[ch] = v;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Map_Index
+ *  Description:  
+ *           ch:  0~127
+ *     mapindex:  0~m_cMAXFreqAmount 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Map_Index(int ch,int mapindex)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+		m_Imple->m_ChanMapMedia2FreqIndex[ch] = mapindex;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_ProbeGain
+ *  Description:  Set the the Channels ProbeGain 
+ *  	     ch:  0~127
+ *  	     v:   0~7
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_ProbeGain(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 7 )
+			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeGain = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_ProbeBalance
+ *  Description:  Set the Probe balance parameters 
+ *           ch:  0~127
+ *            v:  0~15
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_ProbeBalance(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 15 )
+			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeBal= v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforPickA
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforPickA(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforPickA = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforPickB
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforPickB(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforPickB = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforDriverA
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforDriverA(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforDriverA = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforDriverB
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforDriverB(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforDriverB = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_HighFilter
+ *  Description:  Set the Channels Paramters High Filte
+ *           ch:  0~127
+ *            v:  0,  0.1~100Hz  ( 1~1000 )  step 0.1Hz ( 1 )
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_HighFilter(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v == 0 )
+			m_Imple->m_High_Filter[ch] = v;
+		else if ( v >= 1 && v <= 1000 ) 
+			m_Imple->m_High_Filter[ch] = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_LowFilter
+ *  Description:  Set the Channels Paramters Low Filte
+ *           ch:  0~127
+ *            v:  -1  10~2000Hz (100~20000) step 1Hz
+ *
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_LowFilter(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v == -1 )
+			m_Imple->m_Low_Filter[ch] = v;
+		else if ( v >= 100 && v <= 20000 ) 
+			m_Imple->m_Low_Filter[ch] = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Offset
+ *  Description:  Set the offset of Device 
+ *        value:  -100 ~ 100 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Offset(int value)
+{
+	if 	( value >= -100 && value <= 100 )
+		m_Imple->m_Offset = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_SineAmplitude
+ *  Description:  Set the Sine Amplitude value into media layer 
+ *        value:  0~7:    1~8V
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_SineAmplitude(int value)
+{
+	if 	( value >= 0 && value <= 7 )
+		m_Imple->m_SineAmp = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Sin_Point_Amount
+ *  Description:  Get the Sin Point Amount
+ * =====================================================================================
+ */
+int Etio::Get_Sin_Point_Amount(int chan)
+{
+	int M;
+	if ( m_Imple->m_Chan_Type[chan] == EMS )
+		M = 500; 
+	else
+		M = static_cast<int>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Frequence);
+
+	div_t re = div(M,256); 
+
+	int CptRate = 0;
+	if 	( re.rem == 0 )
+		CptRate = re.quot;
+	else
+		CptRate = re.quot + 1;
+
+	re = div(M,CptRate);
+
+	if 	( re.rem == 0 )
+		return re.quot;
+	else
+		return re.quot + 1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Sin_Data
+ *  Description:  Sample the SIN Function 
+ * =====================================================================================
+ */
+bool Etio::Sample_Sin_Data(int* data,int len)
+{
+	int addr;
+	uint8_t t1,t2,t3,t4;
+
+	if 	( PEEKB_TC(0x006) & 0x01 == true )
+		return false;
+
+	addr = 0x1000;
+
+	m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+	m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+	for ( int i = 0; i < len; i += 1 ) 
+	{
+		t1 = m_Imple->m_pET[0x0a];
+		t2 = m_Imple->m_pET[0x0a];
+		t3 = m_Imple->m_pET[0x0a];
+		t4 = m_Imple->m_pET[0x0a];
+
+		data[i] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+	}
+
+	POKEB_TC(0x020,0x01);		// restart next sample
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequence_Index
+ *  Description:  Return the Frequence value index 
+ * =====================================================================================
+ */
+int Etio::Get_Frequence_Index(int frequnce)
+{
+	for ( int i=0;i< m_Imple->m_FREQVALUEN_40MHz;i++ )
+	{
+		if ( frequnce == m_Imple->m_FreqValue[i].Frequence )
+			return i;
+	}
+	printf ( "No Found Freq\n" );
+	return 100;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequence
+ *  Description:  Get the Frequecen of given index 
+ * =====================================================================================
+ */
+int Etio::Get_Frequence(int index)
+{
+	return m_Imple->m_FreqValue[index].Frequence;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Work_Mode
+ *  Description:  Set the Work Mode of FPGA 
+ * =====================================================================================
+ */
+void Etio::Set_Work_Mode(FUNMODE mode)
+{
+	m_Imple->m_Work_Mode = mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Work_Mode
+ *  Description:  Get the Work Mode
+ * =====================================================================================
+ */
+Etio::FUNMODE Etio::Get_Work_Mode()
+{
+	return m_Imple->m_Work_Mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Select_Sin_Channel
+ *  Description:  Select Sin Channel of FPGA
+ * =====================================================================================
+ */
+void Etio::Interface_Select_Sin_Channel(int ch)
+{
+	if ( ch >= 0 && ch <= 128 )
+		m_Imple->m_Sin_Channel = ch;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Get_Sin_Channel
+ *  Description:  Get the Sin Channel 
+ * =====================================================================================
+ */
+int Etio::Interface_Get_Sin_Channel()
+{
+	return m_Imple->m_Sin_Channel;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Max_Frequence_Length
+ *  Description:  Return the Max Frequence Length 
+ * =====================================================================================
+ */
+int  Etio::Get_Max_Frequence_Length()
+{
+	return m_Imple->m_FREQVALUEN_40MHz;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Version
+ *  Description:  Get the Module Version 
+ * =====================================================================================
+ */
+int  Etio::Get_Version()
+{
+	return m_Imple->m_Version;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_DataN
+ *  Description:  return the Sample Data Length 
+ * =====================================================================================
+ */
+int Etio::Sample_DataN()
+{
+	if 	( m_Imple->m_Work_Mode == Etio::NORMAL )
+		return m_Imple->m_Channels_Number<<1;
+	else if ( m_Imple->m_Work_Mode == Etio::SIN )
+		return Get_Sin_Point_Amount(m_Imple->m_Sin_Channel);
+	else
+		return 2;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Chan_Type
+ *  Description:  Set each Channel type and calculate the m_Imple->m_Channels_Number
+ * =====================================================================================
+ */
+void Etio::Set_Chan_Type()
+{
+	int num = 0;
+
+	for ( int i = 0; i < m_Imple->m_MAX_Channels; i += 1 ) 
+	{
+		if 	( m_Imple->m_Chan_Type[i] != CLOSE )
+		{
+			num ++;
+			switch ( m_Imple->m_Chan_Type[i] )
+			{
+				case ECT:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+					break;
+
+				case FECT:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 1;
+					break;
+
+				case EMS:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 2;
+					break;
+
+				default:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+					break;
+			}				/* -----  end switch  ----- */
+		}
+		else
+			m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+	}
+
+	m_Imple->m_Channels_Number = num;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_RF_Filter_Enable_Switch
+ *  Description:  Set the flag that indicate whether to calculate RF parameters 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_RF_Filter_Enable_Switch(bool flag)
+{
+	m_Imple->m_RF_Filter_Enable = flag;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Get_Channels_Fun
+ *  Description:  Only get the signal Channel work mode
+ * =====================================================================================
+ */
+int Etio::Interface_Get_Channels_Fun(int ch)
+{
+	switch ( m_Imple->m_Chan_Type[ch] ) 
+	{
+		case CLOSE:	
+			return 0;
+			break;
+
+		case ECT:	
+			return 1;
+			break;
+
+		case FECT:	
+			return 2;
+			break;
+
+		case EMS:	
+			return 3;
+			break;
+
+		default:	
+			return 1;
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Convert_Media_FreqValue_To_Inside_FreqIndex
+ *  Description:  Convert Data Buffer to Inside Frequence index
+ * =====================================================================================
+ */
+void Etio::Convert_Media_FreqValue_To_Inside_FreqIndex()
+{
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		m_Imple->m_ChanFreq[i] = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Timer_Mode
+ *  Description:  Set the Timer1 and Timer2 work mode 
+ * =====================================================================================
+ */
+void Etio::Set_Timer_Mode()
+{
+	if 	( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == false )
+		POKEB_TC(0x23,0x00);
+	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == true )
+		POKEB_TC(0x23,0x06);
+	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == false )
+		POKEB_TC(0x23,0x02);
+	else if ( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == true )
+		POKEB_TC(0x23,0x04);
+	else
+		POKEB_TC(0x23,0x00);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Timers_Mode
+ *  Description:  Set the Timers Work Mode  
+ *         Note:  index:0~Timer1
+ *                      1~Timer2
+ *                flag: f~Normal
+ *			t~scan1A clean
+ *			  scan2A clean
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Timers_Mode(int index,bool flag)
+{
+	if 	( index == 0 )
+		m_Imple->m_Timer1Mode = flag;
+	else if ( index == 1 )
+		m_Imple->m_Timer2Mode = flag;
+}
diff --git a/src/EVA11/base/etio.h b/src/EVA11/base/etio.h
new file mode 100644
index 0000000..3174811
--- /dev/null
+++ b/src/EVA11/base/etio.h
@@ -0,0 +1,169 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  etio.h
+ *
+ *    Description:  Declearation of etio class
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月18日 11时40分11秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ETIO_INC
+#define  _ETIO_INC
+
+#include 	<memory>	
+#include 	<stdint.h>
+
+class Etio
+{
+	public:
+		static Etio* Instance();
+
+		enum FUNMODE 
+		{
+			NORMAL  = 	0,
+			SIN     =       1,
+		};
+		typedef enum FUNMODE FUNMODE;
+
+		enum SAMPLETYPE                 	/* Smaple data mode  */
+		{
+			RAWECT	=	0,		//  only X Y 
+			RAWEMS	=	1,		//  only X
+			ALLECT	=	2,		//  X Y INT EXT1 EXT2
+			ALLEMS  =       3,		//  X 0 INT EXT1 EXT2
+			TIMERS  =       4,              //  INT EXT1 EXT2
+		};
+		typedef enum SAMPLETYPE SAMPLETYPE;
+
+		enum CHANTYPE 				/* define the channels type */
+		{
+			CLOSE   =        0,
+			ECT     =        1,
+			FECT    =        2,
+			EMS     =        3
+		};
+		typedef enum CHANTYPE CHANTYPE;
+
+		/*-----------------------------------------------------------------------------
+		 *  module interface
+		 *-----------------------------------------------------------------------------*/
+		int Version();
+		bool InitiateETIO();
+		void UnInitiateETIO();
+
+		/*-----------------------------------------------------------------------------
+		 *  base function interface
+		 *-----------------------------------------------------------------------------*/
+		uint8_t GKey();
+		void Set_ET();
+		void Clear_Timers(int);
+		void POKEB_TC(int add,uint8_t value);
+		uint8_t PEEKB_TC(int add);
+
+		/*-----------------------------------------------------------------------------
+		 *  parameters sets interface,only used by users 
+		 *-----------------------------------------------------------------------------*/
+		void Interface_Set_Channels_Type(int,CHANTYPE);
+		void Interface_Set_Channels_Amount(int);
+		void Interface_Set_Channels_Frequence_Value(int,int);
+		void Interface_Set_Channels_Map_Index(int,int);
+
+		void Interface_Set_Channels_ProbeGain(int,int);
+		void Interface_Set_Channels_ProbeBalance(int,int);
+
+		void Interface_Set_Channels_CoilNumforPickA(int,int);
+		void Interface_Set_Channels_CoilNumforPickB(int,int);
+		void Interface_Set_Channels_CoilNumforDriverA(int,int);
+		void Interface_Set_Channels_CoilNumforDriverB(int,int);
+
+		void Interface_Set_Channels_HighFilter(int,int);
+		void Interface_Set_Channels_LowFilter(int,int);
+
+		void Interface_Set_Channels_Offset(int);
+		void Interface_Set_Channels_SineAmplitude(int);
+
+		void Interface_Set_RF_Filter_Enable_Switch(bool);
+		int Interface_Get_Channels_Fun(int);
+
+		void Interface_Set_Timers_Mode(int,bool);
+
+		void Interface_Select_Sin_Channel(int);
+		int  Interface_Get_Sin_Channel();
+
+		int Get_Frequence_Index(int);
+		int Get_Frequence(int);
+		int  Get_Max_Frequence_Length();
+
+		bool Sample_Chan_Data(int* data,SAMPLETYPE st = RAWECT);
+		int Get_Sin_Point_Amount(int);
+		bool Sample_Sin_Data(int* data,int len);
+
+		void Init_Default_Value();
+
+		void Set_Work_Mode(FUNMODE);
+		FUNMODE Get_Work_Mode();
+		int Sample_DataN();
+
+		/*-----------------------------------------------------------------------------
+		 *  Module Version
+		 *-----------------------------------------------------------------------------*/
+		int  Get_Version();
+	protected:
+
+	private:
+		Etio();                              	   /* constructor */
+		~Etio ();                             	   /* destructor */
+		Etio( const Etio& );
+		Etio& operator = (const Etio&);
+
+		friend class std::auto_ptr<Etio>;
+		static std::auto_ptr<Etio>		m_Instance;
+
+
+		void Load_Board_Information();
+		void Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA);
+
+		void Set_WparamRam_Into_FPGA(int);
+
+		void Refresh_Board_Status();
+
+		void Power(bool);
+		void Running(bool);
+		void Restart();
+
+		void Set_Chan_Amount(int);
+
+		void Init_Frequence_Value();
+		void Calculate_Channel_Parameters();
+		void Calculate_RFCoef(int);
+		void Calculate_LFCoef(int);
+		void Disable_RFCoef(int);
+
+		void Set_Chan_Type();
+		void Set_AdOffset(int);
+		void Set_SineAmplitude(int);
+		void Set_Timer_Mode();
+
+		void Convert_Media_FreqValue_To_Inside_FreqIndex();
+
+	private:
+		struct PImpl;
+		struct WPARAMS;
+		struct JOBAMOUNT;
+		struct PROBBALGAIN;
+		struct BOARDSTATUS;
+		struct FREQUENCESTR;
+
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif   /* ----- #ifndef _ETIO_INC  ----- */
diff --git a/src/EVA11/base/main.cpp b/src/EVA11/base/main.cpp
new file mode 100644
index 0000000..a9a6442
--- /dev/null
+++ b/src/EVA11/base/main.cpp
@@ -0,0 +1,394 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  main.cpp
+ *
+ *    Description:  Main function define file 
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月05日 09时44分45秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+#ifndef _MAIN_FILE
+#define _MAIN_FILE
+
+#include 	<cstdlib>
+#include 	<cstdio>
+#include	<iostream>	
+
+#include 	<gsl/gsl_integration.h>
+
+#include 	"ShellCommand.h"
+
+#include	"Basewin.h"
+#include	"Loadwin.h"
+#include	"Mainwin.h"
+#include	"Global.h"	
+#include 	"Initfacade.h"
+#include 	"TCPMainwin.h"
+#include 	"Log.h"
+
+#include 	"Graphic.h"
+
+#include 	<SDL.h>
+#include 	<SDL/SDL_gfxPrimitives.h>
+#include 	<SDL/SDL_gfxBlitFunc.h>
+#include 	<SDL/SDL_rotozoom.h>
+#include 	<SDL/SDL_image.h>
+
+#include 	"Uart.h"
+#include 	"Gif.h"
+#include 	"Resource.h"
+
+#include 	<boost/timer.hpp>
+//#include 	<random.h>
+//#include 	<sort.h>
+
+#include 	<zthread/Thread.h>
+/*-----------------------------------------------------------------------------
+ * the thread be used to calculate my tick system
+ *-----------------------------------------------------------------------------*/
+class TimeTickThread : public ZThread::Runnable
+{
+public:
+	bool	m_SelfEndFlag;
+public:
+	TimeTickThread()
+	{
+		m_SelfEndFlag = false;
+	}
+	bool Get_EndFlag() { return m_SelfEndFlag; }
+	void run()
+	{
+		Global* gp = Global::Instance();
+		while ( !gp->bTickStop )
+		{
+			if ( !gp->bTickPasuse )
+				gp->Tick ++;
+			ZThread::Thread::sleep(1000);  // sleep 1 second
+		}
+		m_SelfEndFlag = true;
+		std::cout<<"thread exit"<<std::endl;
+	}
+};
+
+#ifdef ARM9
+extern "C"
+{
+	void Asm_Init(void);
+	int Asm_Add(int,int);
+	int Asm_Mul(int,int);
+	int Asm_Point(int*);
+}
+#endif
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Standard_ET_Fun
+ *  Description:  Real Program Enter pointer
+ * =====================================================================================
+ */
+	void
+Standard_ET_Fun()
+{
+//	Asm_Init();
+//	printf("%x \n",Asm_Add(1,2));
+//	printf("%d \n",Asm_Mul(15,20));
+//	int temp = 2;
+//	Asm_Point(&temp);
+//	printf("%d \n",temp);
+
+//	const int SIZE = 10;
+//	splab::Vector<int> a( SIZE );
+//
+//	for ( int i = 0; i < SIZE; i += 1 ) 
+//	{
+//		a[i] = splab::randu(22,0,100);
+//		printf ( "%d\n",a[i] );
+//	}
+
+//	splab::selectSort(a,0,a.size()-1);
+//
+//	for ( int i = 0; i < SIZE; i += 1 ) 
+//	{
+//		printf ( "%d\n",a[i] );
+//	}
+
+	Log *log = Log::Instance();
+	log->Write_Log("EVA11 System Starting....");
+
+	Initfacade* initfacade = new Initfacade;
+	if  	( initfacade->Standard_ET_System_Init() == false )
+	{
+		Global* gp = Global::Instance();
+		gp->bTickStop = true;
+		return;
+	}
+
+	Graphic *g = Graphic::Instance(); 
+
+MAINLOOP:
+	Loadwin *loadw = new Loadwin(*g,Loadwin::LT_LOAD);
+	int result = loadw->Loopwindow(*g);
+	delete loadw;
+	loadw = NULL; 
+	if 	( result == Basewin::CO_OK || result == Basewin::CO_LOADEXIT )
+	{
+		Mainwin *mwin = new Mainwin;
+		mwin->Loopwindow(*g);
+		delete mwin;
+		mwin = NULL;
+		goto MAINLOOP;
+	}
+
+	initfacade->Standard_ET_System_Destroy();
+	delete initfacade;
+	initfacade = NULL;
+	log->Write_Log("EVA11 System Exit....");
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Standard_Network_TCP
+ *  Description:  Run Network function based on TCP protocol 
+ * =====================================================================================
+ */
+	void
+Standard_Network_TCP()
+{
+	printf ( "tcp netowrk work mode start, but no finish\n" );
+
+	Initfacade* initfacade = new Initfacade;
+	if  	( initfacade->Standard_TCP_System_Init() == false )
+		return;
+
+	Graphic *g = Graphic::Instance(); 
+
+	TCPMainwin* tcpwin = new TCPMainwin;
+	tcpwin->Loopwindow(*g);
+	delete tcpwin;
+	tcpwin = NULL;
+	initfacade->Standard_TCP_System_Destroy();
+	delete initfacade;
+	initfacade = NULL;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Standard_SDL_Fun
+ *  Description:  Used for test SDL function 
+ * =====================================================================================
+ */
+//double f(double x,void* param)
+//{
+//	double alpha = *(double *)param;
+//	double f     = alpha * x * x; 
+//	return f;
+//}
+
+	void
+Standard_SDL_Fun()
+{
+//	boost::timer t;
+//	for ( int m = 0; m < 100; m += 1 ) 
+//	{
+//
+//		for ( volatile int i = 0; i < 640; i += 1 )
+//		{
+//			for ( volatile int j = 0; j < 480; j += 1 )
+//			{
+//				g->Setpixel(i,j,0x00);
+//			}
+//		}
+//	}
+//
+//	printf ( "graphic second %d\n",t.elapsed() );
+//
+//	g->Closegraph();
+//	delete g;
+//	g = NULL;
+
+
+//	gsl_integration_workspace *w = gsl_integration_workspace_alloc(1000);
+//
+//	gsl_function F;
+//	F.function   = &f;
+//
+//	double alpha = 1.0;
+//	F.params     = &alpha;
+//
+//	double result,error;
+//	gsl_integration_qags(&F,3,5,0,1e-7,1000,w,&result,&error);
+//
+//	printf ( "%f\n",result );
+//	printf ( "%f\n",error );
+//	printf ( "%d\n",w->size );
+//	printf ( "%.20f\n",1e-20 );
+//
+//	gsl_integration_workspace_free(w);
+
+//	splab::Vector<int> a(10);
+//	for ( int i=0;i<10;i++ )
+//	{
+//		a[i] = splab::randu(67,1,100);
+//		printf ( "%d\n",a[i] );
+//	}
+//
+//	quickSort(a,0,a.size()-1);
+//
+//	for ( int i=0;i<10;i++ )
+//	{
+//		printf ( "%d\n",a[i] );
+//	}
+
+//	if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
+//	{
+//		printf("SDL init fail: %s\n",SDL_GetError());
+//		return ;
+//	}
+//
+//	SDL_Surface *scr = NULL;
+//	scr = SDL_SetVideoMode(640,480,16,SDL_SWSURFACE);
+//	if ( scr == NULL )
+//	{
+//		printf("SDL set video mode fail: %s\n",SDL_GetError());
+//		return ;
+//	}
+//
+//	int color;
+//	for ( int i=0;i<480;i++ )
+//	{
+//		for ( int j=0;j<640;j++ )
+//		{
+//			*((short *)scr->pixels+i*scr->pitch/2+j) = SDL_MapRGB(scr->format,color,0,0); 
+//			color ++;
+//			if ( color == 256 )
+//				color = 0;
+//		}
+//	}
+//
+//	roundedBoxColor(scr,440,0,639,100,15,0xffffffff);
+//	stringColor(scr,100,100,"Hello the world 中华 RGB-2312",0xffffffff);
+//
+//	pixelColor(scr,100,20,0xffffff00);
+//	pixelColor(scr,100,21,0xffffff00);
+//	pixelColor(scr,100,22,0xffffff00);
+
+//	div_t result = div(416,32); 
+//	printf ( "quot = %d\n",result.quot );
+//	printf ( "remain = %d\n",result.rem );
+
+//	Uart uart;
+//	uart.Init_Uart();
+
+//	uint8_t data[100];
+//	for ( int i = 0; i < 100; i += 1 ) 
+//	{
+//		data[i] = 0x50+i; 
+//	}
+//
+//	uart.Send_Data(data,100);
+//	uart.Destory_Uart();
+
+//	SDL_UpdateRect(scr,0,0,639,479);
+//	SDL_Delay(5000);
+//
+//	SDL_Quit();
+	
+
+	Graphic *g = Graphic::Instance(); 
+	if 	( g->Initgraph() == false ) 
+	{
+		perror("Error! Can't init the environment");
+		return ;
+	}
+
+	Resource *res = Resource::Instance();
+	res->Show_Resource_Gif(12,2,80,160,120);
+
+	g->Closegraph();
+
+
+//	if ( SDL_Init(SDL_INIT_EVERYTHING) == -1 ){
+//		perror(SDL_GetError());
+//		return ;
+//	}
+//
+//	SDL_Window *win = NULL;
+//	win = SDL_CreateWindow("Hello World!", 100, 100, 640, 480, SDL_WINDOW_SHOWN);
+//	if (win == NULL){
+//		std::cout << SDL_GetError() << std::endl;
+//		return ;
+//	}
+//
+// 	SDL_DestroyWindow(win);
+//	SDL_Quit();
+
+	return ;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Signal_Interrupt
+ *  Description:  When User enter ctrl-C button call this function 
+ * =====================================================================================
+ */
+void Signal_Interrupt(int n,siginfo_t *psiginfo,void *myact)
+{
+	printf("signal number:%d\n",n);			/* * 打印出信号值 **/  
+	printf("siginfo signo:%d\n",psiginfo->si_signo); /* * siginfo结构里保存的信号值 **/  
+	printf("siginfo errno:%d\n",psiginfo->si_errno); /* * 打印出错误代码 **/  
+	printf("siginfo code:%d\n",psiginfo->si_code);   /* * 打印出出错原因 **/  
+	exit(0);
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  main
+ *  Description:  Program Enter pointer 
+ * =====================================================================================
+ */
+	int
+main ( int argc, char *argv[] )
+{
+	struct sigaction act;  
+	sigemptyset(&act.sa_mask);     				/* * 清空阻塞信号 **/  
+	act.sa_flags = SA_SIGINFO;     				/* * 设置SA_SIGINFO 表示传递附加信息到触发函数 **/  
+	act.sa_sigaction = Signal_Interrupt;  
+	if	( sigaction(SIGINT,&act,NULL) < 0 )  
+	{
+		perror("install signal error\n");  
+	}
+
+	ShellCommand *shc = new ShellCommand();
+	shc->SetVer(PROVERSION);
+	ShellCommand::SHELLCOMMAND command = shc->Analyze(argc,argv);
+	delete shc;
+	shc = NULL;
+
+	if 	( command == ShellCommand::SHELLCOMMAND_NORMAL )
+	{
+		TimeTickThread *pthread = new TimeTickThread;
+		ZThread::Thread t(pthread);
+		Standard_ET_Fun();
+		while( !pthread->Get_EndFlag() )
+			usleep(500);				// need some time to excute other thread
+	}
+	else if ( command == ShellCommand::SHELLCOMMAND_TCPNETWORK )
+	{
+		Standard_Network_TCP();
+	}
+	else if ( command == ShellCommand::SHELLCOMMAND_SDL )
+	{
+		Standard_SDL_Fun();
+	}
+
+	return EXIT_SUCCESS;
+}
+#endif
diff --git a/src/EVA11/base/main.h b/src/EVA11/base/main.h
new file mode 100644
index 0000000..1fd1f70
--- /dev/null
+++ b/src/EVA11/base/main.h
@@ -0,0 +1,123 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  main.h
+ *
+ *    Description:  工程使用头文件放置常量以及类型定义
+ *
+ *        Version:  1.0
+ *        Created:  2012年06月05日 15时36分53秒
+ *       Revision:  none
+ *       Compiler:  gcc-arm
+ *
+ *         Author:  kevin.wang
+ *        Company:  eddysun
+ *
+ * =====================================================================================
+ */
+#ifndef _MAINHEAD_
+#define _MAINHEAD_
+
+#define PROVERSION 	"1.01"
+#define PAR_FILE_PATH	"/var/1"
+
+#ifdef ARM9
+#define FONT_FILE_PATH  "/tmp/wqy-zenhei.ttc"
+#else
+#define FONT_FILE_PATH  "wqy-zenhei.ttc"
+#endif
+
+//#define CALSAMPLE				     /* calculate the sample ratio */
+
+/*-----------------------------------------------------------------------------
+ *  Define the platform flag
+ *-----------------------------------------------------------------------------*/
+//#define _ARM_ 
+#define _X86_
+/*-----------------------------------------------------------------------------
+ *  Define Hardware -- Device type
+ *-----------------------------------------------------------------------------*/
+#define _SMART_308_
+/*-----------------------------------------------------------------------------
+ *  keyboard mapping marc, becareful the marc must be only one
+ *-----------------------------------------------------------------------------*/
+#ifdef X86
+#define _KEY_PC_                                      /* Used the PC keyboard */
+#else
+#define _KEY_PC_                                      /* Used the PC keyboard */
+//#define _KEY_308_A_                                     /* EVA11 Array keyboard two board */
+//#define _KEY_308_1_                                   /* Smart-308 keyboard just only one board */
+//#define _KEY_308_2_                                   /* Smart-308 keyboard two board */
+#endif
+
+#include 	"ProjectFixHead.h"
+
+/*-----------------------------------------------------------------------------
+ * The const variable as follow were used by programe during runtime 
+ *-----------------------------------------------------------------------------*/
+/*-----------------------------------------------------------------------------
+ *  The path used by application
+ *-----------------------------------------------------------------------------*/
+#define HELP_PATH		"/tmp/EVA/HELP/"            /* The path saving the help document */
+#define DATA_PATH		"/tmp/EVA/DATA/"            /* The path saving the Eddy testing data*/
+#define PARA_PATH               "/tmp/EVA/PARA/"            /* The path saving the parameters of device */
+#define PIC_PATH                "/tmp/EVA/PIC/"             /* The path saving the parameters of device */
+#define LOG_PATH		"/tmp/EVA/LOG/"
+#define DB_PATH			"/tmp/EVA/DB/"
+
+#ifdef  ARM9
+#define RUN_PATH                "/jffs2/ET/"                /* The application running envirenment */
+#else
+#define RUN_PATH                "./"                	    /* The application running envirenment */
+#endif
+
+#define MAIN_PATH               "/jffs2/"                   /* The Main program */
+#define PBM_PATH		"/tmp/EVA/"                 /* Save the PBM picture temprary used by print */
+#define APP_READY_PATH          "/tmp/EVA/"                 /* When update the application,cp the program to this */
+
+#define HELP_PATH_RU            "/mnt/eva/help/"            /* The usb help directory */
+#define DATA_PATH_RU            "/mnt/eva/data/"	
+#define PARA_PATH_RU            "/mnt/eva/para/"
+#define PIC_PATH_RU             "/mnt/eva/pic/"
+#define LOG_PATH_RU		"/tmp/eva/log/"
+#define DB_PATH_RU		"/tmp/eva/db/"
+
+#define RUN_PATH_RU             "/mnt/eva/"                 /* The usb remote directory */
+
+#define	LOGDIRECTORY            LOG_PATH
+/*-----------------------------------------------------------------------------
+ *  Globle variables define 
+ *-----------------------------------------------------------------------------*/
+#ifdef _MAIN_FILE
+#define EXTF
+#else
+#define EXTF extern
+#endif
+/*-----------------------------------------------------------------------------
+ *  Color variables define
+ *-----------------------------------------------------------------------------*/
+EXTF COLORTYPE           g_SHADOW_CO;
+EXTF COLORTYPE           g_LIGHT_CO;
+
+EXTF COLORTYPE           g_BATTARY_CO;
+
+EXTF COLORTYPE           g_BUTXNO_CO;
+EXTF COLORTYPE           g_BUTXFO_CO;
+EXTF COLORTYPE           g_BUBGNO_CO;
+EXTF COLORTYPE           g_BUBGFO_CO;
+
+EXTF COLORTYPE           g_MAINBG_CO;
+EXTF COLORTYPE           g_MAINFG_CO;
+EXTF COLORTYPE           g_BUFFFG_CO;
+
+EXTF COLORTYPE           g_MOVBBG_CO;
+EXTF COLORTYPE           g_MOVBFG_CO;
+EXTF COLORTYPE           g_MOVBTX_CO;
+
+EXTF COLORTYPE           g_SCBG_CO;
+EXTF COLORTYPE           g_SCFG_CO;
+EXTF COLORTYPE           g_SCTX_CO;
+
+EXTF COLORTYPE		 g_Pen[32];                        /* It mapped to 224-255 32 pallates */
+
+#endif   /* ----- #ifndef _MAINHEAD_INC  ----- */
diff --git a/src/EVA11/cssl.c b/src/EVA11/cssl.c
deleted file mode 100644
index a287d0a..0000000
--- a/src/EVA11/cssl.c
+++ /dev/null
@@ -1,564 +0,0 @@
-/* Copyright 2003 Marcin Siennicki <m.siennicki@cloos.pl>
- * see COPYING file for details */
-#define _GNU_SOURCE
-
-#include <stdio.h>
-
-#include <string.h>
-#include <termios.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include "cssl.h"
-
-/*
- * Static variables and constants
- */
-
-/* signal number for serial i/o read */
-static int CSSL_SIGNAL=0;
-
-/* boolean that say if we have started cssl */
-static int cssl_started=0;
-
-/* sigactions */
-static struct sigaction sa;
-static struct sigaction oldsa;
-
-/* head of the cssl_t list */
-static cssl_t *head=0;
-
-/* error messages table */
-static const char *cssl_errors[]= {
-    "cssl: OK",
-    "cssl: there's no free signal",
-    "cssl: not started",
-    "cssl: null pointer",
-    "cssl: oops",
-    "cssl: out of memory",
-    "cssl: cannot open file"
-};
-
-/* status of last cssl function */ 
-static cssl_error_t cssl_error=CSSL_OK;
-
-/* prototype of signal handler */
-static void cssl_handler(int signo, siginfo_t *info, void *ignored);
-
-
-/**************************************
- * Public functions
- **************************************/
-
-/*-------------------------------------
- * Error handling
- */
-
-/* gets the last operation status message */
-const char *cssl_geterrormsg()
-{
-    return cssl_errors[cssl_error];
-}
-
-
-/* gets the last error code */
-int cssl_geterror()
-{
-    return cssl_error;
-}
-
-/*-------------------------------------
- * Startig/stoping cssl
- */
-
-/* starts cssl */
-void cssl_start()
-{
-    int sig;
-
-    if (cssl_started) {
-	return;
-    }
-
-    /* Here we scan for unused real time signal */
-    sig=SIGRTMIN;
-
-    do {
-	
-	/* get old sigaction */
-	sigaction(sig,0,&oldsa);
-	
-	/* if signal's handler is empty */
-	if (oldsa.sa_handler == 0) 
-	{
-	    /* set the signal handler, and others */
-	    CSSL_SIGNAL=sig;
-	    sa.sa_sigaction = cssl_handler;
-	    sa.sa_flags = SA_SIGINFO;
-	    sa.sa_restorer = NULL;
-	    sigemptyset(&sa.sa_mask);
-	    sigaction(CSSL_SIGNAL,&sa,0);
-
-	    /* OK, the cssl is started */
-	    cssl_started=1;
-	    cssl_error=CSSL_OK;
-	    return;
-	} else {
-	    /* signal handler was not empty, 
-	       restore original */
-	    sigaction(CSSL_SIGNAL,&oldsa,0);
-	}
-	sig++;
-    } while(sig<=SIGRTMAX);
-    
-
-    /* Sorry, there's no free signal */
-    cssl_error=CSSL_ERROR_NOSIGNAL;
-    
-}
-
-/* stops the cssl */
-void cssl_stop()
-{
-    /* if not started we do nothing */
-    if (!cssl_started)
-	return;
-
-    /* we close all ports, and free the list */
-    while (head)
-	cssl_close(head);
-
-    /* then we remove the signal handler */
-    sigaction(CSSL_SIGNAL,&oldsa,NULL);
-
-    /* And at least : */
-    cssl_started=0;
-    cssl_error=CSSL_OK;
-}
-
-/*-------------------------------------
- * Basic port operation - open/close
- */
-
-
-/* opens the port */
-cssl_t *cssl_open(const char *fname,
-		  cssl_callback_t callback,
-		  int id,
-		  int baud,
-		  int bits,
-		  int parity,
-		  int stop)
-{
-    cssl_t *serial;
-
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return NULL;
-    }
-    
-    /* create new cssl_t structure */
-    serial=calloc(1,sizeof(cssl_t));
-
-    /* oops, no memory */
-    if (!serial) {
-	cssl_error=CSSL_ERROR_MEMORY;
-	return 0;
-    }
-
-    /* opening the file */
-    if(callback) {
-	/* user wants event driven reading */
-	serial->fd=open(fname,O_RDWR|O_NOCTTY|O_NONBLOCK);
-	fcntl(serial->fd,F_SETSIG,CSSL_SIGNAL);
-	fcntl(serial->fd,F_SETOWN,getpid());
-	fcntl(serial->fd,F_SETFL,O_ASYNC|O_NONBLOCK);
-    } else {
-	/* the read/write operations will be bloking */
-	serial->fd=open(fname,O_RDWR|O_NOCTTY);
-    }
-
-    /* oops, cannot open */
-    if (serial->fd == -1) {
-	cssl_error=CSSL_ERROR_OPEN;
-	free(serial);
-	return NULL;
-    }
-
-    /* we remember old termios */
-    tcgetattr(serial->fd,&(serial->oldtio));
-    
-    /* now we set new values */
-    cssl_setup(serial,baud,parity,bits,stop);
-
-    /* and id */
-    serial->id=id;
-
-    /* then set the callback */
-    serial->callback=callback;
-    
-    /* we add the serial to our list */
-    serial->next=head;
-    head=serial;
-	
-    cssl_error=CSSL_OK;
-
-    return serial;
-}
-
-
-/* closes file, removes serial from the list and frees it */
-void cssl_close(cssl_t *serial)
-{
-    cssl_t *cur;
-    
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }
-    
-    /* first we flush the port */
-    tcflush(serial->fd,TCOFLUSH); 
-    tcflush(serial->fd,TCIFLUSH); 
-    
-    /* then we restore old settings */
-    tcsetattr(serial->fd,TCSANOW,&(serial->oldtio));
-    
-    /* and close the file */
-    close(serial->fd);
-    
-    /* now we can remove the serial from the list */
-
-    if (head==serial) {
-	head=serial->next;
-	free(serial);
-	cssl_error=CSSL_OK;
-	return;
-    }
-
-    for (cur=head;cur;cur=cur->next) {
-	if (cur->next==serial) {
-	    cur->next=serial->next;
-	    free(serial);
-	    cssl_error=CSSL_OK;
-	    return;
-	}
-    }
-
-    /* we should never reach there,
-       it means, that serial was not found in the list */
-    cssl_error=CSSL_ERROR_OOPS;
-}
-
-/*-------------------------------------
- * Port setup
- */
-
-/* sets up the port parameters */
-void cssl_setup(cssl_t *serial,
-		   int baud,
-		   int bits,
-		   int parity,
-		   int stop)
-{
-    tcflag_t baudrate;
-    tcflag_t databits;
-    tcflag_t stopbits;
-    tcflag_t checkparity;
-
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }    
-
-    /* get the propr baudrate */
-    switch (baud) {
-    case 75:
-	baudrate=B75;
-	break;
-    case 110:
-	baudrate=B110;
-	break;
-    case 150:
-	baudrate=B150;
-	break;
-    case 300:
-	baudrate=B300;
-	break;
-    case 600:
-	baudrate=B600;
-	break;
-    case 1200:
-	baudrate=B1200;
-	break;
-    case 2400:
-	baudrate=B2400;
-	break;
-    case 4800:
-	baudrate=B4800;
-	break;
-    case 9600:
-	baudrate=B9600;
-	break;
-    case 19200:
-	baudrate=B19200;
-	break;
-    case 38400:
-	baudrate=B38400;
-	break;
-    case 57600:
-	baudrate=B57600;
-	break;
-    case 115200:
-	baudrate=B115200;
-	break;
-    default:
-	baudrate=B9600;
-    }
-
-    /* databits */
-    switch (bits) {
-    case 7:
-	databits=CS7;
-	break;
-    case 8:
-	databits=CS8;
-	break;
-    default:
-	databits=CS8;
-    }
-    
-    /* parity, */
-    switch (parity) {
-    case 0:
-	checkparity=0;
-	break;
-    case 1:   //odd
-	checkparity=PARENB|PARODD;
-	break;
-    case 2:
-	checkparity=PARENB;
-	break;
-    default:
-	checkparity=0;
-    }
-    
-    /* and stop bits */
-    switch (stop) {
-    case 1:
-	stopbits=0;
-	break;
-    case 2:
-	stopbits=CSTOPB;
-	break;
-    default:
-	stopbits=0;
-    }
-    
-    /* now we setup the values in port's termios */
-    serial->tio.c_cflag=baudrate|databits|checkparity|stopbits|CLOCAL|CREAD;
-    serial->tio.c_iflag=IGNPAR;
-    serial->tio.c_oflag=0;
-    serial->tio.c_lflag=0;
-    serial->tio.c_cc[VMIN]=1;
-    serial->tio.c_cc[VTIME]=0;
-
-    /* we flush the port */
-    tcflush(serial->fd,TCOFLUSH);
-    tcflush(serial->fd,TCIFLUSH);
-    
-    /* we send new config to the port */
-    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
-
-    cssl_error=CSSL_OK;
-}
-
-void cssl_setflowcontrol(cssl_t *serial,
-			 int rtscts,
-			 int xonxoff)
-{
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }    
-
-    /* We setup rts/cts (hardware) flow control */
-    if (rtscts) {
-	serial->tio.c_cflag |= CRTSCTS;
-    } else {
-	serial->tio.c_cflag &= ~CRTSCTS;
-    }
-    
-    /* We setup xon/xoff (soft) flow control */
-    if (xonxoff) {
-	serial->tio.c_iflag |= (IXON|IXOFF);
-    } else {
-	serial->tio.c_iflag &= ~(IXON|IXOFF);
-    }
-    
-    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
-
-    cssl_error=CSSL_OK;
-}
-
-/* Blocking mode: sets the timeout in 
-   hundreds of miliseconds */
-void cssl_settimeout(cssl_t *serial, int timeout)
-{
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }    
-
-    serial->tio.c_cc[VTIME]=timeout;
-    
-    tcsetattr(serial->fd,TCSANOW,&(serial->tio));
-
-    cssl_error=CSSL_OK;
-}
-
-/*-------------------------------------
- * Serial communication
- */
-
-/* sending a char */
-void cssl_putchar(cssl_t *serial,
-		     char c)
-{
-    if (!cssl_started) 
-    {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) 
-    {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }
-
-    int result = write(serial->fd,&c,1);
-}
-
-/* sending a null-terminated string */
-void cssl_putstring(cssl_t *serial,
-		     char *str)
-{
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }
-
-    int result = write(serial->fd,str,strlen(str));
-}
-
-/* sending a data of known size */
-void cssl_putdata(cssl_t *serial,
-		  uint8_t *data,
-		  int datalen)
-{
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }    
-
-    int result = write(serial->fd,data,datalen);
-}
-
-void cssl_drain(cssl_t *serial)
-{
-    if (!cssl_started) {
-	cssl_error=CSSL_ERROR_NOTSTARTED;
-	return;
-    }
-    
-    if (!serial) {
-	cssl_error=CSSL_ERROR_NULLPOINTER;
-	return;
-    }    
-
-    tcdrain(serial->fd);
-}
-
-/* blocking mode: reading a char */
-int cssl_getchar(cssl_t *serial)
-{
-    uint8_t c;
-    int result = read(serial->fd,&c,sizeof(c));
-    if (result<=0)
-	return -1;
-    
-    return c;
-}
-
-/* blocking mode: reading a data buffer */
-int cssl_getdata(cssl_t *serial,
-		 uint8_t *buffer,
-		 int size)
-{
-    return read(serial->fd,buffer,size);
-}
-
-/*------------------------------------------*/
-
-/* The most important: signal handler */
-void cssl_handler(int signo, siginfo_t *info, void *ignored)
-{
-    cssl_t *cur;
-    int n;
-
-    /* is this signal which says about
-       incoming of the data? */
-    if (info->si_code==POLL_IN) {
-
-	/* Yes, we got some data */
-	for(cur=head;cur;cur=cur->next) {
-
-	    /* Let's find proper cssl_t */
-	    if (cur->fd==info->si_fd) {
-
-		/* Got it */
-		n=read(cur->fd,cur->buffer,255);
-
-		/* Execute callback */
-		if ((n>0)&&(cur->callback))
-		    cur->callback(cur->id,cur->buffer,n);
-		return;
-	    }
-	}
-    }
-}
diff --git a/src/EVA11/cssl.h b/src/EVA11/cssl.h
deleted file mode 100644
index 823aab5..0000000
--- a/src/EVA11/cssl.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* Copyright 2003 Marcin Siennicki <m.siennicki@cloos.pl>
- * see COPYING file for details */
-
-#ifndef __CSSL_H__
-#define __CSSL_H__
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#include <stdint.h>
-#include <signal.h>
-#include <termios.h>
-
-typedef void (*cssl_callback_t)(int id,  /* id passed to callback */
-				uint8_t *buffer, /* data received */
-				int len); /* length of data in bytes */
-
-typedef struct __cssl_t {
-
-    uint8_t buffer[255];      /* input buffer */
-
-    int fd;                   /* tty file descriptor */
-
-    struct termios tio;       /* termios structure for the port */
-    struct termios oldtio;    /* old termios structure */
-
-    cssl_callback_t callback; /* callback function */
-
-    int id;                   /* id which would be passed to callback */
-
-    struct __cssl_t *next;
-
-} cssl_t;
-
-typedef enum {
-    CSSL_OK,                 /* everything is all right */
-    CSSL_ERROR_NOSIGNAL,     /* there's no free signal */
-    CSSL_ERROR_NOTSTARTED,   /* you should first start cssl */
-    CSSL_ERROR_NULLPOINTER,  /* you gave a null pointer to the function */
-    CSSL_ERROR_OOPS,         /* internal error, something's erong */
-    CSSL_ERROR_MEMORY,       /* there's no memory for cssl_t structure */
-    CSSL_ERROR_OPEN          /* file doesnt exist or you aren't good user */
-} cssl_error_t;
-
-/* get the error message */
-const char *cssl_geterrormsg();
-
-/* get the error code */
-int cssl_geterror();
-
-/* start the cssl */
-void cssl_start();
-
-/* finish all jobs, clear memory, etc. */
-void cssl_stop();
-
-/* alloc new cssl_t struct and open the port */
-cssl_t *cssl_open(const char *fname, /* pathname of port file,
-				      * for example "/dev/ttyS0" */
-		  cssl_callback_t callback, /* callback function
-					     * If you dont want
-					     * event driven reading - set
-					     * it to NULL */
-		  int id,     /* your own id for the port, it can help
-			       * to identify the port in callback f.*/
-		  int baud,   /* baudrate, integer, for example 19200 */
-		  int bits,   /* data bits: 7 or 8 */
-		  int parity, /* parity: 0 - none, 1-odd, 2-even */
-		  int stop);  /* stop bits: 1 or 2 */
-
-/* closes the port, and frees its cssl_t struct */
-void cssl_close(cssl_t *serial);
-
-/* setups the port, look at cssl_open */
-void cssl_setup(cssl_t *serial,
-		   int baud,
-		   int bits,
-		   int parity,
-		   int stop);
-
-void cssl_setflowcontrol(cssl_t *serial,
-			 int rtscts,   /* Boolean: 
-					* 0 - no rts/cts control,
-					* 1 - rts/cts control 
-					*/
-			 int xonxoff); /* Boolean: 
-					* 0 - no xon/xoff, 
-					* 1 - xon/xoff 
-					*/
-
-/* sends a char via serial port */
-void cssl_putchar(cssl_t *serial,
-		     char c);
-
-/* sends a null terminated string */
-void cssl_putstring(cssl_t *serial,
-		       char *str);
-
-/* sends a data of known size */
-void cssl_putdata(cssl_t *serial,
-		  uint8_t *data, /* data */
-		  int datalen);  /* length of data */
-
-/* waits until all data has been transmited */
-
-void cssl_drain(cssl_t *serial);
-
-/*====================================== 
- * Blocking mode 
- */
-
-/* Sets port timeout (deciseconds) in blocking mode */
-void cssl_settimeout(cssl_t *serial, int timeout);
-
-/* reads a char in blocking mode */
-int cssl_getchar(cssl_t *serial);
-
-/* reads a data to a buffer in blocking mode*/
-int cssl_getdata(cssl_t *serial,
-		 uint8_t *buffer,  /* buffer for data */
-		 int size);        /* buffer size */
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* __CSSL_H__ */
diff --git a/src/EVA11/etio.cpp b/src/EVA11/etio.cpp
deleted file mode 100644
index f8728ea..0000000
--- a/src/EVA11/etio.cpp
+++ /dev/null
@@ -1,1762 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  etio.cpp
- *
- *    Description:  
- *
- *        Version:  1.0
- *        Created:  2012年12月18日 11时07分14秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#include 	<cmath>
-#include 	<cstdio>
-#include 	<cstdlib>
-#include 	<fcntl.h>
-#include 	<unistd.h>
-#include 	<sys/mman.h>
-
-#include 	"etio.h"
-
-#define 	DEVICE_KBTEST	"/dev/ECT"
-#define 	PI              3.1415926
-
-std::auto_ptr<Etio> Etio::m_Instance;
-
-struct Etio::BOARDSTATUS
-{
-	unsigned 		SampleReady : 1;
-	unsigned 		None3       : 3;
-	unsigned 		PowerOn     : 1;
-	unsigned 		Running     : 1;
-	unsigned 		Shutdown    : 1;
-	unsigned 		None1       : 1;
-};
-
-struct Etio::PROBBALGAIN
-{
-	unsigned 		ProbeGain : 3;
-	unsigned 		None	  : 1;
-	unsigned 		ProbeBal  : 4;
-};
-
-struct Etio::JOBAMOUNT
-{
-	unsigned 		WpAmount : 4;
-	unsigned 		ChJob    : 4;
-};
-
-struct Etio::WPARAMS
-{
-	uint8_t 		WpDivisorLo;
-	uint8_t 		WpDivisorHi;
-	uint8_t 		WpAmount;
-
-	Etio::JOBAMOUNT		JobWpAmount;
-
-	uint8_t 		WpDeltaLo;
-	uint8_t 		WpDeltaMi;
-	uint8_t 		WpDeltaHi;
-
-	Etio::PROBBALGAIN	ProbeBalGain;
-
-	uint8_t			CoilNumforPickB;
-	uint8_t			CoilNumforPickA;
-
-	uint8_t			CoilNumforDriverB;
-	uint8_t			CoilNumforDriverA;
-
-	uint8_t			RfLpCoefLo;
-	uint8_t			RfLpCoefHi;
-
-	uint8_t			RfHpCoefLo;
-	uint8_t			RfHpCoefHi;
-
-	uint8_t			LfLpCoefLo;
-	uint8_t			LfLpCoefHi;
-
-	uint8_t			LfHpCoefLo;
-	uint8_t			LfHpCoefHi;
-};
-
-struct Etio::FREQUENCESTR
-{
-	int			Frequence;
-	int			Wck;
-};
-
-struct Etio::PImpl
-{
-	static const int 	m_Version 	   = 101;
-	static const int	m_FREQVALUEN_40MHz = 2216;
-	static const int	m_cMAXSN 	   = 128;   // Max Structure Number
-	static const int	m_cMAXFreqAmount   = 8;
-
-	int			m_FD;
-
-	volatile uint8_t*	m_pET;
-
-	FUNMODE			m_Work_Mode;		    // Normal\Sin
-	int			m_Sin_Channel;		    // select the SIN channel
-	/*-----------------------------------------------------------------------------
-	 * Media layer  
-	 *-----------------------------------------------------------------------------*/
-	int			m_High_Filter[m_cMAXSN];
-	int			m_Low_Filter[m_cMAXSN];
-	int			m_Offset;
-	int			m_SineAmp;
-	CHANTYPE		m_Chan_Type[m_cMAXSN];
-	int			m_MediaChanFreq[m_cMAXFreqAmount];
-	/*-----------------------------------------------------------------------------
-	 * Board Information  
-	 *-----------------------------------------------------------------------------*/
-	uint8_t			m_TQ_Main_Version;          // 03
-	uint8_t 		m_TQ_Sub_Version;      	    // 4
-	uint8_t			m_FPGA_Version;	       	    // 1 ..
-
-	uint8_t			m_MAX_Channels;        	    // 1~128
-
-	bool			m_bECT;
-	bool			m_bFECT;
-	bool			m_bRF;
-	bool			m_bEMS;
-	bool			m_bLF;
-
-	bool			m_RF_Filter_Enable;	    // it desides whether RF readmode need to set RF Filter Enable
-
-	Etio::FREQUENCESTR	m_FreqValue[m_FREQVALUEN_40MHz];	
-	int			m_FreqValueLength;
-
-	int			m_Channels_Number;	     // Current MAX channels
-	int			m_ChanFreq[m_cMAXSN];
-	int			m_ChanMapMedia2FreqIndex[m_cMAXSN];
-	Etio::WPARAMS           m_ChanPara[m_cMAXSN];	     // used this strcuture to configrature probe
-
-	bool			m_Timer1Mode;
-	bool			m_Timer2Mode;
-
-	Etio::BOARDSTATUS       BoardStatus;
-};
-
-Etio::Etio () : m_Imple(new struct PImpl)
-{
-}
-
-Etio::~Etio ()
-{
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Instance
- *  Description:  make sure the class instance can be only instance once
- * =====================================================================================
- */
-Etio* Etio::Instance()
-{
-	if 	( m_Instance.get() == 0 )
-	{
-		m_Instance.reset( new Etio() );
-	}
-	return m_Instance.get();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Version
- *  Description:  Get the share library version 
- * =====================================================================================
- */
-int Etio::Version()
-{
-	return m_Imple->m_Version; 
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Board_Version
- *  Description:  Get the Board Version information from board 
- * =====================================================================================
- */
-void Etio::Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA)
-{
-#ifdef X86
-	Main = 1;
-	Sub  = 2;
-	FPGA = 3;
-#else
-	Main = m_Imple->m_TQ_Main_Version;
-	Sub  = m_Imple->m_TQ_Sub_Version;
-	FPGA = m_Imple->m_FPGA_Version;
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Load_Board_Information
- *  Description:  Load infromation from Board 
- * =====================================================================================
- */
-void Etio::Load_Board_Information()
-{
-#ifdef X86
-	m_Imple->m_TQ_Sub_Version = 3;
-	m_Imple->m_FPGA_Version   = 2;
-	m_Imple->m_TQ_Main_Version= 1; 
-	m_Imple->m_MAX_Channels   = 128;
-
-	m_Imple->m_bECT  = true;
-	m_Imple->m_bFECT = true;
-	m_Imple->m_bRF   = true;
-	m_Imple->m_bEMS  = true;  
-	m_Imple->m_bLF   = true;
-#else
-	uint8_t t = PEEKB_TC(0x0000);
-	m_Imple->m_TQ_Sub_Version  = ( t & 0xf0 ) >> 4;
-	m_Imple->m_FPGA_Version    = t & 0x0f;
-	m_Imple->m_TQ_Main_Version = PEEKB_TC(0x0001);
-	m_Imple->m_MAX_Channels    = pow(2,PEEKB_TC(0x0002) & 0x07);
-
-	m_Imple->m_bECT  = false;
-	m_Imple->m_bFECT = false;
-	m_Imple->m_bRF   = false;
-	m_Imple->m_bEMS  = false;  
-	m_Imple->m_bLF   = false;
-
-	t = ( PEEKB_TC(0x0002) & 0xf8 ) >> 3;
-
-	if ( t & 0x01 )
-		m_Imple->m_bECT  = true;
-
-	if ( (t>>1) & 0x01 )
-		m_Imple->m_bFECT = true;
-
-	if ( (t>>2) & 0x01 )
-		m_Imple->m_bRF   = true;
-
-	if ( (t>>3) & 0x01 )
-		m_Imple->m_bEMS  = true;
-
-	if ( (t>>4) & 0x01 )
-		m_Imple->m_bLF   = true;
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  POKEB_TC
- *  Description:  Set value into TCB 
- * =====================================================================================
- */
-void Etio::POKEB_TC(int add,uint8_t value)
-{
-#ifdef X86
-#else
-	m_Imple->m_pET[2] = static_cast<uint8_t>( add & 0xff );
-	m_Imple->m_pET[3] = static_cast<uint8_t>( ( add >> 8 ) & 0xff ); 
-	m_Imple->m_pET[4] = value; 
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  PEEKB_TC
- *  Description:  Read Dat from TC 
- * =====================================================================================
- */
-uint8_t Etio::PEEKB_TC(int add)
-{
-#ifdef X86
-	return 0;
-#else
-	m_Imple->m_pET[2]   = static_cast<uint8_t>( add & 0xff );
-	m_Imple->m_pET[3]   = static_cast<uint8_t>( (add>>8) & 0xff );
-	return m_Imple->m_pET[8];
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  InitialteETIO
- *  Description:  Initialte the ETIO board 
- * =====================================================================================
- */
-bool Etio::InitiateETIO()
-{
-#ifdef X86
-#else
-	if	( (m_Imple->m_FD=open(DEVICE_KBTEST, O_RDWR ))<0 )
-	{ 
-		perror("can not open device");
-		return false;
-	}
-	else
-	{ 
-		m_Imple->m_pET =(volatile uint8_t*) mmap(NULL, 16, PROT_READ|PROT_WRITE, /*0*/MAP_SHARED, m_Imple->m_FD, 0); 
-		if	( m_Imple->m_pET==MAP_FAILED )
-		{
-			perror("Map Failed"); 
-			return false;
-		}
-
-		POKEB_TC(0x10,0); 
-		if	( ( PEEKB_TC(0x06) & 0x10 ) !=0 )
-		{
-			perror("No Found the ET Board");
-			return false;
-		}
-		POKEB_TC(0x10,1); 
-		if	( ( PEEKB_TC(0x06) & 0x10 ) != 0x10 ) 
-		{
-			perror("No Found the ET Board");
-			return false;
-		}
-	}
-#endif
-
-	/*-----------------------------------------------------------------------------
-	 *  Init FPGA Board variables
-	 *-----------------------------------------------------------------------------*/
-	uint8_t main,sub,fpga;
-	Load_Board_Information();
-	Refresh_Board_Status();
-	Get_Board_Version(main,sub,fpga);
-	printf ( "FPGA Information TQ%02d-%c FPGA%d\n",main,'A'+sub,fpga );
-
-	Init_Frequence_Value();
-	Init_Default_Value();
-
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  UnInitiateETIO
- *  Description:  Release Board Value
- * =====================================================================================
- */
-void Etio::UnInitiateETIO()
-{
-	Running(false);
-	Power(false);
-#ifdef X86
-#else
-	munmap((void *)(m_Imple->m_pET),16); 
-	close(m_Imple->m_FD); 
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Chan_Data
- *  Description:  Sample the Each Channel Data
- *	          x0-data[0] y0-data[1]
- *	          x1-data[2] y1-data[3]
- *	          x2-data[4] y1-data[5]
- *	          .
- *	          .
- *	          x127-data[254] y127-data[255]
- *
- *       return:  false    Sample NOT OK   
- *       	  true     Sample OK 
- * =====================================================================================
- */
-bool Etio::Sample_Chan_Data(int* data,SAMPLETYPE st)
-{
-#ifdef X86
-#else
-	int addr;
-	uint8_t t1,t2,t3,t4;
-
-	if ( PEEKB_TC(0x006) & 0x01 == true )
-		return false;
-
-	switch ( st ) 
-	{
-		case TIMERS:    // INT EXT1  EXT2
-			{
-				POKEB_TC(0x22,0x00);  // Lock the Timers value
-
-				addr = 0x030;
-				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-				for (int j=0;j<3;j++ )
-				{
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-
-				POKEB_TC(0x22,0x01);  // UnLock the timers value
-			}
-			break;
-
-		case RAWECT:    //  X0 Y0 .... .... Xn Yn
-			{
-				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
-				{
-					addr = 0x1000 + ( i << 3 );
-
-					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-			}
-			break;
-
-		case RAWEMS:	// X0 0  .... .... Xn 0
-			{
-				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
-				{
-					addr = 0x1000 + ( i << 3 );
-
-					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-					data[(i<<1) + 1] = 0; 
-				}
-			}
-			break;
-
-		case ALLECT:   //  X0 Y0 .... .... Xn Yn INTTIME EXTTIME1 EXTTIME2
-			{
-				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
-				{
-					addr = 0x1000 + ( i << 3 );
-
-					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-
-				POKEB_TC(0x22,0x00);  // Lock the Timers value
-
-				addr = 0x030;
-				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-				for (int j=0;j<3;j++ )
-				{
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-
-				POKEB_TC(0x22,0x01);  // UnLock the timers value
-			}
-			break;
-
-		case ALLEMS:   //  X0 0 .... .... Xn 0 INTTIME EXTTIME1 EXTTIME2
-			{
-				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
-				{
-					addr = 0x1000 + ( i << 3 );
-
-					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-					data[(i<<1) + 1] = 0; 
-				}
-
-				POKEB_TC(0x22,0x00);  // Lock the Timers value
-
-				addr = 0x030;
-				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-				for (int j=0;j<3;j++ )
-				{
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-
-				POKEB_TC(0x22,0x01);  // UnLock the timers value
-			}
-			break;
-
-		default:       // RAW ECT
-			{
-				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
-				{
-					addr = 0x1000 + ( i << 3 );
-
-					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-
-					t1 = m_Imple->m_pET[0x0a];
-					t2 = m_Imple->m_pET[0x0a];
-					t3 = m_Imple->m_pET[0x0a];
-					t4 = m_Imple->m_pET[0x0a];
-
-					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-				}
-
-			}
-			break;
-	}				/* -----  end switch  ----- */
-
-	POKEB_TC(0x020,0x01);		// restart next sample
-#endif
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_WparaRam
- *  Description:  Acoording the Wparameters then set the value to FPGA 
- * =====================================================================================
- */
-void Etio::Set_WparamRam_Into_FPGA(int chan)
-{
-	int addr = 0x2000 +  ( chan << 4 );
-
-	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].WpDivisorLo);
-	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].WpDivisorHi);
-	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].WpAmount);
-
-	uint8_t v = m_Imple->m_ChanPara[chan].JobWpAmount.WpAmount + ( m_Imple->m_ChanPara[chan].JobWpAmount.ChJob<<4 );
-	POKEB_TC(addr+0x003,v);
-
-	POKEB_TC(addr+0x004,m_Imple->m_ChanPara[chan].WpDeltaLo);
-	POKEB_TC(addr+0x005,m_Imple->m_ChanPara[chan].WpDeltaMi);
-	POKEB_TC(addr+0x006,m_Imple->m_ChanPara[chan].WpDeltaHi);
-
-	v = 0;
-	v = m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeGain + ( m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeBal<<4 );
-	POKEB_TC(addr+0x007,v);
-
-	POKEB_TC(addr+0x008,m_Imple->m_ChanPara[chan].CoilNumforPickB);
-	POKEB_TC(addr+0x009,m_Imple->m_ChanPara[chan].CoilNumforPickA);
-	POKEB_TC(addr+0x00a,m_Imple->m_ChanPara[chan].CoilNumforDriverB);
-	POKEB_TC(addr+0x00b,m_Imple->m_ChanPara[chan].CoilNumforDriverA);
-
-	POKEB_TC(addr+0x00c,m_Imple->m_ChanPara[chan].RfLpCoefLo);
-	POKEB_TC(addr+0x00d,m_Imple->m_ChanPara[chan].RfLpCoefHi);
-	POKEB_TC(addr+0x00e,m_Imple->m_ChanPara[chan].RfHpCoefLo);
-	POKEB_TC(addr+0x00f,m_Imple->m_ChanPara[chan].RfHpCoefHi);
-
-	addr = 0x3000 +  ( chan << 2 );
-	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].LfLpCoefLo);
-	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].LfLpCoefHi);
-	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].LfHpCoefLo);
-	POKEB_TC(addr+0x003,m_Imple->m_ChanPara[chan].LfHpCoefHi);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Board_Status
- *  Description:  Refresh the Board Status into mem_fun1_ref_tnory
- * =====================================================================================
- */
-void Etio::Refresh_Board_Status()
-{
-#ifdef X86
-#else
-	uint8_t v = PEEKB_TC(0x006);
-
-	m_Imple->BoardStatus.SampleReady = v & 0x01;
-	m_Imple->BoardStatus.PowerOn     = ( v & 0x10 ) >> 4;
-	m_Imple->BoardStatus.Running     = ( v & 0x20 ) >> 5;
-	m_Imple->BoardStatus.Shutdown    = ( v & 0x40 ) >> 6;
-#endif
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Power
- *  Description:  Set the Power flag  
- *         flag:  true  	PowerOn
- *                false 	PowerOff
- * =====================================================================================
- */
-void Etio::Power(bool flag)
-{
-	uint8_t v = 0;
-	if 	( flag == true )
-		v = 1;
-
-	POKEB_TC(0x010,v);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Running
- *  Description:  Set the Running flag 
- *         flag:  true           Running
- *                false          Stopping
- * =====================================================================================
- */
-void Etio::Running(bool flag)
-{
-	uint8_t v = 0;
-	if 	( flag == true )
-		v = 1;
-
-	POKEB_TC(0x011,v);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Chan_Amount
- *  Description:  Set the Channel Amount 
- *  		  1~128
- * =====================================================================================
- */
-void Etio::Set_Chan_Amount(int amount)
-{
-	if 	( amount > 128 || amount < 1 )
-		return;
-
-	POKEB_TC(0x015,amount);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_AdOffset
- *  Description:  Set the Offset (-100 +100)
- * =====================================================================================
- */
-void Etio::Set_AdOffset(int offset)
-{
-	if 	( offset > 100 || offset < -100 )
-		return;
-
-	POKEB_TC(0x018,offset);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_SineAmplitude
- *  Description:  Set the sine Amplitude times  0~15
- * =====================================================================================
- */
-void Etio::Set_SineAmplitude(int value)
-{
-	if 	( value > 15 || value < 0 )
-		return;
-
-	POKEB_TC(0x01F,value);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Restart
- *  Description:  Restart the Board 
- * =====================================================================================
- */
-void Etio::Restart()
-{
-	POKEB_TC(0x020,0x01);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  GKey
- *  Description:  Get the Key Value from ECT Board 
- *                0~6 bits	Key Value
- *                7 bits   	Length Push
- * =====================================================================================
- */
-uint8_t Etio::GKey()
-{
-	return PEEKB_TC(0x02F);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_ET
- *  Description:  Set the ETIO parameter into Board
- *                this function convert all device parameters from package to FPGA parameters
- * =====================================================================================
- */
-void Etio::Set_ET()
-{
-	Running(false);		  	// halt the system
-
-	if 	( m_Imple->m_Work_Mode == SIN )
-		POKEB_TC(0x016,(m_Imple->m_Sin_Channel|0x80));
-	else 
-		POKEB_TC(0x016,(m_Imple->m_Sin_Channel&0x7F));
-
-	Set_Chan_Type();		// set each channels paramters and calculate channels number
-	Set_Chan_Amount(m_Imple->m_Channels_Number);
-	Set_AdOffset(m_Imple->m_Offset);
-	Set_SineAmplitude(m_Imple->m_SineAmp);
-	Set_Timer_Mode();
-	Convert_Media_FreqValue_To_Inside_FreqIndex();
-	Calculate_Channel_Parameters();
-
-	for ( int i = 0; i < m_Imple->m_cMAXSN; i += 1 ) 
-		Set_WparamRam_Into_FPGA(i);
-
-	Running(true);			// re-running system
-	Restart();			// Start Sample
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Clear_Timers
- *  Description:  Clear the Int Ext1 Ext2 Timers 
- * =====================================================================================
- */
-void Etio::Clear_Timers(int index)
-{
-	switch ( index ) 
-	{
-		case 0:			// InTimer
-			POKEB_TC(0x024,0x01);
-			break;
-
-		case 1:			// Extimer1 
-			POKEB_TC(0x024,0x02);
-			break;
-
-		case 2:			// Extimer2 
-			POKEB_TC(0x024,0x04);
-			break;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Frequence_Value
- *  Description:  Init Frequence Value into Buffer  
- * =====================================================================================
- */
-void Etio::Init_Frequence_Value()
-{
-	int fn = 0;
-
-	m_Imple->m_FreqValue[fn].Frequence 	   = 1;
-	m_Imple->m_FreqValue[fn].Wck       	   = 2000;
-	fn ++;
-
-	for ( int i=2;i<4;i++ )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 4000;
-		fn ++;
-	}
-
-	for ( int i=4;i<8;i++ )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 8000;
-		fn ++;
-	}
-
-	for ( int i=8;i<16;i++ )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 16000;
-		fn ++;
-	}
-
-	for ( int i=16;i<32;i++ )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 32000;
-		fn ++;
-	}
-
-	for ( int i=32;i<80; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 64000;
-		fn ++;
-		i += 2;
-	}
-
-	for ( int i=80;i<151; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 160000;
-		fn ++;
-		i += 2;
-	}
-
-	for ( int i=160;i<391; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 320000;
-		fn ++;
-		i += 2;
-	}
-
-	for ( int i=400;i<791; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 800000;
-		fn ++;
-		i += 4;
-	}
-
-	for ( int i=800;i<1901; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 1600000;
-		fn ++;
-		i += 4;
-	}
-
-	for ( int i=2000;i<3901; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 3200000;
-		fn ++;
-		i += 5;
-	}
-
-	for ( int i=4000;i<9901; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 8000000;
-		fn ++;
-		i += 6;
-	}
-
-	for ( int i=10000;i<19001; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 20000000;
-		fn ++;
-		i += 300;
-	}
-
-	for ( int i=20000;i<100000; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 40000000;
-		fn ++;
-		i += 1000;
-	}
-
-	for ( int i=100000;i<1000000; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 40000000;
-		fn ++;
-		i += 10000;
-	}
-
-	for ( int i=1000000;i<3000000; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 40000000;
-		fn ++;
-		i += 40000;
-	}
-
-	for ( int i=3200000;i<=5000000; )
-	{
-		m_Imple->m_FreqValue[fn].Frequence = i;
-		m_Imple->m_FreqValue[fn].Wck       = 40000000;
-		fn ++;
-		i += 100000;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Init_Default_Value
- *  Description:  Init the Default Value 
- *                Before User Configrature give the board a default value
- * =====================================================================================
- */
-void Etio::Init_Default_Value()
-{
-	/*-----------------------------------------------------------------------------
-	 *  Default Frequence and RF LF Filter Parameters
-	 *-----------------------------------------------------------------------------*/
-	m_Imple->m_Work_Mode			       = NORMAL;
-	m_Imple->m_Sin_Channel			       = 0;
-	m_Imple->m_RF_Filter_Enable		       = false;
-	m_Imple->m_Channels_Number		       = 1;		// only one signal channel
-
-	for ( int i = 0; i < m_Imple->m_cMAXFreqAmount; i += 1 ) 
-	{
-		m_Imple->m_MediaChanFreq[i]            = 25000;
-	}
-
-	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
-	{
-		m_Imple->m_ChanMapMedia2FreqIndex[i]   = 0;
-
-		m_Imple->m_Chan_Type[i]                = CLOSE;
-		m_Imple->m_ChanFreq[i]                 = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);		// 1982: 25KHz
-
-		m_Imple->m_ChanPara[i].RfLpCoefLo      = 0xff;
-                m_Imple->m_ChanPara[i].RfLpCoefHi      = 0xff;
-
-		m_Imple->m_ChanPara[i].RfHpCoefLo      = 0x00;
-                m_Imple->m_ChanPara[i].RfHpCoefHi      = 0x00;
-
-		m_Imple->m_ChanPara[i].LfLpCoefLo      = 0xff;
-                m_Imple->m_ChanPara[i].LfLpCoefHi      = 0xff;
-
-		m_Imple->m_ChanPara[i].LfHpCoefLo      = 0x00;
-                m_Imple->m_ChanPara[i].LfHpCoefHi      = 0x00;
-
-		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeBal
-			                               = 8;
-		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeGain 
-						       = 7;
-		m_Imple->m_ChanPara[i].JobWpAmount.ChJob     
-			 			       = 0;		// Nomal ET
-
-		m_Imple->m_ChanPara[i].CoilNumforPickB = 255;		// Close all Channels
-                m_Imple->m_ChanPara[i].CoilNumforPickA = 255;
-
-		m_Imple->m_ChanPara[i].CoilNumforDriverB 
-						       = 255;
-		m_Imple->m_ChanPara[i].CoilNumforDriverA 
-			                               = 255;
-
-		if 	( i == 0 )					// Init only one Channels
-		{
-                 	m_Imple->m_ChanPara[i].CoilNumforPickA
-						       = 0;
-			m_Imple->m_ChanPara[i].CoilNumforPickB
-						       = 1;
-
-			m_Imple->m_ChanPara[i].CoilNumforDriverA 
-						       = 0;
-			m_Imple->m_ChanPara[i].CoilNumforDriverB 
-						       = 1;
-		}
-
-		m_Imple->m_High_Filter[i]              = 0;		// Close High Filter
-		m_Imple->m_Low_Filter[i]               = -1;		// Close Low Filter
-	}
-
-	for ( int i = 0; i < m_Imple->m_Channels_Number; i += 1 ) 
-	{
-		m_Imple->m_Chan_Type[i]		       = ECT;
-	}
-
-	m_Imple->m_Offset			       = 0;
-	m_Imple->m_SineAmp			       = 7;
-
-	m_Imple->m_Timer1Mode			       = false;
-	m_Imple->m_Timer2Mode			       = false;
-	Set_Timer_Mode();
-
-	Calculate_Channel_Parameters();
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_Channel_Parameters
- *  Description:  According to the Channel Frequence parameters to set Probe 
- * =====================================================================================
- */
-void Etio::Calculate_Channel_Parameters()
-{
-	unsigned short v,t;
-	int s;
-
-	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
-	{
-		if 	( m_Imple->m_Chan_Type[i] == EMS )             //  WCk=40MHz    Freq=80KHz
-		{
-			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / 40000000 - 1 );
-
-			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
-			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
-
-			v = static_cast<unsigned short>(static_cast<double>(40000000) / 80000);
-
-			t = v;                                 			//  500 pts
-
-			m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
-			m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
-
-			t = 2048 / v;
-
-			m_Imple->m_ChanPara[i].WpDeltaHi = t;
-
-			s = ( ( 2048 - v * t ) * 65536 ) / v; 
-		}
-		else
-		{
-			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck - 1 );
-
-			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
-			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
-
-			v = static_cast<unsigned short>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Frequence);
-
-			t = v % 4; 
-
-			if 	( t == 0 )
-			{
-				m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
-				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
-			}
-			else
-			{
-				m_Imple->m_ChanPara[i].WpAmount 	    = ( v + ( 4 - t ) ) & 0x00ff;
-				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( ( v + ( 4 - t ) ) >> 8 ) & 0x0f;
-			}
-
-			t = 2048 / v;
-
-			m_Imple->m_ChanPara[i].WpDeltaHi = t;
-
-			s = ( ( 2048 - v * t ) * 65536 ) / v; 
-		}
-
-		m_Imple->m_ChanPara[i].WpDeltaLo = s & 0x00ff;
-		m_Imple->m_ChanPara[i].WpDeltaMi = ( s >> 8 ) & 0x00ff;
-
-		if 	( m_Imple->m_Work_Mode == SIN && m_Imple->m_RF_Filter_Enable == false )	// enter SIN Mode disable RF-Filter
-			Disable_RFCoef(i);
-		else
-			Calculate_RFCoef(i);
-
-		Calculate_LFCoef(i);							        // calculate the LFCoef
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_RFCoef
- *  Description:  Calculate the RF Coef 
- * =====================================================================================
- */
-void Etio::Calculate_RFCoef(int index)
-{
-	double T;
-	double Ft;
-
-	if 	( m_Imple->m_Chan_Type[index] == EMS )
-	{
-		T    	  = 1 / static_cast<double>( 40000000 );
-		Ft        = 1 / static_cast<double>( 80000 );
-	}
-	else
-	{
-		T    	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
-		Ft        = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
-	}
-
-	double Fc   	  = 0.3 * Ft;
-
-	double t1   	  = 2 * PI * Fc * T;
-	double temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
-	unsigned short vh = static_cast<unsigned short>(temp* 65535);
-
-	if 	( m_Imple->m_Chan_Type[index] == EMS )
-	{
-		T    	  = 1 / static_cast<double>( 40000000 );
-		Fc        = 1 / static_cast<double>( 80000 );
-	}
-	else
-	{
-		T   	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
-		Fc   	  = 4 * static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
-	}
-
-	t1   	  	  = 2 * PI * Fc * T;
-	temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
-	unsigned short vl = static_cast<unsigned short>(temp* 65535);
-
-	m_Imple->m_ChanPara[index].RfHpCoefLo
-		          = vh & 0x00ff;
-	m_Imple->m_ChanPara[index].RfHpCoefHi
-		          = ( vh >> 8 ) & 0x00ff;
-	m_Imple->m_ChanPara[index].RfLpCoefLo 
-		          = vl & 0x00ff;
-	m_Imple->m_ChanPara[index].RfLpCoefHi
-		          = ( vl >> 8 ) & 0x00ff;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Disable_RFCoef
- *  Description:  When Enter RF Mode Disbale RFCoef
- * =====================================================================================
- */
-void Etio::Disable_RFCoef(int index)
-{
-	unsigned short vh = 0;
-	unsigned short vl = static_cast<unsigned short>(65535);
-
-	m_Imple->m_ChanPara[index].RfHpCoefLo 
-		          = vh & 0x00ff;
-	m_Imple->m_ChanPara[index].RfHpCoefHi
-		          = ( vh >> 8 ) & 0x00ff;
-	m_Imple->m_ChanPara[index].RfLpCoefLo 
-		          = vl & 0x00ff;
-	m_Imple->m_ChanPara[index].RfLpCoefHi
-		          = ( vl >> 8 ) & 0x00ff;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Calculate_LFCoef
- *  Description:  Calculate the LF Coef 
- *                注意关闭的情况
- * =====================================================================================
- */
-void Etio::Calculate_LFCoef(int index)
-{
-	double st;
-	int    M;
-	int   quot;
-	double T;
-	double Fc;
-	double t1;
-	double temp;
-	unsigned short vh,vl;
-
-
-	if 	( m_Imple->m_Chan_Type[index] == EMS )
-	{
-		st	  = 1 / static_cast<double>( 80000 );
-		M      	  = static_cast<int>( static_cast<double>( 40000000 ) / \
-			    static_cast<double>( 80000 ));
-	}
-	else
-	{
-		st	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
-		M      	  = static_cast<int>( static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck ) / \
-			    static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence ));
-	}
-
-	div_t result = div(400,M);
-	if 	( result.rem == 0 )
-		quot = result.quot;
-	else 
-		quot = result.quot + 1;
-
-	if 	( m_Imple->m_Chan_Type[index] == FECT )
-		T	  = 1 * quot * st;
-	else
-		T	  = 2 * quot * st;
-
-	Fc   	  = m_Imple->m_High_Filter[index] / static_cast<double>(10); 
-	t1   	  = 2 * PI * Fc * T;
-	temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
-
-	if 	( m_Imple->m_High_Filter[index] != 0 )
-	{
-		vh = static_cast<unsigned short>(temp* 65535);
-	}
-	else
-		vh = 0; 
-
-	if 	( m_Imple->m_Low_Filter[index] != -1 )
-	{
-		Fc   	  	  = m_Imple->m_Low_Filter[index] / static_cast<double>(10);
-		t1   	  	  = 2 * PI * Fc * T;
-		temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
-		vl = static_cast<unsigned short>(temp* 65535);
-	}
-	else
-		vl = static_cast<unsigned short>(65535);
-
-	m_Imple->m_ChanPara[index].LfHpCoefLo 
-		          = vh & 0x00ff;
-	m_Imple->m_ChanPara[index].LfHpCoefHi
-		          = ( vh >> 8 ) & 0x00ff;
-	m_Imple->m_ChanPara[index].LfLpCoefLo 
-		          = vl & 0x00ff;
-	m_Imple->m_ChanPara[index].LfLpCoefHi
-		          = ( vl >> 8 ) & 0x00ff;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_Type
- *  Description:  Set the Channel run type
- *         type:  CLOSE|ECT|FECT|EMS
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_Type(int ch,CHANTYPE type)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-		m_Imple->m_Chan_Type[ch] = type;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_Amount
- *  Description:  Set the device work channels 
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_Amount(int v)
-{
-	if 	( v <= m_Imple->m_MAX_Channels )
-		m_Imple->m_Channels_Number = v;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_Frequence_Value
- *  Description:  Set the Channel's value 
- *  	     ch:  0-7
- *  	      v:  10~5MHz 
- *  	          Notice it is index value
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_Frequence_Value(int ch,int v)
-{
-	if 	( ch >= 0 && ch <= 7 )
-		m_Imple->m_MediaChanFreq[ch] = v;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_Map_Index
- *  Description:  
- *           ch:  0~127
- *     mapindex:  0~m_cMAXFreqAmount 
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_Map_Index(int ch,int mapindex)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-		m_Imple->m_ChanMapMedia2FreqIndex[ch] = mapindex;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_ProbeGain
- *  Description:  Set the the Channels ProbeGain 
- *  	     ch:  0~127
- *  	     v:   0~7
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_ProbeGain(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 7 )
-			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeGain = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_ProbeBalance
- *  Description:  Set the Probe balance parameters 
- *           ch:  0~127
- *            v:  0~15
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_ProbeBalance(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 15 )
-			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeBal= v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_CoilNumforPickA
- *  Description: Set the CoilNumforPickA paramters 
- *           ch:  0~127
- *            v:  0~255
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_CoilNumforPickA(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 255 )
-			m_Imple->m_ChanPara[ch].CoilNumforPickA = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_CoilNumforPickB
- *  Description: Set the CoilNumforPickA paramters 
- *           ch:  0~127
- *            v:  0~255
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_CoilNumforPickB(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 255 )
-			m_Imple->m_ChanPara[ch].CoilNumforPickB = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_CoilNumforDriverA
- *  Description: Set the CoilNumforPickA paramters 
- *           ch:  0~127
- *            v:  0~255
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_CoilNumforDriverA(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 255 )
-			m_Imple->m_ChanPara[ch].CoilNumforDriverA = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_CoilNumforDriverB
- *  Description: Set the CoilNumforPickA paramters 
- *           ch:  0~127
- *            v:  0~255
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_CoilNumforDriverB(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v >= 0 && v <= 255 )
-			m_Imple->m_ChanPara[ch].CoilNumforDriverB = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_HighFilter
- *  Description:  Set the Channels Paramters High Filte
- *           ch:  0~127
- *            v:  0,  0.1~100Hz  ( 1~1000 )  step 0.1Hz ( 1 )
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_HighFilter(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v == 0 )
-			m_Imple->m_High_Filter[ch] = v;
-		else if ( v >= 1 && v <= 1000 ) 
-			m_Imple->m_High_Filter[ch] = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_LowFilter
- *  Description:  Set the Channels Paramters Low Filte
- *           ch:  0~127
- *            v:  -1  10~2000Hz (100~20000) step 1Hz
- *
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_LowFilter(int ch,int v)
-{
-	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
-	{
-		if 	( v == -1 )
-			m_Imple->m_Low_Filter[ch] = v;
-		else if ( v >= 100 && v <= 20000 ) 
-			m_Imple->m_Low_Filter[ch] = v;
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_Offset
- *  Description:  Set the offset of Device 
- *        value:  -100 ~ 100 
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_Offset(int value)
-{
-	if 	( value >= -100 && value <= 100 )
-		m_Imple->m_Offset = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Channels_SineAmplitude
- *  Description:  Set the Sine Amplitude value into media layer 
- *        value:  0~7:    1~8V
- * =====================================================================================
- */
-void Etio::Interface_Set_Channels_SineAmplitude(int value)
-{
-	if 	( value >= 0 && value <= 7 )
-		m_Imple->m_SineAmp = value;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Sin_Point_Amount
- *  Description:  Get the Sin Point Amount
- * =====================================================================================
- */
-int Etio::Get_Sin_Point_Amount(int chan)
-{
-	int M;
-	if ( m_Imple->m_Chan_Type[chan] == EMS )
-		M = 500; 
-	else
-		M = static_cast<int>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Frequence);
-
-	div_t re = div(M,256); 
-
-	int CptRate = 0;
-	if 	( re.rem == 0 )
-		CptRate = re.quot;
-	else
-		CptRate = re.quot + 1;
-
-	re = div(M,CptRate);
-
-	if 	( re.rem == 0 )
-		return re.quot;
-	else
-		return re.quot + 1;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_Sin_Data
- *  Description:  Sample the SIN Function 
- * =====================================================================================
- */
-bool Etio::Sample_Sin_Data(int* data,int len)
-{
-	int addr;
-	uint8_t t1,t2,t3,t4;
-
-	if 	( PEEKB_TC(0x006) & 0x01 == true )
-		return false;
-
-	addr = 0x1000;
-
-	m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
-	m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
-
-	for ( int i = 0; i < len; i += 1 ) 
-	{
-		t1 = m_Imple->m_pET[0x0a];
-		t2 = m_Imple->m_pET[0x0a];
-		t3 = m_Imple->m_pET[0x0a];
-		t4 = m_Imple->m_pET[0x0a];
-
-		data[i] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
-	}
-
-	POKEB_TC(0x020,0x01);		// restart next sample
-	return true;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Frequence_Index
- *  Description:  Return the Frequence value index 
- * =====================================================================================
- */
-int Etio::Get_Frequence_Index(int frequnce)
-{
-	for ( int i=0;i< m_Imple->m_FREQVALUEN_40MHz;i++ )
-	{
-		if ( frequnce == m_Imple->m_FreqValue[i].Frequence )
-			return i;
-	}
-	printf ( "No Found Freq\n" );
-	return 100;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Frequence
- *  Description:  Get the Frequecen of given index 
- * =====================================================================================
- */
-int Etio::Get_Frequence(int index)
-{
-	return m_Imple->m_FreqValue[index].Frequence;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Work_Mode
- *  Description:  Set the Work Mode of FPGA 
- * =====================================================================================
- */
-void Etio::Set_Work_Mode(FUNMODE mode)
-{
-	m_Imple->m_Work_Mode = mode;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Work_Mode
- *  Description:  Get the Work Mode
- * =====================================================================================
- */
-Etio::FUNMODE Etio::Get_Work_Mode()
-{
-	return m_Imple->m_Work_Mode;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Select_Sin_Channel
- *  Description:  Select Sin Channel of FPGA
- * =====================================================================================
- */
-void Etio::Interface_Select_Sin_Channel(int ch)
-{
-	if ( ch >= 0 && ch <= 128 )
-		m_Imple->m_Sin_Channel = ch;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Get_Sin_Channel
- *  Description:  Get the Sin Channel 
- * =====================================================================================
- */
-int Etio::Interface_Get_Sin_Channel()
-{
-	return m_Imple->m_Sin_Channel;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Max_Frequence_Length
- *  Description:  Return the Max Frequence Length 
- * =====================================================================================
- */
-int  Etio::Get_Max_Frequence_Length()
-{
-	return m_Imple->m_FREQVALUEN_40MHz;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Get_Version
- *  Description:  Get the Module Version 
- * =====================================================================================
- */
-int  Etio::Get_Version()
-{
-	return m_Imple->m_Version;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Sample_DataN
- *  Description:  return the Sample Data Length 
- * =====================================================================================
- */
-int Etio::Sample_DataN()
-{
-	if 	( m_Imple->m_Work_Mode == Etio::NORMAL )
-		return m_Imple->m_Channels_Number<<1;
-	else if ( m_Imple->m_Work_Mode == Etio::SIN )
-		return Get_Sin_Point_Amount(m_Imple->m_Sin_Channel);
-	else
-		return 2;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Chan_Type
- *  Description:  Set each Channel type and calculate the m_Imple->m_Channels_Number
- * =====================================================================================
- */
-void Etio::Set_Chan_Type()
-{
-	int num = 0;
-
-	for ( int i = 0; i < m_Imple->m_MAX_Channels; i += 1 ) 
-	{
-		if 	( m_Imple->m_Chan_Type[i] != CLOSE )
-		{
-			num ++;
-			switch ( m_Imple->m_Chan_Type[i] )
-			{
-				case ECT:
-					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
-					break;
-
-				case FECT:
-					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 1;
-					break;
-
-				case EMS:
-					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 2;
-					break;
-
-				default:
-					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
-					break;
-			}				/* -----  end switch  ----- */
-		}
-		else
-			m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
-	}
-
-	m_Imple->m_Channels_Number = num;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_RF_Filter_Enable_Switch
- *  Description:  Set the flag that indicate whether to calculate RF parameters 
- * =====================================================================================
- */
-void Etio::Interface_Set_RF_Filter_Enable_Switch(bool flag)
-{
-	m_Imple->m_RF_Filter_Enable = flag;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Get_Channels_Fun
- *  Description:  Only get the signal Channel work mode
- * =====================================================================================
- */
-int Etio::Interface_Get_Channels_Fun(int ch)
-{
-	switch ( m_Imple->m_Chan_Type[ch] ) 
-	{
-		case CLOSE:	
-			return 0;
-			break;
-
-		case ECT:	
-			return 1;
-			break;
-
-		case FECT:	
-			return 2;
-			break;
-
-		case EMS:	
-			return 3;
-			break;
-
-		default:	
-			return 1;
-			break;
-	}				/* -----  end switch  ----- */
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Convert_Media_FreqValue_To_Inside_FreqIndex
- *  Description:  Convert Data Buffer to Inside Frequence index
- * =====================================================================================
- */
-void Etio::Convert_Media_FreqValue_To_Inside_FreqIndex()
-{
-	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
-	{
-		m_Imple->m_ChanFreq[i] = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);
-	}
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Set_Timer_Mode
- *  Description:  Set the Timer1 and Timer2 work mode 
- * =====================================================================================
- */
-void Etio::Set_Timer_Mode()
-{
-	if 	( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == false )
-		POKEB_TC(0x23,0x00);
-	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == true )
-		POKEB_TC(0x23,0x06);
-	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == false )
-		POKEB_TC(0x23,0x02);
-	else if ( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == true )
-		POKEB_TC(0x23,0x04);
-	else
-		POKEB_TC(0x23,0x00);
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Interface_Set_Timers_Mode
- *  Description:  Set the Timers Work Mode  
- *         Note:  index:0~Timer1
- *                      1~Timer2
- *                flag: f~Normal
- *			t~scan1A clean
- *			  scan2A clean
- * =====================================================================================
- */
-void Etio::Interface_Set_Timers_Mode(int index,bool flag)
-{
-	if 	( index == 0 )
-		m_Imple->m_Timer1Mode = flag;
-	else if ( index == 1 )
-		m_Imple->m_Timer2Mode = flag;
-}
diff --git a/src/EVA11/etio.h b/src/EVA11/etio.h
deleted file mode 100644
index 3174811..0000000
--- a/src/EVA11/etio.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  etio.h
- *
- *    Description:  Declearation of etio class
- *
- *        Version:  1.0
- *        Created:  2012年12月18日 11时40分11秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-
-#ifndef  _ETIO_INC
-#define  _ETIO_INC
-
-#include 	<memory>	
-#include 	<stdint.h>
-
-class Etio
-{
-	public:
-		static Etio* Instance();
-
-		enum FUNMODE 
-		{
-			NORMAL  = 	0,
-			SIN     =       1,
-		};
-		typedef enum FUNMODE FUNMODE;
-
-		enum SAMPLETYPE                 	/* Smaple data mode  */
-		{
-			RAWECT	=	0,		//  only X Y 
-			RAWEMS	=	1,		//  only X
-			ALLECT	=	2,		//  X Y INT EXT1 EXT2
-			ALLEMS  =       3,		//  X 0 INT EXT1 EXT2
-			TIMERS  =       4,              //  INT EXT1 EXT2
-		};
-		typedef enum SAMPLETYPE SAMPLETYPE;
-
-		enum CHANTYPE 				/* define the channels type */
-		{
-			CLOSE   =        0,
-			ECT     =        1,
-			FECT    =        2,
-			EMS     =        3
-		};
-		typedef enum CHANTYPE CHANTYPE;
-
-		/*-----------------------------------------------------------------------------
-		 *  module interface
-		 *-----------------------------------------------------------------------------*/
-		int Version();
-		bool InitiateETIO();
-		void UnInitiateETIO();
-
-		/*-----------------------------------------------------------------------------
-		 *  base function interface
-		 *-----------------------------------------------------------------------------*/
-		uint8_t GKey();
-		void Set_ET();
-		void Clear_Timers(int);
-		void POKEB_TC(int add,uint8_t value);
-		uint8_t PEEKB_TC(int add);
-
-		/*-----------------------------------------------------------------------------
-		 *  parameters sets interface,only used by users 
-		 *-----------------------------------------------------------------------------*/
-		void Interface_Set_Channels_Type(int,CHANTYPE);
-		void Interface_Set_Channels_Amount(int);
-		void Interface_Set_Channels_Frequence_Value(int,int);
-		void Interface_Set_Channels_Map_Index(int,int);
-
-		void Interface_Set_Channels_ProbeGain(int,int);
-		void Interface_Set_Channels_ProbeBalance(int,int);
-
-		void Interface_Set_Channels_CoilNumforPickA(int,int);
-		void Interface_Set_Channels_CoilNumforPickB(int,int);
-		void Interface_Set_Channels_CoilNumforDriverA(int,int);
-		void Interface_Set_Channels_CoilNumforDriverB(int,int);
-
-		void Interface_Set_Channels_HighFilter(int,int);
-		void Interface_Set_Channels_LowFilter(int,int);
-
-		void Interface_Set_Channels_Offset(int);
-		void Interface_Set_Channels_SineAmplitude(int);
-
-		void Interface_Set_RF_Filter_Enable_Switch(bool);
-		int Interface_Get_Channels_Fun(int);
-
-		void Interface_Set_Timers_Mode(int,bool);
-
-		void Interface_Select_Sin_Channel(int);
-		int  Interface_Get_Sin_Channel();
-
-		int Get_Frequence_Index(int);
-		int Get_Frequence(int);
-		int  Get_Max_Frequence_Length();
-
-		bool Sample_Chan_Data(int* data,SAMPLETYPE st = RAWECT);
-		int Get_Sin_Point_Amount(int);
-		bool Sample_Sin_Data(int* data,int len);
-
-		void Init_Default_Value();
-
-		void Set_Work_Mode(FUNMODE);
-		FUNMODE Get_Work_Mode();
-		int Sample_DataN();
-
-		/*-----------------------------------------------------------------------------
-		 *  Module Version
-		 *-----------------------------------------------------------------------------*/
-		int  Get_Version();
-	protected:
-
-	private:
-		Etio();                              	   /* constructor */
-		~Etio ();                             	   /* destructor */
-		Etio( const Etio& );
-		Etio& operator = (const Etio&);
-
-		friend class std::auto_ptr<Etio>;
-		static std::auto_ptr<Etio>		m_Instance;
-
-
-		void Load_Board_Information();
-		void Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA);
-
-		void Set_WparamRam_Into_FPGA(int);
-
-		void Refresh_Board_Status();
-
-		void Power(bool);
-		void Running(bool);
-		void Restart();
-
-		void Set_Chan_Amount(int);
-
-		void Init_Frequence_Value();
-		void Calculate_Channel_Parameters();
-		void Calculate_RFCoef(int);
-		void Calculate_LFCoef(int);
-		void Disable_RFCoef(int);
-
-		void Set_Chan_Type();
-		void Set_AdOffset(int);
-		void Set_SineAmplitude(int);
-		void Set_Timer_Mode();
-
-		void Convert_Media_FreqValue_To_Inside_FreqIndex();
-
-	private:
-		struct PImpl;
-		struct WPARAMS;
-		struct JOBAMOUNT;
-		struct PROBBALGAIN;
-		struct BOARDSTATUS;
-		struct FREQUENCESTR;
-
-		std::auto_ptr<struct PImpl>	m_Imple;
-};
-
-#endif   /* ----- #ifndef _ETIO_INC  ----- */
diff --git a/src/EVA11/main.cpp b/src/EVA11/main.cpp
deleted file mode 100644
index a9a6442..0000000
--- a/src/EVA11/main.cpp
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  main.cpp
- *
- *    Description:  Main function define file 
- *
- *        Version:  1.0
- *        Created:  2012年06月05日 09时44分45秒
- *       Revision:  none
- *       Compiler:  gcc
- *
- *         Author:  YOUR NAME (), 
- *   Organization:  
- *
- * =====================================================================================
- */
-#ifndef _MAIN_FILE
-#define _MAIN_FILE
-
-#include 	<cstdlib>
-#include 	<cstdio>
-#include	<iostream>	
-
-#include 	<gsl/gsl_integration.h>
-
-#include 	"ShellCommand.h"
-
-#include	"Basewin.h"
-#include	"Loadwin.h"
-#include	"Mainwin.h"
-#include	"Global.h"	
-#include 	"Initfacade.h"
-#include 	"TCPMainwin.h"
-#include 	"Log.h"
-
-#include 	"Graphic.h"
-
-#include 	<SDL.h>
-#include 	<SDL/SDL_gfxPrimitives.h>
-#include 	<SDL/SDL_gfxBlitFunc.h>
-#include 	<SDL/SDL_rotozoom.h>
-#include 	<SDL/SDL_image.h>
-
-#include 	"Uart.h"
-#include 	"Gif.h"
-#include 	"Resource.h"
-
-#include 	<boost/timer.hpp>
-//#include 	<random.h>
-//#include 	<sort.h>
-
-#include 	<zthread/Thread.h>
-/*-----------------------------------------------------------------------------
- * the thread be used to calculate my tick system
- *-----------------------------------------------------------------------------*/
-class TimeTickThread : public ZThread::Runnable
-{
-public:
-	bool	m_SelfEndFlag;
-public:
-	TimeTickThread()
-	{
-		m_SelfEndFlag = false;
-	}
-	bool Get_EndFlag() { return m_SelfEndFlag; }
-	void run()
-	{
-		Global* gp = Global::Instance();
-		while ( !gp->bTickStop )
-		{
-			if ( !gp->bTickPasuse )
-				gp->Tick ++;
-			ZThread::Thread::sleep(1000);  // sleep 1 second
-		}
-		m_SelfEndFlag = true;
-		std::cout<<"thread exit"<<std::endl;
-	}
-};
-
-#ifdef ARM9
-extern "C"
-{
-	void Asm_Init(void);
-	int Asm_Add(int,int);
-	int Asm_Mul(int,int);
-	int Asm_Point(int*);
-}
-#endif
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  Standard_ET_Fun
- *  Description:  Real Program Enter pointer
- * =====================================================================================
- */
-	void
-Standard_ET_Fun()
-{
-//	Asm_Init();
-//	printf("%x \n",Asm_Add(1,2));
-//	printf("%d \n",Asm_Mul(15,20));
-//	int temp = 2;
-//	Asm_Point(&temp);
-//	printf("%d \n",temp);
-
-//	const int SIZE = 10;
-//	splab::Vector<int> a( SIZE );
-//
-//	for ( int i = 0; i < SIZE; i += 1 ) 
-//	{
-//		a[i] = splab::randu(22,0,100);
-//		printf ( "%d\n",a[i] );
-//	}
-
-//	splab::selectSort(a,0,a.size()-1);
-//
-//	for ( int i = 0; i < SIZE; i += 1 ) 
-//	{
-//		printf ( "%d\n",a[i] );
-//	}
-
-	Log *log = Log::Instance();
-	log->Write_Log("EVA11 System Starting....");
-
-	Initfacade* initfacade = new Initfacade;
-	if  	( initfacade->Standard_ET_System_Init() == false )
-	{
-		Global* gp = Global::Instance();
-		gp->bTickStop = true;
-		return;
-	}
-
-	Graphic *g = Graphic::Instance(); 
-
-MAINLOOP:
-	Loadwin *loadw = new Loadwin(*g,Loadwin::LT_LOAD);
-	int result = loadw->Loopwindow(*g);
-	delete loadw;
-	loadw = NULL; 
-	if 	( result == Basewin::CO_OK || result == Basewin::CO_LOADEXIT )
-	{
-		Mainwin *mwin = new Mainwin;
-		mwin->Loopwindow(*g);
-		delete mwin;
-		mwin = NULL;
-		goto MAINLOOP;
-	}
-
-	initfacade->Standard_ET_System_Destroy();
-	delete initfacade;
-	initfacade = NULL;
-	log->Write_Log("EVA11 System Exit....");
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Standard_Network_TCP
- *  Description:  Run Network function based on TCP protocol 
- * =====================================================================================
- */
-	void
-Standard_Network_TCP()
-{
-	printf ( "tcp netowrk work mode start, but no finish\n" );
-
-	Initfacade* initfacade = new Initfacade;
-	if  	( initfacade->Standard_TCP_System_Init() == false )
-		return;
-
-	Graphic *g = Graphic::Instance(); 
-
-	TCPMainwin* tcpwin = new TCPMainwin;
-	tcpwin->Loopwindow(*g);
-	delete tcpwin;
-	tcpwin = NULL;
-	initfacade->Standard_TCP_System_Destroy();
-	delete initfacade;
-	initfacade = NULL;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Standard_SDL_Fun
- *  Description:  Used for test SDL function 
- * =====================================================================================
- */
-//double f(double x,void* param)
-//{
-//	double alpha = *(double *)param;
-//	double f     = alpha * x * x; 
-//	return f;
-//}
-
-	void
-Standard_SDL_Fun()
-{
-//	boost::timer t;
-//	for ( int m = 0; m < 100; m += 1 ) 
-//	{
-//
-//		for ( volatile int i = 0; i < 640; i += 1 )
-//		{
-//			for ( volatile int j = 0; j < 480; j += 1 )
-//			{
-//				g->Setpixel(i,j,0x00);
-//			}
-//		}
-//	}
-//
-//	printf ( "graphic second %d\n",t.elapsed() );
-//
-//	g->Closegraph();
-//	delete g;
-//	g = NULL;
-
-
-//	gsl_integration_workspace *w = gsl_integration_workspace_alloc(1000);
-//
-//	gsl_function F;
-//	F.function   = &f;
-//
-//	double alpha = 1.0;
-//	F.params     = &alpha;
-//
-//	double result,error;
-//	gsl_integration_qags(&F,3,5,0,1e-7,1000,w,&result,&error);
-//
-//	printf ( "%f\n",result );
-//	printf ( "%f\n",error );
-//	printf ( "%d\n",w->size );
-//	printf ( "%.20f\n",1e-20 );
-//
-//	gsl_integration_workspace_free(w);
-
-//	splab::Vector<int> a(10);
-//	for ( int i=0;i<10;i++ )
-//	{
-//		a[i] = splab::randu(67,1,100);
-//		printf ( "%d\n",a[i] );
-//	}
-//
-//	quickSort(a,0,a.size()-1);
-//
-//	for ( int i=0;i<10;i++ )
-//	{
-//		printf ( "%d\n",a[i] );
-//	}
-
-//	if ( SDL_Init(SDL_INIT_VIDEO) < 0 )
-//	{
-//		printf("SDL init fail: %s\n",SDL_GetError());
-//		return ;
-//	}
-//
-//	SDL_Surface *scr = NULL;
-//	scr = SDL_SetVideoMode(640,480,16,SDL_SWSURFACE);
-//	if ( scr == NULL )
-//	{
-//		printf("SDL set video mode fail: %s\n",SDL_GetError());
-//		return ;
-//	}
-//
-//	int color;
-//	for ( int i=0;i<480;i++ )
-//	{
-//		for ( int j=0;j<640;j++ )
-//		{
-//			*((short *)scr->pixels+i*scr->pitch/2+j) = SDL_MapRGB(scr->format,color,0,0); 
-//			color ++;
-//			if ( color == 256 )
-//				color = 0;
-//		}
-//	}
-//
-//	roundedBoxColor(scr,440,0,639,100,15,0xffffffff);
-//	stringColor(scr,100,100,"Hello the world 中华 RGB-2312",0xffffffff);
-//
-//	pixelColor(scr,100,20,0xffffff00);
-//	pixelColor(scr,100,21,0xffffff00);
-//	pixelColor(scr,100,22,0xffffff00);
-
-//	div_t result = div(416,32); 
-//	printf ( "quot = %d\n",result.quot );
-//	printf ( "remain = %d\n",result.rem );
-
-//	Uart uart;
-//	uart.Init_Uart();
-
-//	uint8_t data[100];
-//	for ( int i = 0; i < 100; i += 1 ) 
-//	{
-//		data[i] = 0x50+i; 
-//	}
-//
-//	uart.Send_Data(data,100);
-//	uart.Destory_Uart();
-
-//	SDL_UpdateRect(scr,0,0,639,479);
-//	SDL_Delay(5000);
-//
-//	SDL_Quit();
-	
-
-	Graphic *g = Graphic::Instance(); 
-	if 	( g->Initgraph() == false ) 
-	{
-		perror("Error! Can't init the environment");
-		return ;
-	}
-
-	Resource *res = Resource::Instance();
-	res->Show_Resource_Gif(12,2,80,160,120);
-
-	g->Closegraph();
-
-
-//	if ( SDL_Init(SDL_INIT_EVERYTHING) == -1 ){
-//		perror(SDL_GetError());
-//		return ;
-//	}
-//
-//	SDL_Window *win = NULL;
-//	win = SDL_CreateWindow("Hello World!", 100, 100, 640, 480, SDL_WINDOW_SHOWN);
-//	if (win == NULL){
-//		std::cout << SDL_GetError() << std::endl;
-//		return ;
-//	}
-//
-// 	SDL_DestroyWindow(win);
-//	SDL_Quit();
-
-	return ;
-}
-
-/* 
- * ===  FUNCTION  ======================================================================
- *         Name:  Signal_Interrupt
- *  Description:  When User enter ctrl-C button call this function 
- * =====================================================================================
- */
-void Signal_Interrupt(int n,siginfo_t *psiginfo,void *myact)
-{
-	printf("signal number:%d\n",n);			/* * 打印出信号值 **/  
-	printf("siginfo signo:%d\n",psiginfo->si_signo); /* * siginfo结构里保存的信号值 **/  
-	printf("siginfo errno:%d\n",psiginfo->si_errno); /* * 打印出错误代码 **/  
-	printf("siginfo code:%d\n",psiginfo->si_code);   /* * 打印出出错原因 **/  
-	exit(0);
-}
-
-/*
- * ===  FUNCTION  ======================================================================
- *         Name:  main
- *  Description:  Program Enter pointer 
- * =====================================================================================
- */
-	int
-main ( int argc, char *argv[] )
-{
-	struct sigaction act;  
-	sigemptyset(&act.sa_mask);     				/* * 清空阻塞信号 **/  
-	act.sa_flags = SA_SIGINFO;     				/* * 设置SA_SIGINFO 表示传递附加信息到触发函数 **/  
-	act.sa_sigaction = Signal_Interrupt;  
-	if	( sigaction(SIGINT,&act,NULL) < 0 )  
-	{
-		perror("install signal error\n");  
-	}
-
-	ShellCommand *shc = new ShellCommand();
-	shc->SetVer(PROVERSION);
-	ShellCommand::SHELLCOMMAND command = shc->Analyze(argc,argv);
-	delete shc;
-	shc = NULL;
-
-	if 	( command == ShellCommand::SHELLCOMMAND_NORMAL )
-	{
-		TimeTickThread *pthread = new TimeTickThread;
-		ZThread::Thread t(pthread);
-		Standard_ET_Fun();
-		while( !pthread->Get_EndFlag() )
-			usleep(500);				// need some time to excute other thread
-	}
-	else if ( command == ShellCommand::SHELLCOMMAND_TCPNETWORK )
-	{
-		Standard_Network_TCP();
-	}
-	else if ( command == ShellCommand::SHELLCOMMAND_SDL )
-	{
-		Standard_SDL_Fun();
-	}
-
-	return EXIT_SUCCESS;
-}
-#endif
diff --git a/src/EVA11/main.h b/src/EVA11/main.h
deleted file mode 100644
index 1fd1f70..0000000
--- a/src/EVA11/main.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * =====================================================================================
- *
- *       Filename:  main.h
- *
- *    Description:  工程使用头文件放置常量以及类型定义
- *
- *        Version:  1.0
- *        Created:  2012年06月05日 15时36分53秒
- *       Revision:  none
- *       Compiler:  gcc-arm
- *
- *         Author:  kevin.wang
- *        Company:  eddysun
- *
- * =====================================================================================
- */
-#ifndef _MAINHEAD_
-#define _MAINHEAD_
-
-#define PROVERSION 	"1.01"
-#define PAR_FILE_PATH	"/var/1"
-
-#ifdef ARM9
-#define FONT_FILE_PATH  "/tmp/wqy-zenhei.ttc"
-#else
-#define FONT_FILE_PATH  "wqy-zenhei.ttc"
-#endif
-
-//#define CALSAMPLE				     /* calculate the sample ratio */
-
-/*-----------------------------------------------------------------------------
- *  Define the platform flag
- *-----------------------------------------------------------------------------*/
-//#define _ARM_ 
-#define _X86_
-/*-----------------------------------------------------------------------------
- *  Define Hardware -- Device type
- *-----------------------------------------------------------------------------*/
-#define _SMART_308_
-/*-----------------------------------------------------------------------------
- *  keyboard mapping marc, becareful the marc must be only one
- *-----------------------------------------------------------------------------*/
-#ifdef X86
-#define _KEY_PC_                                      /* Used the PC keyboard */
-#else
-#define _KEY_PC_                                      /* Used the PC keyboard */
-//#define _KEY_308_A_                                     /* EVA11 Array keyboard two board */
-//#define _KEY_308_1_                                   /* Smart-308 keyboard just only one board */
-//#define _KEY_308_2_                                   /* Smart-308 keyboard two board */
-#endif
-
-#include 	"ProjectFixHead.h"
-
-/*-----------------------------------------------------------------------------
- * The const variable as follow were used by programe during runtime 
- *-----------------------------------------------------------------------------*/
-/*-----------------------------------------------------------------------------
- *  The path used by application
- *-----------------------------------------------------------------------------*/
-#define HELP_PATH		"/tmp/EVA/HELP/"            /* The path saving the help document */
-#define DATA_PATH		"/tmp/EVA/DATA/"            /* The path saving the Eddy testing data*/
-#define PARA_PATH               "/tmp/EVA/PARA/"            /* The path saving the parameters of device */
-#define PIC_PATH                "/tmp/EVA/PIC/"             /* The path saving the parameters of device */
-#define LOG_PATH		"/tmp/EVA/LOG/"
-#define DB_PATH			"/tmp/EVA/DB/"
-
-#ifdef  ARM9
-#define RUN_PATH                "/jffs2/ET/"                /* The application running envirenment */
-#else
-#define RUN_PATH                "./"                	    /* The application running envirenment */
-#endif
-
-#define MAIN_PATH               "/jffs2/"                   /* The Main program */
-#define PBM_PATH		"/tmp/EVA/"                 /* Save the PBM picture temprary used by print */
-#define APP_READY_PATH          "/tmp/EVA/"                 /* When update the application,cp the program to this */
-
-#define HELP_PATH_RU            "/mnt/eva/help/"            /* The usb help directory */
-#define DATA_PATH_RU            "/mnt/eva/data/"	
-#define PARA_PATH_RU            "/mnt/eva/para/"
-#define PIC_PATH_RU             "/mnt/eva/pic/"
-#define LOG_PATH_RU		"/tmp/eva/log/"
-#define DB_PATH_RU		"/tmp/eva/db/"
-
-#define RUN_PATH_RU             "/mnt/eva/"                 /* The usb remote directory */
-
-#define	LOGDIRECTORY            LOG_PATH
-/*-----------------------------------------------------------------------------
- *  Globle variables define 
- *-----------------------------------------------------------------------------*/
-#ifdef _MAIN_FILE
-#define EXTF
-#else
-#define EXTF extern
-#endif
-/*-----------------------------------------------------------------------------
- *  Color variables define
- *-----------------------------------------------------------------------------*/
-EXTF COLORTYPE           g_SHADOW_CO;
-EXTF COLORTYPE           g_LIGHT_CO;
-
-EXTF COLORTYPE           g_BATTARY_CO;
-
-EXTF COLORTYPE           g_BUTXNO_CO;
-EXTF COLORTYPE           g_BUTXFO_CO;
-EXTF COLORTYPE           g_BUBGNO_CO;
-EXTF COLORTYPE           g_BUBGFO_CO;
-
-EXTF COLORTYPE           g_MAINBG_CO;
-EXTF COLORTYPE           g_MAINFG_CO;
-EXTF COLORTYPE           g_BUFFFG_CO;
-
-EXTF COLORTYPE           g_MOVBBG_CO;
-EXTF COLORTYPE           g_MOVBFG_CO;
-EXTF COLORTYPE           g_MOVBTX_CO;
-
-EXTF COLORTYPE           g_SCBG_CO;
-EXTF COLORTYPE           g_SCFG_CO;
-EXTF COLORTYPE           g_SCTX_CO;
-
-EXTF COLORTYPE		 g_Pen[32];                        /* It mapped to 224-255 32 pallates */
-
-#endif   /* ----- #ifndef _MAINHEAD_INC  ----- */
-- 
1.8.5.1


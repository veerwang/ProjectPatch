From 5e16928a6a9e1c6c98f9a42504e1bfa19ea66e92 Mon Sep 17 00:00:00 2001
From: kevin <kevin.wang2004@hotmail.com>
Date: Mon, 13 Jan 2014 08:53:06 +0800
Subject: [PATCH] =?UTF-8?q?=E7=BB=A7=E7=BB=AD=E4=BF=AE=E6=AD=A3Makefile?=
 =?UTF-8?q?=E6=96=87=E4=BB=B6,=E5=B9=B6=E4=B8=94=E5=88=A0=E9=99=A4DEPS?=
 =?UTF-8?q?=E4=B8=8EOBJS=E7=9B=AE=E5=BD=95?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 src/EVA11/Makefile              |    1 +
 src/EVA11/base/DEPS/ASMS/README |    0
 src/EVA11/base/DEPS/JPGS/README |    0
 src/EVA11/base/DEPS/README      |    0
 src/EVA11/base/Makefile         |   73 +-
 src/EVA11/base/OBJS/ASMS/README |    0
 src/EVA11/base/OBJS/JPGS/README |    0
 src/EVA11/base/OBJS/README      |    0
 src/EVA11/libetio/Makefile      |   70 ++
 src/EVA11/libetio/etio.cpp      | 1762 +++++++++++++++++++++++++++++++++++++++
 src/EVA11/libetio/etio.h        |  169 ++++
 11 files changed, 2048 insertions(+), 27 deletions(-)
 delete mode 100644 src/EVA11/base/DEPS/ASMS/README
 delete mode 100644 src/EVA11/base/DEPS/JPGS/README
 delete mode 100644 src/EVA11/base/DEPS/README
 delete mode 100644 src/EVA11/base/OBJS/ASMS/README
 delete mode 100644 src/EVA11/base/OBJS/JPGS/README
 delete mode 100644 src/EVA11/base/OBJS/README
 create mode 100644 src/EVA11/libetio/Makefile
 create mode 100644 src/EVA11/libetio/etio.cpp
 create mode 100644 src/EVA11/libetio/etio.h

diff --git a/src/EVA11/Makefile b/src/EVA11/Makefile
index 86ab0c8..0434292 100644
--- a/src/EVA11/Makefile
+++ b/src/EVA11/Makefile
@@ -9,6 +9,7 @@
 #            which project to be constructed
 #            
 ###########################################################
+#SUBDIRS := $(shell find * -maxdepth 0 -path 'test' -o -path 'ggg' -prune -o -name '*' -type d -print)
 SUBDIRS := $(shell find * -maxdepth 0 -type d)
 .PHONY : all
 all:
diff --git a/src/EVA11/base/DEPS/ASMS/README b/src/EVA11/base/DEPS/ASMS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/base/DEPS/JPGS/README b/src/EVA11/base/DEPS/JPGS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/base/DEPS/README b/src/EVA11/base/DEPS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/base/Makefile b/src/EVA11/base/Makefile
index 2abbbff..51348a5 100644
--- a/src/EVA11/base/Makefile
+++ b/src/EVA11/base/Makefile
@@ -9,6 +9,9 @@
 #            
 #
 ###########################################################
+#LOOPDIR:=$(shell find * -maxdepth 0 -path 'OBJS' -o -path 'DEPS' -prune -o -name '*' -type d -print)
+#SRCS+=$(wildcard $($(foreach DIR,$(LOOPDIR),$(DIR))/*.cpp))
+
 include MKlib.mk 
 
 ifeq ($(CMOD),dynamic)
@@ -27,8 +30,7 @@ OBJS_DIR:=./$(TXTOBJS)/
 DEPS_DIR:=./$(TXTDEPS)/
 
 SRCS=
-SRCS+=$(wildcard *.cpp *.c)
-SRCS+=$(wildcard $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif)
+SRCS+=$(wildcard *.cpp *.c $(TXTJPGS)/*.jpg $(TXTJPGS)/*.png $(TXTJPGS)/*.gif)
 
 ifeq ($(COMPILE),arm9)
 SRCS+=$(wildcard $(TXTASMS)/*.s)
@@ -53,72 +55,89 @@ endif
 endif
 
 all: $(DEPS) $(EXEC)
+	@echo "build EVA11 ..."
 
-$(DEPS_DIR)%.cpp.dep: %.cpp
+$(DEPS_DIR)%.cpp.dep: %.cpp | depsdir
 	@set -e; \
 	$(RM) -rf $@.tmp; \
 	gcc -E -MM $^ > $@.tmp; \
 	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.cpp.o:,g' < $@.tmp > $@; \
 	$(RM) $@.tmp
 
-$(DEPS_DIR)%.c.dep: %.c
+$(DEPS_DIR)%.c.dep: %.c | depsdir
 	@set -e; \
 	$(RM) -rf $@.tmp; \
 	gcc -E -MM $^ > $@.tmp; \
 	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.c.o:,g' < $@.tmp > $@; \
 	$(RM) $@.tmp
 
-$(DEPS_DIR)$(TXTASMS)/%.s.dep: $(TXTASMS)/%.s
+$(DEPS_DIR)$(TXTASMS)/%.s.dep: $(TXTASMS)/%.s | depsasmdir
 	@set -e; \
 	$(RM) -rf $@.tmp; \
 	echo $^: $^ > $@.tmp; \
 	sed 's,\(.*\)\.s: *,$(TXTOBJS)/\1.o:,g' < $@.tmp > $@; \
 	$(RM) $@.tmp
 
-$(DEPS_DIR)$(TXTJPGS)/%.jpg.dep: $(TXTJPGS)/%.jpg
+$(DEPS_DIR)$(TXTJPGS)/%.jpg.dep: $(TXTJPGS)/%.jpg | depsjpegdir
 	@set -e;
 
-$(DEPS_DIR)$(TXTJPGS)/%.png.dep: $(TXTJPGS)/%.png
+$(DEPS_DIR)$(TXTJPGS)/%.png.dep: $(TXTJPGS)/%.png | depsjpegdir
 	@set -e;
 
-$(DEPS_DIR)$(TXTJPGS)/%.gif.dep: $(TXTJPGS)/%.gif
+$(DEPS_DIR)$(TXTJPGS)/%.gif.dep: $(TXTJPGS)/%.gif | depsjpegdir
 	@set -e;
 
+depsdir:
+	@mkdir -p $(DEPS_DIR)
+
+depsasmdir:
+	@mkdir -p $(DEPS_DIR)$(TXTASMS)
+
+depsjpegdir:
+	@mkdir -p $(DEPS_DIR)$(TXTJPGS)
+
 -include $(DEPS)
 
 $(EXEC): $(OBJS)
 	$(CPP) $(FLAG) -o $@ $^ -Wl,-Bdynamic $(addprefix -l,$(DYNAMICLIBS)) -Wl,-Bstatic $(addprefix -l,$(STATICLIBS)) $(SEARCH_LIBPATH) -Wl,-Bdynamic
 
-$(addprefix $(OBJS_DIR),%.s.o): %.s
-	$(AS) $< -o $@
-
-$(addprefix $(OBJS_DIR),%.c.o): %.c
+$(OBJS_DIR)%.c.o: %.c | objsdir
 	$(CC) $(C_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
 
-$(addprefix $(OBJS_DIR),%.cpp.o): %.cpp
+$(OBJS_DIR)%.cpp.o: %.cpp | objsdir
 	$(CPP) $(CPP_COMPILE_FLAG) $(DFLAG) $(COMPILE_FLAG) $(SEARCH_INCPATH) -c $< -o $@
 
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.jpg.o): $(TXTJPGS)/%.jpg
-ifeq ($(COMPILE),arm9)
-	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
-else
-	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
-endif
+$(OBJS_DIR)$(TXTASMS)%.s.o: $(TXTASMS)/%.s | objsasmsdir
+	$(AS) $< -o $@
 
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.png.o): $(TXTJPGS)/%.png
-ifeq ($(COMPILE),arm9)
-	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
-else
-	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
-endif
+$(OBJS_DIR)$(TXTJPGS)/%.jpg.o: $(TXTJPGS)/%.jpg | objsjpegdir
+	$(makejpegresource)
+
+$(OBJS_DIR)$(TXTJPGS)/%.png.o: $(TXTJPGS)/%.png | objsjpegdir
+	$(makejpegresource)
+
+$(OBJS_DIR)$(TXTJPGS)/%.gif.o: $(TXTJPGS)/%.gif | objsjpegdir
+	$(makejpegresource)
 
-$(addprefix $(OBJS_DIR),$(TXTJPGS)/%.gif.o): $(TXTJPGS)/%.gif
 ifeq ($(COMPILE),arm9)
+define makejpegresource
 	$(OBJCOPY) -I binary -O elf32-littlearm -B arm $< $@
+endef
 else
+define makejpegresource
 	$(OBJCOPY) -I binary -O elf32-i386 -B i386 $< $@
+endef
 endif
 
+objsdir:
+	@mkdir -p $(OBJS_DIR)
+
+objsasmsdir:
+	@mkdir -p $(OBJS_DIR)$(TXTASMS)
+
+objsjpegdir:
+	@mkdir -p $(OBJS_DIR)$(TXTJPGS)
+
 .PHONY: clean
 clean:
-	$(RM) -rf $(addprefix $(OBJS_DIR),*.o) $(addprefix $(OBJS_DIR),$(TXTJPGS)/*.o) $(addprefix $(OBJS_DIR),$(TXTASMS)/*.o) $(addprefix $(DEPS_DIR),*.dep) $(addprefix $(DEPS_DIR)ASMS/,*.dep) $(EXEC)
+	$(RM) -rf $(OBJS_DIR) $(DEPS_DIR) $(EXEC)
diff --git a/src/EVA11/base/OBJS/ASMS/README b/src/EVA11/base/OBJS/ASMS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/base/OBJS/JPGS/README b/src/EVA11/base/OBJS/JPGS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/base/OBJS/README b/src/EVA11/base/OBJS/README
deleted file mode 100644
index e69de29..0000000
diff --git a/src/EVA11/libetio/Makefile b/src/EVA11/libetio/Makefile
new file mode 100644
index 0000000..7171bf7
--- /dev/null
+++ b/src/EVA11/libetio/Makefile
@@ -0,0 +1,70 @@
+##########################################################
+#
+#                   For Shared library Test 
+#
+# Author:    kevin.wang
+# Company:   Eddysun     xiamen
+# Date:      2012.12.18
+#            
+#
+###########################################################
+LIBNAME := libetio
+SONAME   := $(LIBNAME).so.0
+REALNAME := $(LIBNAME).so.0.0.0
+LINKNAME := $(LIBNAME).so
+STATICLIB:= $(LIBNAME).a
+
+TXTOBJS:=OBJS
+TXTDEPS:=DEPS
+OBJS_DIR:=./$(TXTOBJS)/
+DEPS_DIR:=./$(TXTDEPS)/
+
+SRCS:=$(wildcard *.cpp *.c *.s *.jpg)
+OBJS:=$(SRCS:=.o)
+DEPS:=$(SRCS:=.dep)
+
+OBJS:=$(addprefix $(OBJS_DIR),$(OBJS))
+DEPS:=$(addprefix $(DEPS_DIR),$(DEPS))
+
+ifeq 	($(COMPILE),arm9)
+COMPILE_FLAG = -O2 -std=gnu++0x -fPIC -DPIC -march=armv4t
+else ifeq ($(COMPILE),x86)
+COMPILE_FLAG = -O2 -std=gnu++0x -fPIC -DPIC
+endif
+
+LIBS:=$(LIBS) gsl
+STATICLIBS:=
+
+SEARCH_LIBPATH = -L$(MYLIBS_DIR)/libgsl/lib/
+SEARCH_INCPATH = -I$(MYLIBS_DIR)/libgsl/include/
+
+all: $(DEPS) $(REALNAME)
+	@echo "build $(LIBNAME) ..."
+	@ln -sf $(REALNAME) $(SONAME);ln -sf $(REALNAME) $(LINKNAME)
+
+$(DEPS_DIR)%.cpp.dep: %.cpp | depsdir
+	@set -e; \
+	$(RM) -rf $@.tmp; \
+	gcc -E -MM $^ > $@.tmp; \
+	sed 's,\(.*\)\.o[ :]*,$(TXTOBJS)/\1.cpp.o:,g' < $@.tmp > $@; \
+	$(RM) $@.tmp
+
+depsdir:
+	@mkdir -p $(DEPS_DIR)
+
+-include $(DEPS)
+
+$(REALNAME): $(OBJS)
+	$(CPP) -fPIC -DPIC -shared -Wl,-soname -Wl,$(SONAME) -o $@ $^ -Wl,-Bdynamic $(addprefix -l,$(LIBS)) -Wl,-Bstatic $(addprefix -l,$(STATICLIBS)) $(SEARCH_LIBPATH) -Wl,-Bdynamic
+	$(AR) -r $(STATICLIB) $^
+	$(RANLIB) $(STATICLIB)
+
+$(OBJS_DIR)%.cpp.o: %.cpp | objsdir
+	$(CPP) $(COMPILE_FLAG) $(EXTDEF) $(SEARCH_INCPATH) -c $< -o $@
+
+objsdir:
+	@mkdir -p $(OBJS_DIR)
+
+.PHONY: clean
+clean:
+	$(RM) -rf $(OBJS_DIR) $(DEPS_DIR) $(REALNAME) $(LINKNAME) $(SONAME) $(STATICLIB)
diff --git a/src/EVA11/libetio/etio.cpp b/src/EVA11/libetio/etio.cpp
new file mode 100644
index 0000000..f8728ea
--- /dev/null
+++ b/src/EVA11/libetio/etio.cpp
@@ -0,0 +1,1762 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  etio.cpp
+ *
+ *    Description:  
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月18日 11时07分14秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#include 	<cmath>
+#include 	<cstdio>
+#include 	<cstdlib>
+#include 	<fcntl.h>
+#include 	<unistd.h>
+#include 	<sys/mman.h>
+
+#include 	"etio.h"
+
+#define 	DEVICE_KBTEST	"/dev/ECT"
+#define 	PI              3.1415926
+
+std::auto_ptr<Etio> Etio::m_Instance;
+
+struct Etio::BOARDSTATUS
+{
+	unsigned 		SampleReady : 1;
+	unsigned 		None3       : 3;
+	unsigned 		PowerOn     : 1;
+	unsigned 		Running     : 1;
+	unsigned 		Shutdown    : 1;
+	unsigned 		None1       : 1;
+};
+
+struct Etio::PROBBALGAIN
+{
+	unsigned 		ProbeGain : 3;
+	unsigned 		None	  : 1;
+	unsigned 		ProbeBal  : 4;
+};
+
+struct Etio::JOBAMOUNT
+{
+	unsigned 		WpAmount : 4;
+	unsigned 		ChJob    : 4;
+};
+
+struct Etio::WPARAMS
+{
+	uint8_t 		WpDivisorLo;
+	uint8_t 		WpDivisorHi;
+	uint8_t 		WpAmount;
+
+	Etio::JOBAMOUNT		JobWpAmount;
+
+	uint8_t 		WpDeltaLo;
+	uint8_t 		WpDeltaMi;
+	uint8_t 		WpDeltaHi;
+
+	Etio::PROBBALGAIN	ProbeBalGain;
+
+	uint8_t			CoilNumforPickB;
+	uint8_t			CoilNumforPickA;
+
+	uint8_t			CoilNumforDriverB;
+	uint8_t			CoilNumforDriverA;
+
+	uint8_t			RfLpCoefLo;
+	uint8_t			RfLpCoefHi;
+
+	uint8_t			RfHpCoefLo;
+	uint8_t			RfHpCoefHi;
+
+	uint8_t			LfLpCoefLo;
+	uint8_t			LfLpCoefHi;
+
+	uint8_t			LfHpCoefLo;
+	uint8_t			LfHpCoefHi;
+};
+
+struct Etio::FREQUENCESTR
+{
+	int			Frequence;
+	int			Wck;
+};
+
+struct Etio::PImpl
+{
+	static const int 	m_Version 	   = 101;
+	static const int	m_FREQVALUEN_40MHz = 2216;
+	static const int	m_cMAXSN 	   = 128;   // Max Structure Number
+	static const int	m_cMAXFreqAmount   = 8;
+
+	int			m_FD;
+
+	volatile uint8_t*	m_pET;
+
+	FUNMODE			m_Work_Mode;		    // Normal\Sin
+	int			m_Sin_Channel;		    // select the SIN channel
+	/*-----------------------------------------------------------------------------
+	 * Media layer  
+	 *-----------------------------------------------------------------------------*/
+	int			m_High_Filter[m_cMAXSN];
+	int			m_Low_Filter[m_cMAXSN];
+	int			m_Offset;
+	int			m_SineAmp;
+	CHANTYPE		m_Chan_Type[m_cMAXSN];
+	int			m_MediaChanFreq[m_cMAXFreqAmount];
+	/*-----------------------------------------------------------------------------
+	 * Board Information  
+	 *-----------------------------------------------------------------------------*/
+	uint8_t			m_TQ_Main_Version;          // 03
+	uint8_t 		m_TQ_Sub_Version;      	    // 4
+	uint8_t			m_FPGA_Version;	       	    // 1 ..
+
+	uint8_t			m_MAX_Channels;        	    // 1~128
+
+	bool			m_bECT;
+	bool			m_bFECT;
+	bool			m_bRF;
+	bool			m_bEMS;
+	bool			m_bLF;
+
+	bool			m_RF_Filter_Enable;	    // it desides whether RF readmode need to set RF Filter Enable
+
+	Etio::FREQUENCESTR	m_FreqValue[m_FREQVALUEN_40MHz];	
+	int			m_FreqValueLength;
+
+	int			m_Channels_Number;	     // Current MAX channels
+	int			m_ChanFreq[m_cMAXSN];
+	int			m_ChanMapMedia2FreqIndex[m_cMAXSN];
+	Etio::WPARAMS           m_ChanPara[m_cMAXSN];	     // used this strcuture to configrature probe
+
+	bool			m_Timer1Mode;
+	bool			m_Timer2Mode;
+
+	Etio::BOARDSTATUS       BoardStatus;
+};
+
+Etio::Etio () : m_Imple(new struct PImpl)
+{
+}
+
+Etio::~Etio ()
+{
+}
+
+/*
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Instance
+ *  Description:  make sure the class instance can be only instance once
+ * =====================================================================================
+ */
+Etio* Etio::Instance()
+{
+	if 	( m_Instance.get() == 0 )
+	{
+		m_Instance.reset( new Etio() );
+	}
+	return m_Instance.get();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Version
+ *  Description:  Get the share library version 
+ * =====================================================================================
+ */
+int Etio::Version()
+{
+	return m_Imple->m_Version; 
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Board_Version
+ *  Description:  Get the Board Version information from board 
+ * =====================================================================================
+ */
+void Etio::Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA)
+{
+#ifdef X86
+	Main = 1;
+	Sub  = 2;
+	FPGA = 3;
+#else
+	Main = m_Imple->m_TQ_Main_Version;
+	Sub  = m_Imple->m_TQ_Sub_Version;
+	FPGA = m_Imple->m_FPGA_Version;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Load_Board_Information
+ *  Description:  Load infromation from Board 
+ * =====================================================================================
+ */
+void Etio::Load_Board_Information()
+{
+#ifdef X86
+	m_Imple->m_TQ_Sub_Version = 3;
+	m_Imple->m_FPGA_Version   = 2;
+	m_Imple->m_TQ_Main_Version= 1; 
+	m_Imple->m_MAX_Channels   = 128;
+
+	m_Imple->m_bECT  = true;
+	m_Imple->m_bFECT = true;
+	m_Imple->m_bRF   = true;
+	m_Imple->m_bEMS  = true;  
+	m_Imple->m_bLF   = true;
+#else
+	uint8_t t = PEEKB_TC(0x0000);
+	m_Imple->m_TQ_Sub_Version  = ( t & 0xf0 ) >> 4;
+	m_Imple->m_FPGA_Version    = t & 0x0f;
+	m_Imple->m_TQ_Main_Version = PEEKB_TC(0x0001);
+	m_Imple->m_MAX_Channels    = pow(2,PEEKB_TC(0x0002) & 0x07);
+
+	m_Imple->m_bECT  = false;
+	m_Imple->m_bFECT = false;
+	m_Imple->m_bRF   = false;
+	m_Imple->m_bEMS  = false;  
+	m_Imple->m_bLF   = false;
+
+	t = ( PEEKB_TC(0x0002) & 0xf8 ) >> 3;
+
+	if ( t & 0x01 )
+		m_Imple->m_bECT  = true;
+
+	if ( (t>>1) & 0x01 )
+		m_Imple->m_bFECT = true;
+
+	if ( (t>>2) & 0x01 )
+		m_Imple->m_bRF   = true;
+
+	if ( (t>>3) & 0x01 )
+		m_Imple->m_bEMS  = true;
+
+	if ( (t>>4) & 0x01 )
+		m_Imple->m_bLF   = true;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  POKEB_TC
+ *  Description:  Set value into TCB 
+ * =====================================================================================
+ */
+void Etio::POKEB_TC(int add,uint8_t value)
+{
+#ifdef X86
+#else
+	m_Imple->m_pET[2] = static_cast<uint8_t>( add & 0xff );
+	m_Imple->m_pET[3] = static_cast<uint8_t>( ( add >> 8 ) & 0xff ); 
+	m_Imple->m_pET[4] = value; 
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  PEEKB_TC
+ *  Description:  Read Dat from TC 
+ * =====================================================================================
+ */
+uint8_t Etio::PEEKB_TC(int add)
+{
+#ifdef X86
+	return 0;
+#else
+	m_Imple->m_pET[2]   = static_cast<uint8_t>( add & 0xff );
+	m_Imple->m_pET[3]   = static_cast<uint8_t>( (add>>8) & 0xff );
+	return m_Imple->m_pET[8];
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  InitialteETIO
+ *  Description:  Initialte the ETIO board 
+ * =====================================================================================
+ */
+bool Etio::InitiateETIO()
+{
+#ifdef X86
+#else
+	if	( (m_Imple->m_FD=open(DEVICE_KBTEST, O_RDWR ))<0 )
+	{ 
+		perror("can not open device");
+		return false;
+	}
+	else
+	{ 
+		m_Imple->m_pET =(volatile uint8_t*) mmap(NULL, 16, PROT_READ|PROT_WRITE, /*0*/MAP_SHARED, m_Imple->m_FD, 0); 
+		if	( m_Imple->m_pET==MAP_FAILED )
+		{
+			perror("Map Failed"); 
+			return false;
+		}
+
+		POKEB_TC(0x10,0); 
+		if	( ( PEEKB_TC(0x06) & 0x10 ) !=0 )
+		{
+			perror("No Found the ET Board");
+			return false;
+		}
+		POKEB_TC(0x10,1); 
+		if	( ( PEEKB_TC(0x06) & 0x10 ) != 0x10 ) 
+		{
+			perror("No Found the ET Board");
+			return false;
+		}
+	}
+#endif
+
+	/*-----------------------------------------------------------------------------
+	 *  Init FPGA Board variables
+	 *-----------------------------------------------------------------------------*/
+	uint8_t main,sub,fpga;
+	Load_Board_Information();
+	Refresh_Board_Status();
+	Get_Board_Version(main,sub,fpga);
+	printf ( "FPGA Information TQ%02d-%c FPGA%d\n",main,'A'+sub,fpga );
+
+	Init_Frequence_Value();
+	Init_Default_Value();
+
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  UnInitiateETIO
+ *  Description:  Release Board Value
+ * =====================================================================================
+ */
+void Etio::UnInitiateETIO()
+{
+	Running(false);
+	Power(false);
+#ifdef X86
+#else
+	munmap((void *)(m_Imple->m_pET),16); 
+	close(m_Imple->m_FD); 
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Chan_Data
+ *  Description:  Sample the Each Channel Data
+ *	          x0-data[0] y0-data[1]
+ *	          x1-data[2] y1-data[3]
+ *	          x2-data[4] y1-data[5]
+ *	          .
+ *	          .
+ *	          x127-data[254] y127-data[255]
+ *
+ *       return:  false    Sample NOT OK   
+ *       	  true     Sample OK 
+ * =====================================================================================
+ */
+bool Etio::Sample_Chan_Data(int* data,SAMPLETYPE st)
+{
+#ifdef X86
+#else
+	int addr;
+	uint8_t t1,t2,t3,t4;
+
+	if ( PEEKB_TC(0x006) & 0x01 == true )
+		return false;
+
+	switch ( st ) 
+	{
+		case TIMERS:    // INT EXT1  EXT2
+			{
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		case RAWECT:    //  X0 Y0 .... .... Xn Yn
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+			}
+			break;
+
+		case RAWEMS:	// X0 0  .... .... Xn 0
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+					data[(i<<1) + 1] = 0; 
+				}
+			}
+			break;
+
+		case ALLECT:   //  X0 Y0 .... .... Xn Yn INTTIME EXTTIME1 EXTTIME2
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		case ALLEMS:   //  X0 0 .... .... Xn 0 INTTIME EXTTIME1 EXTTIME2
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+					data[(i<<1) + 1] = 0; 
+				}
+
+				POKEB_TC(0x22,0x00);  // Lock the Timers value
+
+				addr = 0x030;
+				m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+				m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+				for (int j=0;j<3;j++ )
+				{
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(m_Imple->m_Channels_Number<<1) + j] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+				POKEB_TC(0x22,0x01);  // UnLock the timers value
+			}
+			break;
+
+		default:       // RAW ECT
+			{
+				for ( int i=0;i<m_Imple->m_Channels_Number;i++ )
+				{
+					addr = 0x1000 + ( i << 3 );
+
+					m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+					m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 0] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+
+					t1 = m_Imple->m_pET[0x0a];
+					t2 = m_Imple->m_pET[0x0a];
+					t3 = m_Imple->m_pET[0x0a];
+					t4 = m_Imple->m_pET[0x0a];
+
+					data[(i<<1) + 1] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+				}
+
+			}
+			break;
+	}				/* -----  end switch  ----- */
+
+	POKEB_TC(0x020,0x01);		// restart next sample
+#endif
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_WparaRam
+ *  Description:  Acoording the Wparameters then set the value to FPGA 
+ * =====================================================================================
+ */
+void Etio::Set_WparamRam_Into_FPGA(int chan)
+{
+	int addr = 0x2000 +  ( chan << 4 );
+
+	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].WpDivisorLo);
+	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].WpDivisorHi);
+	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].WpAmount);
+
+	uint8_t v = m_Imple->m_ChanPara[chan].JobWpAmount.WpAmount + ( m_Imple->m_ChanPara[chan].JobWpAmount.ChJob<<4 );
+	POKEB_TC(addr+0x003,v);
+
+	POKEB_TC(addr+0x004,m_Imple->m_ChanPara[chan].WpDeltaLo);
+	POKEB_TC(addr+0x005,m_Imple->m_ChanPara[chan].WpDeltaMi);
+	POKEB_TC(addr+0x006,m_Imple->m_ChanPara[chan].WpDeltaHi);
+
+	v = 0;
+	v = m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeGain + ( m_Imple->m_ChanPara[chan].ProbeBalGain.ProbeBal<<4 );
+	POKEB_TC(addr+0x007,v);
+
+	POKEB_TC(addr+0x008,m_Imple->m_ChanPara[chan].CoilNumforPickB);
+	POKEB_TC(addr+0x009,m_Imple->m_ChanPara[chan].CoilNumforPickA);
+	POKEB_TC(addr+0x00a,m_Imple->m_ChanPara[chan].CoilNumforDriverB);
+	POKEB_TC(addr+0x00b,m_Imple->m_ChanPara[chan].CoilNumforDriverA);
+
+	POKEB_TC(addr+0x00c,m_Imple->m_ChanPara[chan].RfLpCoefLo);
+	POKEB_TC(addr+0x00d,m_Imple->m_ChanPara[chan].RfLpCoefHi);
+	POKEB_TC(addr+0x00e,m_Imple->m_ChanPara[chan].RfHpCoefLo);
+	POKEB_TC(addr+0x00f,m_Imple->m_ChanPara[chan].RfHpCoefHi);
+
+	addr = 0x3000 +  ( chan << 2 );
+	POKEB_TC(addr+0x000,m_Imple->m_ChanPara[chan].LfLpCoefLo);
+	POKEB_TC(addr+0x001,m_Imple->m_ChanPara[chan].LfLpCoefHi);
+	POKEB_TC(addr+0x002,m_Imple->m_ChanPara[chan].LfHpCoefLo);
+	POKEB_TC(addr+0x003,m_Imple->m_ChanPara[chan].LfHpCoefHi);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Board_Status
+ *  Description:  Refresh the Board Status into mem_fun1_ref_tnory
+ * =====================================================================================
+ */
+void Etio::Refresh_Board_Status()
+{
+#ifdef X86
+#else
+	uint8_t v = PEEKB_TC(0x006);
+
+	m_Imple->BoardStatus.SampleReady = v & 0x01;
+	m_Imple->BoardStatus.PowerOn     = ( v & 0x10 ) >> 4;
+	m_Imple->BoardStatus.Running     = ( v & 0x20 ) >> 5;
+	m_Imple->BoardStatus.Shutdown    = ( v & 0x40 ) >> 6;
+#endif
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Power
+ *  Description:  Set the Power flag  
+ *         flag:  true  	PowerOn
+ *                false 	PowerOff
+ * =====================================================================================
+ */
+void Etio::Power(bool flag)
+{
+	uint8_t v = 0;
+	if 	( flag == true )
+		v = 1;
+
+	POKEB_TC(0x010,v);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Running
+ *  Description:  Set the Running flag 
+ *         flag:  true           Running
+ *                false          Stopping
+ * =====================================================================================
+ */
+void Etio::Running(bool flag)
+{
+	uint8_t v = 0;
+	if 	( flag == true )
+		v = 1;
+
+	POKEB_TC(0x011,v);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Chan_Amount
+ *  Description:  Set the Channel Amount 
+ *  		  1~128
+ * =====================================================================================
+ */
+void Etio::Set_Chan_Amount(int amount)
+{
+	if 	( amount > 128 || amount < 1 )
+		return;
+
+	POKEB_TC(0x015,amount);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_AdOffset
+ *  Description:  Set the Offset (-100 +100)
+ * =====================================================================================
+ */
+void Etio::Set_AdOffset(int offset)
+{
+	if 	( offset > 100 || offset < -100 )
+		return;
+
+	POKEB_TC(0x018,offset);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_SineAmplitude
+ *  Description:  Set the sine Amplitude times  0~15
+ * =====================================================================================
+ */
+void Etio::Set_SineAmplitude(int value)
+{
+	if 	( value > 15 || value < 0 )
+		return;
+
+	POKEB_TC(0x01F,value);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Restart
+ *  Description:  Restart the Board 
+ * =====================================================================================
+ */
+void Etio::Restart()
+{
+	POKEB_TC(0x020,0x01);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  GKey
+ *  Description:  Get the Key Value from ECT Board 
+ *                0~6 bits	Key Value
+ *                7 bits   	Length Push
+ * =====================================================================================
+ */
+uint8_t Etio::GKey()
+{
+	return PEEKB_TC(0x02F);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_ET
+ *  Description:  Set the ETIO parameter into Board
+ *                this function convert all device parameters from package to FPGA parameters
+ * =====================================================================================
+ */
+void Etio::Set_ET()
+{
+	Running(false);		  	// halt the system
+
+	if 	( m_Imple->m_Work_Mode == SIN )
+		POKEB_TC(0x016,(m_Imple->m_Sin_Channel|0x80));
+	else 
+		POKEB_TC(0x016,(m_Imple->m_Sin_Channel&0x7F));
+
+	Set_Chan_Type();		// set each channels paramters and calculate channels number
+	Set_Chan_Amount(m_Imple->m_Channels_Number);
+	Set_AdOffset(m_Imple->m_Offset);
+	Set_SineAmplitude(m_Imple->m_SineAmp);
+	Set_Timer_Mode();
+	Convert_Media_FreqValue_To_Inside_FreqIndex();
+	Calculate_Channel_Parameters();
+
+	for ( int i = 0; i < m_Imple->m_cMAXSN; i += 1 ) 
+		Set_WparamRam_Into_FPGA(i);
+
+	Running(true);			// re-running system
+	Restart();			// Start Sample
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Clear_Timers
+ *  Description:  Clear the Int Ext1 Ext2 Timers 
+ * =====================================================================================
+ */
+void Etio::Clear_Timers(int index)
+{
+	switch ( index ) 
+	{
+		case 0:			// InTimer
+			POKEB_TC(0x024,0x01);
+			break;
+
+		case 1:			// Extimer1 
+			POKEB_TC(0x024,0x02);
+			break;
+
+		case 2:			// Extimer2 
+			POKEB_TC(0x024,0x04);
+			break;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Frequence_Value
+ *  Description:  Init Frequence Value into Buffer  
+ * =====================================================================================
+ */
+void Etio::Init_Frequence_Value()
+{
+	int fn = 0;
+
+	m_Imple->m_FreqValue[fn].Frequence 	   = 1;
+	m_Imple->m_FreqValue[fn].Wck       	   = 2000;
+	fn ++;
+
+	for ( int i=2;i<4;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 4000;
+		fn ++;
+	}
+
+	for ( int i=4;i<8;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 8000;
+		fn ++;
+	}
+
+	for ( int i=8;i<16;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 16000;
+		fn ++;
+	}
+
+	for ( int i=16;i<32;i++ )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 32000;
+		fn ++;
+	}
+
+	for ( int i=32;i<80; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 64000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=80;i<151; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 160000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=160;i<391; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 320000;
+		fn ++;
+		i += 2;
+	}
+
+	for ( int i=400;i<791; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 800000;
+		fn ++;
+		i += 4;
+	}
+
+	for ( int i=800;i<1901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 1600000;
+		fn ++;
+		i += 4;
+	}
+
+	for ( int i=2000;i<3901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 3200000;
+		fn ++;
+		i += 5;
+	}
+
+	for ( int i=4000;i<9901; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 8000000;
+		fn ++;
+		i += 6;
+	}
+
+	for ( int i=10000;i<19001; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 20000000;
+		fn ++;
+		i += 300;
+	}
+
+	for ( int i=20000;i<100000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 1000;
+	}
+
+	for ( int i=100000;i<1000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 10000;
+	}
+
+	for ( int i=1000000;i<3000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 40000;
+	}
+
+	for ( int i=3200000;i<=5000000; )
+	{
+		m_Imple->m_FreqValue[fn].Frequence = i;
+		m_Imple->m_FreqValue[fn].Wck       = 40000000;
+		fn ++;
+		i += 100000;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Init_Default_Value
+ *  Description:  Init the Default Value 
+ *                Before User Configrature give the board a default value
+ * =====================================================================================
+ */
+void Etio::Init_Default_Value()
+{
+	/*-----------------------------------------------------------------------------
+	 *  Default Frequence and RF LF Filter Parameters
+	 *-----------------------------------------------------------------------------*/
+	m_Imple->m_Work_Mode			       = NORMAL;
+	m_Imple->m_Sin_Channel			       = 0;
+	m_Imple->m_RF_Filter_Enable		       = false;
+	m_Imple->m_Channels_Number		       = 1;		// only one signal channel
+
+	for ( int i = 0; i < m_Imple->m_cMAXFreqAmount; i += 1 ) 
+	{
+		m_Imple->m_MediaChanFreq[i]            = 25000;
+	}
+
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		m_Imple->m_ChanMapMedia2FreqIndex[i]   = 0;
+
+		m_Imple->m_Chan_Type[i]                = CLOSE;
+		m_Imple->m_ChanFreq[i]                 = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);		// 1982: 25KHz
+
+		m_Imple->m_ChanPara[i].RfLpCoefLo      = 0xff;
+                m_Imple->m_ChanPara[i].RfLpCoefHi      = 0xff;
+
+		m_Imple->m_ChanPara[i].RfHpCoefLo      = 0x00;
+                m_Imple->m_ChanPara[i].RfHpCoefHi      = 0x00;
+
+		m_Imple->m_ChanPara[i].LfLpCoefLo      = 0xff;
+                m_Imple->m_ChanPara[i].LfLpCoefHi      = 0xff;
+
+		m_Imple->m_ChanPara[i].LfHpCoefLo      = 0x00;
+                m_Imple->m_ChanPara[i].LfHpCoefHi      = 0x00;
+
+		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeBal
+			                               = 8;
+		m_Imple->m_ChanPara[i].ProbeBalGain.ProbeGain 
+						       = 7;
+		m_Imple->m_ChanPara[i].JobWpAmount.ChJob     
+			 			       = 0;		// Nomal ET
+
+		m_Imple->m_ChanPara[i].CoilNumforPickB = 255;		// Close all Channels
+                m_Imple->m_ChanPara[i].CoilNumforPickA = 255;
+
+		m_Imple->m_ChanPara[i].CoilNumforDriverB 
+						       = 255;
+		m_Imple->m_ChanPara[i].CoilNumforDriverA 
+			                               = 255;
+
+		if 	( i == 0 )					// Init only one Channels
+		{
+                 	m_Imple->m_ChanPara[i].CoilNumforPickA
+						       = 0;
+			m_Imple->m_ChanPara[i].CoilNumforPickB
+						       = 1;
+
+			m_Imple->m_ChanPara[i].CoilNumforDriverA 
+						       = 0;
+			m_Imple->m_ChanPara[i].CoilNumforDriverB 
+						       = 1;
+		}
+
+		m_Imple->m_High_Filter[i]              = 0;		// Close High Filter
+		m_Imple->m_Low_Filter[i]               = -1;		// Close Low Filter
+	}
+
+	for ( int i = 0; i < m_Imple->m_Channels_Number; i += 1 ) 
+	{
+		m_Imple->m_Chan_Type[i]		       = ECT;
+	}
+
+	m_Imple->m_Offset			       = 0;
+	m_Imple->m_SineAmp			       = 7;
+
+	m_Imple->m_Timer1Mode			       = false;
+	m_Imple->m_Timer2Mode			       = false;
+	Set_Timer_Mode();
+
+	Calculate_Channel_Parameters();
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_Channel_Parameters
+ *  Description:  According to the Channel Frequence parameters to set Probe 
+ * =====================================================================================
+ */
+void Etio::Calculate_Channel_Parameters()
+{
+	unsigned short v,t;
+	int s;
+
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		if 	( m_Imple->m_Chan_Type[i] == EMS )             //  WCk=40MHz    Freq=80KHz
+		{
+			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / 40000000 - 1 );
+
+			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
+			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
+
+			v = static_cast<unsigned short>(static_cast<double>(40000000) / 80000);
+
+			t = v;                                 			//  500 pts
+
+			m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
+			m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
+
+			t = 2048 / v;
+
+			m_Imple->m_ChanPara[i].WpDeltaHi = t;
+
+			s = ( ( 2048 - v * t ) * 65536 ) / v; 
+		}
+		else
+		{
+			v = static_cast<unsigned short>( static_cast<double>( 40 * 1000000 ) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck - 1 );
+
+			m_Imple->m_ChanPara[i].WpDivisorLo = v & 0x00ff;
+			m_Imple->m_ChanPara[i].WpDivisorHi = ( v & 0xff00 ) >> 8;
+
+			v = static_cast<unsigned short>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[i]].Frequence);
+
+			t = v % 4; 
+
+			if 	( t == 0 )
+			{
+				m_Imple->m_ChanPara[i].WpAmount    	    = v & 0x00ff;
+				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( v >> 8 ) & 0x0f;
+			}
+			else
+			{
+				m_Imple->m_ChanPara[i].WpAmount 	    = ( v + ( 4 - t ) ) & 0x00ff;
+				m_Imple->m_ChanPara[i].JobWpAmount.WpAmount = ( ( v + ( 4 - t ) ) >> 8 ) & 0x0f;
+			}
+
+			t = 2048 / v;
+
+			m_Imple->m_ChanPara[i].WpDeltaHi = t;
+
+			s = ( ( 2048 - v * t ) * 65536 ) / v; 
+		}
+
+		m_Imple->m_ChanPara[i].WpDeltaLo = s & 0x00ff;
+		m_Imple->m_ChanPara[i].WpDeltaMi = ( s >> 8 ) & 0x00ff;
+
+		if 	( m_Imple->m_Work_Mode == SIN && m_Imple->m_RF_Filter_Enable == false )	// enter SIN Mode disable RF-Filter
+			Disable_RFCoef(i);
+		else
+			Calculate_RFCoef(i);
+
+		Calculate_LFCoef(i);							        // calculate the LFCoef
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_RFCoef
+ *  Description:  Calculate the RF Coef 
+ * =====================================================================================
+ */
+void Etio::Calculate_RFCoef(int index)
+{
+	double T;
+	double Ft;
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		T    	  = 1 / static_cast<double>( 40000000 );
+		Ft        = 1 / static_cast<double>( 80000 );
+	}
+	else
+	{
+		T    	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
+		Ft        = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+	}
+
+	double Fc   	  = 0.3 * Ft;
+
+	double t1   	  = 2 * PI * Fc * T;
+	double temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
+	unsigned short vh = static_cast<unsigned short>(temp* 65535);
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		T    	  = 1 / static_cast<double>( 40000000 );
+		Fc        = 1 / static_cast<double>( 80000 );
+	}
+	else
+	{
+		T   	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck );
+		Fc   	  = 4 * static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+	}
+
+	t1   	  	  = 2 * PI * Fc * T;
+	temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1;
+	unsigned short vl = static_cast<unsigned short>(temp* 65535);
+
+	m_Imple->m_ChanPara[index].RfHpCoefLo
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].RfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Disable_RFCoef
+ *  Description:  When Enter RF Mode Disbale RFCoef
+ * =====================================================================================
+ */
+void Etio::Disable_RFCoef(int index)
+{
+	unsigned short vh = 0;
+	unsigned short vl = static_cast<unsigned short>(65535);
+
+	m_Imple->m_ChanPara[index].RfHpCoefLo 
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].RfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].RfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Calculate_LFCoef
+ *  Description:  Calculate the LF Coef 
+ *                注意关闭的情况
+ * =====================================================================================
+ */
+void Etio::Calculate_LFCoef(int index)
+{
+	double st;
+	int    M;
+	int   quot;
+	double T;
+	double Fc;
+	double t1;
+	double temp;
+	unsigned short vh,vl;
+
+
+	if 	( m_Imple->m_Chan_Type[index] == EMS )
+	{
+		st	  = 1 / static_cast<double>( 80000 );
+		M      	  = static_cast<int>( static_cast<double>( 40000000 ) / \
+			    static_cast<double>( 80000 ));
+	}
+	else
+	{
+		st	  = 1 / static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence );
+		M      	  = static_cast<int>( static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Wck ) / \
+			    static_cast<double>( m_Imple->m_FreqValue[m_Imple->m_ChanFreq[index]].Frequence ));
+	}
+
+	div_t result = div(400,M);
+	if 	( result.rem == 0 )
+		quot = result.quot;
+	else 
+		quot = result.quot + 1;
+
+	if 	( m_Imple->m_Chan_Type[index] == FECT )
+		T	  = 1 * quot * st;
+	else
+		T	  = 2 * quot * st;
+
+	Fc   	  = m_Imple->m_High_Filter[index] / static_cast<double>(10); 
+	t1   	  = 2 * PI * Fc * T;
+	temp 	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
+
+	if 	( m_Imple->m_High_Filter[index] != 0 )
+	{
+		vh = static_cast<unsigned short>(temp* 65535);
+	}
+	else
+		vh = 0; 
+
+	if 	( m_Imple->m_Low_Filter[index] != -1 )
+	{
+		Fc   	  	  = m_Imple->m_Low_Filter[index] / static_cast<double>(10);
+		t1   	  	  = 2 * PI * Fc * T;
+		temp 	  	  = cos( t1 ) + sqrt( cos(t1)*cos(t1) - 4 * cos(t1) + 3 ) - 1; 
+		vl = static_cast<unsigned short>(temp* 65535);
+	}
+	else
+		vl = static_cast<unsigned short>(65535);
+
+	m_Imple->m_ChanPara[index].LfHpCoefLo 
+		          = vh & 0x00ff;
+	m_Imple->m_ChanPara[index].LfHpCoefHi
+		          = ( vh >> 8 ) & 0x00ff;
+	m_Imple->m_ChanPara[index].LfLpCoefLo 
+		          = vl & 0x00ff;
+	m_Imple->m_ChanPara[index].LfLpCoefHi
+		          = ( vl >> 8 ) & 0x00ff;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Type
+ *  Description:  Set the Channel run type
+ *         type:  CLOSE|ECT|FECT|EMS
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Type(int ch,CHANTYPE type)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+		m_Imple->m_Chan_Type[ch] = type;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Amount
+ *  Description:  Set the device work channels 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Amount(int v)
+{
+	if 	( v <= m_Imple->m_MAX_Channels )
+		m_Imple->m_Channels_Number = v;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Frequence_Value
+ *  Description:  Set the Channel's value 
+ *  	     ch:  0-7
+ *  	      v:  10~5MHz 
+ *  	          Notice it is index value
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Frequence_Value(int ch,int v)
+{
+	if 	( ch >= 0 && ch <= 7 )
+		m_Imple->m_MediaChanFreq[ch] = v;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Map_Index
+ *  Description:  
+ *           ch:  0~127
+ *     mapindex:  0~m_cMAXFreqAmount 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Map_Index(int ch,int mapindex)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+		m_Imple->m_ChanMapMedia2FreqIndex[ch] = mapindex;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_ProbeGain
+ *  Description:  Set the the Channels ProbeGain 
+ *  	     ch:  0~127
+ *  	     v:   0~7
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_ProbeGain(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 7 )
+			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeGain = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_ProbeBalance
+ *  Description:  Set the Probe balance parameters 
+ *           ch:  0~127
+ *            v:  0~15
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_ProbeBalance(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 15 )
+			m_Imple->m_ChanPara[ch].ProbeBalGain.ProbeBal= v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforPickA
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforPickA(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforPickA = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforPickB
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforPickB(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforPickB = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforDriverA
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforDriverA(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforDriverA = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_CoilNumforDriverB
+ *  Description: Set the CoilNumforPickA paramters 
+ *           ch:  0~127
+ *            v:  0~255
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_CoilNumforDriverB(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v >= 0 && v <= 255 )
+			m_Imple->m_ChanPara[ch].CoilNumforDriverB = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_HighFilter
+ *  Description:  Set the Channels Paramters High Filte
+ *           ch:  0~127
+ *            v:  0,  0.1~100Hz  ( 1~1000 )  step 0.1Hz ( 1 )
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_HighFilter(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v == 0 )
+			m_Imple->m_High_Filter[ch] = v;
+		else if ( v >= 1 && v <= 1000 ) 
+			m_Imple->m_High_Filter[ch] = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_LowFilter
+ *  Description:  Set the Channels Paramters Low Filte
+ *           ch:  0~127
+ *            v:  -1  10~2000Hz (100~20000) step 1Hz
+ *
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_LowFilter(int ch,int v)
+{
+	if 	( ch <= m_Imple->m_MAX_Channels && ch >= 0 )
+	{
+		if 	( v == -1 )
+			m_Imple->m_Low_Filter[ch] = v;
+		else if ( v >= 100 && v <= 20000 ) 
+			m_Imple->m_Low_Filter[ch] = v;
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_Offset
+ *  Description:  Set the offset of Device 
+ *        value:  -100 ~ 100 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_Offset(int value)
+{
+	if 	( value >= -100 && value <= 100 )
+		m_Imple->m_Offset = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Channels_SineAmplitude
+ *  Description:  Set the Sine Amplitude value into media layer 
+ *        value:  0~7:    1~8V
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Channels_SineAmplitude(int value)
+{
+	if 	( value >= 0 && value <= 7 )
+		m_Imple->m_SineAmp = value;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Sin_Point_Amount
+ *  Description:  Get the Sin Point Amount
+ * =====================================================================================
+ */
+int Etio::Get_Sin_Point_Amount(int chan)
+{
+	int M;
+	if ( m_Imple->m_Chan_Type[chan] == EMS )
+		M = 500; 
+	else
+		M = static_cast<int>(static_cast<double>(m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Wck) / m_Imple->m_FreqValue[m_Imple->m_ChanFreq[chan]].Frequence);
+
+	div_t re = div(M,256); 
+
+	int CptRate = 0;
+	if 	( re.rem == 0 )
+		CptRate = re.quot;
+	else
+		CptRate = re.quot + 1;
+
+	re = div(M,CptRate);
+
+	if 	( re.rem == 0 )
+		return re.quot;
+	else
+		return re.quot + 1;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_Sin_Data
+ *  Description:  Sample the SIN Function 
+ * =====================================================================================
+ */
+bool Etio::Sample_Sin_Data(int* data,int len)
+{
+	int addr;
+	uint8_t t1,t2,t3,t4;
+
+	if 	( PEEKB_TC(0x006) & 0x01 == true )
+		return false;
+
+	addr = 0x1000;
+
+	m_Imple->m_pET[2] = static_cast<uint8_t>( addr & 0xff );
+	m_Imple->m_pET[3] = static_cast<uint8_t>( (addr>>8) & 0xff );
+
+	for ( int i = 0; i < len; i += 1 ) 
+	{
+		t1 = m_Imple->m_pET[0x0a];
+		t2 = m_Imple->m_pET[0x0a];
+		t3 = m_Imple->m_pET[0x0a];
+		t4 = m_Imple->m_pET[0x0a];
+
+		data[i] = ( t4 << 24 ) + ( t3 << 16 ) + ( t2 << 8 ) + t1;
+	}
+
+	POKEB_TC(0x020,0x01);		// restart next sample
+	return true;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequence_Index
+ *  Description:  Return the Frequence value index 
+ * =====================================================================================
+ */
+int Etio::Get_Frequence_Index(int frequnce)
+{
+	for ( int i=0;i< m_Imple->m_FREQVALUEN_40MHz;i++ )
+	{
+		if ( frequnce == m_Imple->m_FreqValue[i].Frequence )
+			return i;
+	}
+	printf ( "No Found Freq\n" );
+	return 100;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Frequence
+ *  Description:  Get the Frequecen of given index 
+ * =====================================================================================
+ */
+int Etio::Get_Frequence(int index)
+{
+	return m_Imple->m_FreqValue[index].Frequence;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Work_Mode
+ *  Description:  Set the Work Mode of FPGA 
+ * =====================================================================================
+ */
+void Etio::Set_Work_Mode(FUNMODE mode)
+{
+	m_Imple->m_Work_Mode = mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Work_Mode
+ *  Description:  Get the Work Mode
+ * =====================================================================================
+ */
+Etio::FUNMODE Etio::Get_Work_Mode()
+{
+	return m_Imple->m_Work_Mode;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Select_Sin_Channel
+ *  Description:  Select Sin Channel of FPGA
+ * =====================================================================================
+ */
+void Etio::Interface_Select_Sin_Channel(int ch)
+{
+	if ( ch >= 0 && ch <= 128 )
+		m_Imple->m_Sin_Channel = ch;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Get_Sin_Channel
+ *  Description:  Get the Sin Channel 
+ * =====================================================================================
+ */
+int Etio::Interface_Get_Sin_Channel()
+{
+	return m_Imple->m_Sin_Channel;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Max_Frequence_Length
+ *  Description:  Return the Max Frequence Length 
+ * =====================================================================================
+ */
+int  Etio::Get_Max_Frequence_Length()
+{
+	return m_Imple->m_FREQVALUEN_40MHz;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Get_Version
+ *  Description:  Get the Module Version 
+ * =====================================================================================
+ */
+int  Etio::Get_Version()
+{
+	return m_Imple->m_Version;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Sample_DataN
+ *  Description:  return the Sample Data Length 
+ * =====================================================================================
+ */
+int Etio::Sample_DataN()
+{
+	if 	( m_Imple->m_Work_Mode == Etio::NORMAL )
+		return m_Imple->m_Channels_Number<<1;
+	else if ( m_Imple->m_Work_Mode == Etio::SIN )
+		return Get_Sin_Point_Amount(m_Imple->m_Sin_Channel);
+	else
+		return 2;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Chan_Type
+ *  Description:  Set each Channel type and calculate the m_Imple->m_Channels_Number
+ * =====================================================================================
+ */
+void Etio::Set_Chan_Type()
+{
+	int num = 0;
+
+	for ( int i = 0; i < m_Imple->m_MAX_Channels; i += 1 ) 
+	{
+		if 	( m_Imple->m_Chan_Type[i] != CLOSE )
+		{
+			num ++;
+			switch ( m_Imple->m_Chan_Type[i] )
+			{
+				case ECT:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+					break;
+
+				case FECT:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 1;
+					break;
+
+				case EMS:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 2;
+					break;
+
+				default:
+					m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+					break;
+			}				/* -----  end switch  ----- */
+		}
+		else
+			m_Imple->m_ChanPara[i].JobWpAmount.ChJob = 0;
+	}
+
+	m_Imple->m_Channels_Number = num;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_RF_Filter_Enable_Switch
+ *  Description:  Set the flag that indicate whether to calculate RF parameters 
+ * =====================================================================================
+ */
+void Etio::Interface_Set_RF_Filter_Enable_Switch(bool flag)
+{
+	m_Imple->m_RF_Filter_Enable = flag;
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Get_Channels_Fun
+ *  Description:  Only get the signal Channel work mode
+ * =====================================================================================
+ */
+int Etio::Interface_Get_Channels_Fun(int ch)
+{
+	switch ( m_Imple->m_Chan_Type[ch] ) 
+	{
+		case CLOSE:	
+			return 0;
+			break;
+
+		case ECT:	
+			return 1;
+			break;
+
+		case FECT:	
+			return 2;
+			break;
+
+		case EMS:	
+			return 3;
+			break;
+
+		default:	
+			return 1;
+			break;
+	}				/* -----  end switch  ----- */
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Convert_Media_FreqValue_To_Inside_FreqIndex
+ *  Description:  Convert Data Buffer to Inside Frequence index
+ * =====================================================================================
+ */
+void Etio::Convert_Media_FreqValue_To_Inside_FreqIndex()
+{
+	for ( int i=0;i<m_Imple->m_cMAXSN;i++ )
+	{
+		m_Imple->m_ChanFreq[i] = Get_Frequence_Index(m_Imple->m_MediaChanFreq[m_Imple->m_ChanMapMedia2FreqIndex[i]]);
+	}
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Set_Timer_Mode
+ *  Description:  Set the Timer1 and Timer2 work mode 
+ * =====================================================================================
+ */
+void Etio::Set_Timer_Mode()
+{
+	if 	( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == false )
+		POKEB_TC(0x23,0x00);
+	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == true )
+		POKEB_TC(0x23,0x06);
+	else if ( m_Imple->m_Timer1Mode == true && m_Imple->m_Timer2Mode == false )
+		POKEB_TC(0x23,0x02);
+	else if ( m_Imple->m_Timer1Mode == false && m_Imple->m_Timer2Mode == true )
+		POKEB_TC(0x23,0x04);
+	else
+		POKEB_TC(0x23,0x00);
+}
+
+/* 
+ * ===  FUNCTION  ======================================================================
+ *         Name:  Interface_Set_Timers_Mode
+ *  Description:  Set the Timers Work Mode  
+ *         Note:  index:0~Timer1
+ *                      1~Timer2
+ *                flag: f~Normal
+ *			t~scan1A clean
+ *			  scan2A clean
+ * =====================================================================================
+ */
+void Etio::Interface_Set_Timers_Mode(int index,bool flag)
+{
+	if 	( index == 0 )
+		m_Imple->m_Timer1Mode = flag;
+	else if ( index == 1 )
+		m_Imple->m_Timer2Mode = flag;
+}
diff --git a/src/EVA11/libetio/etio.h b/src/EVA11/libetio/etio.h
new file mode 100644
index 0000000..3174811
--- /dev/null
+++ b/src/EVA11/libetio/etio.h
@@ -0,0 +1,169 @@
+/*
+ * =====================================================================================
+ *
+ *       Filename:  etio.h
+ *
+ *    Description:  Declearation of etio class
+ *
+ *        Version:  1.0
+ *        Created:  2012年12月18日 11时40分11秒
+ *       Revision:  none
+ *       Compiler:  gcc
+ *
+ *         Author:  YOUR NAME (), 
+ *   Organization:  
+ *
+ * =====================================================================================
+ */
+
+#ifndef  _ETIO_INC
+#define  _ETIO_INC
+
+#include 	<memory>	
+#include 	<stdint.h>
+
+class Etio
+{
+	public:
+		static Etio* Instance();
+
+		enum FUNMODE 
+		{
+			NORMAL  = 	0,
+			SIN     =       1,
+		};
+		typedef enum FUNMODE FUNMODE;
+
+		enum SAMPLETYPE                 	/* Smaple data mode  */
+		{
+			RAWECT	=	0,		//  only X Y 
+			RAWEMS	=	1,		//  only X
+			ALLECT	=	2,		//  X Y INT EXT1 EXT2
+			ALLEMS  =       3,		//  X 0 INT EXT1 EXT2
+			TIMERS  =       4,              //  INT EXT1 EXT2
+		};
+		typedef enum SAMPLETYPE SAMPLETYPE;
+
+		enum CHANTYPE 				/* define the channels type */
+		{
+			CLOSE   =        0,
+			ECT     =        1,
+			FECT    =        2,
+			EMS     =        3
+		};
+		typedef enum CHANTYPE CHANTYPE;
+
+		/*-----------------------------------------------------------------------------
+		 *  module interface
+		 *-----------------------------------------------------------------------------*/
+		int Version();
+		bool InitiateETIO();
+		void UnInitiateETIO();
+
+		/*-----------------------------------------------------------------------------
+		 *  base function interface
+		 *-----------------------------------------------------------------------------*/
+		uint8_t GKey();
+		void Set_ET();
+		void Clear_Timers(int);
+		void POKEB_TC(int add,uint8_t value);
+		uint8_t PEEKB_TC(int add);
+
+		/*-----------------------------------------------------------------------------
+		 *  parameters sets interface,only used by users 
+		 *-----------------------------------------------------------------------------*/
+		void Interface_Set_Channels_Type(int,CHANTYPE);
+		void Interface_Set_Channels_Amount(int);
+		void Interface_Set_Channels_Frequence_Value(int,int);
+		void Interface_Set_Channels_Map_Index(int,int);
+
+		void Interface_Set_Channels_ProbeGain(int,int);
+		void Interface_Set_Channels_ProbeBalance(int,int);
+
+		void Interface_Set_Channels_CoilNumforPickA(int,int);
+		void Interface_Set_Channels_CoilNumforPickB(int,int);
+		void Interface_Set_Channels_CoilNumforDriverA(int,int);
+		void Interface_Set_Channels_CoilNumforDriverB(int,int);
+
+		void Interface_Set_Channels_HighFilter(int,int);
+		void Interface_Set_Channels_LowFilter(int,int);
+
+		void Interface_Set_Channels_Offset(int);
+		void Interface_Set_Channels_SineAmplitude(int);
+
+		void Interface_Set_RF_Filter_Enable_Switch(bool);
+		int Interface_Get_Channels_Fun(int);
+
+		void Interface_Set_Timers_Mode(int,bool);
+
+		void Interface_Select_Sin_Channel(int);
+		int  Interface_Get_Sin_Channel();
+
+		int Get_Frequence_Index(int);
+		int Get_Frequence(int);
+		int  Get_Max_Frequence_Length();
+
+		bool Sample_Chan_Data(int* data,SAMPLETYPE st = RAWECT);
+		int Get_Sin_Point_Amount(int);
+		bool Sample_Sin_Data(int* data,int len);
+
+		void Init_Default_Value();
+
+		void Set_Work_Mode(FUNMODE);
+		FUNMODE Get_Work_Mode();
+		int Sample_DataN();
+
+		/*-----------------------------------------------------------------------------
+		 *  Module Version
+		 *-----------------------------------------------------------------------------*/
+		int  Get_Version();
+	protected:
+
+	private:
+		Etio();                              	   /* constructor */
+		~Etio ();                             	   /* destructor */
+		Etio( const Etio& );
+		Etio& operator = (const Etio&);
+
+		friend class std::auto_ptr<Etio>;
+		static std::auto_ptr<Etio>		m_Instance;
+
+
+		void Load_Board_Information();
+		void Get_Board_Version(uint8_t& Main,uint8_t& Sub,uint8_t& FPGA);
+
+		void Set_WparamRam_Into_FPGA(int);
+
+		void Refresh_Board_Status();
+
+		void Power(bool);
+		void Running(bool);
+		void Restart();
+
+		void Set_Chan_Amount(int);
+
+		void Init_Frequence_Value();
+		void Calculate_Channel_Parameters();
+		void Calculate_RFCoef(int);
+		void Calculate_LFCoef(int);
+		void Disable_RFCoef(int);
+
+		void Set_Chan_Type();
+		void Set_AdOffset(int);
+		void Set_SineAmplitude(int);
+		void Set_Timer_Mode();
+
+		void Convert_Media_FreqValue_To_Inside_FreqIndex();
+
+	private:
+		struct PImpl;
+		struct WPARAMS;
+		struct JOBAMOUNT;
+		struct PROBBALGAIN;
+		struct BOARDSTATUS;
+		struct FREQUENCESTR;
+
+		std::auto_ptr<struct PImpl>	m_Imple;
+};
+
+#endif   /* ----- #ifndef _ETIO_INC  ----- */
-- 
1.8.5.1

